import { clsx as pM } from "clsx";
import { twMerge as hM } from "tailwind-merge";
import { defineComponent as S, openBlock as x, createBlock as L, unref as b, normalizeProps as Pe, guardReactiveProps as Ue, withCtx as A, renderSlot as B, computed as R, mergeProps as oe, createElementVNode as be, normalizeClass as ce, createVNode as $, createElementBlock as W, resolveDynamicComponent as Nr, createCommentVNode as Qe, toDisplayString as ze, Fragment as Ge, renderList as ft, createTextVNode as Xt, withModifiers as K_, h as Fr, resolveComponent as Ta, ref as _e, isRef as Co, getCurrentScope as gM, onScopeDispose as mM, toRef as Mi, readonly as Zf, customRef as Y_, onMounted as Jn, nextTick as Ft, getCurrentInstance as jn, watch as Mt, watchEffect as lr, shallowRef as I0, normalizeStyle as Rr, onBeforeUnmount as Qs, markRaw as bM, toValue as Me, inject as Wr, toRaw as Sa, provide as zi, reactive as vs, withDirectives as Ja, vShow as O1, vModelText as Q_, warn as yM, onUnmounted as Zs, useAttrs as Z_, vModelDynamic as vM, camelize as I1, toRefs as _M, createApp as R1 } from "vue";
import { useForwardPropsEmits as Le, AccordionRoot as EM, AccordionContent as wM, useForwardProps as We, AccordionItem as xM, AccordionHeader as kM, AccordionTrigger as MM, AlertDialogRoot as AM, AlertDialogTrigger as TM, useEmitAsProps as SM, AlertDialogPortal as CM, AlertDialogOverlay as NM, AlertDialogContent as DM, AlertDialogTitle as OM, AlertDialogDescription as IM, AlertDialogAction as RM, AlertDialogCancel as LM, CalendarRoot as BM, CalendarCell as PM, CalendarCellTrigger as $M, CalendarGrid as zM, CalendarGridBody as FM, CalendarGridHead as jM, CalendarGridRow as UM, CalendarHeadCell as VM, CalendarHeader as HM, CalendarHeading as qM, CalendarNext as GM, CalendarPrev as WM, CheckboxRoot as KM, CheckboxIndicator as YM, CollapsibleRoot as QM, CollapsibleTrigger as ZM, CollapsibleContent as XM, ComboboxRoot as JM, DialogRoot as eA, DialogClose as R0, DialogTrigger as tA, DialogTitle as nA, DialogDescription as rA, DialogPortal as X_, DialogOverlay as J_, DialogContent as e2, ComboboxEmpty as iA, ComboboxGroup as oA, ComboboxLabel as sA, ComboboxInput as aA, ComboboxItem as lA, ComboboxContent as uA, ComboboxSeparator as cA, DropdownMenuRoot as fA, DropdownMenuTrigger as dA, DropdownMenuPortal as pA, DropdownMenuContent as hA, DropdownMenuGroup as gA, DropdownMenuRadioGroup as mA, DropdownMenuItem as bA, DropdownMenuCheckboxItem as yA, DropdownMenuItemIndicator as t2, DropdownMenuRadioItem as vA, DropdownMenuSeparator as _A, DropdownMenuLabel as EA, DropdownMenuSub as wA, DropdownMenuSubTrigger as xA, DropdownMenuSubContent as kA, PopoverRoot as MA, PopoverTrigger as AA, PopoverPortal as TA, PopoverContent as SA, SelectRoot as CA, SelectValue as NA, SelectTrigger as DA, SelectIcon as OA, SelectPortal as IA, SelectContent as RA, SelectViewport as LA, SelectGroup as BA, SelectItem as PA, SelectItemIndicator as $A, SelectItemText as n2, SelectLabel as zA, SelectSeparator as FA, SelectScrollUpButton as jA, SelectScrollDownButton as UA, TooltipRoot as VA, TooltipTrigger as HA, TooltipPortal as qA, TooltipContent as GA, Separator as WA, TooltipProvider as KA, Toggle as YA, Label as r2, Slot as QA, HoverCardRoot as ZA, HoverCardTrigger as XA, HoverCardPortal as JA, HoverCardContent as eT, MenubarRoot as tT, MenubarItem as nT, MenubarPortal as i2, MenubarContent as rT, MenubarGroup as iT, MenubarMenu as oT, MenubarRadioGroup as sT, MenubarRadioItem as aT, MenubarItemIndicator as o2, MenubarCheckboxItem as lT, MenubarSeparator as uT, MenubarSub as cT, MenubarSubContent as fT, MenubarSubTrigger as dT, MenubarTrigger as pT, MenubarLabel as hT, NavigationMenuViewport as gT, NavigationMenuRoot as mT, NavigationMenuList as bT, NavigationMenuItem as yT, NavigationMenuTrigger as vT, NavigationMenuContent as _T, NavigationMenuLink as ET, PaginationEllipsis as wT, PaginationFirst as xT, PaginationLast as kT, PaginationNext as MT, PaginationPrev as AT, PinInputRoot as TT, Primitive as s2, PinInputInput as ST, ProgressRoot as CT, ProgressIndicator as L1, RadioGroupRoot as NT, RadioGroupItem as DT, RadioGroupIndicator as OT, ScrollAreaScrollbar as IT, ScrollAreaThumb as RT, ScrollAreaRoot as LT, ScrollAreaViewport as BT, ScrollAreaCorner as PT, SwitchRoot as $T, SwitchThumb as zT, TabsRoot as FT, TabsTrigger as jT, TabsList as UT, TabsContent as VT, SplitterGroup as HT, SplitterResizeHandle as qT, AvatarRoot as GT, AvatarImage as WT, AvatarFallback as KT } from "radix-vue";
import { DropdownMenuPortal as gre, PaginationRoot as mre, PaginationList as bre, PaginationListItem as yre, SplitterPanel as vre } from "radix-vue";
import { ChevronDown as Xs, Loader2 as YT, ChevronRight as Xf, ChevronLeft as a2, Check as $l, X as L0, Search as QT, Circle as Jf, ChevronUp as ZT, Moon as XT, Sun as JT, ChevronsDownUp as eS, ChevronsUpDown as tS, CaseSensitive as nS, MoreHorizontal as l2, Bold as rS, Italic as iS, UnderlineIcon as oS, StrikethroughIcon as sS, CodeIcon as aS, RemoveFormatting as lS, ListOrdered as uS, List as cS, ListChecks as fS, SmilePlus as dS, ChevronsLeft as pS, ChevronsRight as hS, Dot as gS, GripVertical as mS, CalendarIcon as bS } from "lucide-vue-next";
import { cva as Js } from "class-variance-authority";
function G(...e) {
  return hM(pM(e));
}
const B1 = (e) => {
  var o, s, a, l;
  const t = (o = e == null ? void 0 : e.replace(/[^0-9+]+/g, "")) == null ? void 0 : o.match(/(?:\+1)?(\d{0,3})(\d{0,3})?(\d{0,4})?/);
  let n, r, i = "";
  return t && (((s = t[1]) == null ? void 0 : s.length) > 0 && (n = t[1]), ((a = t[2]) == null ? void 0 : a.length) > 0 && (r = t[2]), ((l = t[3]) == null ? void 0 : l.length) > 0 && (i = t[3])), {
    areaCode: n,
    prefix: r,
    lineNumber: i
  };
}, Uee = /* @__PURE__ */ S({
  __name: "Accordion",
  props: {
    collapsible: { type: Boolean },
    disabled: { type: Boolean },
    dir: {},
    orientation: {},
    asChild: { type: Boolean },
    as: {},
    type: {},
    modelValue: {},
    defaultValue: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const i = Le(e, t);
    return (o, s) => (x(), L(b(EM), Pe(Ue(b(i))), {
      default: A(() => [
        B(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Vee = /* @__PURE__ */ S({
  __name: "AccordionContent",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: r, ...i } = t;
      return i;
    });
    return (r, i) => (x(), L(b(wM), oe(n.value, { class: "overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down" }), {
      default: A(() => [
        be("div", {
          class: ce(b(G)("pb-4 pt-0", t.class))
        }, [
          B(r.$slots, "default")
        ], 2)
      ]),
      _: 3
    }, 16));
  }
}), Hee = /* @__PURE__ */ S({
  __name: "AccordionItem",
  props: {
    disabled: { type: Boolean },
    value: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(xM), oe(b(r), {
      class: b(G)("border-b", t.class)
    }), {
      default: A(() => [
        B(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), qee = /* @__PURE__ */ S({
  __name: "AccordionTrigger",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: r, ...i } = t;
      return i;
    });
    return (r, i) => (x(), L(b(kM), { class: "flex" }, {
      default: A(() => [
        $(b(MM), oe(n.value, {
          class: b(G)(
            "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
            t.class
          )
        }), {
          default: A(() => [
            B(r.$slots, "default"),
            B(r.$slots, "icon", {}, () => [
              $(b(Xs), { class: "h-4 w-4 shrink-0 transition-transform duration-200" })
            ])
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), Gee = /* @__PURE__ */ S({
  __name: "Alert",
  props: {
    class: {},
    variant: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("div", {
      class: ce(b(G)(b(yS)({ variant: n.variant }), t.class)),
      role: "alert"
    }, [
      B(n.$slots, "default")
    ], 2));
  }
}), Wee = /* @__PURE__ */ S({
  __name: "AlertTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("h5", {
      class: ce(b(G)("mb-1 font-medium leading-none tracking-tight", t.class))
    }, [
      B(n.$slots, "default")
    ], 2));
  }
}), Kee = /* @__PURE__ */ S({
  __name: "AlertDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("div", {
      class: ce(b(G)("text-sm [&_p]:leading-relaxed", t.class))
    }, [
      B(n.$slots, "default")
    ], 2));
  }
}), yS = Js(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-layer-0 text-foreground",
        destructive: "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
        warning: "border-warning/50 text-warning dark:border-warning [&>svg]:text-warning"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), Yee = /* @__PURE__ */ S({
  __name: "AlertDialog",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const i = Le(e, t);
    return (o, s) => (x(), L(b(AM), Pe(Ue(b(i))), {
      default: A(() => [
        B(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Qee = /* @__PURE__ */ S({
  __name: "AlertDialogTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(TM), Pe(Ue(t)), {
      default: A(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Zee = /* @__PURE__ */ S({
  __name: "AlertDialogContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, i = SM(t);
    return (o, s) => (x(), L(b(CM), null, {
      default: A(() => [
        $(b(NM), { class: "fixed inset-0 z-50 bg-layer-0/80 backdrop-blur-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0" }),
        $(b(DM), oe({ ...n, ...b(i) }, {
          class: b(G)(
            "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border border-border bg-layer-0 p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg md:w-full",
            n.class
          )
        }), {
          default: A(() => [
            B(o.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), Xee = /* @__PURE__ */ S({
  __name: "AlertDialogHeader",
  props: {
    class: {
      type: String,
      default: ""
    }
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("div", {
      class: ce(b(G)("flex flex-col space-y-2 text-center sm:text-left", t.class))
    }, [
      B(n.$slots, "default")
    ], 2));
  }
}), Jee = /* @__PURE__ */ S({
  __name: "AlertDialogTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(OM), {
      "as-child": t.asChild,
      class: ce(b(G)("text-lg font-semibold text-foreground", t.class))
    }, {
      default: A(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "class"]));
  }
}), ete = /* @__PURE__ */ S({
  __name: "AlertDialogDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(IM), {
      class: ce(b(G)("text-sm text-muted-foreground", t.class)),
      "as-child": t.asChild
    }, {
      default: A(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "as-child"]));
  }
}), tte = /* @__PURE__ */ S({
  __name: "AlertDialogFooter",
  props: {
    class: {
      type: String,
      default: ""
    }
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("div", {
      class: ce(
        b(G)(
          "mt-3.5 flex flex-col space-y-2 sm:flex-row sm:justify-end sm:space-x-2 sm:space-y-0",
          t.class
        )
      )
    }, [
      B(n.$slots, "default")
    ], 2));
  }
}), Kr = /* @__PURE__ */ S({
  __name: "Button",
  props: {
    variant: {},
    size: {},
    as: { default: "button" },
    loading: { type: Boolean, default: !1 },
    disabled: { type: Boolean }
  },
  setup(e) {
    return (t, n) => (x(), L(Nr(t.as), {
      class: ce(b(G)("space-x-2", b(ea)({ variant: t.variant, size: t.size }), t.$attrs.class ?? "")),
      disabled: t.loading || t.disabled
    }, {
      default: A(() => [
        t.loading ? (x(), L(b(YT), {
          key: 0,
          class: "inline-block max-h-4 min-h-4 min-w-4 max-w-4 animate-spin"
        })) : Qe("", !0),
        be("div", null, [
          B(t.$slots, "default")
        ])
      ]),
      _: 3
    }, 8, ["class", "disabled"]));
  }
}), ea = Js(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-layer-0 hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-muted",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-10 px-4 py-2",
        xs: "h-7 rounded px-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), nte = /* @__PURE__ */ S({
  __name: "AlertDialogAction",
  props: {
    asChild: { type: Boolean },
    as: {},
    variant: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(RM), oe(t, {
      class: b(G)(b(ea)({ variant: n.variant }), n.$attrs.class ?? "")
    }), {
      default: A(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), rte = /* @__PURE__ */ S({
  __name: "AlertDialogCancel",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(LM), oe(t, {
      class: b(G)(b(ea)({ variant: "outline" }), "mt-2 sm:mt-0", n.$attrs.class ?? "")
    }), {
      default: A(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), ite = /* @__PURE__ */ S({
  __name: "Badge",
  props: {
    variant: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("div", {
      class: ce(b(G)(b(vS)({ variant: n.variant }), t.class))
    }, [
      B(n.$slots, "default")
    ], 2));
  }
}), vS = Js(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive: "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        positive: "border-transparent bg-positive text-positive-foreground hover:bg-positive/80",
        outline: "text-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), _S = { class: "mt-4 flex flex-col gap-y-4 sm:flex-row sm:gap-x-4 sm:gap-y-0" }, ES = /* @__PURE__ */ S({
  __name: "Calendar",
  props: {
    modelValue: {},
    multiple: { type: Boolean },
    defaultValue: {},
    defaultPlaceholder: {},
    placeholder: {},
    pagedNavigation: { type: Boolean },
    preventDeselect: { type: Boolean },
    weekStartsOn: {},
    weekdayFormat: {},
    calendarLabel: {},
    fixedWeeks: { type: Boolean },
    maxValue: {},
    minValue: {},
    locale: {},
    numberOfMonths: {},
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    initialFocus: { type: Boolean },
    isDateDisabled: { type: Function },
    isDateUnavailable: { type: Function },
    dir: {},
    nextPage: { type: Function },
    prevPage: { type: Function },
    asChild: { type: Boolean },
    as: {},
    eventDates: {},
    class: {}
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: a, ...l } = n;
      return l;
    }), o = Le(i, r), s = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "June",
      "July",
      "Aug",
      "Sept",
      "Oct",
      "Nov",
      "Dec"
    ];
    return (a, l) => (x(), L(b(BM), oe({
      class: b(G)("p-3", n.class)
    }, b(o)), {
      default: A(({ grid: u, weekDays: c }) => [
        $(b(SS), { class: "mb-3" }, {
          default: A(() => [
            $(b(DS)),
            $(b(CS), null, {
              default: A(() => [
                be("div", null, ze(s[u[0].value.month - 1]) + " " + ze(u[0].value.year), 1)
              ]),
              _: 2
            }, 1024),
            $(b(NS))
          ]),
          _: 2
        }, 1024),
        be("div", _S, [
          (x(!0), W(Ge, null, ft(u, (f) => (x(), L(b(kS), {
            key: f.value.toString()
          }, {
            default: A(() => [
              $(b(AS), null, {
                default: A(() => [
                  $(b(P1), null, {
                    default: A(() => [
                      (x(!0), W(Ge, null, ft(c, (d) => (x(), L(b(TS), { key: d }, {
                        default: A(() => [
                          Xt(ze(d.slice(0, 2)), 1)
                        ]),
                        _: 2
                      }, 1024))), 128))
                    ]),
                    _: 2
                  }, 1024)
                ]),
                _: 2
              }, 1024),
              $(b(MS), null, {
                default: A(() => [
                  (x(!0), W(Ge, null, ft(f.rows, (d, p) => (x(), L(b(P1), {
                    key: `weekDate-${p}`,
                    class: "mt-2 w-full"
                  }, {
                    default: A(() => [
                      (x(!0), W(Ge, null, ft(d, (h) => (x(), L(b(wS), {
                        key: h.toString(),
                        date: h
                      }, {
                        default: A(() => {
                          var m;
                          return [
                            $(b(xS), {
                              day: h,
                              month: f.value,
                              "data-event-today": (m = n.eventDates) != null && m.includes(h.toString()) ? !0 : void 0
                            }, null, 8, ["day", "month", "data-event-today"])
                          ];
                        }),
                        _: 2
                      }, 1032, ["date"]))), 128))
                    ]),
                    _: 2
                  }, 1024))), 128))
                ]),
                _: 2
              }, 1024)
            ]),
            _: 2
          }, 1024))), 128))
        ])
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), wS = /* @__PURE__ */ S({
  __name: "CalendarCell",
  props: {
    date: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(PM), oe({
      class: b(G)(
        "relative h-5 w-5 p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([data-selected])]:rounded-lg [&:has([data-selected])]:bg-accent [&:has([data-selected][data-outside-month])]:bg-accent/50",
        t.class
      )
    }, b(r)), {
      default: A(() => [
        B(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), xS = /* @__PURE__ */ S({
  __name: "CalendarCellTrigger",
  props: {
    day: {},
    month: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b($M), oe({
      class: b(G)(
        b(ea)({ variant: "ghost" }),
        "h-5 w-5 p-0 text-xs font-normal",
        "[&[data-today]:not([data-selected])]:rounded-full [&[data-today]:not([data-selected])]:bg-secondary [&[data-today]:not([data-selected])]:text-foreground",
        "[&[data-event-today]:not([data-selected])]:rounded-full [&[data-event-today]:not([data-selected])]:bg-gray-200 [&[data-event-today]:not([data-selected])]:text-foreground",
        // Event today from events passed in
        "dark:[&[data-event-today]:not([data-selected])]:bg-gray-600",
        // Event today from events passed in (dark)
        // Selected
        "data-[selected]:bg-primary data-[selected]:text-primary-foreground data-[selected]:opacity-100 data-[selected]:hover:bg-primary data-[selected]:hover:text-primary-foreground data-[selected]:focus:bg-primary data-[selected]:focus:text-primary-foreground",
        // Disabled
        "data-[disabled]:text-muted-foreground data-[disabled]:opacity-50",
        // Unavailable
        "data-[unavailable]:text-destructive-foreground data-[unavailable]:line-through",
        // Outside months
        "data-[outside-month]:pointer-events-none data-[outside-month]:text-muted-foreground data-[outside-month]:opacity-50 [&[data-outside-month][data-selected]]:bg-accent/50 [&[data-outside-month][data-selected]]:text-muted-foreground [&[data-outside-month][data-selected]]:opacity-30",
        t.class
      )
    }, b(r)), {
      default: A(() => [
        B(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), kS = /* @__PURE__ */ S({
  __name: "CalendarGrid",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(zM), oe({
      class: b(G)("w-full border-collapse space-y-1", t.class)
    }, b(r)), {
      default: A(() => [
        B(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), MS = /* @__PURE__ */ S({
  __name: "CalendarGridBody",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(FM), Pe(Ue(t)), {
      default: A(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), AS = /* @__PURE__ */ S({
  __name: "CalendarGridHead",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(jM), Pe(Ue(t)), {
      default: A(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), P1 = /* @__PURE__ */ S({
  __name: "CalendarGridRow",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(UM), oe({
      class: b(G)("flex", t.class)
    }, b(r)), {
      default: A(() => [
        B(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), TS = /* @__PURE__ */ S({
  __name: "CalendarHeadCell",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(VM), oe({
      class: b(G)(
        "w-5 justify-center rounded-md text-[0.6875rem] font-normal text-muted-foreground",
        t.class
      )
    }, b(r)), {
      default: A(() => [
        B(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), SS = /* @__PURE__ */ S({
  __name: "CalendarHeader",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(HM), oe({
      class: b(G)("relative flex w-full items-center justify-between pt-1", t.class)
    }, b(r)), {
      default: A(() => [
        B(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), CS = /* @__PURE__ */ S({
  __name: "CalendarHeading",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(qM), oe({
      class: b(G)("text-sm font-medium", t.class)
    }, b(r)), {
      default: A(({ headingValue: s }) => [
        B(i.$slots, "default", { headingValue: s }, () => [
          Xt(ze(s), 1)
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), NS = /* @__PURE__ */ S({
  __name: "CalendarNextButton",
  props: {
    step: {},
    nextPage: { type: Function },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(GM), oe({
      class: b(G)(
        b(ea)({ variant: "ghost" }),
        "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        t.class
      )
    }, b(r)), {
      default: A(() => [
        B(i.$slots, "default", {}, () => [
          $(b(Xf), { class: "h-5 w-5" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), DS = /* @__PURE__ */ S({
  __name: "CalendarPrevButton",
  props: {
    step: {},
    prevPage: { type: Function },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(WM), oe({
      class: b(G)(
        b(ea)({ variant: "ghost" }),
        "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        t.class
      )
    }, b(r)), {
      default: A(() => [
        B(i.$slots, "default", {}, () => [
          $(b(a2), { class: "h-5 w-5" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), u2 = /* @__PURE__ */ S({
  __name: "Card",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("div", {
      class: ce(b(G)("rounded-lg border bg-card text-card-foreground shadow-sm", t.class))
    }, [
      B(n.$slots, "default")
    ], 2));
  }
}), c2 = /* @__PURE__ */ S({
  __name: "CardHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("div", {
      class: ce(b(G)("flex flex-col gap-y-1.5 p-6", t.class))
    }, [
      B(n.$slots, "default")
    ], 2));
  }
}), f2 = /* @__PURE__ */ S({
  __name: "CardTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("h3", {
      class: ce(b(G)("text-2xl font-semibold leading-none tracking-tight", t.class))
    }, [
      B(n.$slots, "default")
    ], 2));
  }
}), ote = /* @__PURE__ */ S({
  __name: "CardDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("p", {
      class: ce(b(G)("text-sm text-muted-foreground", t.class))
    }, [
      B(n.$slots, "default")
    ], 2));
  }
}), ah = /* @__PURE__ */ S({
  __name: "CardContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("div", {
      class: ce(b(G)("p-6 pt-0", t.class))
    }, [
      B(n.$slots, "default")
    ], 2));
  }
}), OS = /* @__PURE__ */ S({
  __name: "CardFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("div", {
      class: ce(b(G)("flex items-center p-6 pt-0", t.class))
    }, [
      B(n.$slots, "default")
    ], 2));
  }
}), ste = /* @__PURE__ */ S({
  __name: "Checkbox",
  props: {
    defaultChecked: { type: Boolean },
    checked: { type: [Boolean, String] },
    disabled: { type: Boolean },
    required: { type: Boolean },
    name: {},
    value: {},
    id: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:checked"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: s, ...a } = n;
      return a;
    }), o = Le(i, r);
    return (s, a) => (x(), L(b(KM), oe(b(o), {
      class: b(G)(
        "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
        n.class
      )
    }), {
      default: A(() => [
        $(b(YM), { class: "flex h-full w-full items-center justify-center text-current" }, {
          default: A(() => [
            B(s.$slots, "default", {}, () => [
              $(b($l), { class: "h-4 w-4" })
            ])
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), ate = /* @__PURE__ */ S({
  __name: "Collapsible",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const i = Le(e, t);
    return (o, s) => (x(), L(b(QM), Pe(Ue(b(i))), {
      default: A(({ open: a }) => [
        B(o.$slots, "default", { open: a })
      ]),
      _: 3
    }, 16));
  }
}), lte = /* @__PURE__ */ S({
  __name: "CollapsibleTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(ZM), Pe(Ue(t)), {
      default: A(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ute = /* @__PURE__ */ S({
  __name: "CollapsibleContent",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(XM), oe(t, { class: "overflow-hidden transition-all data-[state=closed]:animate-collapsible-up data-[state=open]:animate-collapsible-down" }), {
      default: A(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), d2 = /* @__PURE__ */ S({
  __name: "Command",
  props: {
    modelValue: { default: "" },
    defaultValue: {},
    open: { type: Boolean, default: !0 },
    defaultOpen: { type: Boolean },
    searchTerm: {},
    selectedValue: {},
    multiple: { type: Boolean },
    disabled: { type: Boolean },
    name: {},
    dir: {},
    filterFunction: {},
    displayValue: {},
    resetSearchTermOnBlur: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue", "update:open", "update:searchTerm", "update:selectedValue"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: s, ...a } = n;
      return a;
    }), o = Le(i, r);
    return (s, a) => (x(), L(b(JM), oe(b(o), {
      class: b(G)(
        "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
        n.class
      )
    }), {
      default: A(() => [
        B(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), IS = /* @__PURE__ */ S({
  __name: "Dialog",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const i = Le(e, t);
    return (o, s) => (x(), L(b(eA), Pe(Ue(b(i))), {
      default: A(() => [
        B(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), cte = /* @__PURE__ */ S({
  __name: "DialogClose",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(R0), Pe(Ue(t)), {
      default: A(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), fte = /* @__PURE__ */ S({
  __name: "DialogTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(tA), Pe(Ue(t)), {
      default: A(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), dte = /* @__PURE__ */ S({
  __name: "DialogHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("div", {
      class: ce(b(G)("flex flex-col gap-y-1.5 text-center sm:text-left", t.class))
    }, [
      B(n.$slots, "default")
    ], 2));
  }
}), pte = /* @__PURE__ */ S({
  __name: "DialogTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(nA), oe(b(r), {
      class: b(G)("text-lg font-semibold leading-none tracking-tight", t.class)
    }), {
      default: A(() => [
        B(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), hte = /* @__PURE__ */ S({
  __name: "DialogDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(rA), oe(b(r), {
      class: b(G)("text-sm text-muted-foreground", t.class)
    }), {
      default: A(() => [
        B(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), RS = /* @__PURE__ */ S({
  __name: "DialogContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: s, ...a } = n;
      return a;
    }), o = Le(i, r);
    return (s, a) => (x(), L(b(X_), null, {
      default: A(() => [
        $(b(J_), { class: "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0" }),
        $(b(e2), oe(b(o), {
          class: b(G)(
            "fixed left-1/2 top-1/2 z-50 grid w-full max-w-lg -translate-x-1/2 -translate-y-1/2 gap-4 border bg-layer-0 p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
            n.class
          )
        }), {
          default: A(() => [
            B(s.$slots, "default"),
            $(b(R0), {
              onMousedown: K_(() => {
              }, ["prevent"]),
              class: "ring-offset-background absolute right-4 top-4 rounded-sm opacity-70 transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground"
            }, {
              default: A(() => [
                $(b(L0), { class: "h-4 w-4" }),
                a[0] || (a[0] = be("span", { class: "sr-only" }, "Close", -1))
              ]),
              _: 1
            })
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), gte = /* @__PURE__ */ S({
  __name: "DialogScrollContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: s, ...a } = n;
      return a;
    }), o = Le(i, r);
    return (s, a) => (x(), L(b(X_), null, {
      default: A(() => [
        $(b(J_), { class: "fixed inset-0 z-50 grid place-items-center overflow-y-auto bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0" }, {
          default: A(() => [
            $(b(e2), oe({
              class: b(G)(
                "relative z-50 my-8 grid w-full max-w-lg gap-4 border border-border bg-layer-0 p-6 shadow-lg duration-200 sm:rounded-lg md:w-full",
                n.class
              )
            }, b(o), {
              onPointerDownOutside: a[0] || (a[0] = (l) => {
                const u = l.detail.originalEvent, c = u.target;
                (u.offsetX > c.clientWidth || u.offsetY > c.clientHeight) && l.preventDefault();
              })
            }), {
              default: A(() => [
                B(s.$slots, "default"),
                $(b(R0), { class: "absolute right-3 top-3 rounded-md p-0.5 transition-colors hover:bg-secondary" }, {
                  default: A(() => [
                    $(b(L0), { class: "h-4 w-4" }),
                    a[1] || (a[1] = be("span", { class: "sr-only" }, "Close", -1))
                  ]),
                  _: 1
                })
              ]),
              _: 3
            }, 16, ["class"])
          ]),
          _: 3
        })
      ]),
      _: 3
    }));
  }
}), mte = /* @__PURE__ */ S({
  __name: "DialogFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("div", {
      class: ce(b(G)("flex flex-col-reverse sm:flex-row sm:justify-end sm:gap-x-2", t.class))
    }, [
      B(n.$slots, "default")
    ], 2));
  }
}), bte = /* @__PURE__ */ S({
  __name: "CommandDialog",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const i = Le(e, t);
    return (o, s) => (x(), L(b(IS), Pe(Ue(b(i))), {
      default: A(() => [
        $(b(RS), { class: "overflow-hidden p-0 shadow-lg" }, {
          default: A(() => [
            $(d2, { class: "[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5" }, {
              default: A(() => [
                B(o.$slots, "default")
              ]),
              _: 3
            })
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 16));
  }
}), yte = /* @__PURE__ */ S({
  __name: "CommandEmpty",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: r, ...i } = t;
      return i;
    });
    return (r, i) => (x(), L(b(iA), oe(n.value, {
      class: b(G)("py-6 text-center text-sm", t.class)
    }), {
      default: A(() => [
        B(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), LS = /* @__PURE__ */ S({
  __name: "CommandGroup",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    heading: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: r, ...i } = t;
      return i;
    });
    return (r, i) => (x(), L(b(oA), oe(n.value, {
      class: b(G)(
        "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
        t.class
      )
    }), {
      default: A(() => [
        r.heading ? (x(), L(b(sA), {
          key: 0,
          class: "px-2 py-1.5 text-xs font-medium text-muted-foreground"
        }, {
          default: A(() => [
            Xt(ze(r.heading), 1)
          ]),
          _: 1
        })) : Qe("", !0),
        B(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), BS = {
  class: "flex items-center border-b px-3",
  "cmdk-input-wrapper": ""
}, vte = /* @__PURE__ */ S({
  inheritAttrs: !1,
  __name: "CommandInput",
  props: {
    type: {},
    disabled: { type: Boolean },
    autoFocus: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), W("div", BS, [
      $(b(QT), { class: "mr-2 h-4 w-4 shrink-0 opacity-50" }),
      $(b(aA), oe({ ...b(r), ...i.$attrs }, {
        "auto-focus": "",
        class: b(G)(
          "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
          t.class
        )
      }), null, 16, ["class"])
    ]));
  }
}), PS = /* @__PURE__ */ S({
  __name: "CommandItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: s, ...a } = n;
      return a;
    }), o = Le(i, r);
    return (s, a) => (x(), L(b(lA), oe(b(o), {
      class: b(G)(
        "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled]:pointer-events-none data-[highlighted]:bg-accent data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: A(() => [
        B(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), $S = { role: "presentation" }, _te = /* @__PURE__ */ S({
  __name: "CommandList",
  props: {
    forceMount: { type: Boolean },
    position: {},
    bodyLock: { type: Boolean },
    dismissable: { type: Boolean, default: !1 },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean },
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: s, ...a } = n;
      return a;
    }), o = Le(i, r);
    return (s, a) => (x(), L(b(uA), oe(b(o), {
      class: b(G)("max-h-[300px] overflow-y-auto overflow-x-hidden", n.class)
    }), {
      default: A(() => [
        be("div", $S, [
          B(s.$slots, "default")
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Ete = /* @__PURE__ */ S({
  __name: "CommandSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: r, ...i } = t;
      return i;
    });
    return (r, i) => (x(), L(b(cA), oe(n.value, {
      class: b(G)("-mx-1 h-px bg-border", t.class)
    }), {
      default: A(() => [
        B(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), wte = /* @__PURE__ */ S({
  __name: "CommandShortcut",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("span", {
      class: ce(b(G)("ml-auto text-xs tracking-widest text-muted-foreground", t.class))
    }, [
      B(n.$slots, "default")
    ], 2));
  }
}), p2 = /* @__PURE__ */ S({
  __name: "DropdownMenu",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    dir: {},
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const i = Le(e, t);
    return (o, s) => (x(), L(b(fA), Pe(Ue(b(i))), {
      default: A(() => [
        B(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), h2 = /* @__PURE__ */ S({
  __name: "DropdownMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const n = We(e);
    return (r, i) => (x(), L(b(dA), oe({ class: "outline-none" }, b(n)), {
      default: A(() => [
        B(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), g2 = /* @__PURE__ */ S({
  __name: "DropdownMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: s, ...a } = n;
      return a;
    }), o = Le(i, r);
    return (s, a) => (x(), L(b(pA), null, {
      default: A(() => [
        $(b(hA), oe(b(o), {
          class: b(G)(
            "z-50 min-w-32 overflow-hidden rounded-md border border-border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
            n.class
          )
        }), {
          default: A(() => [
            B(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), xte = /* @__PURE__ */ S({
  __name: "DropdownMenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(gA), Pe(Ue(t)), {
      default: A(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), kte = /* @__PURE__ */ S({
  __name: "DropdownMenuRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const i = Le(e, t);
    return (o, s) => (x(), L(b(mA), Pe(Ue(b(i))), {
      default: A(() => [
        B(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), m2 = /* @__PURE__ */ S({
  __name: "DropdownMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(bA), oe(b(r), {
      class: b(G)(
        "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        i.inset && "pl-8",
        t.class
      )
    }), {
      default: A(() => [
        B(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), zS = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, Mte = /* @__PURE__ */ S({
  __name: "DropdownMenuCheckboxItem",
  props: {
    checked: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select", "update:checked"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: s, ...a } = n;
      return a;
    }), o = Le(i, r);
    return (s, a) => (x(), L(b(yA), oe(b(o), {
      class: b(G)(
        "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: A(() => [
        be("span", zS, [
          $(b(t2), null, {
            default: A(() => [
              $(b($l), { class: "h-4 w-4" })
            ]),
            _: 1
          })
        ]),
        B(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), FS = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, Ate = /* @__PURE__ */ S({
  __name: "DropdownMenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: s, ...a } = n;
      return a;
    }), o = Le(i, r);
    return (s, a) => (x(), L(b(vA), oe(b(o), {
      class: b(G)(
        "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: A(() => [
        be("span", FS, [
          $(b(t2), null, {
            default: A(() => [
              $(b(Jf), { class: "h-2 w-2 fill-current" })
            ]),
            _: 1
          })
        ]),
        B(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Tte = /* @__PURE__ */ S({
  __name: "DropdownMenuShortcut",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("span", {
      class: ce(b(G)("ml-auto text-xs tracking-widest opacity-60", t.class))
    }, [
      B(n.$slots, "default")
    ], 2));
  }
}), Ste = /* @__PURE__ */ S({
  __name: "DropdownMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: r, ...i } = t;
      return i;
    });
    return (r, i) => (x(), L(b(_A), oe(n.value, {
      class: b(G)("-mx-1 my-1 h-px bg-muted", t.class)
    }), null, 16, ["class"]));
  }
}), Cte = /* @__PURE__ */ S({
  __name: "DropdownMenuLabel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(EA), oe(b(r), {
      class: b(G)("px-2 py-1.5 text-sm font-semibold", i.inset && "pl-8", t.class)
    }), {
      default: A(() => [
        B(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Nte = /* @__PURE__ */ S({
  __name: "DropdownMenuSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const i = Le(e, t);
    return (o, s) => (x(), L(b(wA), Pe(Ue(b(i))), {
      default: A(() => [
        B(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Dte = /* @__PURE__ */ S({
  __name: "DropdownMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(xA), oe(b(r), {
      class: b(G)(
        "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
        t.class
      )
    }), {
      default: A(() => [
        B(i.$slots, "default"),
        $(b(Xf), { class: "ml-auto h-4 w-4" })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Ote = /* @__PURE__ */ S({
  __name: "DropdownMenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: s, ...a } = n;
      return a;
    }), o = Le(i, r);
    return (s, a) => (x(), L(b(kA), oe(b(o), {
      class: b(G)(
        "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        n.class
      )
    }), {
      default: A(() => [
        B(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
});
/*!
  * vue-draggable-next v2.2.0
  * (c) 2023 Anish George
  * @license MIT
  */
/**!
 * Sortable 1.14.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function $1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function jr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $1(Object(n), !0).forEach(function(r) {
      jS(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Ku(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Ku = function(t) {
    return typeof t;
  } : Ku = function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ku(e);
}
function jS(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function fi() {
  return fi = Object.assign || function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, fi.apply(this, arguments);
}
function US(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function VS(e, t) {
  if (e == null) return {};
  var n = US(e, t), r, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var HS = "1.14.0";
function ai(e) {
  if (typeof window < "u" && window.navigator)
    return !!/* @__PURE__ */ navigator.userAgent.match(e);
}
var hi = ai(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i), zl = ai(/Edge/i), z1 = ai(/firefox/i), Ca = ai(/safari/i) && !ai(/chrome/i) && !ai(/android/i), b2 = ai(/iP(ad|od|hone)/i), qS = ai(/chrome/i) && ai(/android/i), y2 = {
  capture: !1,
  passive: !1
};
function tt(e, t, n) {
  e.addEventListener(t, n, !hi && y2);
}
function Ye(e, t, n) {
  e.removeEventListener(t, n, !hi && y2);
}
function _c(e, t) {
  if (t) {
    if (t[0] === ">" && (t = t.substring(1)), e)
      try {
        if (e.matches)
          return e.matches(t);
        if (e.msMatchesSelector)
          return e.msMatchesSelector(t);
        if (e.webkitMatchesSelector)
          return e.webkitMatchesSelector(t);
      } catch {
        return !1;
      }
    return !1;
  }
}
function GS(e) {
  return e.host && e !== document && e.host.nodeType ? e.host : e.parentNode;
}
function Ar(e, t, n, r) {
  if (e) {
    n = n || document;
    do {
      if (t != null && (t[0] === ">" ? e.parentNode === n && _c(e, t) : _c(e, t)) || r && e === n)
        return e;
      if (e === n) break;
    } while (e = GS(e));
  }
  return null;
}
var F1 = /\s+/g;
function In(e, t, n) {
  if (e && t)
    if (e.classList)
      e.classList[n ? "add" : "remove"](t);
    else {
      var r = (" " + e.className + " ").replace(F1, " ").replace(" " + t + " ", " ");
      e.className = (r + (n ? " " + t : "")).replace(F1, " ");
    }
}
function Ne(e, t, n) {
  var r = e && e.style;
  if (r) {
    if (n === void 0)
      return document.defaultView && document.defaultView.getComputedStyle ? n = document.defaultView.getComputedStyle(e, "") : e.currentStyle && (n = e.currentStyle), t === void 0 ? n : n[t];
    !(t in r) && t.indexOf("webkit") === -1 && (t = "-webkit-" + t), r[t] = n + (typeof n == "string" ? "" : "px");
  }
}
function us(e, t) {
  var n = "";
  if (typeof e == "string")
    n = e;
  else
    do {
      var r = Ne(e, "transform");
      r && r !== "none" && (n = r + " " + n);
    } while (!t && (e = e.parentNode));
  var i = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return i && new i(n);
}
function v2(e, t, n) {
  if (e) {
    var r = e.getElementsByTagName(t), i = 0, o = r.length;
    if (n)
      for (; i < o; i++)
        n(r[i], i);
    return r;
  }
  return [];
}
function Lr() {
  var e = document.scrollingElement;
  return e || document.documentElement;
}
function Lt(e, t, n, r, i) {
  if (!(!e.getBoundingClientRect && e !== window)) {
    var o, s, a, l, u, c, f;
    if (e !== window && e.parentNode && e !== Lr() ? (o = e.getBoundingClientRect(), s = o.top, a = o.left, l = o.bottom, u = o.right, c = o.height, f = o.width) : (s = 0, a = 0, l = window.innerHeight, u = window.innerWidth, c = window.innerHeight, f = window.innerWidth), (t || n) && e !== window && (i = i || e.parentNode, !hi))
      do
        if (i && i.getBoundingClientRect && (Ne(i, "transform") !== "none" || n && Ne(i, "position") !== "static")) {
          var d = i.getBoundingClientRect();
          s -= d.top + parseInt(Ne(i, "border-top-width")), a -= d.left + parseInt(Ne(i, "border-left-width")), l = s + o.height, u = a + o.width;
          break;
        }
      while (i = i.parentNode);
    if (r && e !== window) {
      var p = us(i || e), h = p && p.a, m = p && p.d;
      p && (s /= m, a /= h, f /= h, c /= m, l = s + c, u = a + f);
    }
    return {
      top: s,
      left: a,
      bottom: l,
      right: u,
      width: f,
      height: c
    };
  }
}
function j1(e, t, n) {
  for (var r = Ni(e, !0), i = Lt(e)[t]; r; ) {
    var o = Lt(r)[n], s = void 0;
    if (s = i >= o, !s) return r;
    if (r === Lr()) break;
    r = Ni(r, !1);
  }
  return !1;
}
function _s(e, t, n, r) {
  for (var i = 0, o = 0, s = e.children; o < s.length; ) {
    if (s[o].style.display !== "none" && s[o] !== De.ghost && (r || s[o] !== De.dragged) && Ar(s[o], n.draggable, e, !1)) {
      if (i === t)
        return s[o];
      i++;
    }
    o++;
  }
  return null;
}
function B0(e, t) {
  for (var n = e.lastElementChild; n && (n === De.ghost || Ne(n, "display") === "none" || t && !_c(n, t)); )
    n = n.previousElementSibling;
  return n || null;
}
function Wn(e, t) {
  var n = 0;
  if (!e || !e.parentNode)
    return -1;
  for (; e = e.previousElementSibling; )
    e.nodeName.toUpperCase() !== "TEMPLATE" && e !== De.clone && (!t || _c(e, t)) && n++;
  return n;
}
function U1(e) {
  var t = 0, n = 0, r = Lr();
  if (e)
    do {
      var i = us(e), o = i.a, s = i.d;
      t += e.scrollLeft * o, n += e.scrollTop * s;
    } while (e !== r && (e = e.parentNode));
  return [t, n];
}
function WS(e, t) {
  for (var n in e)
    if (e.hasOwnProperty(n)) {
      for (var r in t)
        if (t.hasOwnProperty(r) && t[r] === e[n][r]) return Number(n);
    }
  return -1;
}
function Ni(e, t) {
  if (!e || !e.getBoundingClientRect) return Lr();
  var n = e, r = !1;
  do
    if (n.clientWidth < n.scrollWidth || n.clientHeight < n.scrollHeight) {
      var i = Ne(n);
      if (n.clientWidth < n.scrollWidth && (i.overflowX == "auto" || i.overflowX == "scroll") || n.clientHeight < n.scrollHeight && (i.overflowY == "auto" || i.overflowY == "scroll")) {
        if (!n.getBoundingClientRect || n === document.body) return Lr();
        if (r || t) return n;
        r = !0;
      }
    }
  while (n = n.parentNode);
  return Lr();
}
function KS(e, t) {
  if (e && t)
    for (var n in t)
      t.hasOwnProperty(n) && (e[n] = t[n]);
  return e;
}
function jd(e, t) {
  return Math.round(e.top) === Math.round(t.top) && Math.round(e.left) === Math.round(t.left) && Math.round(e.height) === Math.round(t.height) && Math.round(e.width) === Math.round(t.width);
}
var Na;
function _2(e, t) {
  return function() {
    if (!Na) {
      var n = arguments, r = this;
      n.length === 1 ? e.call(r, n[0]) : e.apply(r, n), Na = setTimeout(function() {
        Na = void 0;
      }, t);
    }
  };
}
function YS() {
  clearTimeout(Na), Na = void 0;
}
function E2(e, t, n) {
  e.scrollLeft += t, e.scrollTop += n;
}
function w2(e) {
  var t = window.Polymer, n = window.jQuery || window.Zepto;
  return t && t.dom ? t.dom(e).cloneNode(!0) : n ? n(e).clone(!0)[0] : e.cloneNode(!0);
}
var Pn = "Sortable" + (/* @__PURE__ */ new Date()).getTime();
function QS() {
  var e = [], t;
  return {
    captureAnimationState: function() {
      if (e = [], !!this.options.animation) {
        var r = [].slice.call(this.el.children);
        r.forEach(function(i) {
          if (!(Ne(i, "display") === "none" || i === De.ghost)) {
            e.push({
              target: i,
              rect: Lt(i)
            });
            var o = jr({}, e[e.length - 1].rect);
            if (i.thisAnimationDuration) {
              var s = us(i, !0);
              s && (o.top -= s.f, o.left -= s.e);
            }
            i.fromRect = o;
          }
        });
      }
    },
    addAnimationState: function(r) {
      e.push(r);
    },
    removeAnimationState: function(r) {
      e.splice(WS(e, {
        target: r
      }), 1);
    },
    animateAll: function(r) {
      var i = this;
      if (!this.options.animation) {
        clearTimeout(t), typeof r == "function" && r();
        return;
      }
      var o = !1, s = 0;
      e.forEach(function(a) {
        var l = 0, u = a.target, c = u.fromRect, f = Lt(u), d = u.prevFromRect, p = u.prevToRect, h = a.rect, m = us(u, !0);
        m && (f.top -= m.f, f.left -= m.e), u.toRect = f, u.thisAnimationDuration && jd(d, f) && !jd(c, f) && // Make sure animatingRect is on line between toRect & fromRect
        (h.top - f.top) / (h.left - f.left) === (c.top - f.top) / (c.left - f.left) && (l = XS(h, d, p, i.options)), jd(f, c) || (u.prevFromRect = c, u.prevToRect = f, l || (l = i.options.animation), i.animate(u, h, f, l)), l && (o = !0, s = Math.max(s, l), clearTimeout(u.animationResetTimer), u.animationResetTimer = setTimeout(function() {
          u.animationTime = 0, u.prevFromRect = null, u.fromRect = null, u.prevToRect = null, u.thisAnimationDuration = null;
        }, l), u.thisAnimationDuration = l);
      }), clearTimeout(t), o ? t = setTimeout(function() {
        typeof r == "function" && r();
      }, s) : typeof r == "function" && r(), e = [];
    },
    animate: function(r, i, o, s) {
      if (s) {
        Ne(r, "transition", ""), Ne(r, "transform", "");
        var a = us(this.el), l = a && a.a, u = a && a.d, c = (i.left - o.left) / (l || 1), f = (i.top - o.top) / (u || 1);
        r.animatingX = !!c, r.animatingY = !!f, Ne(r, "transform", "translate3d(" + c + "px," + f + "px,0)"), this.forRepaintDummy = ZS(r), Ne(r, "transition", "transform " + s + "ms" + (this.options.easing ? " " + this.options.easing : "")), Ne(r, "transform", "translate3d(0,0,0)"), typeof r.animated == "number" && clearTimeout(r.animated), r.animated = setTimeout(function() {
          Ne(r, "transition", ""), Ne(r, "transform", ""), r.animated = !1, r.animatingX = !1, r.animatingY = !1;
        }, s);
      }
    }
  };
}
function ZS(e) {
  return e.offsetWidth;
}
function XS(e, t, n, r) {
  return Math.sqrt(Math.pow(t.top - e.top, 2) + Math.pow(t.left - e.left, 2)) / Math.sqrt(Math.pow(t.top - n.top, 2) + Math.pow(t.left - n.left, 2)) * r.animation;
}
var jo = [], Ud = {
  initializeByDefault: !0
}, Fl = {
  mount: function(t) {
    for (var n in Ud)
      Ud.hasOwnProperty(n) && !(n in t) && (t[n] = Ud[n]);
    jo.forEach(function(r) {
      if (r.pluginName === t.pluginName)
        throw "Sortable: Cannot mount plugin ".concat(t.pluginName, " more than once");
    }), jo.push(t);
  },
  pluginEvent: function(t, n, r) {
    var i = this;
    this.eventCanceled = !1, r.cancel = function() {
      i.eventCanceled = !0;
    };
    var o = t + "Global";
    jo.forEach(function(s) {
      n[s.pluginName] && (n[s.pluginName][o] && n[s.pluginName][o](jr({
        sortable: n
      }, r)), n.options[s.pluginName] && n[s.pluginName][t] && n[s.pluginName][t](jr({
        sortable: n
      }, r)));
    });
  },
  initializePlugins: function(t, n, r, i) {
    jo.forEach(function(a) {
      var l = a.pluginName;
      if (!(!t.options[l] && !a.initializeByDefault)) {
        var u = new a(t, n, t.options);
        u.sortable = t, u.options = t.options, t[l] = u, fi(r, u.defaults);
      }
    });
    for (var o in t.options)
      if (t.options.hasOwnProperty(o)) {
        var s = this.modifyOption(t, o, t.options[o]);
        typeof s < "u" && (t.options[o] = s);
      }
  },
  getEventProperties: function(t, n) {
    var r = {};
    return jo.forEach(function(i) {
      typeof i.eventProperties == "function" && fi(r, i.eventProperties.call(n[i.pluginName], t));
    }), r;
  },
  modifyOption: function(t, n, r) {
    var i;
    return jo.forEach(function(o) {
      t[o.pluginName] && o.optionListeners && typeof o.optionListeners[n] == "function" && (i = o.optionListeners[n].call(t[o.pluginName], r));
    }), i;
  }
};
function JS(e) {
  var t = e.sortable, n = e.rootEl, r = e.name, i = e.targetEl, o = e.cloneEl, s = e.toEl, a = e.fromEl, l = e.oldIndex, u = e.newIndex, c = e.oldDraggableIndex, f = e.newDraggableIndex, d = e.originalEvent, p = e.putSortable, h = e.extraEventProperties;
  if (t = t || n && n[Pn], !!t) {
    var m, g = t.options, y = "on" + r.charAt(0).toUpperCase() + r.substr(1);
    window.CustomEvent && !hi && !zl ? m = new CustomEvent(r, {
      bubbles: !0,
      cancelable: !0
    }) : (m = document.createEvent("Event"), m.initEvent(r, !0, !0)), m.to = s || n, m.from = a || n, m.item = i || n, m.clone = o, m.oldIndex = l, m.newIndex = u, m.oldDraggableIndex = c, m.newDraggableIndex = f, m.originalEvent = d, m.pullMode = p ? p.lastPutMode : void 0;
    var _ = jr(jr({}, h), Fl.getEventProperties(r, t));
    for (var E in _)
      m[E] = _[E];
    n && n.dispatchEvent(m), g[y] && g[y].call(t, m);
  }
}
var e6 = ["evt"], bn = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = r.evt, o = VS(r, e6);
  Fl.pluginEvent.bind(De)(t, n, jr({
    dragEl: pe,
    parentEl: Et,
    ghostEl: Re,
    rootEl: bt,
    nextEl: oo,
    lastDownEl: Yu,
    cloneEl: wt,
    cloneHidden: Ai,
    dragStarted: ma,
    putSortable: Gt,
    activeSortable: De.active,
    originalEvent: i,
    oldIndex: rs,
    oldDraggableIndex: Da,
    newIndex: Rn,
    newDraggableIndex: yi,
    hideGhostForTarget: A2,
    unhideGhostForTarget: T2,
    cloneNowHidden: function() {
      Ai = !0;
    },
    cloneNowShown: function() {
      Ai = !1;
    },
    dispatchSortableEvent: function(a) {
      cn({
        sortable: n,
        name: a,
        originalEvent: i
      });
    }
  }, o));
};
function cn(e) {
  JS(jr({
    putSortable: Gt,
    cloneEl: wt,
    targetEl: pe,
    rootEl: bt,
    oldIndex: rs,
    oldDraggableIndex: Da,
    newIndex: Rn,
    newDraggableIndex: yi
  }, e));
}
var pe, Et, Re, bt, oo, Yu, wt, Ai, rs, Rn, Da, yi, su, Gt, Qo = !1, Ec = !1, wc = [], no, ir, Vd, Hd, V1, H1, ma, Uo, Oa, Ia = !1, au = !1, Qu, tn, qd = [], lh = !1, xc = [], ed = typeof document < "u", lu = b2, q1 = zl || hi ? "cssFloat" : "float", t6 = ed && !qS && !b2 && "draggable" in document.createElement("div"), x2 = function() {
  if (ed) {
    if (hi)
      return !1;
    var e = document.createElement("x");
    return e.style.cssText = "pointer-events:auto", e.style.pointerEvents === "auto";
  }
}(), k2 = function(t, n) {
  var r = Ne(t), i = parseInt(r.width) - parseInt(r.paddingLeft) - parseInt(r.paddingRight) - parseInt(r.borderLeftWidth) - parseInt(r.borderRightWidth), o = _s(t, 0, n), s = _s(t, 1, n), a = o && Ne(o), l = s && Ne(s), u = a && parseInt(a.marginLeft) + parseInt(a.marginRight) + Lt(o).width, c = l && parseInt(l.marginLeft) + parseInt(l.marginRight) + Lt(s).width;
  if (r.display === "flex")
    return r.flexDirection === "column" || r.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  if (r.display === "grid")
    return r.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  if (o && a.float && a.float !== "none") {
    var f = a.float === "left" ? "left" : "right";
    return s && (l.clear === "both" || l.clear === f) ? "vertical" : "horizontal";
  }
  return o && (a.display === "block" || a.display === "flex" || a.display === "table" || a.display === "grid" || u >= i && r[q1] === "none" || s && r[q1] === "none" && u + c > i) ? "vertical" : "horizontal";
}, n6 = function(t, n, r) {
  var i = r ? t.left : t.top, o = r ? t.right : t.bottom, s = r ? t.width : t.height, a = r ? n.left : n.top, l = r ? n.right : n.bottom, u = r ? n.width : n.height;
  return i === a || o === l || i + s / 2 === a + u / 2;
}, r6 = function(t, n) {
  var r;
  return wc.some(function(i) {
    var o = i[Pn].options.emptyInsertThreshold;
    if (!(!o || B0(i))) {
      var s = Lt(i), a = t >= s.left - o && t <= s.right + o, l = n >= s.top - o && n <= s.bottom + o;
      if (a && l)
        return r = i;
    }
  }), r;
}, M2 = function(t) {
  function n(o, s) {
    return function(a, l, u, c) {
      var f = a.options.group.name && l.options.group.name && a.options.group.name === l.options.group.name;
      if (o == null && (s || f))
        return !0;
      if (o == null || o === !1)
        return !1;
      if (s && o === "clone")
        return o;
      if (typeof o == "function")
        return n(o(a, l, u, c), s)(a, l, u, c);
      var d = (s ? a : l).options.group.name;
      return o === !0 || typeof o == "string" && o === d || o.join && o.indexOf(d) > -1;
    };
  }
  var r = {}, i = t.group;
  (!i || Ku(i) != "object") && (i = {
    name: i
  }), r.name = i.name, r.checkPull = n(i.pull, !0), r.checkPut = n(i.put), r.revertClone = i.revertClone, t.group = r;
}, A2 = function() {
  !x2 && Re && Ne(Re, "display", "none");
}, T2 = function() {
  !x2 && Re && Ne(Re, "display", "");
};
ed && document.addEventListener("click", function(e) {
  if (Ec)
    return e.preventDefault(), e.stopPropagation && e.stopPropagation(), e.stopImmediatePropagation && e.stopImmediatePropagation(), Ec = !1, !1;
}, !0);
var ro = function(t) {
  if (pe) {
    t = t.touches ? t.touches[0] : t;
    var n = r6(t.clientX, t.clientY);
    if (n) {
      var r = {};
      for (var i in t)
        t.hasOwnProperty(i) && (r[i] = t[i]);
      r.target = r.rootEl = n, r.preventDefault = void 0, r.stopPropagation = void 0, n[Pn]._onDragOver(r);
    }
  }
}, i6 = function(t) {
  pe && pe.parentNode[Pn]._isOutsideThisEl(t.target);
};
function De(e, t) {
  if (!(e && e.nodeType && e.nodeType === 1))
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(e));
  this.el = e, this.options = t = fi({}, t), e[Pn] = this;
  var n = {
    group: null,
    sort: !0,
    disabled: !1,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(e.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: !1,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: !0,
    direction: function() {
      return k2(e, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: !0,
    animation: 0,
    easing: null,
    setData: function(s, a) {
      s.setData("Text", a.textContent);
    },
    dropBubble: !1,
    dragoverBubble: !1,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: !1,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: !1,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: !1,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: De.supportPointer !== !1 && "PointerEvent" in window && !Ca,
    emptyInsertThreshold: 5
  };
  Fl.initializePlugins(this, e, n);
  for (var r in n)
    !(r in t) && (t[r] = n[r]);
  M2(t);
  for (var i in this)
    i.charAt(0) === "_" && typeof this[i] == "function" && (this[i] = this[i].bind(this));
  this.nativeDraggable = t.forceFallback ? !1 : t6, this.nativeDraggable && (this.options.touchStartThreshold = 1), t.supportPointer ? tt(e, "pointerdown", this._onTapStart) : (tt(e, "mousedown", this._onTapStart), tt(e, "touchstart", this._onTapStart)), this.nativeDraggable && (tt(e, "dragover", this), tt(e, "dragenter", this)), wc.push(this.el), t.store && t.store.get && this.sort(t.store.get(this) || []), fi(this, QS());
}
De.prototype = /** @lends Sortable.prototype */
{
  constructor: De,
  _isOutsideThisEl: function(t) {
    !this.el.contains(t) && t !== this.el && (Uo = null);
  },
  _getDirection: function(t, n) {
    return typeof this.options.direction == "function" ? this.options.direction.call(this, t, n, pe) : this.options.direction;
  },
  _onTapStart: function(t) {
    if (t.cancelable) {
      var n = this, r = this.el, i = this.options, o = i.preventOnFilter, s = t.type, a = t.touches && t.touches[0] || t.pointerType && t.pointerType === "touch" && t, l = (a || t).target, u = t.target.shadowRoot && (t.path && t.path[0] || t.composedPath && t.composedPath()[0]) || l, c = i.filter;
      if (d6(r), !pe && !(/mousedown|pointerdown/.test(s) && t.button !== 0 || i.disabled) && !u.isContentEditable && !(!this.nativeDraggable && Ca && l && l.tagName.toUpperCase() === "SELECT") && (l = Ar(l, i.draggable, r, !1), !(l && l.animated) && Yu !== l)) {
        if (rs = Wn(l), Da = Wn(l, i.draggable), typeof c == "function") {
          if (c.call(this, t, l, this)) {
            cn({
              sortable: n,
              rootEl: u,
              name: "filter",
              targetEl: l,
              toEl: r,
              fromEl: r
            }), bn("filter", n, {
              evt: t
            }), o && t.cancelable && t.preventDefault();
            return;
          }
        } else if (c && (c = c.split(",").some(function(f) {
          if (f = Ar(u, f.trim(), r, !1), f)
            return cn({
              sortable: n,
              rootEl: f,
              name: "filter",
              targetEl: l,
              fromEl: r,
              toEl: r
            }), bn("filter", n, {
              evt: t
            }), !0;
        }), c)) {
          o && t.cancelable && t.preventDefault();
          return;
        }
        i.handle && !Ar(u, i.handle, r, !1) || this._prepareDragStart(t, a, l);
      }
    }
  },
  _prepareDragStart: function(t, n, r) {
    var i = this, o = i.el, s = i.options, a = o.ownerDocument, l;
    if (r && !pe && r.parentNode === o) {
      var u = Lt(r);
      if (bt = o, pe = r, Et = pe.parentNode, oo = pe.nextSibling, Yu = r, su = s.group, De.dragged = pe, no = {
        target: pe,
        clientX: (n || t).clientX,
        clientY: (n || t).clientY
      }, V1 = no.clientX - u.left, H1 = no.clientY - u.top, this._lastX = (n || t).clientX, this._lastY = (n || t).clientY, pe.style["will-change"] = "all", l = function() {
        if (bn("delayEnded", i, {
          evt: t
        }), De.eventCanceled) {
          i._onDrop();
          return;
        }
        i._disableDelayedDragEvents(), !z1 && i.nativeDraggable && (pe.draggable = !0), i._triggerDragStart(t, n), cn({
          sortable: i,
          name: "choose",
          originalEvent: t
        }), In(pe, s.chosenClass, !0);
      }, s.ignore.split(",").forEach(function(c) {
        v2(pe, c.trim(), Gd);
      }), tt(a, "dragover", ro), tt(a, "mousemove", ro), tt(a, "touchmove", ro), tt(a, "mouseup", i._onDrop), tt(a, "touchend", i._onDrop), tt(a, "touchcancel", i._onDrop), z1 && this.nativeDraggable && (this.options.touchStartThreshold = 4, pe.draggable = !0), bn("delayStart", this, {
        evt: t
      }), s.delay && (!s.delayOnTouchOnly || n) && (!this.nativeDraggable || !(zl || hi))) {
        if (De.eventCanceled) {
          this._onDrop();
          return;
        }
        tt(a, "mouseup", i._disableDelayedDrag), tt(a, "touchend", i._disableDelayedDrag), tt(a, "touchcancel", i._disableDelayedDrag), tt(a, "mousemove", i._delayedDragTouchMoveHandler), tt(a, "touchmove", i._delayedDragTouchMoveHandler), s.supportPointer && tt(a, "pointermove", i._delayedDragTouchMoveHandler), i._dragStartTimer = setTimeout(l, s.delay);
      } else
        l();
    }
  },
  _delayedDragTouchMoveHandler: function(t) {
    var n = t.touches ? t.touches[0] : t;
    Math.max(Math.abs(n.clientX - this._lastX), Math.abs(n.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1)) && this._disableDelayedDrag();
  },
  _disableDelayedDrag: function() {
    pe && Gd(pe), clearTimeout(this._dragStartTimer), this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function() {
    var t = this.el.ownerDocument;
    Ye(t, "mouseup", this._disableDelayedDrag), Ye(t, "touchend", this._disableDelayedDrag), Ye(t, "touchcancel", this._disableDelayedDrag), Ye(t, "mousemove", this._delayedDragTouchMoveHandler), Ye(t, "touchmove", this._delayedDragTouchMoveHandler), Ye(t, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function(t, n) {
    n = n || t.pointerType == "touch" && t, !this.nativeDraggable || n ? this.options.supportPointer ? tt(document, "pointermove", this._onTouchMove) : n ? tt(document, "touchmove", this._onTouchMove) : tt(document, "mousemove", this._onTouchMove) : (tt(pe, "dragend", this), tt(bt, "dragstart", this._onDragStart));
    try {
      document.selection ? Zu(function() {
        document.selection.empty();
      }) : window.getSelection().removeAllRanges();
    } catch {
    }
  },
  _dragStarted: function(t, n) {
    if (Qo = !1, bt && pe) {
      bn("dragStarted", this, {
        evt: n
      }), this.nativeDraggable && tt(document, "dragover", i6);
      var r = this.options;
      !t && In(pe, r.dragClass, !1), In(pe, r.ghostClass, !0), De.active = this, t && this._appendGhost(), cn({
        sortable: this,
        name: "start",
        originalEvent: n
      });
    } else
      this._nulling();
  },
  _emulateDragOver: function() {
    if (ir) {
      this._lastX = ir.clientX, this._lastY = ir.clientY, A2();
      for (var t = document.elementFromPoint(ir.clientX, ir.clientY), n = t; t && t.shadowRoot && (t = t.shadowRoot.elementFromPoint(ir.clientX, ir.clientY), t !== n); )
        n = t;
      if (pe.parentNode[Pn]._isOutsideThisEl(t), n)
        do {
          if (n[Pn]) {
            var r = void 0;
            if (r = n[Pn]._onDragOver({
              clientX: ir.clientX,
              clientY: ir.clientY,
              target: t,
              rootEl: n
            }), r && !this.options.dragoverBubble)
              break;
          }
          t = n;
        } while (n = n.parentNode);
      T2();
    }
  },
  _onTouchMove: function(t) {
    if (no) {
      var n = this.options, r = n.fallbackTolerance, i = n.fallbackOffset, o = t.touches ? t.touches[0] : t, s = Re && us(Re, !0), a = Re && s && s.a, l = Re && s && s.d, u = lu && tn && U1(tn), c = (o.clientX - no.clientX + i.x) / (a || 1) + (u ? u[0] - qd[0] : 0) / (a || 1), f = (o.clientY - no.clientY + i.y) / (l || 1) + (u ? u[1] - qd[1] : 0) / (l || 1);
      if (!De.active && !Qo) {
        if (r && Math.max(Math.abs(o.clientX - this._lastX), Math.abs(o.clientY - this._lastY)) < r)
          return;
        this._onDragStart(t, !0);
      }
      if (Re) {
        s ? (s.e += c - (Vd || 0), s.f += f - (Hd || 0)) : s = {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          e: c,
          f
        };
        var d = "matrix(".concat(s.a, ",").concat(s.b, ",").concat(s.c, ",").concat(s.d, ",").concat(s.e, ",").concat(s.f, ")");
        Ne(Re, "webkitTransform", d), Ne(Re, "mozTransform", d), Ne(Re, "msTransform", d), Ne(Re, "transform", d), Vd = c, Hd = f, ir = o;
      }
      t.cancelable && t.preventDefault();
    }
  },
  _appendGhost: function() {
    if (!Re) {
      var t = this.options.fallbackOnBody ? document.body : bt, n = Lt(pe, !0, lu, !0, t), r = this.options;
      if (lu) {
        for (tn = t; Ne(tn, "position") === "static" && Ne(tn, "transform") === "none" && tn !== document; )
          tn = tn.parentNode;
        tn !== document.body && tn !== document.documentElement ? (tn === document && (tn = Lr()), n.top += tn.scrollTop, n.left += tn.scrollLeft) : tn = Lr(), qd = U1(tn);
      }
      Re = pe.cloneNode(!0), In(Re, r.ghostClass, !1), In(Re, r.fallbackClass, !0), In(Re, r.dragClass, !0), Ne(Re, "transition", ""), Ne(Re, "transform", ""), Ne(Re, "box-sizing", "border-box"), Ne(Re, "margin", 0), Ne(Re, "top", n.top), Ne(Re, "left", n.left), Ne(Re, "width", n.width), Ne(Re, "height", n.height), Ne(Re, "opacity", "0.8"), Ne(Re, "position", lu ? "absolute" : "fixed"), Ne(Re, "zIndex", "100000"), Ne(Re, "pointerEvents", "none"), De.ghost = Re, t.appendChild(Re), Ne(Re, "transform-origin", V1 / parseInt(Re.style.width) * 100 + "% " + H1 / parseInt(Re.style.height) * 100 + "%");
    }
  },
  _onDragStart: function(t, n) {
    var r = this, i = t.dataTransfer, o = r.options;
    if (bn("dragStart", this, {
      evt: t
    }), De.eventCanceled) {
      this._onDrop();
      return;
    }
    bn("setupClone", this), De.eventCanceled || (wt = w2(pe), wt.draggable = !1, wt.style["will-change"] = "", this._hideClone(), In(wt, this.options.chosenClass, !1), De.clone = wt), r.cloneId = Zu(function() {
      bn("clone", r), !De.eventCanceled && (r.options.removeCloneOnHide || bt.insertBefore(wt, pe), r._hideClone(), cn({
        sortable: r,
        name: "clone"
      }));
    }), !n && In(pe, o.dragClass, !0), n ? (Ec = !0, r._loopId = setInterval(r._emulateDragOver, 50)) : (Ye(document, "mouseup", r._onDrop), Ye(document, "touchend", r._onDrop), Ye(document, "touchcancel", r._onDrop), i && (i.effectAllowed = "move", o.setData && o.setData.call(r, i, pe)), tt(document, "drop", r), Ne(pe, "transform", "translateZ(0)")), Qo = !0, r._dragStartId = Zu(r._dragStarted.bind(r, n, t)), tt(document, "selectstart", r), ma = !0, Ca && Ne(document.body, "user-select", "none");
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function(t) {
    var n = this.el, r = t.target, i, o, s, a = this.options, l = a.group, u = De.active, c = su === l, f = a.sort, d = Gt || u, p, h = this, m = !1;
    if (lh) return;
    function g(O, q) {
      bn(O, h, jr({
        evt: t,
        isOwner: c,
        axis: p ? "vertical" : "horizontal",
        revert: s,
        dragRect: i,
        targetRect: o,
        canSort: f,
        fromSortable: d,
        target: r,
        completed: _,
        onMove: function(se, fe) {
          return uu(bt, n, pe, i, se, Lt(se), t, fe);
        },
        changed: E
      }, q));
    }
    function y() {
      g("dragOverAnimationCapture"), h.captureAnimationState(), h !== d && d.captureAnimationState();
    }
    function _(O) {
      return g("dragOverCompleted", {
        insertion: O
      }), O && (c ? u._hideClone() : u._showClone(h), h !== d && (In(pe, Gt ? Gt.options.ghostClass : u.options.ghostClass, !1), In(pe, a.ghostClass, !0)), Gt !== h && h !== De.active ? Gt = h : h === De.active && Gt && (Gt = null), d === h && (h._ignoreWhileAnimating = r), h.animateAll(function() {
        g("dragOverAnimationComplete"), h._ignoreWhileAnimating = null;
      }), h !== d && (d.animateAll(), d._ignoreWhileAnimating = null)), (r === pe && !pe.animated || r === n && !r.animated) && (Uo = null), !a.dragoverBubble && !t.rootEl && r !== document && (pe.parentNode[Pn]._isOutsideThisEl(t.target), !O && ro(t)), !a.dragoverBubble && t.stopPropagation && t.stopPropagation(), m = !0;
    }
    function E() {
      Rn = Wn(pe), yi = Wn(pe, a.draggable), cn({
        sortable: h,
        name: "change",
        toEl: n,
        newIndex: Rn,
        newDraggableIndex: yi,
        originalEvent: t
      });
    }
    if (t.preventDefault !== void 0 && t.cancelable && t.preventDefault(), r = Ar(r, a.draggable, n, !0), g("dragOver"), De.eventCanceled) return m;
    if (pe.contains(t.target) || r.animated && r.animatingX && r.animatingY || h._ignoreWhileAnimating === r)
      return _(!1);
    if (Ec = !1, u && !a.disabled && (c ? f || (s = Et !== bt) : Gt === this || (this.lastPutMode = su.checkPull(this, u, pe, t)) && l.checkPut(this, u, pe, t))) {
      if (p = this._getDirection(t, r) === "vertical", i = Lt(pe), g("dragOverValid"), De.eventCanceled) return m;
      if (s)
        return Et = bt, y(), this._hideClone(), g("revert"), De.eventCanceled || (oo ? bt.insertBefore(pe, oo) : bt.appendChild(pe)), _(!0);
      var v = B0(n, a.draggable);
      if (!v || l6(t, p, this) && !v.animated) {
        if (v === pe)
          return _(!1);
        if (v && n === t.target && (r = v), r && (o = Lt(r)), uu(bt, n, pe, i, r, o, t, !!r) !== !1)
          return y(), n.appendChild(pe), Et = n, E(), _(!0);
      } else if (v && a6(t, p, this)) {
        var M = _s(n, 0, a, !0);
        if (M === pe)
          return _(!1);
        if (r = M, o = Lt(r), uu(bt, n, pe, i, r, o, t, !1) !== !1)
          return y(), n.insertBefore(pe, M), Et = n, E(), _(!0);
      } else if (r.parentNode === n) {
        o = Lt(r);
        var k = 0, T, U = pe.parentNode !== n, C = !n6(pe.animated && pe.toRect || i, r.animated && r.toRect || o, p), z = p ? "top" : "left", H = j1(r, "top", "top") || j1(pe, "top", "top"), j = H ? H.scrollTop : void 0;
        Uo !== r && (T = o[z], Ia = !1, au = !C && a.invertSwap || U), k = u6(t, r, o, p, C ? 1 : a.swapThreshold, a.invertedSwapThreshold == null ? a.swapThreshold : a.invertedSwapThreshold, au, Uo === r);
        var V;
        if (k !== 0) {
          var Q = Wn(pe);
          do
            Q -= k, V = Et.children[Q];
          while (V && (Ne(V, "display") === "none" || V === Re));
        }
        if (k === 0 || V === r)
          return _(!1);
        Uo = r, Oa = k;
        var le = r.nextElementSibling, ne = !1;
        ne = k === 1;
        var w = uu(bt, n, pe, i, r, o, t, ne);
        if (w !== !1)
          return (w === 1 || w === -1) && (ne = w === 1), lh = !0, setTimeout(s6, 30), y(), ne && !le ? n.appendChild(pe) : r.parentNode.insertBefore(pe, ne ? le : r), H && E2(H, 0, j - H.scrollTop), Et = pe.parentNode, T !== void 0 && !au && (Qu = Math.abs(T - Lt(r)[z])), E(), _(!0);
      }
      if (n.contains(pe))
        return _(!1);
    }
    return !1;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function() {
    Ye(document, "mousemove", this._onTouchMove), Ye(document, "touchmove", this._onTouchMove), Ye(document, "pointermove", this._onTouchMove), Ye(document, "dragover", ro), Ye(document, "mousemove", ro), Ye(document, "touchmove", ro);
  },
  _offUpEvents: function() {
    var t = this.el.ownerDocument;
    Ye(t, "mouseup", this._onDrop), Ye(t, "touchend", this._onDrop), Ye(t, "pointerup", this._onDrop), Ye(t, "touchcancel", this._onDrop), Ye(document, "selectstart", this);
  },
  _onDrop: function(t) {
    var n = this.el, r = this.options;
    if (Rn = Wn(pe), yi = Wn(pe, r.draggable), bn("drop", this, {
      evt: t
    }), Et = pe && pe.parentNode, Rn = Wn(pe), yi = Wn(pe, r.draggable), De.eventCanceled) {
      this._nulling();
      return;
    }
    Qo = !1, au = !1, Ia = !1, clearInterval(this._loopId), clearTimeout(this._dragStartTimer), uh(this.cloneId), uh(this._dragStartId), this.nativeDraggable && (Ye(document, "drop", this), Ye(n, "dragstart", this._onDragStart)), this._offMoveEvents(), this._offUpEvents(), Ca && Ne(document.body, "user-select", ""), Ne(pe, "transform", ""), t && (ma && (t.cancelable && t.preventDefault(), !r.dropBubble && t.stopPropagation()), Re && Re.parentNode && Re.parentNode.removeChild(Re), (bt === Et || Gt && Gt.lastPutMode !== "clone") && wt && wt.parentNode && wt.parentNode.removeChild(wt), pe && (this.nativeDraggable && Ye(pe, "dragend", this), Gd(pe), pe.style["will-change"] = "", ma && !Qo && In(pe, Gt ? Gt.options.ghostClass : this.options.ghostClass, !1), In(pe, this.options.chosenClass, !1), cn({
      sortable: this,
      name: "unchoose",
      toEl: Et,
      newIndex: null,
      newDraggableIndex: null,
      originalEvent: t
    }), bt !== Et ? (Rn >= 0 && (cn({
      rootEl: Et,
      name: "add",
      toEl: Et,
      fromEl: bt,
      originalEvent: t
    }), cn({
      sortable: this,
      name: "remove",
      toEl: Et,
      originalEvent: t
    }), cn({
      rootEl: Et,
      name: "sort",
      toEl: Et,
      fromEl: bt,
      originalEvent: t
    }), cn({
      sortable: this,
      name: "sort",
      toEl: Et,
      originalEvent: t
    })), Gt && Gt.save()) : Rn !== rs && Rn >= 0 && (cn({
      sortable: this,
      name: "update",
      toEl: Et,
      originalEvent: t
    }), cn({
      sortable: this,
      name: "sort",
      toEl: Et,
      originalEvent: t
    })), De.active && ((Rn == null || Rn === -1) && (Rn = rs, yi = Da), cn({
      sortable: this,
      name: "end",
      toEl: Et,
      originalEvent: t
    }), this.save()))), this._nulling();
  },
  _nulling: function() {
    bn("nulling", this), bt = pe = Et = Re = oo = wt = Yu = Ai = no = ir = ma = Rn = yi = rs = Da = Uo = Oa = Gt = su = De.dragged = De.ghost = De.clone = De.active = null, xc.forEach(function(t) {
      t.checked = !0;
    }), xc.length = Vd = Hd = 0;
  },
  handleEvent: function(t) {
    switch (t.type) {
      case "drop":
      case "dragend":
        this._onDrop(t);
        break;
      case "dragenter":
      case "dragover":
        pe && (this._onDragOver(t), o6(t));
        break;
      case "selectstart":
        t.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function() {
    for (var t = [], n, r = this.el.children, i = 0, o = r.length, s = this.options; i < o; i++)
      n = r[i], Ar(n, s.draggable, this.el, !1) && t.push(n.getAttribute(s.dataIdAttr) || f6(n));
    return t;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function(t, n) {
    var r = {}, i = this.el;
    this.toArray().forEach(function(o, s) {
      var a = i.children[s];
      Ar(a, this.options.draggable, i, !1) && (r[o] = a);
    }, this), n && this.captureAnimationState(), t.forEach(function(o) {
      r[o] && (i.removeChild(r[o]), i.appendChild(r[o]));
    }), n && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function() {
    var t = this.options.store;
    t && t.set && t.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function(t, n) {
    return Ar(t, n || this.options.draggable, this.el, !1);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function(t, n) {
    var r = this.options;
    if (n === void 0)
      return r[t];
    var i = Fl.modifyOption(this, t, n);
    typeof i < "u" ? r[t] = i : r[t] = n, t === "group" && M2(r);
  },
  /**
   * Destroy
   */
  destroy: function() {
    bn("destroy", this);
    var t = this.el;
    t[Pn] = null, Ye(t, "mousedown", this._onTapStart), Ye(t, "touchstart", this._onTapStart), Ye(t, "pointerdown", this._onTapStart), this.nativeDraggable && (Ye(t, "dragover", this), Ye(t, "dragenter", this)), Array.prototype.forEach.call(t.querySelectorAll("[draggable]"), function(n) {
      n.removeAttribute("draggable");
    }), this._onDrop(), this._disableDelayedDragEvents(), wc.splice(wc.indexOf(this.el), 1), this.el = t = null;
  },
  _hideClone: function() {
    if (!Ai) {
      if (bn("hideClone", this), De.eventCanceled) return;
      Ne(wt, "display", "none"), this.options.removeCloneOnHide && wt.parentNode && wt.parentNode.removeChild(wt), Ai = !0;
    }
  },
  _showClone: function(t) {
    if (t.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (Ai) {
      if (bn("showClone", this), De.eventCanceled) return;
      pe.parentNode == bt && !this.options.group.revertClone ? bt.insertBefore(wt, pe) : oo ? bt.insertBefore(wt, oo) : bt.appendChild(wt), this.options.group.revertClone && this.animate(pe, wt), Ne(wt, "display", ""), Ai = !1;
    }
  }
};
function o6(e) {
  e.dataTransfer && (e.dataTransfer.dropEffect = "move"), e.cancelable && e.preventDefault();
}
function uu(e, t, n, r, i, o, s, a) {
  var l, u = e[Pn], c = u.options.onMove, f;
  return window.CustomEvent && !hi && !zl ? l = new CustomEvent("move", {
    bubbles: !0,
    cancelable: !0
  }) : (l = document.createEvent("Event"), l.initEvent("move", !0, !0)), l.to = t, l.from = e, l.dragged = n, l.draggedRect = r, l.related = i || t, l.relatedRect = o || Lt(t), l.willInsertAfter = a, l.originalEvent = s, e.dispatchEvent(l), c && (f = c.call(u, l, s)), f;
}
function Gd(e) {
  e.draggable = !1;
}
function s6() {
  lh = !1;
}
function a6(e, t, n) {
  var r = Lt(_s(n.el, 0, n.options, !0)), i = 10;
  return t ? e.clientX < r.left - i || e.clientY < r.top && e.clientX < r.right : e.clientY < r.top - i || e.clientY < r.bottom && e.clientX < r.left;
}
function l6(e, t, n) {
  var r = Lt(B0(n.el, n.options.draggable)), i = 10;
  return t ? e.clientX > r.right + i || e.clientX <= r.right && e.clientY > r.bottom && e.clientX >= r.left : e.clientX > r.right && e.clientY > r.top || e.clientX <= r.right && e.clientY > r.bottom + i;
}
function u6(e, t, n, r, i, o, s, a) {
  var l = r ? e.clientY : e.clientX, u = r ? n.height : n.width, c = r ? n.top : n.left, f = r ? n.bottom : n.right, d = !1;
  if (!s) {
    if (a && Qu < u * i) {
      if (!Ia && (Oa === 1 ? l > c + u * o / 2 : l < f - u * o / 2) && (Ia = !0), Ia)
        d = !0;
      else if (Oa === 1 ? l < c + Qu : l > f - Qu)
        return -Oa;
    } else if (l > c + u * (1 - i) / 2 && l < f - u * (1 - i) / 2)
      return c6(t);
  }
  return d = d || s, d && (l < c + u * o / 2 || l > f - u * o / 2) ? l > c + u / 2 ? 1 : -1 : 0;
}
function c6(e) {
  return Wn(pe) < Wn(e) ? 1 : -1;
}
function f6(e) {
  for (var t = e.tagName + e.className + e.src + e.href + e.textContent, n = t.length, r = 0; n--; )
    r += t.charCodeAt(n);
  return r.toString(36);
}
function d6(e) {
  xc.length = 0;
  for (var t = e.getElementsByTagName("input"), n = t.length; n--; ) {
    var r = t[n];
    r.checked && xc.push(r);
  }
}
function Zu(e) {
  return setTimeout(e, 0);
}
function uh(e) {
  return clearTimeout(e);
}
ed && tt(document, "touchmove", function(e) {
  (De.active || Qo) && e.cancelable && e.preventDefault();
});
De.utils = {
  on: tt,
  off: Ye,
  css: Ne,
  find: v2,
  is: function(t, n) {
    return !!Ar(t, n, t, !1);
  },
  extend: KS,
  throttle: _2,
  closest: Ar,
  toggleClass: In,
  clone: w2,
  index: Wn,
  nextTick: Zu,
  cancelNextTick: uh,
  detectDirection: k2,
  getChild: _s
};
De.get = function(e) {
  return e[Pn];
};
De.mount = function() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  t[0].constructor === Array && (t = t[0]), t.forEach(function(r) {
    if (!r.prototype || !r.prototype.constructor)
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(r));
    r.utils && (De.utils = jr(jr({}, De.utils), r.utils)), Fl.mount(r);
  });
};
De.create = function(e, t) {
  return new De(e, t);
};
De.version = HS;
var Dt = [], ba, ch, fh = !1, Wd, Kd, kc, ya;
function p6() {
  function e() {
    this.defaults = {
      scroll: !0,
      forceAutoScrollFallback: !1,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: !0
    };
    for (var t in this)
      t.charAt(0) === "_" && typeof this[t] == "function" && (this[t] = this[t].bind(this));
  }
  return e.prototype = {
    dragStarted: function(n) {
      var r = n.originalEvent;
      this.sortable.nativeDraggable ? tt(document, "dragover", this._handleAutoScroll) : this.options.supportPointer ? tt(document, "pointermove", this._handleFallbackAutoScroll) : r.touches ? tt(document, "touchmove", this._handleFallbackAutoScroll) : tt(document, "mousemove", this._handleFallbackAutoScroll);
    },
    dragOverCompleted: function(n) {
      var r = n.originalEvent;
      !this.options.dragOverBubble && !r.rootEl && this._handleAutoScroll(r);
    },
    drop: function() {
      this.sortable.nativeDraggable ? Ye(document, "dragover", this._handleAutoScroll) : (Ye(document, "pointermove", this._handleFallbackAutoScroll), Ye(document, "touchmove", this._handleFallbackAutoScroll), Ye(document, "mousemove", this._handleFallbackAutoScroll)), G1(), Xu(), YS();
    },
    nulling: function() {
      kc = ch = ba = fh = ya = Wd = Kd = null, Dt.length = 0;
    },
    _handleFallbackAutoScroll: function(n) {
      this._handleAutoScroll(n, !0);
    },
    _handleAutoScroll: function(n, r) {
      var i = this, o = (n.touches ? n.touches[0] : n).clientX, s = (n.touches ? n.touches[0] : n).clientY, a = document.elementFromPoint(o, s);
      if (kc = n, r || this.options.forceAutoScrollFallback || zl || hi || Ca) {
        Yd(n, this.options, a, r);
        var l = Ni(a, !0);
        fh && (!ya || o !== Wd || s !== Kd) && (ya && G1(), ya = setInterval(function() {
          var u = Ni(document.elementFromPoint(o, s), !0);
          u !== l && (l = u, Xu()), Yd(n, i.options, u, r);
        }, 10), Wd = o, Kd = s);
      } else {
        if (!this.options.bubbleScroll || Ni(a, !0) === Lr()) {
          Xu();
          return;
        }
        Yd(n, this.options, Ni(a, !1), !1);
      }
    }
  }, fi(e, {
    pluginName: "scroll",
    initializeByDefault: !0
  });
}
function Xu() {
  Dt.forEach(function(e) {
    clearInterval(e.pid);
  }), Dt = [];
}
function G1() {
  clearInterval(ya);
}
var Yd = _2(function(e, t, n, r) {
  if (t.scroll) {
    var i = (e.touches ? e.touches[0] : e).clientX, o = (e.touches ? e.touches[0] : e).clientY, s = t.scrollSensitivity, a = t.scrollSpeed, l = Lr(), u = !1, c;
    ch !== n && (ch = n, Xu(), ba = t.scroll, c = t.scrollFn, ba === !0 && (ba = Ni(n, !0)));
    var f = 0, d = ba;
    do {
      var p = d, h = Lt(p), m = h.top, g = h.bottom, y = h.left, _ = h.right, E = h.width, v = h.height, M = void 0, k = void 0, T = p.scrollWidth, U = p.scrollHeight, C = Ne(p), z = p.scrollLeft, H = p.scrollTop;
      p === l ? (M = E < T && (C.overflowX === "auto" || C.overflowX === "scroll" || C.overflowX === "visible"), k = v < U && (C.overflowY === "auto" || C.overflowY === "scroll" || C.overflowY === "visible")) : (M = E < T && (C.overflowX === "auto" || C.overflowX === "scroll"), k = v < U && (C.overflowY === "auto" || C.overflowY === "scroll"));
      var j = M && (Math.abs(_ - i) <= s && z + E < T) - (Math.abs(y - i) <= s && !!z), V = k && (Math.abs(g - o) <= s && H + v < U) - (Math.abs(m - o) <= s && !!H);
      if (!Dt[f])
        for (var Q = 0; Q <= f; Q++)
          Dt[Q] || (Dt[Q] = {});
      (Dt[f].vx != j || Dt[f].vy != V || Dt[f].el !== p) && (Dt[f].el = p, Dt[f].vx = j, Dt[f].vy = V, clearInterval(Dt[f].pid), (j != 0 || V != 0) && (u = !0, Dt[f].pid = setInterval((function() {
        r && this.layer === 0 && De.active._onTouchMove(kc);
        var le = Dt[this.layer].vy ? Dt[this.layer].vy * a : 0, ne = Dt[this.layer].vx ? Dt[this.layer].vx * a : 0;
        typeof c == "function" && c.call(De.dragged.parentNode[Pn], ne, le, e, kc, Dt[this.layer].el) !== "continue" || E2(Dt[this.layer].el, ne, le);
      }).bind({
        layer: f
      }), 24))), f++;
    } while (t.bubbleScroll && d !== l && (d = Ni(d, !1)));
    fh = u;
  }
}, 30), S2 = function(t) {
  var n = t.originalEvent, r = t.putSortable, i = t.dragEl, o = t.activeSortable, s = t.dispatchSortableEvent, a = t.hideGhostForTarget, l = t.unhideGhostForTarget;
  if (n) {
    var u = r || o;
    a();
    var c = n.changedTouches && n.changedTouches.length ? n.changedTouches[0] : n, f = document.elementFromPoint(c.clientX, c.clientY);
    l(), u && !u.el.contains(f) && (s("spill"), this.onSpill({
      dragEl: i,
      putSortable: r
    }));
  }
};
function P0() {
}
P0.prototype = {
  startIndex: null,
  dragStart: function(t) {
    var n = t.oldDraggableIndex;
    this.startIndex = n;
  },
  onSpill: function(t) {
    var n = t.dragEl, r = t.putSortable;
    this.sortable.captureAnimationState(), r && r.captureAnimationState();
    var i = _s(this.sortable.el, this.startIndex, this.options);
    i ? this.sortable.el.insertBefore(n, i) : this.sortable.el.appendChild(n), this.sortable.animateAll(), r && r.animateAll();
  },
  drop: S2
};
fi(P0, {
  pluginName: "revertOnSpill"
});
function $0() {
}
$0.prototype = {
  onSpill: function(t) {
    var n = t.dragEl, r = t.putSortable, i = r || this.sortable;
    i.captureAnimationState(), n.parentNode && n.parentNode.removeChild(n), i.animateAll();
  },
  drop: S2
};
fi($0, {
  pluginName: "removeOnSpill"
});
De.mount(new p6());
De.mount($0, P0);
function h6() {
  return typeof window < "u" ? window.console : global.console;
}
const g6 = h6();
function m6(e) {
  const t = /* @__PURE__ */ Object.create(null);
  return function(r) {
    return t[r] || (t[r] = e(r));
  };
}
const b6 = /-(\w)/g, W1 = m6((e) => e.replace(b6, (t, n) => n ? n.toUpperCase() : ""));
function Qd(e) {
  e.parentElement !== null && e.parentElement.removeChild(e);
}
function K1(e, t, n) {
  const r = n === 0 ? e.children[0] : e.children[n - 1].nextSibling;
  e.insertBefore(t, r);
}
function y6(e, t) {
  return Object.values(e).indexOf(t);
}
function v6(e, t, n, r) {
  if (!e)
    return [];
  const i = Object.values(e), o = t.length - r;
  return [...t].map((a, l) => l >= o ? i.length : i.indexOf(a));
}
function C2(e, t) {
  this.$nextTick(() => this.$emit(e.toLowerCase(), t));
}
function _6(e) {
  return (t) => {
    this.realList !== null && this["onDrag" + e](t), C2.call(this, e, t);
  };
}
function E6(e) {
  return ["transition-group", "TransitionGroup"].includes(e);
}
function w6(e) {
  if (!e || e.length !== 1)
    return !1;
  const [{ type: t }] = e;
  return t ? E6(t.name) : !1;
}
function x6(e, t) {
  return t ? { ...t.props, ...t.attrs } : e;
}
const dh = ["Start", "Add", "Remove", "Update", "End"], ph = ["Choose", "Unchoose", "Sort", "Filter", "Clone"], k6 = ["Move", ...dh, ...ph].map((e) => "on" + e);
let Zd = null;
const M6 = {
  options: Object,
  list: {
    type: Array,
    required: !1,
    default: null
  },
  noTransitionOnDrag: {
    type: Boolean,
    default: !1
  },
  clone: {
    type: Function,
    default: (e) => e
  },
  tag: {
    type: String,
    default: "div"
  },
  move: {
    type: Function,
    default: null
  },
  componentData: {
    type: Object,
    required: !1,
    default: null
  },
  component: {
    type: String,
    default: null
  },
  modelValue: {
    type: Array,
    required: !1,
    default: null
  }
}, A6 = S({
  name: "VueDraggableNext",
  inheritAttrs: !1,
  emits: [
    "update:modelValue",
    "move",
    "change",
    ...dh.map((e) => e.toLowerCase()),
    ...ph.map((e) => e.toLowerCase())
  ],
  props: M6,
  data() {
    return {
      transitionMode: !1,
      noneFunctionalComponentMode: !1,
      headerOffset: 0,
      footerOffset: 0,
      _sortable: {},
      visibleIndexes: [],
      context: {}
    };
  },
  render() {
    const e = this.$slots.default ? this.$slots.default() : null, t = x6(this.$attrs, this.componentData);
    return e ? (this.transitionMode = w6(e), Fr(this.getTag(), t, e)) : Fr(this.getTag(), t, []);
  },
  created() {
    this.list !== null && this.modelValue !== null && g6.error("list props are mutually exclusive! Please set one.");
  },
  mounted() {
    const e = {};
    dh.forEach((i) => {
      e["on" + i] = _6.call(this, i);
    }), ph.forEach((i) => {
      e["on" + i] = C2.bind(this, i);
    });
    const t = Object.keys(this.$attrs).reduce((i, o) => (i[W1(o)] = this.$attrs[o], i), {}), n = Object.assign({}, t, e, {
      onMove: (i, o) => this.onDragMove(i, o)
    });
    !("draggable" in n) && (n.draggable = ">*");
    const r = this.$el.nodeType === 1 ? this.$el : this.$el.parentElement;
    this._sortable = new De(r, n), r.__draggable_component__ = this, this.computeIndexes();
  },
  beforeUnmount() {
    try {
      this._sortable !== void 0 && this._sortable.destroy();
    } catch {
    }
  },
  computed: {
    realList() {
      return this.list ? this.list : this.modelValue;
    }
  },
  watch: {
    $attrs: {
      handler(e) {
        this.updateOptions(e);
      },
      deep: !0
    },
    realList() {
      this.computeIndexes();
    }
  },
  methods: {
    getTag() {
      return this.component ? Ta(this.component) : this.tag;
    },
    updateOptions(e) {
      for (var t in e) {
        const n = W1(t);
        k6.indexOf(n) === -1 && this._sortable.option(n, e[t]);
      }
    },
    getChildrenNodes() {
      return this.$el.children;
    },
    computeIndexes() {
      this.$nextTick(() => {
        this.visibleIndexes = v6(this.getChildrenNodes(), this.$el.children, this.transitionMode, this.footerOffset);
      });
    },
    getUnderlyingVm(e) {
      const t = y6(this.getChildrenNodes() || [], e);
      if (t === -1)
        return null;
      const n = this.realList[t];
      return { index: t, element: n };
    },
    emitChanges(e) {
      this.$nextTick(() => {
        this.$emit("change", e);
      });
    },
    alterList(e) {
      if (this.list) {
        e(this.list);
        return;
      }
      const t = [...this.modelValue];
      e(t), this.$emit("update:modelValue", t);
    },
    spliceList() {
      const e = (t) => t.splice(...arguments);
      this.alterList(e);
    },
    updatePosition(e, t) {
      const n = (r) => r.splice(t, 0, r.splice(e, 1)[0]);
      this.alterList(n);
    },
    getVmIndex(e) {
      const t = this.visibleIndexes, n = t.length;
      return e > n - 1 ? n : t[e];
    },
    getComponent() {
      return this.$slots.default ? (
        //@ts-ignore
        this.$slots.default()[0].componentInstance
      ) : null;
    },
    resetTransitionData(e) {
      if (!this.noTransitionOnDrag || !this.transitionMode)
        return;
      var t = this.getChildrenNodes();
      t[e].data = null;
      const n = this.getComponent();
      n.children = [], n.kept = void 0;
    },
    onDragStart(e) {
      this.computeIndexes(), this.context = this.getUnderlyingVm(e.item), this.context && (e.item._underlying_vm_ = this.clone(this.context.element), Zd = e.item);
    },
    onDragAdd(e) {
      const t = e.item._underlying_vm_;
      if (t === void 0)
        return;
      Qd(e.item);
      const n = this.getVmIndex(e.newIndex);
      this.spliceList(n, 0, t), this.computeIndexes();
      const r = { element: t, newIndex: n };
      this.emitChanges({ added: r });
    },
    onDragRemove(e) {
      if (K1(this.$el, e.item, e.oldIndex), e.pullMode === "clone") {
        Qd(e.clone);
        return;
      }
      if (!this.context)
        return;
      const t = this.context.index;
      this.spliceList(t, 1);
      const n = { element: this.context.element, oldIndex: t };
      this.resetTransitionData(t), this.emitChanges({ removed: n });
    },
    onDragUpdate(e) {
      Qd(e.item), K1(e.from, e.item, e.oldIndex);
      const t = this.context.index, n = this.getVmIndex(e.newIndex);
      this.updatePosition(t, n);
      const r = { element: this.context.element, oldIndex: t, newIndex: n };
      this.emitChanges({ moved: r });
    },
    updateProperty(e, t) {
      e.hasOwnProperty(t) && (e[t] += this.headerOffset);
    },
    onDragMove(e, t) {
      const n = this.move;
      if (!n || !this.realList)
        return !0;
      const r = this.getRelatedContextFromMoveEvent(e), i = this.context, o = this.computeFutureIndex(r, e);
      Object.assign(i, { futureIndex: o });
      const s = Object.assign({}, e, {
        relatedContext: r,
        draggedContext: i
      });
      return n(s, t);
    },
    onDragEnd() {
      this.computeIndexes(), Zd = null;
    },
    getTrargetedComponent(e) {
      return e.__draggable_component__;
    },
    getRelatedContextFromMoveEvent({ to: e, related: t }) {
      const n = this.getTrargetedComponent(e);
      if (!n)
        return { component: n };
      const r = n.realList, i = { list: r, component: n };
      if (e !== t && r && n.getUnderlyingVm) {
        const o = n.getUnderlyingVm(t);
        if (o)
          return Object.assign(o, i);
      }
      return i;
    },
    computeFutureIndex(e, t) {
      const n = [...t.to.children].filter((s) => s.style.display !== "none");
      if (n.length === 0)
        return 0;
      const r = n.indexOf(t.related), i = e.component.getVmIndex(r);
      return n.indexOf(Zd) !== -1 || !t.willInsertAfter ? i : i + 1;
    }
  }
}), Ite = /* @__PURE__ */ S({
  __name: "DragAndDropList",
  props: {
    class: {},
    iteratorClass: {},
    modelValue: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(A6), {
      class: ce(b(G)("w-full mx-auto", t.class))
    }, {
      default: A(() => [
        (x(!0), W(Ge, null, ft(t.modelValue, (i) => (x(), W("div", {
          key: i.id,
          class: ce(
            b(G)(
              "flex items-center py-0 group transition duration-300 ease-in-out hover:bg-neutral-100 border-b last:border-b-0 border-border",
              t.iteratorClass
            )
          )
        }, [
          B(n.$slots, "default", { item: i })
        ], 2))), 128)),
        be("div", {
          class: ce(b(G)("flex items-center py-1 border-b  border-border", t.iteratorClass))
        }, [
          B(n.$slots, "input")
        ], 2)
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), z0 = /* @__PURE__ */ S({
  __name: "Popover",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const i = Le(e, t);
    return (o, s) => (x(), L(b(MA), Pe(Ue(b(i))), {
      default: A(() => [
        B(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), F0 = /* @__PURE__ */ S({
  __name: "PopoverTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(AA), Pe(Ue(t)), {
      default: A(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), j0 = /* @__PURE__ */ S({
  inheritAttrs: !1,
  __name: "PopoverContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    align: { default: "center" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean },
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: s, ...a } = n;
      return a;
    }), o = Le(i, r);
    return (s, a) => (x(), L(b(TA), null, {
      default: A(() => [
        $(b(SA), oe({ ...b(o), ...s.$attrs }, {
          class: b(G)(
            "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
            n.class
          )
        }), {
          default: A(() => [
            B(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), T6 = { key: 0 }, S6 = { class: "flex" }, C6 = { class: "min-w-[25px]" }, N6 = { class: "flex-grow" }, Rte = /* @__PURE__ */ S({
  __name: "MultiSelect",
  props: {
    options: { type: Array, required: !0 },
    selected: { type: Array, required: !1 }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = _e(!1);
    function o(s) {
      r("select", s), i.value = !1;
    }
    return (s, a) => (x(), L(b(z0), {
      open: i.value,
      "onUpdate:open": a[0] || (a[0] = (l) => i.value = l)
    }, {
      default: A(() => [
        $(b(F0), { "as-child": "" }, {
          default: A(() => [
            $(b(Kr), {
              variant: "outline",
              role: "combobox",
              "aria-expanded": i.value,
              class: "min-w-[50%] justify-between"
            }, {
              default: A(() => [
                e.selected ? (x(), W("div", T6, [
                  (x(!0), W(Ge, null, ft(e.selected, (l, u) => (x(), W("span", {
                    class: "mr-1 font-normal",
                    key: l
                  }, ze(l) + ze(u === e.selected.length - 1 ? "" : ","), 1))), 128))
                ])) : Qe("", !0),
                $(b(Xs), { class: "ml-2 h-4 w-4 shrink-0 opacity-50" })
              ]),
              _: 1
            }, 8, ["aria-expanded"])
          ]),
          _: 1
        }),
        $(b(j0), { class: "min-w-[50%] p-0" }, {
          default: A(() => [
            $(b(d2), null, {
              default: A(() => [
                $(b(LS), null, {
                  default: A(() => [
                    (x(!0), W(Ge, null, ft(n.options, (l) => (x(), L(b(PS), {
                      key: l,
                      value: l,
                      onSelect: () => o(l)
                    }, {
                      default: A(() => {
                        var u;
                        return [
                          be("div", S6, [
                            be("div", C6, [
                              (u = n.selected) != null && u.includes(l) ? (x(), L(b($l), {
                                key: 0,
                                class: "mr-1 h-4 w-4"
                              })) : Qe("", !0)
                            ]),
                            be("div", N6, [
                              be("span", null, ze(l), 1)
                            ])
                          ])
                        ];
                      }),
                      _: 2
                    }, 1032, ["value", "onSelect"]))), 128))
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["open"]));
  }
}), N2 = /* @__PURE__ */ S({
  __name: "Select",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    defaultValue: {},
    modelValue: {},
    dir: {},
    name: {},
    autocomplete: {},
    disabled: { type: Boolean },
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "update:open"],
  setup(e, { emit: t }) {
    const i = Le(e, t);
    return (o, s) => (x(), L(b(CA), Pe(Ue(b(i))), {
      default: A(() => [
        B(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), D2 = /* @__PURE__ */ S({
  __name: "SelectValue",
  props: {
    placeholder: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(NA), Pe(Ue(t)), {
      default: A(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), O2 = /* @__PURE__ */ S({
  __name: "SelectTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(DA), oe(b(r), {
      class: b(G)(
        "ring-offset-background flex h-10 w-full items-center justify-between rounded-md border border-input bg-layer-0 px-3 py-2 text-sm placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
        t.class
      )
    }), {
      default: A(() => [
        B(i.$slots, "default"),
        $(b(OA), { "as-child": "" }, {
          default: A(() => [
            $(b(Xs), { class: "h-4 w-4 opacity-50" })
          ]),
          _: 1
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), I2 = /* @__PURE__ */ S({
  inheritAttrs: !1,
  __name: "SelectContent",
  props: {
    forceMount: { type: Boolean },
    position: { default: "popper" },
    bodyLock: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: s, ...a } = n;
      return a;
    }), o = Le(i, r);
    return (s, a) => (x(), L(b(IA), null, {
      default: A(() => [
        $(b(RA), oe({ ...b(o), ...s.$attrs }, {
          class: b(G)(
            "relative z-50 max-h-96 min-w-32 overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
            s.position === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
            n.class
          )
        }), {
          default: A(() => [
            $(b(O6)),
            $(b(LA), {
              class: ce(
                b(G)(
                  "p-1",
                  s.position === "popper" && "h-[--radix-select-trigger-height] w-full min-w-[--radix-select-trigger-width]"
                )
              )
            }, {
              default: A(() => [
                B(s.$slots, "default")
              ]),
              _: 3
            }, 8, ["class"]),
            $(b(I6))
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), R2 = /* @__PURE__ */ S({
  __name: "SelectGroup",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: r, ...i } = t;
      return i;
    });
    return (r, i) => (x(), L(b(BA), oe({
      class: b(G)("w-full p-1", t.class)
    }, n.value), {
      default: A(() => [
        B(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), D6 = { class: "absolute right-2 flex h-3.5 w-3.5 items-center justify-center" }, L2 = /* @__PURE__ */ S({
  __name: "SelectItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(PA), oe(b(r), {
      class: b(G)(
        "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        t.class
      )
    }), {
      default: A(() => [
        be("span", D6, [
          $(b($A), null, {
            default: A(() => [
              $(b($l), { class: "h-4 w-4" })
            ]),
            _: 1
          })
        ]),
        $(b(n2), null, {
          default: A(() => [
            B(i.$slots, "default")
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Lte = /* @__PURE__ */ S({
  __name: "SelectItemText",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(n2), Pe(Ue(t)), {
      default: A(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Bte = /* @__PURE__ */ S({
  __name: "SelectLabel",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(zA), {
      class: ce(b(G)("py-1.5 pl-8 pr-2 text-sm font-semibold", t.class))
    }, {
      default: A(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Pte = /* @__PURE__ */ S({
  __name: "SelectSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: r, ...i } = t;
      return i;
    });
    return (r, i) => (x(), L(b(FA), oe(n.value, {
      class: b(G)("-mx-1 my-1 h-px bg-muted", t.class)
    }), null, 16, ["class"]));
  }
}), O6 = /* @__PURE__ */ S({
  __name: "SelectScrollUpButton",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(jA), oe(b(r), {
      class: b(G)("flex cursor-default items-center justify-center py-1", t.class)
    }), {
      default: A(() => [
        B(i.$slots, "default", {}, () => [
          $(b(ZT), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), I6 = /* @__PURE__ */ S({
  __name: "SelectScrollDownButton",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(UA), oe(b(r), {
      class: b(G)("flex cursor-default items-center justify-center py-1", t.class)
    }), {
      default: A(() => [
        B(i.$slots, "default", {}, () => [
          $(b(Xs), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), $te = /* @__PURE__ */ S({
  __name: "StateSelect",
  setup(e) {
    const t = {
      AL: "Alabama",
      AK: "Alaska",
      AZ: "Arizona",
      AR: "Arkansas",
      CA: "California",
      CO: "Colorado",
      CT: "Connecticut",
      DE: "Delaware",
      DC: "District of Columbia",
      FL: "Florida",
      GA: "Georgia",
      HI: "Hawaii",
      ID: "Idaho",
      IL: "Illinois",
      IN: "Indiana",
      IA: "Iowa",
      KS: "Kansas",
      KY: "Kentucky",
      LA: "Louisiana",
      ME: "Maine",
      MD: "Maryland",
      MA: "Massachusetts",
      MI: "Michigan",
      MN: "Minnesota",
      MS: "Mississippi",
      MO: "Missouri",
      MT: "Montana",
      NE: "Nebraska",
      NV: "Nevada",
      NH: "New Hampshire",
      NJ: "New Jersey",
      NM: "New Mexico",
      NY: "New York",
      NC: "North Carolina",
      ND: "North Dakota",
      OH: "Ohio",
      OK: "Oklahoma",
      OR: "Oregon",
      PA: "Pennsylvania",
      RI: "Rhode Island",
      SC: "South Carolina",
      SD: "South Dakota",
      TN: "Tennessee",
      TX: "Texas",
      UT: "Utah",
      VT: "Vermont",
      VA: "Virginia",
      WA: "Washington",
      WV: "West Virginia",
      WI: "Wisconsin",
      WY: "Wyoming"
    };
    return (n, r) => (x(), L(b(N2), null, {
      default: A(() => [
        $(b(O2), null, {
          default: A(() => [
            $(b(D2), { placeholder: "State" })
          ]),
          _: 1
        }),
        $(b(I2), null, {
          default: A(() => [
            $(b(R2), null, {
              default: A(() => [
                (x(), W(Ge, null, ft(t, (i, o) => $(b(L2), {
                  value: o,
                  key: o
                }, {
                  default: A(() => [
                    Xt(ze(i), 1)
                  ]),
                  _: 2
                }, 1032, ["value"])), 64))
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
}), U0 = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [r, i] of t)
    n[r] = i;
  return n;
}, R6 = {}, L6 = { class: "cursor-default rounded-md bg-yellow-50 px-3 py-1.5 text-sm leading-normal text-gray-900 dark:border dark:border-yellow-500 dark:bg-layer-0 dark:text-yellow-500" };
function B6(e, t) {
  return x(), W("div", L6, [
    B(e.$slots, "default")
  ]);
}
const zte = /* @__PURE__ */ U0(R6, [["render", B6]]), P6 = /* @__PURE__ */ S({
  __name: "TimezoneSelect",
  emits: ["blur", "focus"],
  setup(e, { emit: t }) {
    function n(s) {
      r(s ? "focus" : "blur");
    }
    const r = t, i = [
      { offset: "GMT-12:00", name: "Etc/GMT-12" },
      { offset: "GMT-11:00", name: "Etc/GMT-11" },
      { offset: "GMT-11:00", name: "Pacific/Midway" },
      { offset: "GMT-10:00", name: "America/Adak" },
      { offset: "GMT-09:00", name: "America/Anchorage" },
      { offset: "GMT-09:00", name: "Pacific/Gambier" },
      { offset: "GMT-08:00", name: "America/Dawson Creek" },
      { offset: "GMT-08:00", name: "America/Ensenada" },
      { continental_us: !0, offset: "GMT-08:00", name: "America/Los_Angeles" },
      { offset: "GMT-07:00", name: "America/Chihuahua" },
      { continental_us: !0, offset: "GMT-07:00", name: "America/Denver" },
      { offset: "GMT-06:00", name: "America/Belize" },
      { offset: "GMT-06:00", name: "America/Cancun" },
      { continental_us: !0, offset: "GMT-06:00", name: "America/Chicago" },
      { offset: "GMT-06:00", name: "Chile/EasterIsland" },
      { offset: "GMT-05:00", name: "America/Bogota" },
      { offset: "GMT-05:00", name: "America/Havana" },
      { continental_us: !0, offset: "GMT-05:00", name: "America/New_York" },
      { offset: "GMT-04:30", name: "America/Caracas" },
      { offset: "GMT-04:00", name: "America/Campo Grande" },
      { offset: "GMT-04:00", name: "America/Glace Bay" },
      { offset: "GMT-04:00", name: "America/Goose Bay" },
      { offset: "GMT-04:00", name: "America/Santiago" },
      { offset: "GMT-04:00", name: "America/La Paz" },
      { offset: "GMT-03:00", name: "America/Argentina/Buenos Aires" },
      { offset: "GMT-03:00", name: "America/Montevideo" },
      { offset: "GMT-03:00", name: "America/Araguaina" },
      { offset: "GMT-03:00", name: "America/Godthab" },
      { offset: "GMT-03:00", name: "America/Miquelon" },
      { offset: "GMT-03:00", name: "America/Sao Paulo" },
      { offset: "GMT-03:30", name: "America/St Johns" },
      { offset: "GMT-02:00", name: "America/Noronha" },
      { offset: "GMT-01:00", name: "Atlantic/Cape Verde" },
      { offset: "GMT", name: "Europe/Belfast" },
      { offset: "GMT", name: "Africa/Abidjan" },
      { offset: "GMT", name: "Europe/Dublin" },
      { offset: "GMT", name: "Europe/Lisbon" },
      { offset: "GMT", name: "Europe/London" },
      { offset: "UTC", name: "UTC" },
      { offset: "GMT+01:00", name: "Africa/Algiers" },
      { offset: "GMT+01:00", name: "Africa/Windhoek" },
      { offset: "GMT+01:00", name: "Atlantic/Azores" },
      { offset: "GMT+01:00", name: "Atlantic/Stanley" },
      { offset: "GMT+01:00", name: "Europe/Amsterdam" },
      { offset: "GMT+01:00", name: "Europe/Belgrade" },
      { offset: "GMT+01:00", name: "Europe/Brussels" },
      { offset: "GMT+02:00", name: "Africa/Cairo" },
      { offset: "GMT+02:00", name: "Africa/Blantyre" },
      { offset: "GMT+02:00", name: "Asia/Beirut" },
      { offset: "GMT+02:00", name: "Asia/Damascus" },
      { offset: "GMT+02:00", name: "Asia/Gaza" },
      { offset: "GMT+02:00", name: "Asia/Jerusalem" },
      { offset: "GMT+03:00", name: "Africa/Addis Ababa" },
      { offset: "GMT+03:00", name: "Asia/Riyadh89" },
      { offset: "GMT+03:00", name: "Europe/Minsk" },
      { offset: "GMT+03:30", name: "Asia/Tehran" },
      { offset: "GMT+04:00", name: "Asia/Dubai" },
      { offset: "GMT+04:00", name: "Asia/Yerevan" },
      { offset: "GMT+04:00", name: "Europe/Moscow" },
      { offset: "GMT+04:30", name: "Asia/Kabul" },
      { offset: "GMT+05:00", name: "Asia/Tashkent" },
      { offset: "GMT+05:30", name: "Asia/Kolkata" },
      { offset: "GMT+05:45", name: "Asia/Katmandu" },
      { offset: "GMT+06:00", name: "Asia/Dhaka" },
      { offset: "GMT+06:00", name: "Asia/Yekaterinburg" },
      { offset: "GMT+06:30", name: "Asia/Rangoon" },
      { offset: "GMT+07:00", name: "Asia/Bangkok" },
      { offset: "GMT+07:00", name: "Asia/Novosibirsk" },
      { offset: "GMT+08:00", name: "Etc/GMT+8" },
      { offset: "GMT+08:00", name: "Asia/Hong Kong" },
      { offset: "GMT+08:00", name: "Asia/Krasnoyarsk" },
      { offset: "GMT+08:00", name: "Australia/Perth" },
      { offset: "GMT+08:45", name: "Australia/Eucla" },
      { offset: "GMT+09:00", name: "Asia/Irkutsk" },
      { offset: "GMT+09:00", name: "Asia/Seoul" },
      { offset: "GMT+09:00", name: "Asia/Tokyo" },
      { offset: "GMT+09:30", name: "Australia/Adelaide" },
      { offset: "GMT+09:30", name: "Australia/Darwin" },
      { offset: "GMT+09:30", name: "Pacific/Marquesas" },
      { offset: "GMT+10:00", name: "Etc/GMT+10" },
      { offset: "GMT+10:00", name: "Australia/Brisbane" },
      { offset: "GMT+10:00", name: "Australia/Hobart" },
      { offset: "GMT+10:00", name: "Asia/Yakutsk" },
      { offset: "GMT+10:30", name: "Australia/Lord Howe" },
      { offset: "GMT+11:00", name: "Asia/Vladivostok" },
      { offset: "GMT+11:30", name: "Pacific/Norfolk" },
      { offset: "GMT+12:00", name: "Etc/GMT+12" },
      { offset: "GMT+12:00", name: "Asia/Anadyr" },
      { offset: "GMT+12:00", name: "Asia/Magadan" },
      { offset: "GMT+12:00", name: "Pacific/Auckland" },
      { offset: "GMT+12:45", name: "Pacific/Chatham" },
      { offset: "GMT+13:00", name: "Pacific/Tongatapu" },
      { offset: "GMT+14:00", name: "Pacific/Kiritimati" }
    ], o = R(() => i.filter((s) => s.continental_us).reverse());
    return (s, a) => (x(), L(b(N2), { "onUpdate:open": n }, {
      default: A(() => [
        $(b(O2), null, {
          default: A(() => [
            $(b(D2), { placeholder: "Timezone" })
          ]),
          _: 1
        }),
        $(b(I2), null, {
          default: A(() => [
            $(b(R2), null, {
              default: A(() => [
                (x(!0), W(Ge, null, ft(o.value, (l) => (x(), L(b(L2), {
                  value: l.name,
                  key: l.name
                }, {
                  default: A(() => [
                    Xt(ze(l.name) + " (" + ze(l.offset) + ")", 1)
                  ]),
                  _: 2
                }, 1032, ["value"]))), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
});
function B2(e) {
  return gM() ? (mM(e), !0) : !1;
}
function qi(e) {
  return typeof e == "function" ? e() : b(e);
}
const $6 = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const z6 = (e) => typeof e < "u", F6 = Object.prototype.toString, j6 = (e) => F6.call(e) === "[object Object]", Mc = () => {
};
function P2(e, t) {
  function n(...r) {
    return new Promise((i, o) => {
      Promise.resolve(e(() => t.apply(this, r), { fn: t, thisArg: this, args: r })).then(i).catch(o);
    });
  }
  return n;
}
const $2 = (e) => e();
function U6(e, t = {}) {
  let n, r, i = Mc;
  const o = (a) => {
    clearTimeout(a), i(), i = Mc;
  };
  return (a) => {
    const l = qi(e), u = qi(t.maxWait);
    return n && o(n), l <= 0 || u !== void 0 && u <= 0 ? (r && (o(r), r = null), Promise.resolve(a())) : new Promise((c, f) => {
      i = t.rejectOnCancel ? f : c, u && !r && (r = setTimeout(() => {
        n && o(n), r = null, c(a());
      }, u)), n = setTimeout(() => {
        r && o(r), r = null, c(a());
      }, l);
    });
  };
}
function V6(e = $2) {
  const t = _e(!0);
  function n() {
    t.value = !1;
  }
  function r() {
    t.value = !0;
  }
  const i = (...o) => {
    t.value && e(...o);
  };
  return { isActive: Zf(t), pause: n, resume: r, eventFilter: i };
}
function H6(e) {
  return jn();
}
function q6(...e) {
  if (e.length !== 1)
    return Mi(...e);
  const t = e[0];
  return typeof t == "function" ? Zf(Y_(() => ({ get: t, set: Mc }))) : _e(t);
}
function G6(e, t = 200, n = {}) {
  return P2(
    U6(t, n),
    e
  );
}
function W6(e, t, n = {}) {
  const {
    eventFilter: r = $2,
    ...i
  } = n;
  return Mt(
    e,
    P2(
      r,
      t
    ),
    i
  );
}
function K6(e, t, n = {}) {
  const {
    eventFilter: r,
    ...i
  } = n, { eventFilter: o, pause: s, resume: a, isActive: l } = V6(r);
  return { stop: W6(
    e,
    t,
    {
      ...i,
      eventFilter: o
    }
  ), pause: s, resume: a, isActive: l };
}
function z2(e, t = !0, n) {
  H6() ? Jn(e, n) : t ? e() : Ft(e);
}
function Y6(e = !1, t = {}) {
  const {
    truthyValue: n = !0,
    falsyValue: r = !1
  } = t, i = Co(e), o = _e(e);
  function s(a) {
    if (arguments.length)
      return o.value = a, o.value;
    {
      const l = qi(n);
      return o.value = o.value === l ? qi(r) : l, o.value;
    }
  }
  return i ? s : [o, s];
}
const Es = $6 ? window : void 0;
function F2(e) {
  var t;
  const n = qi(e);
  return (t = n == null ? void 0 : n.$el) != null ? t : n;
}
function Ra(...e) {
  let t, n, r, i;
  if (typeof e[0] == "string" || Array.isArray(e[0]) ? ([n, r, i] = e, t = Es) : [t, n, r, i] = e, !t)
    return Mc;
  Array.isArray(n) || (n = [n]), Array.isArray(r) || (r = [r]);
  const o = [], s = () => {
    o.forEach((c) => c()), o.length = 0;
  }, a = (c, f, d, p) => (c.addEventListener(f, d, p), () => c.removeEventListener(f, d, p)), l = Mt(
    () => [F2(t), qi(i)],
    ([c, f]) => {
      if (s(), !c)
        return;
      const d = j6(f) ? { ...f } : f;
      o.push(
        ...n.flatMap((p) => r.map((h) => a(c, p, h, d)))
      );
    },
    { immediate: !0, flush: "post" }
  ), u = () => {
    l(), s();
  };
  return B2(u), u;
}
function j2() {
  const e = _e(!1), t = jn();
  return t && Jn(() => {
    e.value = !0;
  }, t), e;
}
function Q6(e) {
  const t = j2();
  return R(() => (t.value, !!e()));
}
function Z6(e, t = {}) {
  const { window: n = Es } = t, r = Q6(() => n && "matchMedia" in n && typeof n.matchMedia == "function");
  let i;
  const o = _e(!1), s = (u) => {
    o.value = u.matches;
  }, a = () => {
    i && ("removeEventListener" in i ? i.removeEventListener("change", s) : i.removeListener(s));
  }, l = lr(() => {
    r.value && (a(), i = n.matchMedia(qi(e)), "addEventListener" in i ? i.addEventListener("change", s) : i.addListener(s), o.value = i.matches);
  });
  return B2(() => {
    l(), a(), i = void 0;
  }), o;
}
function X6(e) {
  return JSON.parse(JSON.stringify(e));
}
const cu = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, fu = "__vueuse_ssr_handlers__", J6 = /* @__PURE__ */ eC();
function eC() {
  return fu in cu || (cu[fu] = cu[fu] || {}), cu[fu];
}
function U2(e, t) {
  return J6[e] || t;
}
function V2(e) {
  return Z6("(prefers-color-scheme: dark)", e);
}
function tC(e) {
  return e == null ? "any" : e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof Date ? "date" : typeof e == "boolean" ? "boolean" : typeof e == "string" ? "string" : typeof e == "object" ? "object" : Number.isNaN(e) ? "any" : "number";
}
const nC = {
  boolean: {
    read: (e) => e === "true",
    write: (e) => String(e)
  },
  object: {
    read: (e) => JSON.parse(e),
    write: (e) => JSON.stringify(e)
  },
  number: {
    read: (e) => Number.parseFloat(e),
    write: (e) => String(e)
  },
  any: {
    read: (e) => e,
    write: (e) => String(e)
  },
  string: {
    read: (e) => e,
    write: (e) => String(e)
  },
  map: {
    read: (e) => new Map(JSON.parse(e)),
    write: (e) => JSON.stringify(Array.from(e.entries()))
  },
  set: {
    read: (e) => new Set(JSON.parse(e)),
    write: (e) => JSON.stringify(Array.from(e))
  },
  date: {
    read: (e) => new Date(e),
    write: (e) => e.toISOString()
  }
}, Y1 = "vueuse-storage";
function rC(e, t, n, r = {}) {
  var i;
  const {
    flush: o = "pre",
    deep: s = !0,
    listenToStorageChanges: a = !0,
    writeDefaults: l = !0,
    mergeDefaults: u = !1,
    shallow: c,
    window: f = Es,
    eventFilter: d,
    onError: p = (z) => {
      console.error(z);
    },
    initOnMounted: h
  } = r, m = (c ? I0 : _e)(typeof t == "function" ? t() : t);
  if (!n)
    try {
      n = U2("getDefaultStorage", () => {
        var z;
        return (z = Es) == null ? void 0 : z.localStorage;
      })();
    } catch (z) {
      p(z);
    }
  if (!n)
    return m;
  const g = qi(t), y = tC(g), _ = (i = r.serializer) != null ? i : nC[y], { pause: E, resume: v } = K6(
    m,
    () => k(m.value),
    { flush: o, deep: s, eventFilter: d }
  );
  f && a && z2(() => {
    n instanceof Storage ? Ra(f, "storage", U) : Ra(f, Y1, C), h && U();
  }), h || U();
  function M(z, H) {
    if (f) {
      const j = {
        key: e,
        oldValue: z,
        newValue: H,
        storageArea: n
      };
      f.dispatchEvent(n instanceof Storage ? new StorageEvent("storage", j) : new CustomEvent(Y1, {
        detail: j
      }));
    }
  }
  function k(z) {
    try {
      const H = n.getItem(e);
      if (z == null)
        M(H, null), n.removeItem(e);
      else {
        const j = _.write(z);
        H !== j && (n.setItem(e, j), M(H, j));
      }
    } catch (H) {
      p(H);
    }
  }
  function T(z) {
    const H = z ? z.newValue : n.getItem(e);
    if (H == null)
      return l && g != null && n.setItem(e, _.write(g)), g;
    if (!z && u) {
      const j = _.read(H);
      return typeof u == "function" ? u(j, g) : y === "object" && !Array.isArray(j) ? { ...g, ...j } : j;
    } else return typeof H != "string" ? H : _.read(H);
  }
  function U(z) {
    if (!(z && z.storageArea !== n)) {
      if (z && z.key == null) {
        m.value = g;
        return;
      }
      if (!(z && z.key !== e)) {
        E();
        try {
          (z == null ? void 0 : z.newValue) !== _.write(m.value) && (m.value = T(z));
        } catch (H) {
          p(H);
        } finally {
          z ? Ft(v) : v();
        }
      }
    }
  }
  function C(z) {
    U(z.detail);
  }
  return m;
}
const iC = "*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
function oC(e = {}) {
  const {
    selector: t = "html",
    attribute: n = "class",
    initialValue: r = "auto",
    window: i = Es,
    storage: o,
    storageKey: s = "vueuse-color-scheme",
    listenToStorageChanges: a = !0,
    storageRef: l,
    emitAuto: u,
    disableTransition: c = !0
  } = e, f = {
    auto: "",
    light: "light",
    dark: "dark",
    ...e.modes || {}
  }, d = V2({ window: i }), p = R(() => d.value ? "dark" : "light"), h = l || (s == null ? q6(r) : rC(s, r, o, { window: i, listenToStorageChanges: a })), m = R(() => h.value === "auto" ? p.value : h.value), g = U2(
    "updateHTMLAttrs",
    (v, M, k) => {
      const T = typeof v == "string" ? i == null ? void 0 : i.document.querySelector(v) : F2(v);
      if (!T)
        return;
      const U = /* @__PURE__ */ new Set(), C = /* @__PURE__ */ new Set();
      let z = null;
      if (M === "class") {
        const j = k.split(/\s/g);
        Object.values(f).flatMap((V) => (V || "").split(/\s/g)).filter(Boolean).forEach((V) => {
          j.includes(V) ? U.add(V) : C.add(V);
        });
      } else
        z = { key: M, value: k };
      if (U.size === 0 && C.size === 0 && z === null)
        return;
      let H;
      c && (H = i.document.createElement("style"), H.appendChild(document.createTextNode(iC)), i.document.head.appendChild(H));
      for (const j of U)
        T.classList.add(j);
      for (const j of C)
        T.classList.remove(j);
      z && T.setAttribute(z.key, z.value), c && (i.getComputedStyle(H).opacity, document.head.removeChild(H));
    }
  );
  function y(v) {
    var M;
    g(t, n, (M = f[v]) != null ? M : v);
  }
  function _(v) {
    e.onChanged ? e.onChanged(v, y) : y(v);
  }
  Mt(m, _, { flush: "post", immediate: !0 }), z2(() => _(m.value));
  const E = R({
    get() {
      return u ? h.value : m.value;
    },
    set(v) {
      h.value = v;
    }
  });
  try {
    return Object.assign(E, { store: h, system: p, state: m });
  } catch {
    return E;
  }
}
function sC(e = {}) {
  const {
    valueDark: t = "dark",
    valueLight: n = "",
    window: r = Es
  } = e, i = oC({
    ...e,
    onChanged: (a, l) => {
      var u;
      e.onChanged ? (u = e.onChanged) == null || u.call(e, a === "dark", l, a) : l(a);
    },
    modes: {
      dark: t,
      light: n
    }
  }), o = R(() => i.system ? i.system.value : V2({ window: r }).value ? "dark" : "light");
  return R({
    get() {
      return i.value === "dark";
    },
    set(a) {
      const l = a ? "dark" : "light";
      o.value === l ? i.value = "auto" : i.value = l;
    }
  });
}
function H2(e, t, n, r = {}) {
  var i, o, s;
  const {
    clone: a = !1,
    passive: l = !1,
    eventName: u,
    deep: c = !1,
    defaultValue: f,
    shouldEmit: d
  } = r, p = jn(), h = n || (p == null ? void 0 : p.emit) || ((i = p == null ? void 0 : p.$emit) == null ? void 0 : i.bind(p)) || ((s = (o = p == null ? void 0 : p.proxy) == null ? void 0 : o.$emit) == null ? void 0 : s.bind(p == null ? void 0 : p.proxy));
  let m = u;
  m = m || `update:${t.toString()}`;
  const g = (E) => a ? typeof a == "function" ? a(E) : X6(E) : E, y = () => z6(e[t]) ? g(e[t]) : f, _ = (E) => {
    d ? d(E) && h(m, E) : h(m, E);
  };
  if (l) {
    const E = y(), v = _e(E);
    let M = !1;
    return Mt(
      () => e[t],
      (k) => {
        M || (M = !0, v.value = g(k), Ft(() => M = !1));
      }
    ), Mt(
      v,
      (k) => {
        !M && (k !== e[t] || c) && _(k);
      },
      { deep: c }
    ), v;
  } else
    return R({
      get() {
        return y();
      },
      set(E) {
        _(E);
      }
    });
}
const aC = {
  key: 0,
  class: ""
}, lC = {
  key: 1,
  class: ""
}, Fte = /* @__PURE__ */ S({
  __name: "ToggleTheme",
  setup(e) {
    const t = sC(), n = Y6(t);
    return (r, i) => (x(), W("button", {
      onClick: i[0] || (i[0] = (o) => b(n)()),
      class: "mt-3 rounded-md p-3 hover:bg-muted hover:text-foreground"
    }, [
      b(t) ? (x(), W("span", aC, [
        $(b(XT))
      ])) : (x(), W("span", lC, [
        $(b(JT))
      ]))
    ]));
  }
}), uC = {}, cC = { class: "flex" }, fC = { class: "flex" }, dC = { class: "flex w-full h-full" };
function pC(e, t) {
  return x(), W("div", cC, [
    be("div", fC, [
      B(e.$slots, "leftMenu")
    ]),
    be("div", dC, [
      B(e.$slots, "content")
    ])
  ]);
}
const jte = /* @__PURE__ */ U0(uC, [["render", pC]]), Di = /* @__PURE__ */ S({
  __name: "Skeleton",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("div", {
      class: ce(b(G)("animate-pulse rounded-md bg-muted", t.class))
    }, null, 2));
  }
}), q2 = /* @__PURE__ */ S({
  __name: "Tooltip",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    delayDuration: {},
    disableHoverableContent: { type: Boolean },
    disableClosingTrigger: { type: Boolean },
    disabled: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const i = Le(e, t);
    return (o, s) => (x(), L(b(VA), Pe(Ue(b(i))), {
      default: A(() => [
        B(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), G2 = /* @__PURE__ */ S({
  __name: "TooltipTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(HA), Pe(Ue(t)), {
      default: A(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), W2 = /* @__PURE__ */ S({
  inheritAttrs: !1,
  __name: "TooltipContent",
  props: {
    forceMount: { type: Boolean },
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: {},
    sideOffset: { default: 4 },
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: s, ...a } = n;
      return a;
    }), o = Le(i, r);
    return (s, a) => (x(), L(b(qA), null, {
      default: A(() => [
        $(b(GA), oe({ ...b(o), ...s.$attrs }, {
          class: b(G)(
            "z-50 overflow-hidden rounded-md border border-border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
            n.class
          )
        }), {
          default: A(() => [
            B(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), hC = { class: "space-y-3" }, gC = /* @__PURE__ */ S({
  __name: "ExpandableCard",
  props: {
    maxHeight: {},
    loading: { type: Boolean },
    expanded: { type: Boolean },
    fade: { type: Boolean, default: !0 }
  },
  emits: ["update:expanded", "show", "hide"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = _e(null), o = R(() => `max-h-${n.maxHeight || "28"}`);
    function s() {
      r("update:expanded", !n.expanded), n.expanded ? r("hide") : r("show");
    }
    return (a, l) => (x(), L(b(u2), { class: "relative rounded-xl border-border bg-card" }, {
      default: A(() => [
        n.loading ? Qe("", !0) : (x(), L(b(c2), {
          key: 0,
          class: "mb-1 flex flex-col gap-y-1.5 py-2 pb-0 text-foreground"
        }, {
          default: A(() => [
            $(b(f2), { class: "flex items-center space-x-2" }, {
              default: A(() => [
                B(a.$slots, "title", {}, void 0, !0),
                $(q2, null, {
                  default: A(() => [
                    $(G2, null, {
                      default: A(() => [
                        $(b(Kr), {
                          variant: "ghost",
                          size: "sm",
                          class: "rounded-full p-1 text-muted-foreground",
                          onClick: s
                        }, {
                          default: A(() => [
                            a.expanded ? (x(), L(b(eS), { key: 0 })) : (x(), L(b(tS), { key: 1 }))
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    $(W2, null, {
                      default: A(() => [
                        Xt(ze(a.expanded ? "Collapse" : "Expand"), 1)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 3
            })
          ]),
          _: 3
        })),
        n.loading ? (x(), L(b(ah), {
          key: 1,
          class: "text-sm text-foreground"
        }, {
          default: A(() => [
            be("div", hC, [
              $(b(Di), { class: "mb-6 h-6 w-1/3 rounded-lg" }),
              $(b(Di), { class: "h-6 w-full rounded-lg" }),
              $(b(Di), { class: "h-6 w-3/4 rounded-lg" }),
              $(b(Di), { class: "h-6 w-1/2 rounded-lg" })
            ])
          ]),
          _: 1
        })) : (x(), L(b(ah), {
          key: 2,
          class: "py-0 text-sm"
        }, {
          default: A(() => [
            B(a.$slots, "no-content", {}, void 0, !0),
            be("div", {
              ref_key: "contentRef",
              ref: i,
              class: ce(["transition-max-height overflow-hidden duration-300 ease-in-out", {
                [o.value]: !a.expanded,
                "fade-bottom": !a.expanded && n.fade,
                "pb-6": a.expanded
              }])
            }, [
              B(a.$slots, "content", { expanded: a.expanded }, void 0, !0)
            ], 2)
          ]),
          _: 3
        })),
        a.$slots.footer ? (x(), L(b(OS), { key: 3 }, {
          default: A(() => [
            B(a.$slots, "footer", {}, void 0, !0)
          ]),
          _: 3
        })) : Qe("", !0)
      ]),
      _: 3
    }));
  }
}), Ute = /* @__PURE__ */ U0(gC, [["__scopeId", "data-v-1f7cd22e"]]), Vte = /* @__PURE__ */ S({
  __name: "InitialCircle",
  props: {
    initials: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("div", {
      class: ce(
        b(G)(
          "bg-secondary text-foreground w-10 h-10 rounded-full flex items-center justify-center text-md",
          n.$attrs.class ?? ""
        )
      )
    }, ze(t.initials), 3));
  }
}), mC = { class: "w-full space-y-2" }, Hte = /* @__PURE__ */ S({
  __name: "ListLoader",
  props: {
    loading: { type: Boolean, default: !1 },
    rows: { default: 3 }
  },
  setup(e) {
    return (t, n) => t.loading ? (x(!0), W(Ge, { key: 0 }, ft(t.rows, (r) => (x(), W("div", {
      key: r,
      class: "ml-6 flex w-full items-center space-x-10 py-4"
    }, [
      B(t.$slots, "loading-row", {}, () => [
        $(b(Di), { class: "h-8 w-8 rounded-full" }),
        be("div", mC, [
          $(b(Di), { class: "h-4 w-[25%]" }),
          $(b(Di), { class: "h-4 w-[20%]" }),
          $(b(Di), { class: "h-4 w-[90%]" })
        ])
      ])
    ]))), 128)) : B(t.$slots, "default", { key: 1 });
  }
}), qte = /* @__PURE__ */ S({
  __name: "DragWindow",
  props: {
    class: {},
    anchor: { default: () => ({
      bottom: "0px",
      right: "0px"
    }) }
  },
  setup(e) {
    const t = e, n = _e(!1), r = _e(0), i = _e(0), o = _e(0), s = _e(0), a = _e(!1), l = _e(null), u = S((g, { slots: y }) => () => Fr(
      Kr,
      {
        class: n.value ? "cursor-grabbing" : "cursor-grab",
        onMousedown: p,
        onTouchstart: h
      },
      () => y.default ? y.default() : []
    )), c = R(() => {
      var g;
      return ((g = l == null ? void 0 : l.value) == null ? void 0 : g.clientHeight) || 0;
    }), f = R(() => {
      var g;
      return ((g = l == null ? void 0 : l.value) == null ? void 0 : g.clientWidth) || 0;
    }), d = R(() => a.value ? {
      top: `${o.value}px`,
      left: `${s.value}px`
    } : t.anchor);
    Ra(
      document,
      "touchmove",
      (g) => {
        if (!n.value) return;
        a.value = !0, g.preventDefault(), g.stopPropagation();
        let y = g.touches[0].clientX + r.value, _ = g.touches[0].clientY + i.value;
        (y < 0 || y > window.innerWidth - f.value) && (y = y < 0 ? 0 : window.innerWidth - f.value), (_ < 0 || _ > window.innerHeight - c.value) && (_ = _ < 0 ? 0 : window.innerHeight - c.value), o.value = _, s.value = y;
      },
      { passive: !1 }
    ), Ra(document, "mousemove", (g) => {
      if (!n.value) return;
      a.value = !0, g.preventDefault();
      let y = g.clientX + r.value, _ = g.clientY + i.value;
      (y < 0 || y > window.innerWidth - f.value) && (y = y < 0 ? 0 : window.innerWidth - f.value), (_ < 0 || _ > window.innerHeight - c.value) && (_ = _ < 0 ? 0 : window.innerHeight - c.value), o.value = _, s.value = y;
    }), Ra(document, ["mouseup", "touchend"], (g) => {
      n.value = !1;
    });
    function p(g) {
      var y, _;
      n.value = !0, r.value = (((y = l.value) == null ? void 0 : y.offsetLeft) || 0) - g.clientX, i.value = (((_ = l.value) == null ? void 0 : _.offsetTop) || 0) - g.clientY;
    }
    function h(g) {
      var y, _;
      n.value = !0, r.value = (((y = l.value) == null ? void 0 : y.offsetLeft) || 0) - g.touches[0].clientX, i.value = (((_ = l.value) == null ? void 0 : _.offsetTop) || 0) - g.touches[0].clientY;
    }
    function m() {
      a.value = !1;
    }
    return (g, y) => (x(), W("div", {
      ref_key: "wrapper",
      ref: l,
      draggable: "",
      class: ce(["absolute", b(G)("absolute", t.class)]),
      style: Rr(d.value)
    }, [
      B(g.$slots, "default", {
        hasBeenDragged: a.value,
        handleMousedown: p,
        reset: m,
        DragHandle: b(u)
      })
    ], 6));
  }
});
function Wt(e) {
  this.content = e;
}
Wt.prototype = {
  constructor: Wt,
  find: function(e) {
    for (var t = 0; t < this.content.length; t += 2)
      if (this.content[t] === e) return t;
    return -1;
  },
  // :: (string)  ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(e) {
    var t = this.find(e);
    return t == -1 ? void 0 : this.content[t + 1];
  },
  // :: (string, any, ?string)  OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(e, t, n) {
    var r = n && n != e ? this.remove(n) : this, i = r.find(e), o = r.content.slice();
    return i == -1 ? o.push(n || e, t) : (o[i + 1] = t, n && (o[i] = n)), new Wt(o);
  },
  // :: (string)  OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(e) {
    var t = this.find(e);
    if (t == -1) return this;
    var n = this.content.slice();
    return n.splice(t, 2), new Wt(n);
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(e, t) {
    return new Wt([e, t].concat(this.remove(e).content));
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(e, t) {
    var n = this.remove(e).content.slice();
    return n.push(e, t), new Wt(n);
  },
  // :: (string, string, any)  OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(e, t, n) {
    var r = this.remove(t), i = r.content.slice(), o = r.find(e);
    return i.splice(o == -1 ? i.length : o, 0, t, n), new Wt(i);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(e) {
    for (var t = 0; t < this.content.length; t += 2)
      e(this.content[t], this.content[t + 1]);
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(e) {
    return e = Wt.from(e), e.size ? new Wt(e.content.concat(this.subtract(e).content)) : this;
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(e) {
    return e = Wt.from(e), e.size ? new Wt(this.subtract(e).content.concat(e.content)) : this;
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(e) {
    var t = this;
    e = Wt.from(e);
    for (var n = 0; n < e.content.length; n += 2)
      t = t.remove(e.content[n]);
    return t;
  },
  // :: ()  Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var e = {};
    return this.forEach(function(t, n) {
      e[t] = n;
    }), e;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
Wt.from = function(e) {
  if (e instanceof Wt) return e;
  var t = [];
  if (e) for (var n in e) t.push(n, e[n]);
  return new Wt(t);
};
function K2(e, t, n) {
  for (let r = 0; ; r++) {
    if (r == e.childCount || r == t.childCount)
      return e.childCount == t.childCount ? null : n;
    let i = e.child(r), o = t.child(r);
    if (i == o) {
      n += i.nodeSize;
      continue;
    }
    if (!i.sameMarkup(o))
      return n;
    if (i.isText && i.text != o.text) {
      for (let s = 0; i.text[s] == o.text[s]; s++)
        n++;
      return n;
    }
    if (i.content.size || o.content.size) {
      let s = K2(i.content, o.content, n + 1);
      if (s != null)
        return s;
    }
    n += i.nodeSize;
  }
}
function Y2(e, t, n, r) {
  for (let i = e.childCount, o = t.childCount; ; ) {
    if (i == 0 || o == 0)
      return i == o ? null : { a: n, b: r };
    let s = e.child(--i), a = t.child(--o), l = s.nodeSize;
    if (s == a) {
      n -= l, r -= l;
      continue;
    }
    if (!s.sameMarkup(a))
      return { a: n, b: r };
    if (s.isText && s.text != a.text) {
      let u = 0, c = Math.min(s.text.length, a.text.length);
      for (; u < c && s.text[s.text.length - u - 1] == a.text[a.text.length - u - 1]; )
        u++, n--, r--;
      return { a: n, b: r };
    }
    if (s.content.size || a.content.size) {
      let u = Y2(s.content, a.content, n - 1, r - 1);
      if (u)
        return u;
    }
    n -= l, r -= l;
  }
}
class te {
  /**
  @internal
  */
  constructor(t, n) {
    if (this.content = t, this.size = n || 0, n == null)
      for (let r = 0; r < t.length; r++)
        this.size += t[r].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(t, n, r, i = 0, o) {
    for (let s = 0, a = 0; a < n; s++) {
      let l = this.content[s], u = a + l.nodeSize;
      if (u > t && r(l, i + a, o || null, s) !== !1 && l.content.size) {
        let c = a + 1;
        l.nodesBetween(Math.max(0, t - c), Math.min(l.content.size, n - c), r, i + c);
      }
      a = u;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(t) {
    this.nodesBetween(0, this.size, t);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(t, n, r, i) {
    let o = "", s = !0;
    return this.nodesBetween(t, n, (a, l) => {
      let u = a.isText ? a.text.slice(Math.max(t, l) - l, n - l) : a.isLeaf ? i ? typeof i == "function" ? i(a) : i : a.type.spec.leafText ? a.type.spec.leafText(a) : "" : "";
      a.isBlock && (a.isLeaf && u || a.isTextblock) && r && (s ? s = !1 : o += r), o += u;
    }, 0), o;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(t) {
    if (!t.size)
      return this;
    if (!this.size)
      return t;
    let n = this.lastChild, r = t.firstChild, i = this.content.slice(), o = 0;
    for (n.isText && n.sameMarkup(r) && (i[i.length - 1] = n.withText(n.text + r.text), o = 1); o < t.content.length; o++)
      i.push(t.content[o]);
    return new te(i, this.size + t.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(t, n = this.size) {
    if (t == 0 && n == this.size)
      return this;
    let r = [], i = 0;
    if (n > t)
      for (let o = 0, s = 0; s < n; o++) {
        let a = this.content[o], l = s + a.nodeSize;
        l > t && ((s < t || l > n) && (a.isText ? a = a.cut(Math.max(0, t - s), Math.min(a.text.length, n - s)) : a = a.cut(Math.max(0, t - s - 1), Math.min(a.content.size, n - s - 1))), r.push(a), i += a.nodeSize), s = l;
      }
    return new te(r, i);
  }
  /**
  @internal
  */
  cutByIndex(t, n) {
    return t == n ? te.empty : t == 0 && n == this.content.length ? this : new te(this.content.slice(t, n));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(t, n) {
    let r = this.content[t];
    if (r == n)
      return this;
    let i = this.content.slice(), o = this.size + n.nodeSize - r.nodeSize;
    return i[t] = n, new te(i, o);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(t) {
    return new te([t].concat(this.content), this.size + t.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(t) {
    return new te(this.content.concat(t), this.size + t.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(t) {
    if (this.content.length != t.content.length)
      return !1;
    for (let n = 0; n < this.content.length; n++)
      if (!this.content[n].eq(t.content[n]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(t) {
    let n = this.content[t];
    if (!n)
      throw new RangeError("Index " + t + " out of range for " + this);
    return n;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(t) {
    return this.content[t] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(t) {
    for (let n = 0, r = 0; n < this.content.length; n++) {
      let i = this.content[n];
      t(i, r, n), r += i.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(t, n = 0) {
    return K2(this, t, n);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(t, n = this.size, r = t.size) {
    return Y2(this, t, n, r);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(t, n = -1) {
    if (t == 0)
      return du(0, t);
    if (t == this.size)
      return du(this.content.length, t);
    if (t > this.size || t < 0)
      throw new RangeError(`Position ${t} outside of fragment (${this})`);
    for (let r = 0, i = 0; ; r++) {
      let o = this.child(r), s = i + o.nodeSize;
      if (s >= t)
        return s == t || n > 0 ? du(r + 1, s) : du(r, i);
      i = s;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((t) => t.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(t, n) {
    if (!n)
      return te.empty;
    if (!Array.isArray(n))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new te(n.map(t.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(t) {
    if (!t.length)
      return te.empty;
    let n, r = 0;
    for (let i = 0; i < t.length; i++) {
      let o = t[i];
      r += o.nodeSize, i && o.isText && t[i - 1].sameMarkup(o) ? (n || (n = t.slice(0, i)), n[n.length - 1] = o.withText(n[n.length - 1].text + o.text)) : n && n.push(o);
    }
    return new te(n || t, r);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(t) {
    if (!t)
      return te.empty;
    if (t instanceof te)
      return t;
    if (Array.isArray(t))
      return this.fromArray(t);
    if (t.attrs)
      return new te([t], t.nodeSize);
    throw new RangeError("Can not convert " + t + " to a Fragment" + (t.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
te.empty = new te([], 0);
const Xd = { index: 0, offset: 0 };
function du(e, t) {
  return Xd.index = e, Xd.offset = t, Xd;
}
function Ac(e, t) {
  if (e === t)
    return !0;
  if (!(e && typeof e == "object") || !(t && typeof t == "object"))
    return !1;
  let n = Array.isArray(e);
  if (Array.isArray(t) != n)
    return !1;
  if (n) {
    if (e.length != t.length)
      return !1;
    for (let r = 0; r < e.length; r++)
      if (!Ac(e[r], t[r]))
        return !1;
  } else {
    for (let r in e)
      if (!(r in t) || !Ac(e[r], t[r]))
        return !1;
    for (let r in t)
      if (!(r in e))
        return !1;
  }
  return !0;
}
let rt = class hh {
  /**
  @internal
  */
  constructor(t, n) {
    this.type = t, this.attrs = n;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(t) {
    let n, r = !1;
    for (let i = 0; i < t.length; i++) {
      let o = t[i];
      if (this.eq(o))
        return t;
      if (this.type.excludes(o.type))
        n || (n = t.slice(0, i));
      else {
        if (o.type.excludes(this.type))
          return t;
        !r && o.type.rank > this.type.rank && (n || (n = t.slice(0, i)), n.push(this), r = !0), n && n.push(o);
      }
    }
    return n || (n = t.slice()), r || n.push(this), n;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(t) {
    for (let n = 0; n < t.length; n++)
      if (this.eq(t[n]))
        return t.slice(0, n).concat(t.slice(n + 1));
    return t;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(t) {
    for (let n = 0; n < t.length; n++)
      if (this.eq(t[n]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(t) {
    return this == t || this.type == t.type && Ac(this.attrs, t.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let t = { type: this.type.name };
    for (let n in this.attrs) {
      t.attrs = this.attrs;
      break;
    }
    return t;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(t, n) {
    if (!n)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let r = t.marks[n.type];
    if (!r)
      throw new RangeError(`There is no mark type ${n.type} in this schema`);
    let i = r.create(n.attrs);
    return r.checkAttrs(i.attrs), i;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(t, n) {
    if (t == n)
      return !0;
    if (t.length != n.length)
      return !1;
    for (let r = 0; r < t.length; r++)
      if (!t[r].eq(n[r]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(t) {
    if (!t || Array.isArray(t) && t.length == 0)
      return hh.none;
    if (t instanceof hh)
      return [t];
    let n = t.slice();
    return n.sort((r, i) => r.type.rank - i.type.rank), n;
  }
};
rt.none = [];
class Tc extends Error {
}
class ye {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragmenti.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(t, n, r) {
    this.content = t, this.openStart = n, this.openEnd = r;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(t, n) {
    let r = Z2(this.content, t + this.openStart, n);
    return r && new ye(r, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(t, n) {
    return new ye(Q2(this.content, t + this.openStart, n + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(t) {
    return this.content.eq(t.content) && this.openStart == t.openStart && this.openEnd == t.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let t = { content: this.content.toJSON() };
    return this.openStart > 0 && (t.openStart = this.openStart), this.openEnd > 0 && (t.openEnd = this.openEnd), t;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(t, n) {
    if (!n)
      return ye.empty;
    let r = n.openStart || 0, i = n.openEnd || 0;
    if (typeof r != "number" || typeof i != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new ye(te.fromJSON(t, n.content), r, i);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(t, n = !0) {
    let r = 0, i = 0;
    for (let o = t.firstChild; o && !o.isLeaf && (n || !o.type.spec.isolating); o = o.firstChild)
      r++;
    for (let o = t.lastChild; o && !o.isLeaf && (n || !o.type.spec.isolating); o = o.lastChild)
      i++;
    return new ye(t, r, i);
  }
}
ye.empty = new ye(te.empty, 0, 0);
function Q2(e, t, n) {
  let { index: r, offset: i } = e.findIndex(t), o = e.maybeChild(r), { index: s, offset: a } = e.findIndex(n);
  if (i == t || o.isText) {
    if (a != n && !e.child(s).isText)
      throw new RangeError("Removing non-flat range");
    return e.cut(0, t).append(e.cut(n));
  }
  if (r != s)
    throw new RangeError("Removing non-flat range");
  return e.replaceChild(r, o.copy(Q2(o.content, t - i - 1, n - i - 1)));
}
function Z2(e, t, n, r) {
  let { index: i, offset: o } = e.findIndex(t), s = e.maybeChild(i);
  if (o == t || s.isText)
    return e.cut(0, t).append(n).append(e.cut(t));
  let a = Z2(s.content, t - o - 1, n);
  return a && e.replaceChild(i, s.copy(a));
}
function bC(e, t, n) {
  if (n.openStart > e.depth)
    throw new Tc("Inserted content deeper than insertion position");
  if (e.depth - n.openStart != t.depth - n.openEnd)
    throw new Tc("Inconsistent open depths");
  return X2(e, t, n, 0);
}
function X2(e, t, n, r) {
  let i = e.index(r), o = e.node(r);
  if (i == t.index(r) && r < e.depth - n.openStart) {
    let s = X2(e, t, n, r + 1);
    return o.copy(o.content.replaceChild(i, s));
  } else if (n.content.size)
    if (!n.openStart && !n.openEnd && e.depth == r && t.depth == r) {
      let s = e.parent, a = s.content;
      return yo(s, a.cut(0, e.parentOffset).append(n.content).append(a.cut(t.parentOffset)));
    } else {
      let { start: s, end: a } = yC(n, e);
      return yo(o, eE(e, s, a, t, r));
    }
  else return yo(o, Sc(e, t, r));
}
function J2(e, t) {
  if (!t.type.compatibleContent(e.type))
    throw new Tc("Cannot join " + t.type.name + " onto " + e.type.name);
}
function gh(e, t, n) {
  let r = e.node(n);
  return J2(r, t.node(n)), r;
}
function bo(e, t) {
  let n = t.length - 1;
  n >= 0 && e.isText && e.sameMarkup(t[n]) ? t[n] = e.withText(t[n].text + e.text) : t.push(e);
}
function La(e, t, n, r) {
  let i = (t || e).node(n), o = 0, s = t ? t.index(n) : i.childCount;
  e && (o = e.index(n), e.depth > n ? o++ : e.textOffset && (bo(e.nodeAfter, r), o++));
  for (let a = o; a < s; a++)
    bo(i.child(a), r);
  t && t.depth == n && t.textOffset && bo(t.nodeBefore, r);
}
function yo(e, t) {
  return e.type.checkContent(t), e.copy(t);
}
function eE(e, t, n, r, i) {
  let o = e.depth > i && gh(e, t, i + 1), s = r.depth > i && gh(n, r, i + 1), a = [];
  return La(null, e, i, a), o && s && t.index(i) == n.index(i) ? (J2(o, s), bo(yo(o, eE(e, t, n, r, i + 1)), a)) : (o && bo(yo(o, Sc(e, t, i + 1)), a), La(t, n, i, a), s && bo(yo(s, Sc(n, r, i + 1)), a)), La(r, null, i, a), new te(a);
}
function Sc(e, t, n) {
  let r = [];
  if (La(null, e, n, r), e.depth > n) {
    let i = gh(e, t, n + 1);
    bo(yo(i, Sc(e, t, n + 1)), r);
  }
  return La(t, null, n, r), new te(r);
}
function yC(e, t) {
  let n = t.depth - e.openStart, i = t.node(n).copy(e.content);
  for (let o = n - 1; o >= 0; o--)
    i = t.node(o).copy(te.from(i));
  return {
    start: i.resolveNoCache(e.openStart + n),
    end: i.resolveNoCache(i.content.size - e.openEnd - n)
  };
}
class el {
  /**
  @internal
  */
  constructor(t, n, r) {
    this.pos = t, this.path = n, this.parentOffset = r, this.depth = n.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(t) {
    return t == null ? this.depth : t < 0 ? this.depth + t : t;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parenttext nodes are flat in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(t) {
    return this.path[this.resolveDepth(t) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(t) {
    return this.path[this.resolveDepth(t) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(t) {
    return t = this.resolveDepth(t), this.index(t) + (t == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(t) {
    return t = this.resolveDepth(t), t == 0 ? 0 : this.path[t * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(t) {
    return t = this.resolveDepth(t), this.start(t) + this.node(t).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(t) {
    if (t = this.resolveDepth(t), !t)
      throw new RangeError("There is no position before the top-level node");
    return t == this.depth + 1 ? this.pos : this.path[t * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(t) {
    if (t = this.resolveDepth(t), !t)
      throw new RangeError("There is no position after the top-level node");
    return t == this.depth + 1 ? this.pos : this.path[t * 3 - 1] + this.path[t * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let t = this.parent, n = this.index(this.depth);
    if (n == t.childCount)
      return null;
    let r = this.pos - this.path[this.path.length - 1], i = t.child(n);
    return r ? t.child(n).cut(r) : i;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let t = this.index(this.depth), n = this.pos - this.path[this.path.length - 1];
    return n ? this.parent.child(t).cut(0, n) : t == 0 ? null : this.parent.child(t - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(t, n) {
    n = this.resolveDepth(n);
    let r = this.path[n * 3], i = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
    for (let o = 0; o < t; o++)
      i += r.child(o).nodeSize;
    return i;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let t = this.parent, n = this.index();
    if (t.content.size == 0)
      return rt.none;
    if (this.textOffset)
      return t.child(n).marks;
    let r = t.maybeChild(n - 1), i = t.maybeChild(n);
    if (!r) {
      let a = r;
      r = i, i = a;
    }
    let o = r.marks;
    for (var s = 0; s < o.length; s++)
      o[s].type.spec.inclusive === !1 && (!i || !o[s].isInSet(i.marks)) && (o = o[s--].removeFromSet(o));
    return o;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(t) {
    let n = this.parent.maybeChild(this.index());
    if (!n || !n.isInline)
      return null;
    let r = n.marks, i = t.parent.maybeChild(t.index());
    for (var o = 0; o < r.length; o++)
      r[o].type.spec.inclusive === !1 && (!i || !r[o].isInSet(i.marks)) && (r = r[o--].removeFromSet(r));
    return r;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(t) {
    for (let n = this.depth; n > 0; n--)
      if (this.start(n) <= t && this.end(n) >= t)
        return n;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(t = this, n) {
    if (t.pos < this.pos)
      return t.blockRange(this);
    for (let r = this.depth - (this.parent.inlineContent || this.pos == t.pos ? 1 : 0); r >= 0; r--)
      if (t.pos <= this.end(r) && (!n || n(this.node(r))))
        return new Cc(this, t, r);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(t) {
    return this.pos - this.parentOffset == t.pos - t.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(t) {
    return t.pos > this.pos ? t : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(t) {
    return t.pos < this.pos ? t : this;
  }
  /**
  @internal
  */
  toString() {
    let t = "";
    for (let n = 1; n <= this.depth; n++)
      t += (t ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
    return t + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(t, n) {
    if (!(n >= 0 && n <= t.content.size))
      throw new RangeError("Position " + n + " out of range");
    let r = [], i = 0, o = n;
    for (let s = t; ; ) {
      let { index: a, offset: l } = s.content.findIndex(o), u = o - l;
      if (r.push(s, a, i + l), !u || (s = s.child(a), s.isText))
        break;
      o = u - 1, i += l + 1;
    }
    return new el(n, r, o);
  }
  /**
  @internal
  */
  static resolveCached(t, n) {
    let r = Q1.get(t);
    if (r)
      for (let o = 0; o < r.elts.length; o++) {
        let s = r.elts[o];
        if (s.pos == n)
          return s;
      }
    else
      Q1.set(t, r = new vC());
    let i = r.elts[r.i] = el.resolve(t, n);
    return r.i = (r.i + 1) % _C, i;
  }
}
class vC {
  constructor() {
    this.elts = [], this.i = 0;
  }
}
const _C = 12, Q1 = /* @__PURE__ */ new WeakMap();
class Cc {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(t, n, r) {
    this.$from = t, this.$to = n, this.depth = r;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const EC = /* @__PURE__ */ Object.create(null);
let Fi = class mh {
  /**
  @internal
  */
  constructor(t, n, r, i = rt.none) {
    this.type = t, this.attrs = n, this.marks = i, this.content = r || te.empty;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(t) {
    return this.content.child(t);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(t) {
    return this.content.maybeChild(t);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(t) {
    this.content.forEach(t);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(t, n, r, i = 0) {
    this.content.nodesBetween(t, n, r, i, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(t) {
    this.nodesBetween(0, this.content.size, t);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(t, n, r, i) {
    return this.content.textBetween(t, n, r, i);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(t) {
    return this == t || this.sameMarkup(t) && this.content.eq(t.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(t) {
    return this.hasMarkup(t.type, t.attrs, t.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(t, n, r) {
    return this.type == t && Ac(this.attrs, n || t.defaultAttrs || EC) && rt.sameSet(this.marks, r || rt.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(t = null) {
    return t == this.content ? this : new mh(this.type, this.attrs, t, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(t) {
    return t == this.marks ? this : new mh(this.type, this.attrs, this.content, t);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(t, n = this.content.size) {
    return t == 0 && n == this.content.size ? this : this.copy(this.content.cut(t, n));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(t, n = this.content.size, r = !1) {
    if (t == n)
      return ye.empty;
    let i = this.resolve(t), o = this.resolve(n), s = r ? 0 : i.sharedDepth(n), a = i.start(s), u = i.node(s).content.cut(i.pos - a, o.pos - a);
    return new ye(u, i.depth - s, o.depth - s);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(t, n, r) {
    return bC(this.resolve(t), this.resolve(n), r);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(t) {
    for (let n = this; ; ) {
      let { index: r, offset: i } = n.content.findIndex(t);
      if (n = n.maybeChild(r), !n)
        return null;
      if (i == t || n.isText)
        return n;
      t -= i + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(t) {
    let { index: n, offset: r } = this.content.findIndex(t);
    return { node: this.content.maybeChild(n), index: n, offset: r };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(t) {
    if (t == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: n, offset: r } = this.content.findIndex(t);
    if (r < t)
      return { node: this.content.child(n), index: n, offset: r };
    let i = this.content.child(n - 1);
    return { node: i, index: n - 1, offset: r - i.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(t) {
    return el.resolveCached(this, t);
  }
  /**
  @internal
  */
  resolveNoCache(t) {
    return el.resolve(this, t);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(t, n, r) {
    let i = !1;
    return n > t && this.nodesBetween(t, n, (o) => (r.isInSet(o.marks) && (i = !0), !i)), i;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let t = this.type.name;
    return this.content.size && (t += "(" + this.content.toStringInner() + ")"), tE(this.marks, t);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(t) {
    let n = this.type.contentMatch.matchFragment(this.content, 0, t);
    if (!n)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return n;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(t, n, r = te.empty, i = 0, o = r.childCount) {
    let s = this.contentMatchAt(t).matchFragment(r, i, o), a = s && s.matchFragment(this.content, n);
    if (!a || !a.validEnd)
      return !1;
    for (let l = i; l < o; l++)
      if (!this.type.allowsMarks(r.child(l).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(t, n, r, i) {
    if (i && !this.type.allowsMarks(i))
      return !1;
    let o = this.contentMatchAt(t).matchType(r), s = o && o.matchFragment(this.content, n);
    return s ? s.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(t) {
    return t.content.size ? this.canReplace(this.childCount, this.childCount, t.content) : this.type.compatibleContent(t.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let t = rt.none;
    for (let n = 0; n < this.marks.length; n++) {
      let r = this.marks[n];
      r.type.checkAttrs(r.attrs), t = r.addToSet(t);
    }
    if (!rt.sameSet(t, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((n) => n.type.name)}`);
    this.content.forEach((n) => n.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let t = { type: this.type.name };
    for (let n in this.attrs) {
      t.attrs = this.attrs;
      break;
    }
    return this.content.size && (t.content = this.content.toJSON()), this.marks.length && (t.marks = this.marks.map((n) => n.toJSON())), t;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(t, n) {
    if (!n)
      throw new RangeError("Invalid input for Node.fromJSON");
    let r;
    if (n.marks) {
      if (!Array.isArray(n.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      r = n.marks.map(t.markFromJSON);
    }
    if (n.type == "text") {
      if (typeof n.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return t.text(n.text, r);
    }
    let i = te.fromJSON(t, n.content), o = t.nodeType(n.type).create(n.attrs, i, r);
    return o.type.checkAttrs(o.attrs), o;
  }
};
Fi.prototype.text = void 0;
class Nc extends Fi {
  /**
  @internal
  */
  constructor(t, n, r, i) {
    if (super(t, n, null, i), !r)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = r;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : tE(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(t, n) {
    return this.text.slice(t, n);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(t) {
    return t == this.marks ? this : new Nc(this.type, this.attrs, this.text, t);
  }
  withText(t) {
    return t == this.text ? this : new Nc(this.type, this.attrs, t, this.marks);
  }
  cut(t = 0, n = this.text.length) {
    return t == 0 && n == this.text.length ? this : this.withText(this.text.slice(t, n));
  }
  eq(t) {
    return this.sameMarkup(t) && this.text == t.text;
  }
  toJSON() {
    let t = super.toJSON();
    return t.text = this.text, t;
  }
}
function tE(e, t) {
  for (let n = e.length - 1; n >= 0; n--)
    t = e[n].type.name + "(" + t + ")";
  return t;
}
class No {
  /**
  @internal
  */
  constructor(t) {
    this.validEnd = t, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(t, n) {
    let r = new wC(t, n);
    if (r.next == null)
      return No.empty;
    let i = nE(r);
    r.next && r.err("Unexpected trailing text");
    let o = CC(SC(i));
    return NC(o, r), o;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(t) {
    for (let n = 0; n < this.next.length; n++)
      if (this.next[n].type == t)
        return this.next[n].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(t, n = 0, r = t.childCount) {
    let i = this;
    for (let o = n; i && o < r; o++)
      i = i.matchType(t.child(o).type);
    return i;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let t = 0; t < this.next.length; t++) {
      let { type: n } = this.next[t];
      if (!(n.isText || n.hasRequiredAttrs()))
        return n;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(t) {
    for (let n = 0; n < this.next.length; n++)
      for (let r = 0; r < t.next.length; r++)
        if (this.next[n].type == t.next[r].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(t, n = !1, r = 0) {
    let i = [this];
    function o(s, a) {
      let l = s.matchFragment(t, r);
      if (l && (!n || l.validEnd))
        return te.from(a.map((u) => u.createAndFill()));
      for (let u = 0; u < s.next.length; u++) {
        let { type: c, next: f } = s.next[u];
        if (!(c.isText || c.hasRequiredAttrs()) && i.indexOf(f) == -1) {
          i.push(f);
          let d = o(f, a.concat(c));
          if (d)
            return d;
        }
      }
      return null;
    }
    return o(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(t) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == t)
        return this.wrapCache[r + 1];
    let n = this.computeWrapping(t);
    return this.wrapCache.push(t, n), n;
  }
  /**
  @internal
  */
  computeWrapping(t) {
    let n = /* @__PURE__ */ Object.create(null), r = [{ match: this, type: null, via: null }];
    for (; r.length; ) {
      let i = r.shift(), o = i.match;
      if (o.matchType(t)) {
        let s = [];
        for (let a = i; a.type; a = a.via)
          s.push(a.type);
        return s.reverse();
      }
      for (let s = 0; s < o.next.length; s++) {
        let { type: a, next: l } = o.next[s];
        !a.isLeaf && !a.hasRequiredAttrs() && !(a.name in n) && (!i.type || l.validEnd) && (r.push({ match: a.contentMatch, type: a, via: i }), n[a.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(t) {
    if (t >= this.next.length)
      throw new RangeError(`There's no ${t}th edge in this content match`);
    return this.next[t];
  }
  /**
  @internal
  */
  toString() {
    let t = [];
    function n(r) {
      t.push(r);
      for (let i = 0; i < r.next.length; i++)
        t.indexOf(r.next[i].next) == -1 && n(r.next[i].next);
    }
    return n(this), t.map((r, i) => {
      let o = i + (r.validEnd ? "*" : " ") + " ";
      for (let s = 0; s < r.next.length; s++)
        o += (s ? ", " : "") + r.next[s].type.name + "->" + t.indexOf(r.next[s].next);
      return o;
    }).join(`
`);
  }
}
No.empty = new No(!0);
class wC {
  constructor(t, n) {
    this.string = t, this.nodeTypes = n, this.inline = null, this.pos = 0, this.tokens = t.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(t) {
    return this.next == t && (this.pos++ || !0);
  }
  err(t) {
    throw new SyntaxError(t + " (in content expression '" + this.string + "')");
  }
}
function nE(e) {
  let t = [];
  do
    t.push(xC(e));
  while (e.eat("|"));
  return t.length == 1 ? t[0] : { type: "choice", exprs: t };
}
function xC(e) {
  let t = [];
  do
    t.push(kC(e));
  while (e.next && e.next != ")" && e.next != "|");
  return t.length == 1 ? t[0] : { type: "seq", exprs: t };
}
function kC(e) {
  let t = TC(e);
  for (; ; )
    if (e.eat("+"))
      t = { type: "plus", expr: t };
    else if (e.eat("*"))
      t = { type: "star", expr: t };
    else if (e.eat("?"))
      t = { type: "opt", expr: t };
    else if (e.eat("{"))
      t = MC(e, t);
    else
      break;
  return t;
}
function Z1(e) {
  /\D/.test(e.next) && e.err("Expected number, got '" + e.next + "'");
  let t = Number(e.next);
  return e.pos++, t;
}
function MC(e, t) {
  let n = Z1(e), r = n;
  return e.eat(",") && (e.next != "}" ? r = Z1(e) : r = -1), e.eat("}") || e.err("Unclosed braced range"), { type: "range", min: n, max: r, expr: t };
}
function AC(e, t) {
  let n = e.nodeTypes, r = n[t];
  if (r)
    return [r];
  let i = [];
  for (let o in n) {
    let s = n[o];
    s.isInGroup(t) && i.push(s);
  }
  return i.length == 0 && e.err("No node type or group '" + t + "' found"), i;
}
function TC(e) {
  if (e.eat("(")) {
    let t = nE(e);
    return e.eat(")") || e.err("Missing closing paren"), t;
  } else if (/\W/.test(e.next))
    e.err("Unexpected token '" + e.next + "'");
  else {
    let t = AC(e, e.next).map((n) => (e.inline == null ? e.inline = n.isInline : e.inline != n.isInline && e.err("Mixing inline and block content"), { type: "name", value: n }));
    return e.pos++, t.length == 1 ? t[0] : { type: "choice", exprs: t };
  }
}
function SC(e) {
  let t = [[]];
  return i(o(e, 0), n()), t;
  function n() {
    return t.push([]) - 1;
  }
  function r(s, a, l) {
    let u = { term: l, to: a };
    return t[s].push(u), u;
  }
  function i(s, a) {
    s.forEach((l) => l.to = a);
  }
  function o(s, a) {
    if (s.type == "choice")
      return s.exprs.reduce((l, u) => l.concat(o(u, a)), []);
    if (s.type == "seq")
      for (let l = 0; ; l++) {
        let u = o(s.exprs[l], a);
        if (l == s.exprs.length - 1)
          return u;
        i(u, a = n());
      }
    else if (s.type == "star") {
      let l = n();
      return r(a, l), i(o(s.expr, l), l), [r(l)];
    } else if (s.type == "plus") {
      let l = n();
      return i(o(s.expr, a), l), i(o(s.expr, l), l), [r(l)];
    } else {
      if (s.type == "opt")
        return [r(a)].concat(o(s.expr, a));
      if (s.type == "range") {
        let l = a;
        for (let u = 0; u < s.min; u++) {
          let c = n();
          i(o(s.expr, l), c), l = c;
        }
        if (s.max == -1)
          i(o(s.expr, l), l);
        else
          for (let u = s.min; u < s.max; u++) {
            let c = n();
            r(l, c), i(o(s.expr, l), c), l = c;
          }
        return [r(l)];
      } else {
        if (s.type == "name")
          return [r(a, void 0, s.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function rE(e, t) {
  return t - e;
}
function X1(e, t) {
  let n = [];
  return r(t), n.sort(rE);
  function r(i) {
    let o = e[i];
    if (o.length == 1 && !o[0].term)
      return r(o[0].to);
    n.push(i);
    for (let s = 0; s < o.length; s++) {
      let { term: a, to: l } = o[s];
      !a && n.indexOf(l) == -1 && r(l);
    }
  }
}
function CC(e) {
  let t = /* @__PURE__ */ Object.create(null);
  return n(X1(e, 0));
  function n(r) {
    let i = [];
    r.forEach((s) => {
      e[s].forEach(({ term: a, to: l }) => {
        if (!a)
          return;
        let u;
        for (let c = 0; c < i.length; c++)
          i[c][0] == a && (u = i[c][1]);
        X1(e, l).forEach((c) => {
          u || i.push([a, u = []]), u.indexOf(c) == -1 && u.push(c);
        });
      });
    });
    let o = t[r.join(",")] = new No(r.indexOf(e.length - 1) > -1);
    for (let s = 0; s < i.length; s++) {
      let a = i[s][1].sort(rE);
      o.next.push({ type: i[s][0], next: t[a.join(",")] || n(a) });
    }
    return o;
  }
}
function NC(e, t) {
  for (let n = 0, r = [e]; n < r.length; n++) {
    let i = r[n], o = !i.validEnd, s = [];
    for (let a = 0; a < i.next.length; a++) {
      let { type: l, next: u } = i.next[a];
      s.push(l.name), o && !(l.isText || l.hasRequiredAttrs()) && (o = !1), r.indexOf(u) == -1 && r.push(u);
    }
    o && t.err("Only non-generatable nodes (" + s.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function iE(e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let n in e) {
    let r = e[n];
    if (!r.hasDefault)
      return null;
    t[n] = r.default;
  }
  return t;
}
function oE(e, t) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let r in e) {
    let i = t && t[r];
    if (i === void 0) {
      let o = e[r];
      if (o.hasDefault)
        i = o.default;
      else
        throw new RangeError("No value supplied for attribute " + r);
    }
    n[r] = i;
  }
  return n;
}
function sE(e, t, n, r) {
  for (let i in t)
    if (!(i in e))
      throw new RangeError(`Unsupported attribute ${i} for ${n} of type ${i}`);
  for (let i in e) {
    let o = e[i];
    o.validate && o.validate(t[i]);
  }
}
function aE(e, t) {
  let n = /* @__PURE__ */ Object.create(null);
  if (t)
    for (let r in t)
      n[r] = new OC(e, r, t[r]);
  return n;
}
let J1 = class lE {
  /**
  @internal
  */
  constructor(t, n, r) {
    this.name = t, this.schema = n, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = aE(t, r.attrs), this.defaultAttrs = iE(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || t == "text"), this.isText = t == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == No.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(t) {
    return this.groups.indexOf(t) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let t in this.attrs)
      if (this.attrs[t].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(t) {
    return this == t || this.contentMatch.compatible(t.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(t) {
    return !t && this.defaultAttrs ? this.defaultAttrs : oE(this.attrs, t);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(t = null, n, r) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Fi(this, this.computeAttrs(t), te.from(n), rt.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(t = null, n, r) {
    return n = te.from(n), this.checkContent(n), new Fi(this, this.computeAttrs(t), n, rt.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(t = null, n, r) {
    if (t = this.computeAttrs(t), n = te.from(n), n.size) {
      let s = this.contentMatch.fillBefore(n);
      if (!s)
        return null;
      n = s.append(n);
    }
    let i = this.contentMatch.matchFragment(n), o = i && i.fillBefore(te.empty, !0);
    return o ? new Fi(this, t, n.append(o), rt.setFrom(r)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(t) {
    let n = this.contentMatch.matchFragment(t);
    if (!n || !n.validEnd)
      return !1;
    for (let r = 0; r < t.childCount; r++)
      if (!this.allowsMarks(t.child(r).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(t) {
    if (!this.validContent(t))
      throw new RangeError(`Invalid content for node ${this.name}: ${t.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(t) {
    sE(this.attrs, t, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(t) {
    return this.markSet == null || this.markSet.indexOf(t) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(t) {
    if (this.markSet == null)
      return !0;
    for (let n = 0; n < t.length; n++)
      if (!this.allowsMarkType(t[n].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(t) {
    if (this.markSet == null)
      return t;
    let n;
    for (let r = 0; r < t.length; r++)
      this.allowsMarkType(t[r].type) ? n && n.push(t[r]) : n || (n = t.slice(0, r));
    return n ? n.length ? n : rt.none : t;
  }
  /**
  @internal
  */
  static compile(t, n) {
    let r = /* @__PURE__ */ Object.create(null);
    t.forEach((o, s) => r[o] = new lE(o, n, s));
    let i = n.spec.topNode || "doc";
    if (!r[i])
      throw new RangeError("Schema is missing its top node type ('" + i + "')");
    if (!r.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let o in r.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return r;
  }
};
function DC(e, t, n) {
  let r = n.split("|");
  return (i) => {
    let o = i === null ? "null" : typeof i;
    if (r.indexOf(o) < 0)
      throw new RangeError(`Expected value of type ${r} for attribute ${t} on type ${e}, got ${o}`);
  };
}
class OC {
  constructor(t, n, r) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"), this.default = r.default, this.validate = typeof r.validate == "string" ? DC(t, n, r.validate) : r.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class td {
  /**
  @internal
  */
  constructor(t, n, r, i) {
    this.name = t, this.rank = n, this.schema = r, this.spec = i, this.attrs = aE(t, i.attrs), this.excluded = null;
    let o = iE(this.attrs);
    this.instance = o ? new rt(this, o) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(t = null) {
    return !t && this.instance ? this.instance : new rt(this, oE(this.attrs, t));
  }
  /**
  @internal
  */
  static compile(t, n) {
    let r = /* @__PURE__ */ Object.create(null), i = 0;
    return t.forEach((o, s) => r[o] = new td(o, i++, n, s)), r;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(t) {
    for (var n = 0; n < t.length; n++)
      t[n].type == this && (t = t.slice(0, n).concat(t.slice(n + 1)), n--);
    return t;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(t) {
    for (let n = 0; n < t.length; n++)
      if (t[n].type == this)
        return t[n];
  }
  /**
  @internal
  */
  checkAttrs(t) {
    sE(this.attrs, t, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(t) {
    return this.excluded.indexOf(t) > -1;
  }
}
class V0 {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(t) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let n = this.spec = {};
    for (let i in t)
      n[i] = t[i];
    n.nodes = Wt.from(t.nodes), n.marks = Wt.from(t.marks || {}), this.nodes = J1.compile(this.spec.nodes, this), this.marks = td.compile(this.spec.marks, this);
    let r = /* @__PURE__ */ Object.create(null);
    for (let i in this.nodes) {
      if (i in this.marks)
        throw new RangeError(i + " can not be both a node and a mark");
      let o = this.nodes[i], s = o.spec.content || "", a = o.spec.marks;
      if (o.contentMatch = r[s] || (r[s] = No.parse(s, this.nodes)), o.inlineContent = o.contentMatch.inlineContent, o.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!o.isInline || !o.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = o;
      }
      o.markSet = a == "_" ? null : a ? em(this, a.split(" ")) : a == "" || !o.inlineContent ? [] : null;
    }
    for (let i in this.marks) {
      let o = this.marks[i], s = o.spec.excludes;
      o.excluded = s == null ? [o] : s == "" ? [] : em(this, s.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(t, n = null, r, i) {
    if (typeof t == "string")
      t = this.nodeType(t);
    else if (t instanceof J1) {
      if (t.schema != this)
        throw new RangeError("Node type from different schema used (" + t.name + ")");
    } else throw new RangeError("Invalid node type: " + t);
    return t.createChecked(n, r, i);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(t, n) {
    let r = this.nodes.text;
    return new Nc(r, r.defaultAttrs, t, rt.setFrom(n));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(t, n) {
    return typeof t == "string" && (t = this.marks[t]), t.create(n);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(t) {
    return Fi.fromJSON(this, t);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(t) {
    return rt.fromJSON(this, t);
  }
  /**
  @internal
  */
  nodeType(t) {
    let n = this.nodes[t];
    if (!n)
      throw new RangeError("Unknown node type: " + t);
    return n;
  }
}
function em(e, t) {
  let n = [];
  for (let r = 0; r < t.length; r++) {
    let i = t[r], o = e.marks[i], s = o;
    if (o)
      n.push(o);
    else
      for (let a in e.marks) {
        let l = e.marks[a];
        (i == "_" || l.spec.group && l.spec.group.split(" ").indexOf(i) > -1) && n.push(s = l);
      }
    if (!s)
      throw new SyntaxError("Unknown mark type: '" + t[r] + "'");
  }
  return n;
}
function IC(e) {
  return e.tag != null;
}
function RC(e) {
  return e.style != null;
}
class li {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(t, n) {
    this.schema = t, this.rules = n, this.tags = [], this.styles = [];
    let r = this.matchedStyles = [];
    n.forEach((i) => {
      if (IC(i))
        this.tags.push(i);
      else if (RC(i)) {
        let o = /[^=]*/.exec(i.style)[0];
        r.indexOf(o) < 0 && r.push(o), this.styles.push(i);
      }
    }), this.normalizeLists = !this.tags.some((i) => {
      if (!/^(ul|ol)\b/.test(i.tag) || !i.node)
        return !1;
      let o = t.nodes[i.node];
      return o.contentMatch.matchType(o);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(t, n = {}) {
    let r = new nm(this, n, !1);
    return r.addAll(t, rt.none, n.from, n.to), r.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(t, n = {}) {
    let r = new nm(this, n, !0);
    return r.addAll(t, rt.none, n.from, n.to), ye.maxOpen(r.finish());
  }
  /**
  @internal
  */
  matchTag(t, n, r) {
    for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) {
      let o = this.tags[i];
      if (PC(t, o.tag) && (o.namespace === void 0 || t.namespaceURI == o.namespace) && (!o.context || n.matchesContext(o.context))) {
        if (o.getAttrs) {
          let s = o.getAttrs(t);
          if (s === !1)
            continue;
          o.attrs = s || void 0;
        }
        return o;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(t, n, r, i) {
    for (let o = i ? this.styles.indexOf(i) + 1 : 0; o < this.styles.length; o++) {
      let s = this.styles[o], a = s.style;
      if (!(a.indexOf(t) != 0 || s.context && !r.matchesContext(s.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      a.length > t.length && (a.charCodeAt(t.length) != 61 || a.slice(t.length + 1) != n))) {
        if (s.getAttrs) {
          let l = s.getAttrs(n);
          if (l === !1)
            continue;
          s.attrs = l || void 0;
        }
        return s;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(t) {
    let n = [];
    function r(i) {
      let o = i.priority == null ? 50 : i.priority, s = 0;
      for (; s < n.length; s++) {
        let a = n[s];
        if ((a.priority == null ? 50 : a.priority) < o)
          break;
      }
      n.splice(s, 0, i);
    }
    for (let i in t.marks) {
      let o = t.marks[i].spec.parseDOM;
      o && o.forEach((s) => {
        r(s = rm(s)), s.mark || s.ignore || s.clearMark || (s.mark = i);
      });
    }
    for (let i in t.nodes) {
      let o = t.nodes[i].spec.parseDOM;
      o && o.forEach((s) => {
        r(s = rm(s)), s.node || s.ignore || s.mark || (s.node = i);
      });
    }
    return n;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(t) {
    return t.cached.domParser || (t.cached.domParser = new li(t, li.schemaRules(t)));
  }
}
const uE = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, LC = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, cE = { ol: !0, ul: !0 }, Dc = 1, Oc = 2, Ba = 4;
function tm(e, t, n) {
  return t != null ? (t ? Dc : 0) | (t === "full" ? Oc : 0) : e && e.whitespace == "pre" ? Dc | Oc : n & ~Ba;
}
class pu {
  constructor(t, n, r, i, o, s) {
    this.type = t, this.attrs = n, this.marks = r, this.solid = i, this.options = s, this.content = [], this.activeMarks = rt.none, this.match = o || (s & Ba ? null : t.contentMatch);
  }
  findWrapping(t) {
    if (!this.match) {
      if (!this.type)
        return [];
      let n = this.type.contentMatch.fillBefore(te.from(t));
      if (n)
        this.match = this.type.contentMatch.matchFragment(n);
      else {
        let r = this.type.contentMatch, i;
        return (i = r.findWrapping(t.type)) ? (this.match = r, i) : null;
      }
    }
    return this.match.findWrapping(t.type);
  }
  finish(t) {
    if (!(this.options & Dc)) {
      let r = this.content[this.content.length - 1], i;
      if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let o = r;
        r.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = o.withText(o.text.slice(0, o.text.length - i[0].length));
      }
    }
    let n = te.from(this.content);
    return !t && this.match && (n = n.append(this.match.fillBefore(te.empty, !0))), this.type ? this.type.create(this.attrs, n, this.marks) : n;
  }
  inlineContext(t) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : t.parentNode && !uE.hasOwnProperty(t.parentNode.nodeName.toLowerCase());
  }
}
class nm {
  constructor(t, n, r) {
    this.parser = t, this.options = n, this.isOpen = r, this.open = 0;
    let i = n.topNode, o, s = tm(null, n.preserveWhitespace, 0) | (r ? Ba : 0);
    i ? o = new pu(i.type, i.attrs, rt.none, !0, n.topMatch || i.type.contentMatch, s) : r ? o = new pu(null, null, rt.none, !0, null, s) : o = new pu(t.schema.topNodeType, null, rt.none, !0, null, s), this.nodes = [o], this.find = n.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(t, n) {
    t.nodeType == 3 ? this.addTextNode(t, n) : t.nodeType == 1 && this.addElement(t, n);
  }
  addTextNode(t, n) {
    let r = t.nodeValue, i = this.top;
    if (i.options & Oc || i.inlineContext(t) || /[^ \t\r\n\u000c]/.test(r)) {
      if (i.options & Dc)
        i.options & Oc ? r = r.replace(/\r\n?/g, `
`) : r = r.replace(/\r?\n|\r/g, " ");
      else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) {
        let o = i.content[i.content.length - 1], s = t.previousSibling;
        (!o || s && s.nodeName == "BR" || o.isText && /[ \t\r\n\u000c]$/.test(o.text)) && (r = r.slice(1));
      }
      r && this.insertNode(this.parser.schema.text(r), n), this.findInText(t);
    } else
      this.findInside(t);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(t, n, r) {
    let i = t.nodeName.toLowerCase(), o;
    cE.hasOwnProperty(i) && this.parser.normalizeLists && BC(t);
    let s = this.options.ruleFromNode && this.options.ruleFromNode(t) || (o = this.parser.matchTag(t, this, r));
    if (s ? s.ignore : LC.hasOwnProperty(i))
      this.findInside(t), this.ignoreFallback(t, n);
    else if (!s || s.skip || s.closeParent) {
      s && s.closeParent ? this.open = Math.max(0, this.open - 1) : s && s.skip.nodeType && (t = s.skip);
      let a, l = this.top, u = this.needsBlock;
      if (uE.hasOwnProperty(i))
        l.content.length && l.content[0].isInline && this.open && (this.open--, l = this.top), a = !0, l.type || (this.needsBlock = !0);
      else if (!t.firstChild) {
        this.leafFallback(t, n);
        return;
      }
      let c = s && s.skip ? n : this.readStyles(t, n);
      c && this.addAll(t, c), a && this.sync(l), this.needsBlock = u;
    } else {
      let a = this.readStyles(t, n);
      a && this.addElementByRule(t, s, a, s.consuming === !1 ? o : void 0);
    }
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(t, n) {
    t.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(t.ownerDocument.createTextNode(`
`), n);
  }
  // Called for ignored nodes
  ignoreFallback(t, n) {
    t.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), n);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(t, n) {
    let r = t.style;
    if (r && r.length)
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let o = this.parser.matchedStyles[i], s = r.getPropertyValue(o);
        if (s)
          for (let a = void 0; ; ) {
            let l = this.parser.matchStyle(o, s, this, a);
            if (!l)
              break;
            if (l.ignore)
              return null;
            if (l.clearMark ? n = n.filter((u) => !l.clearMark(u)) : n = n.concat(this.parser.schema.marks[l.mark].create(l.attrs)), l.consuming === !1)
              a = l;
            else
              break;
          }
      }
    return n;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(t, n, r, i) {
    let o, s;
    if (n.node)
      if (s = this.parser.schema.nodes[n.node], s.isLeaf)
        this.insertNode(s.create(n.attrs), r) || this.leafFallback(t, r);
      else {
        let l = this.enter(s, n.attrs || null, r, n.preserveWhitespace);
        l && (o = !0, r = l);
      }
    else {
      let l = this.parser.schema.marks[n.mark];
      r = r.concat(l.create(n.attrs));
    }
    let a = this.top;
    if (s && s.isLeaf)
      this.findInside(t);
    else if (i)
      this.addElement(t, r, i);
    else if (n.getContent)
      this.findInside(t), n.getContent(t, this.parser.schema).forEach((l) => this.insertNode(l, r));
    else {
      let l = t;
      typeof n.contentElement == "string" ? l = t.querySelector(n.contentElement) : typeof n.contentElement == "function" ? l = n.contentElement(t) : n.contentElement && (l = n.contentElement), this.findAround(t, l, !0), this.addAll(l, r), this.findAround(t, l, !1);
    }
    o && this.sync(a) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(t, n, r, i) {
    let o = r || 0;
    for (let s = r ? t.childNodes[r] : t.firstChild, a = i == null ? null : t.childNodes[i]; s != a; s = s.nextSibling, ++o)
      this.findAtPoint(t, o), this.addDOM(s, n);
    this.findAtPoint(t, o);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(t, n) {
    let r, i;
    for (let o = this.open; o >= 0; o--) {
      let s = this.nodes[o], a = s.findWrapping(t);
      if (a && (!r || r.length > a.length) && (r = a, i = s, !a.length) || s.solid)
        break;
    }
    if (!r)
      return null;
    this.sync(i);
    for (let o = 0; o < r.length; o++)
      n = this.enterInner(r[o], null, n, !1);
    return n;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(t, n) {
    if (t.isInline && this.needsBlock && !this.top.type) {
      let i = this.textblockFromContext();
      i && (n = this.enterInner(i, null, n));
    }
    let r = this.findPlace(t, n);
    if (r) {
      this.closeExtra();
      let i = this.top;
      i.match && (i.match = i.match.matchType(t.type));
      let o = rt.none;
      for (let s of r.concat(t.marks))
        (i.type ? i.type.allowsMarkType(s.type) : im(s.type, t.type)) && (o = s.addToSet(o));
      return i.content.push(t.mark(o)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(t, n, r, i) {
    let o = this.findPlace(t.create(n), r);
    return o && (o = this.enterInner(t, n, r, !0, i)), o;
  }
  // Open a node of the given type
  enterInner(t, n, r, i = !1, o) {
    this.closeExtra();
    let s = this.top;
    s.match = s.match && s.match.matchType(t);
    let a = tm(t, o, s.options);
    s.options & Ba && s.content.length == 0 && (a |= Ba);
    let l = rt.none;
    return r = r.filter((u) => (s.type ? s.type.allowsMarkType(u.type) : im(u.type, t)) ? (l = u.addToSet(l), !1) : !0), this.nodes.push(new pu(t, n, l, i, null, a)), this.open++, r;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(t = !1) {
    let n = this.nodes.length - 1;
    if (n > this.open) {
      for (; n > this.open; n--)
        this.nodes[n - 1].content.push(this.nodes[n].finish(t));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(this.isOpen || this.options.topOpen);
  }
  sync(t) {
    for (let n = this.open; n >= 0; n--)
      if (this.nodes[n] == t)
        return this.open = n, !0;
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let t = 0;
    for (let n = this.open; n >= 0; n--) {
      let r = this.nodes[n].content;
      for (let i = r.length - 1; i >= 0; i--)
        t += r[i].nodeSize;
      n && t++;
    }
    return t;
  }
  findAtPoint(t, n) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == t && this.find[r].offset == n && (this.find[r].pos = this.currentPos);
  }
  findInside(t) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].pos == null && t.nodeType == 1 && t.contains(this.find[n].node) && (this.find[n].pos = this.currentPos);
  }
  findAround(t, n, r) {
    if (t != n && this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].pos == null && t.nodeType == 1 && t.contains(this.find[i].node) && n.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) && (this.find[i].pos = this.currentPos);
  }
  findInText(t) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].node == t && (this.find[n].pos = this.currentPos - (t.nodeValue.length - this.find[n].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(t) {
    if (t.indexOf("|") > -1)
      return t.split(/\s*\|\s*/).some(this.matchesContext, this);
    let n = t.split("/"), r = this.options.context, i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), o = -(r ? r.depth + 1 : 0) + (i ? 0 : 1), s = (a, l) => {
      for (; a >= 0; a--) {
        let u = n[a];
        if (u == "") {
          if (a == n.length - 1 || a == 0)
            continue;
          for (; l >= o; l--)
            if (s(a - 1, l))
              return !0;
          return !1;
        } else {
          let c = l > 0 || l == 0 && i ? this.nodes[l].type : r && l >= o ? r.node(l - o).type : null;
          if (!c || c.name != u && !c.isInGroup(u))
            return !1;
          l--;
        }
      }
      return !0;
    };
    return s(n.length - 1, this.open);
  }
  textblockFromContext() {
    let t = this.options.context;
    if (t)
      for (let n = t.depth; n >= 0; n--) {
        let r = t.node(n).contentMatchAt(t.indexAfter(n)).defaultType;
        if (r && r.isTextblock && r.defaultAttrs)
          return r;
      }
    for (let n in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[n];
      if (r.isTextblock && r.defaultAttrs)
        return r;
    }
  }
}
function BC(e) {
  for (let t = e.firstChild, n = null; t; t = t.nextSibling) {
    let r = t.nodeType == 1 ? t.nodeName.toLowerCase() : null;
    r && cE.hasOwnProperty(r) && n ? (n.appendChild(t), t = n) : r == "li" ? n = t : r && (n = null);
  }
}
function PC(e, t) {
  return (e.matches || e.msMatchesSelector || e.webkitMatchesSelector || e.mozMatchesSelector).call(e, t);
}
function rm(e) {
  let t = {};
  for (let n in e)
    t[n] = e[n];
  return t;
}
function im(e, t) {
  let n = t.schema.nodes;
  for (let r in n) {
    let i = n[r];
    if (!i.allowsMarkType(e))
      continue;
    let o = [], s = (a) => {
      o.push(a);
      for (let l = 0; l < a.edgeCount; l++) {
        let { type: u, next: c } = a.edge(l);
        if (u == t || o.indexOf(c) < 0 && s(c))
          return !0;
      }
    };
    if (s(i.contentMatch))
      return !0;
  }
}
class $o {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(t, n) {
    this.nodes = t, this.marks = n;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(t, n = {}, r) {
    r || (r = Jd(n).createDocumentFragment());
    let i = r, o = [];
    return t.forEach((s) => {
      if (o.length || s.marks.length) {
        let a = 0, l = 0;
        for (; a < o.length && l < s.marks.length; ) {
          let u = s.marks[l];
          if (!this.marks[u.type.name]) {
            l++;
            continue;
          }
          if (!u.eq(o[a][0]) || u.type.spec.spanning === !1)
            break;
          a++, l++;
        }
        for (; a < o.length; )
          i = o.pop()[1];
        for (; l < s.marks.length; ) {
          let u = s.marks[l++], c = this.serializeMark(u, s.isInline, n);
          c && (o.push([u, i]), i.appendChild(c.dom), i = c.contentDOM || c.dom);
        }
      }
      i.appendChild(this.serializeNodeInner(s, n));
    }), r;
  }
  /**
  @internal
  */
  serializeNodeInner(t, n) {
    let { dom: r, contentDOM: i } = Ju(Jd(n), this.nodes[t.type.name](t), null, t.attrs);
    if (i) {
      if (t.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(t.content, n, i);
    }
    return r;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(t, n = {}) {
    let r = this.serializeNodeInner(t, n);
    for (let i = t.marks.length - 1; i >= 0; i--) {
      let o = this.serializeMark(t.marks[i], t.isInline, n);
      o && ((o.contentDOM || o.dom).appendChild(r), r = o.dom);
    }
    return r;
  }
  /**
  @internal
  */
  serializeMark(t, n, r = {}) {
    let i = this.marks[t.type.name];
    return i && Ju(Jd(r), i(t, n), null, t.attrs);
  }
  static renderSpec(t, n, r = null, i) {
    return Ju(t, n, r, i);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(t) {
    return t.cached.domSerializer || (t.cached.domSerializer = new $o(this.nodesFromSchema(t), this.marksFromSchema(t)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(t) {
    let n = om(t.nodes);
    return n.text || (n.text = (r) => r.text), n;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(t) {
    return om(t.marks);
  }
}
function om(e) {
  let t = {};
  for (let n in e) {
    let r = e[n].spec.toDOM;
    r && (t[n] = r);
  }
  return t;
}
function Jd(e) {
  return e.document || window.document;
}
const sm = /* @__PURE__ */ new WeakMap();
function $C(e) {
  let t = sm.get(e);
  return t === void 0 && sm.set(e, t = zC(e)), t;
}
function zC(e) {
  let t = null;
  function n(r) {
    if (r && typeof r == "object")
      if (Array.isArray(r))
        if (typeof r[0] == "string")
          t || (t = []), t.push(r);
        else
          for (let i = 0; i < r.length; i++)
            n(r[i]);
      else
        for (let i in r)
          n(r[i]);
  }
  return n(e), t;
}
function Ju(e, t, n, r) {
  if (typeof t == "string")
    return { dom: e.createTextNode(t) };
  if (t.nodeType != null)
    return { dom: t };
  if (t.dom && t.dom.nodeType != null)
    return t;
  let i = t[0], o;
  if (typeof i != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (r && (o = $C(r)) && o.indexOf(t) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let s = i.indexOf(" ");
  s > 0 && (n = i.slice(0, s), i = i.slice(s + 1));
  let a, l = n ? e.createElementNS(n, i) : e.createElement(i), u = t[1], c = 1;
  if (u && typeof u == "object" && u.nodeType == null && !Array.isArray(u)) {
    c = 2;
    for (let f in u)
      if (u[f] != null) {
        let d = f.indexOf(" ");
        d > 0 ? l.setAttributeNS(f.slice(0, d), f.slice(d + 1), u[f]) : l.setAttribute(f, u[f]);
      }
  }
  for (let f = c; f < t.length; f++) {
    let d = t[f];
    if (d === 0) {
      if (f < t.length - 1 || f > c)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: l, contentDOM: l };
    } else {
      let { dom: p, contentDOM: h } = Ju(e, d, n, r);
      if (l.appendChild(p), h) {
        if (a)
          throw new RangeError("Multiple content holes");
        a = h;
      }
    }
  }
  return { dom: l, contentDOM: a };
}
const fE = 65535, dE = Math.pow(2, 16);
function FC(e, t) {
  return e + t * dE;
}
function am(e) {
  return e & fE;
}
function jC(e) {
  return (e - (e & fE)) / dE;
}
const pE = 1, hE = 2, ec = 4, gE = 8;
class bh {
  /**
  @internal
  */
  constructor(t, n, r) {
    this.pos = t, this.delInfo = n, this.recover = r;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & gE) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (pE | ec)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (hE | ec)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & ec) > 0;
  }
}
class $n {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(t, n = !1) {
    if (this.ranges = t, this.inverted = n, !t.length && $n.empty)
      return $n.empty;
  }
  /**
  @internal
  */
  recover(t) {
    let n = 0, r = am(t);
    if (!this.inverted)
      for (let i = 0; i < r; i++)
        n += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[r * 3] + n + jC(t);
  }
  mapResult(t, n = 1) {
    return this._map(t, n, !1);
  }
  map(t, n = 1) {
    return this._map(t, n, !0);
  }
  /**
  @internal
  */
  _map(t, n, r) {
    let i = 0, o = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? i : 0);
      if (l > t)
        break;
      let u = this.ranges[a + o], c = this.ranges[a + s], f = l + u;
      if (t <= f) {
        let d = u ? t == l ? -1 : t == f ? 1 : n : n, p = l + i + (d < 0 ? 0 : c);
        if (r)
          return p;
        let h = t == (n < 0 ? l : f) ? null : FC(a / 3, t - l), m = t == l ? hE : t == f ? pE : ec;
        return (n < 0 ? t != l : t != f) && (m |= gE), new bh(p, m, h);
      }
      i += c - u;
    }
    return r ? t + i : new bh(t + i, 0, null);
  }
  /**
  @internal
  */
  touches(t, n) {
    let r = 0, i = am(n), o = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? r : 0);
      if (l > t)
        break;
      let u = this.ranges[a + o], c = l + u;
      if (t <= c && a == i * 3)
        return !0;
      r += this.ranges[a + s] - u;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(t) {
    let n = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
    for (let i = 0, o = 0; i < this.ranges.length; i += 3) {
      let s = this.ranges[i], a = s - (this.inverted ? o : 0), l = s + (this.inverted ? 0 : o), u = this.ranges[i + n], c = this.ranges[i + r];
      t(a, a + u, l, l + c), o += c - u;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new $n(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(t) {
    return t == 0 ? $n.empty : new $n(t < 0 ? [0, -t, 0] : [0, 0, t]);
  }
}
$n.empty = new $n([]);
class cs {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(t = [], n, r = 0, i = t.length) {
    this.maps = t, this.mirror = n, this.from = r, this.to = i;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(t = 0, n = this.maps.length) {
    return new cs(this.maps, this.mirror, t, n);
  }
  /**
  @internal
  */
  copy() {
    return new cs(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(t, n) {
    this.to = this.maps.push(t), n != null && this.setMirror(this.maps.length - 1, n);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(t) {
    for (let n = 0, r = this.maps.length; n < t.maps.length; n++) {
      let i = t.getMirror(n);
      this.appendMap(t.maps[n], i != null && i < n ? r + i : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(t) {
    if (this.mirror) {
      for (let n = 0; n < this.mirror.length; n++)
        if (this.mirror[n] == t)
          return this.mirror[n + (n % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(t, n) {
    this.mirror || (this.mirror = []), this.mirror.push(t, n);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(t) {
    for (let n = t.maps.length - 1, r = this.maps.length + t.maps.length; n >= 0; n--) {
      let i = t.getMirror(n);
      this.appendMap(t.maps[n].invert(), i != null && i > n ? r - i - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let t = new cs();
    return t.appendMappingInverted(this), t;
  }
  /**
  Map a position through this mapping.
  */
  map(t, n = 1) {
    if (this.mirror)
      return this._map(t, n, !0);
    for (let r = this.from; r < this.to; r++)
      t = this.maps[r].map(t, n);
    return t;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(t, n = 1) {
    return this._map(t, n, !1);
  }
  /**
  @internal
  */
  _map(t, n, r) {
    let i = 0;
    for (let o = this.from; o < this.to; o++) {
      let s = this.maps[o], a = s.mapResult(t, n);
      if (a.recover != null) {
        let l = this.getMirror(o);
        if (l != null && l > o && l < this.to) {
          o = l, t = this.maps[l].recover(a.recover);
          continue;
        }
      }
      i |= a.delInfo, t = a.pos;
    }
    return r ? t : new bh(t, i, null);
  }
}
const ep = /* @__PURE__ */ Object.create(null);
class ln {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return $n.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(t) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(t, n) {
    if (!n || !n.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let r = ep[n.stepType];
    if (!r)
      throw new RangeError(`No step type ${n.stepType} defined`);
    return r.fromJSON(t, n);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(t, n) {
    if (t in ep)
      throw new RangeError("Duplicate use of step JSON ID " + t);
    return ep[t] = n, n.prototype.jsonID = t, n;
  }
}
class It {
  /**
  @internal
  */
  constructor(t, n) {
    this.doc = t, this.failed = n;
  }
  /**
  Create a successful step result.
  */
  static ok(t) {
    return new It(t, null);
  }
  /**
  Create a failed step result.
  */
  static fail(t) {
    return new It(null, t);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(t, n, r, i) {
    try {
      return It.ok(t.replace(n, r, i));
    } catch (o) {
      if (o instanceof Tc)
        return It.fail(o.message);
      throw o;
    }
  }
}
function H0(e, t, n) {
  let r = [];
  for (let i = 0; i < e.childCount; i++) {
    let o = e.child(i);
    o.content.size && (o = o.copy(H0(o.content, t, o))), o.isInline && (o = t(o, n, i)), r.push(o);
  }
  return te.fromArray(r);
}
class Oi extends ln {
  /**
  Create a mark step.
  */
  constructor(t, n, r) {
    super(), this.from = t, this.to = n, this.mark = r;
  }
  apply(t) {
    let n = t.slice(this.from, this.to), r = t.resolve(this.from), i = r.node(r.sharedDepth(this.to)), o = new ye(H0(n.content, (s, a) => !s.isAtom || !a.type.allowsMarkType(this.mark.type) ? s : s.mark(this.mark.addToSet(s.marks)), i), n.openStart, n.openEnd);
    return It.fromReplace(t, this.from, this.to, o);
  }
  invert() {
    return new Dr(this.from, this.to, this.mark);
  }
  map(t) {
    let n = t.mapResult(this.from, 1), r = t.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new Oi(n.pos, r.pos, this.mark);
  }
  merge(t) {
    return t instanceof Oi && t.mark.eq(this.mark) && this.from <= t.to && this.to >= t.from ? new Oi(Math.min(this.from, t.from), Math.max(this.to, t.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new Oi(n.from, n.to, t.markFromJSON(n.mark));
  }
}
ln.jsonID("addMark", Oi);
class Dr extends ln {
  /**
  Create a mark-removing step.
  */
  constructor(t, n, r) {
    super(), this.from = t, this.to = n, this.mark = r;
  }
  apply(t) {
    let n = t.slice(this.from, this.to), r = new ye(H0(n.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), t), n.openStart, n.openEnd);
    return It.fromReplace(t, this.from, this.to, r);
  }
  invert() {
    return new Oi(this.from, this.to, this.mark);
  }
  map(t) {
    let n = t.mapResult(this.from, 1), r = t.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new Dr(n.pos, r.pos, this.mark);
  }
  merge(t) {
    return t instanceof Dr && t.mark.eq(this.mark) && this.from <= t.to && this.to >= t.from ? new Dr(Math.min(this.from, t.from), Math.max(this.to, t.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new Dr(n.from, n.to, t.markFromJSON(n.mark));
  }
}
ln.jsonID("removeMark", Dr);
class Ii extends ln {
  /**
  Create a node mark step.
  */
  constructor(t, n) {
    super(), this.pos = t, this.mark = n;
  }
  apply(t) {
    let n = t.nodeAt(this.pos);
    if (!n)
      return It.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
    return It.fromReplace(t, this.pos, this.pos + 1, new ye(te.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(t) {
    let n = t.nodeAt(this.pos);
    if (n) {
      let r = this.mark.addToSet(n.marks);
      if (r.length == n.marks.length) {
        for (let i = 0; i < n.marks.length; i++)
          if (!n.marks[i].isInSet(r))
            return new Ii(this.pos, n.marks[i]);
        return new Ii(this.pos, this.mark);
      }
    }
    return new ws(this.pos, this.mark);
  }
  map(t) {
    let n = t.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new Ii(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new Ii(n.pos, t.markFromJSON(n.mark));
  }
}
ln.jsonID("addNodeMark", Ii);
class ws extends ln {
  /**
  Create a mark-removing step.
  */
  constructor(t, n) {
    super(), this.pos = t, this.mark = n;
  }
  apply(t) {
    let n = t.nodeAt(this.pos);
    if (!n)
      return It.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
    return It.fromReplace(t, this.pos, this.pos + 1, new ye(te.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(t) {
    let n = t.nodeAt(this.pos);
    return !n || !this.mark.isInSet(n.marks) ? this : new Ii(this.pos, this.mark);
  }
  map(t) {
    let n = t.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new ws(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new ws(n.pos, t.markFromJSON(n.mark));
  }
}
ln.jsonID("removeNodeMark", ws);
class jt extends ln {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(t, n, r, i = !1) {
    super(), this.from = t, this.to = n, this.slice = r, this.structure = i;
  }
  apply(t) {
    return this.structure && yh(t, this.from, this.to) ? It.fail("Structure replace would overwrite content") : It.fromReplace(t, this.from, this.to, this.slice);
  }
  getMap() {
    return new $n([this.from, this.to - this.from, this.slice.size]);
  }
  invert(t) {
    return new jt(this.from, this.from + this.slice.size, t.slice(this.from, this.to));
  }
  map(t) {
    let n = t.mapResult(this.from, 1), r = t.mapResult(this.to, -1);
    return n.deletedAcross && r.deletedAcross ? null : new jt(n.pos, Math.max(n.pos, r.pos), this.slice);
  }
  merge(t) {
    if (!(t instanceof jt) || t.structure || this.structure)
      return null;
    if (this.from + this.slice.size == t.from && !this.slice.openEnd && !t.slice.openStart) {
      let n = this.slice.size + t.slice.size == 0 ? ye.empty : new ye(this.slice.content.append(t.slice.content), this.slice.openStart, t.slice.openEnd);
      return new jt(this.from, this.to + (t.to - t.from), n, this.structure);
    } else if (t.to == this.from && !this.slice.openStart && !t.slice.openEnd) {
      let n = this.slice.size + t.slice.size == 0 ? ye.empty : new ye(t.slice.content.append(this.slice.content), t.slice.openStart, this.slice.openEnd);
      return new jt(t.from, this.to, n, this.structure);
    } else
      return null;
  }
  toJSON() {
    let t = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (t.slice = this.slice.toJSON()), this.structure && (t.structure = !0), t;
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new jt(n.from, n.to, ye.fromJSON(t, n.slice), !!n.structure);
  }
}
ln.jsonID("replace", jt);
class Vt extends ln {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(t, n, r, i, o, s, a = !1) {
    super(), this.from = t, this.to = n, this.gapFrom = r, this.gapTo = i, this.slice = o, this.insert = s, this.structure = a;
  }
  apply(t) {
    if (this.structure && (yh(t, this.from, this.gapFrom) || yh(t, this.gapTo, this.to)))
      return It.fail("Structure gap-replace would overwrite content");
    let n = t.slice(this.gapFrom, this.gapTo);
    if (n.openStart || n.openEnd)
      return It.fail("Gap is not a flat range");
    let r = this.slice.insertAt(this.insert, n.content);
    return r ? It.fromReplace(t, this.from, this.to, r) : It.fail("Content does not fit in gap");
  }
  getMap() {
    return new $n([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(t) {
    let n = this.gapTo - this.gapFrom;
    return new Vt(this.from, this.from + this.slice.size + n, this.from + this.insert, this.from + this.insert + n, t.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(t) {
    let n = t.mapResult(this.from, 1), r = t.mapResult(this.to, -1), i = this.from == this.gapFrom ? n.pos : t.map(this.gapFrom, -1), o = this.to == this.gapTo ? r.pos : t.map(this.gapTo, 1);
    return n.deletedAcross && r.deletedAcross || i < n.pos || o > r.pos ? null : new Vt(n.pos, r.pos, i, o, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let t = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (t.slice = this.slice.toJSON()), this.structure && (t.structure = !0), t;
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new Vt(n.from, n.to, n.gapFrom, n.gapTo, ye.fromJSON(t, n.slice), n.insert, !!n.structure);
  }
}
ln.jsonID("replaceAround", Vt);
function yh(e, t, n) {
  let r = e.resolve(t), i = n - t, o = r.depth;
  for (; i > 0 && o > 0 && r.indexAfter(o) == r.node(o).childCount; )
    o--, i--;
  if (i > 0) {
    let s = r.node(o).maybeChild(r.indexAfter(o));
    for (; i > 0; ) {
      if (!s || s.isLeaf)
        return !0;
      s = s.firstChild, i--;
    }
  }
  return !1;
}
function UC(e, t, n, r) {
  let i = [], o = [], s, a;
  e.doc.nodesBetween(t, n, (l, u, c) => {
    if (!l.isInline)
      return;
    let f = l.marks;
    if (!r.isInSet(f) && c.type.allowsMarkType(r.type)) {
      let d = Math.max(u, t), p = Math.min(u + l.nodeSize, n), h = r.addToSet(f);
      for (let m = 0; m < f.length; m++)
        f[m].isInSet(h) || (s && s.to == d && s.mark.eq(f[m]) ? s.to = p : i.push(s = new Dr(d, p, f[m])));
      a && a.to == d ? a.to = p : o.push(a = new Oi(d, p, r));
    }
  }), i.forEach((l) => e.step(l)), o.forEach((l) => e.step(l));
}
function VC(e, t, n, r) {
  let i = [], o = 0;
  e.doc.nodesBetween(t, n, (s, a) => {
    if (!s.isInline)
      return;
    o++;
    let l = null;
    if (r instanceof td) {
      let u = s.marks, c;
      for (; c = r.isInSet(u); )
        (l || (l = [])).push(c), u = c.removeFromSet(u);
    } else r ? r.isInSet(s.marks) && (l = [r]) : l = s.marks;
    if (l && l.length) {
      let u = Math.min(a + s.nodeSize, n);
      for (let c = 0; c < l.length; c++) {
        let f = l[c], d;
        for (let p = 0; p < i.length; p++) {
          let h = i[p];
          h.step == o - 1 && f.eq(i[p].style) && (d = h);
        }
        d ? (d.to = u, d.step = o) : i.push({ style: f, from: Math.max(a, t), to: u, step: o });
      }
    }
  }), i.forEach((s) => e.step(new Dr(s.from, s.to, s.style)));
}
function q0(e, t, n, r = n.contentMatch, i = !0) {
  let o = e.doc.nodeAt(t), s = [], a = t + 1;
  for (let l = 0; l < o.childCount; l++) {
    let u = o.child(l), c = a + u.nodeSize, f = r.matchType(u.type);
    if (!f)
      s.push(new jt(a, c, ye.empty));
    else {
      r = f;
      for (let d = 0; d < u.marks.length; d++)
        n.allowsMarkType(u.marks[d].type) || e.step(new Dr(a, c, u.marks[d]));
      if (i && u.isText && n.whitespace != "pre") {
        let d, p = /\r?\n|\r/g, h;
        for (; d = p.exec(u.text); )
          h || (h = new ye(te.from(n.schema.text(" ", n.allowedMarks(u.marks))), 0, 0)), s.push(new jt(a + d.index, a + d.index + d[0].length, h));
      }
    }
    a = c;
  }
  if (!r.validEnd) {
    let l = r.fillBefore(te.empty, !0);
    e.replace(a, a, new ye(l, 0, 0));
  }
  for (let l = s.length - 1; l >= 0; l--)
    e.step(s[l]);
}
function HC(e, t, n) {
  return (t == 0 || e.canReplace(t, e.childCount)) && (n == e.childCount || e.canReplace(0, n));
}
function ta(e) {
  let n = e.parent.content.cutByIndex(e.startIndex, e.endIndex);
  for (let r = e.depth; ; --r) {
    let i = e.$from.node(r), o = e.$from.index(r), s = e.$to.indexAfter(r);
    if (r < e.depth && i.canReplace(o, s, n))
      return r;
    if (r == 0 || i.type.spec.isolating || !HC(i, o, s))
      break;
  }
  return null;
}
function qC(e, t, n) {
  let { $from: r, $to: i, depth: o } = t, s = r.before(o + 1), a = i.after(o + 1), l = s, u = a, c = te.empty, f = 0;
  for (let h = o, m = !1; h > n; h--)
    m || r.index(h) > 0 ? (m = !0, c = te.from(r.node(h).copy(c)), f++) : l--;
  let d = te.empty, p = 0;
  for (let h = o, m = !1; h > n; h--)
    m || i.after(h + 1) < i.end(h) ? (m = !0, d = te.from(i.node(h).copy(d)), p++) : u++;
  e.step(new Vt(l, u, s, a, new ye(c.append(d), f, p), c.size - f, !0));
}
function G0(e, t, n = null, r = e) {
  let i = GC(e, t), o = i && WC(r, t);
  return o ? i.map(lm).concat({ type: t, attrs: n }).concat(o.map(lm)) : null;
}
function lm(e) {
  return { type: e, attrs: null };
}
function GC(e, t) {
  let { parent: n, startIndex: r, endIndex: i } = e, o = n.contentMatchAt(r).findWrapping(t);
  if (!o)
    return null;
  let s = o.length ? o[0] : t;
  return n.canReplaceWith(r, i, s) ? o : null;
}
function WC(e, t) {
  let { parent: n, startIndex: r, endIndex: i } = e, o = n.child(r), s = t.contentMatch.findWrapping(o.type);
  if (!s)
    return null;
  let l = (s.length ? s[s.length - 1] : t).contentMatch;
  for (let u = r; l && u < i; u++)
    l = l.matchType(n.child(u).type);
  return !l || !l.validEnd ? null : s;
}
function KC(e, t, n) {
  let r = te.empty;
  for (let s = n.length - 1; s >= 0; s--) {
    if (r.size) {
      let a = n[s].type.contentMatch.matchFragment(r);
      if (!a || !a.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    r = te.from(n[s].type.create(n[s].attrs, r));
  }
  let i = t.start, o = t.end;
  e.step(new Vt(i, o, i, o, new ye(r, 0, 0), n.length, !0));
}
function YC(e, t, n, r, i) {
  if (!r.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let o = e.steps.length;
  e.doc.nodesBetween(t, n, (s, a) => {
    let l = typeof i == "function" ? i(s) : i;
    if (s.isTextblock && !s.hasMarkup(r, l) && QC(e.doc, e.mapping.slice(o).map(a), r)) {
      let u = null;
      if (r.schema.linebreakReplacement) {
        let p = r.whitespace == "pre", h = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
        p && !h ? u = !1 : !p && h && (u = !0);
      }
      u === !1 && bE(e, s, a, o), q0(e, e.mapping.slice(o).map(a, 1), r, void 0, u === null);
      let c = e.mapping.slice(o), f = c.map(a, 1), d = c.map(a + s.nodeSize, 1);
      return e.step(new Vt(f, d, f + 1, d - 1, new ye(te.from(r.create(l, null, s.marks)), 0, 0), 1, !0)), u === !0 && mE(e, s, a, o), !1;
    }
  });
}
function mE(e, t, n, r) {
  t.forEach((i, o) => {
    if (i.isText) {
      let s, a = /\r?\n|\r/g;
      for (; s = a.exec(i.text); ) {
        let l = e.mapping.slice(r).map(n + 1 + o + s.index);
        e.replaceWith(l, l + 1, t.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function bE(e, t, n, r) {
  t.forEach((i, o) => {
    if (i.type == i.type.schema.linebreakReplacement) {
      let s = e.mapping.slice(r).map(n + 1 + o);
      e.replaceWith(s, s + 1, t.type.schema.text(`
`));
    }
  });
}
function QC(e, t, n) {
  let r = e.resolve(t), i = r.index();
  return r.parent.canReplaceWith(i, i + 1, n);
}
function ZC(e, t, n, r, i) {
  let o = e.doc.nodeAt(t);
  if (!o)
    throw new RangeError("No node at given position");
  n || (n = o.type);
  let s = n.create(r, null, i || o.marks);
  if (o.isLeaf)
    return e.replaceWith(t, t + o.nodeSize, s);
  if (!n.validContent(o.content))
    throw new RangeError("Invalid content for node type " + n.name);
  e.step(new Vt(t, t + o.nodeSize, t + 1, t + o.nodeSize - 1, new ye(te.from(s), 0, 0), 1, !0));
}
function fs(e, t, n = 1, r) {
  let i = e.resolve(t), o = i.depth - n, s = r && r[r.length - 1] || i.parent;
  if (o < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !s.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount)))
    return !1;
  for (let u = i.depth - 1, c = n - 2; u > o; u--, c--) {
    let f = i.node(u), d = i.index(u);
    if (f.type.spec.isolating)
      return !1;
    let p = f.content.cutByIndex(d, f.childCount), h = r && r[c + 1];
    h && (p = p.replaceChild(0, h.type.create(h.attrs)));
    let m = r && r[c] || f;
    if (!f.canReplace(d + 1, f.childCount) || !m.type.validContent(p))
      return !1;
  }
  let a = i.indexAfter(o), l = r && r[0];
  return i.node(o).canReplaceWith(a, a, l ? l.type : i.node(o + 1).type);
}
function XC(e, t, n = 1, r) {
  let i = e.doc.resolve(t), o = te.empty, s = te.empty;
  for (let a = i.depth, l = i.depth - n, u = n - 1; a > l; a--, u--) {
    o = te.from(i.node(a).copy(o));
    let c = r && r[u];
    s = te.from(c ? c.type.create(c.attrs, s) : i.node(a).copy(s));
  }
  e.step(new jt(t, t, new ye(o.append(s), n, n), !0));
}
function Qi(e, t) {
  let n = e.resolve(t), r = n.index();
  return yE(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1);
}
function JC(e, t) {
  t.content.size || e.type.compatibleContent(t.type);
  let n = e.contentMatchAt(e.childCount), { linebreakReplacement: r } = e.type.schema;
  for (let i = 0; i < t.childCount; i++) {
    let o = t.child(i), s = o.type == r ? e.type.schema.nodes.text : o.type;
    if (n = n.matchType(s), !n || !e.type.allowsMarks(o.marks))
      return !1;
  }
  return n.validEnd;
}
function yE(e, t) {
  return !!(e && t && !e.isLeaf && JC(e, t));
}
function nd(e, t, n = -1) {
  let r = e.resolve(t);
  for (let i = r.depth; ; i--) {
    let o, s, a = r.index(i);
    if (i == r.depth ? (o = r.nodeBefore, s = r.nodeAfter) : n > 0 ? (o = r.node(i + 1), a++, s = r.node(i).maybeChild(a)) : (o = r.node(i).maybeChild(a - 1), s = r.node(i + 1)), o && !o.isTextblock && yE(o, s) && r.node(i).canReplace(a, a + 1))
      return t;
    if (i == 0)
      break;
    t = n < 0 ? r.before(i) : r.after(i);
  }
}
function eN(e, t, n) {
  let r = null, { linebreakReplacement: i } = e.doc.type.schema, o = e.doc.resolve(t - n), s = o.node().type;
  if (i && s.inlineContent) {
    let c = s.whitespace == "pre", f = !!s.contentMatch.matchType(i);
    c && !f ? r = !1 : !c && f && (r = !0);
  }
  let a = e.steps.length;
  if (r === !1) {
    let c = e.doc.resolve(t + n);
    bE(e, c.node(), c.before(), a);
  }
  s.inlineContent && q0(e, t + n - 1, s, o.node().contentMatchAt(o.index()), r == null);
  let l = e.mapping.slice(a), u = l.map(t - n);
  if (e.step(new jt(u, l.map(t + n, -1), ye.empty, !0)), r === !0) {
    let c = e.doc.resolve(u);
    mE(e, c.node(), c.before(), e.steps.length);
  }
  return e;
}
function tN(e, t, n) {
  let r = e.resolve(t);
  if (r.parent.canReplaceWith(r.index(), r.index(), n))
    return t;
  if (r.parentOffset == 0)
    for (let i = r.depth - 1; i >= 0; i--) {
      let o = r.index(i);
      if (r.node(i).canReplaceWith(o, o, n))
        return r.before(i + 1);
      if (o > 0)
        return null;
    }
  if (r.parentOffset == r.parent.content.size)
    for (let i = r.depth - 1; i >= 0; i--) {
      let o = r.indexAfter(i);
      if (r.node(i).canReplaceWith(o, o, n))
        return r.after(i + 1);
      if (o < r.node(i).childCount)
        return null;
    }
  return null;
}
function vE(e, t, n) {
  let r = e.resolve(t);
  if (!n.content.size)
    return t;
  let i = n.content;
  for (let o = 0; o < n.openStart; o++)
    i = i.firstChild.content;
  for (let o = 1; o <= (n.openStart == 0 && n.size ? 2 : 1); o++)
    for (let s = r.depth; s >= 0; s--) {
      let a = s == r.depth ? 0 : r.pos <= (r.start(s + 1) + r.end(s + 1)) / 2 ? -1 : 1, l = r.index(s) + (a > 0 ? 1 : 0), u = r.node(s), c = !1;
      if (o == 1)
        c = u.canReplace(l, l, i);
      else {
        let f = u.contentMatchAt(l).findWrapping(i.firstChild.type);
        c = f && u.canReplaceWith(l, l, f[0]);
      }
      if (c)
        return a == 0 ? r.pos : a < 0 ? r.before(s + 1) : r.after(s + 1);
    }
  return null;
}
function rd(e, t, n = t, r = ye.empty) {
  if (t == n && !r.size)
    return null;
  let i = e.resolve(t), o = e.resolve(n);
  return _E(i, o, r) ? new jt(t, n, r) : new nN(i, o, r).fit();
}
function _E(e, t, n) {
  return !n.openStart && !n.openEnd && e.start() == t.start() && e.parent.canReplace(e.index(), t.index(), n.content);
}
class nN {
  constructor(t, n, r) {
    this.$from = t, this.$to = n, this.unplaced = r, this.frontier = [], this.placed = te.empty;
    for (let i = 0; i <= t.depth; i++) {
      let o = t.node(i);
      this.frontier.push({
        type: o.type,
        match: o.contentMatchAt(t.indexAfter(i))
      });
    }
    for (let i = t.depth; i > 0; i--)
      this.placed = te.from(t.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let u = this.findFittable();
      u ? this.placeNodes(u) : this.openMore() || this.dropNode();
    }
    let t = this.mustMoveInline(), n = this.placed.size - this.depth - this.$from.depth, r = this.$from, i = this.close(t < 0 ? this.$to : r.doc.resolve(t));
    if (!i)
      return null;
    let o = this.placed, s = r.depth, a = i.depth;
    for (; s && a && o.childCount == 1; )
      o = o.firstChild.content, s--, a--;
    let l = new ye(o, s, a);
    return t > -1 ? new Vt(r.pos, t, this.$to.pos, this.$to.end(), l, n) : l.size || r.pos != this.$to.pos ? new jt(r.pos, i.pos, l) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let t = this.unplaced.openStart;
    for (let n = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < t; r++) {
      let o = n.firstChild;
      if (n.childCount > 1 && (i = 0), o.type.spec.isolating && i <= r) {
        t = r;
        break;
      }
      n = o.content;
    }
    for (let n = 1; n <= 2; n++)
      for (let r = n == 1 ? t : this.unplaced.openStart; r >= 0; r--) {
        let i, o = null;
        r ? (o = tp(this.unplaced.content, r - 1).firstChild, i = o.content) : i = this.unplaced.content;
        let s = i.firstChild;
        for (let a = this.depth; a >= 0; a--) {
          let { type: l, match: u } = this.frontier[a], c, f = null;
          if (n == 1 && (s ? u.matchType(s.type) || (f = u.fillBefore(te.from(s), !1)) : o && l.compatibleContent(o.type)))
            return { sliceDepth: r, frontierDepth: a, parent: o, inject: f };
          if (n == 2 && s && (c = u.findWrapping(s.type)))
            return { sliceDepth: r, frontierDepth: a, parent: o, wrap: c };
          if (o && u.matchType(o.type))
            break;
        }
      }
  }
  openMore() {
    let { content: t, openStart: n, openEnd: r } = this.unplaced, i = tp(t, n);
    return !i.childCount || i.firstChild.isLeaf ? !1 : (this.unplaced = new ye(t, n + 1, Math.max(r, i.size + n >= t.size - r ? n + 1 : 0)), !0);
  }
  dropNode() {
    let { content: t, openStart: n, openEnd: r } = this.unplaced, i = tp(t, n);
    if (i.childCount <= 1 && n > 0) {
      let o = t.size - n <= n + i.size;
      this.unplaced = new ye(va(t, n - 1, 1), n - 1, o ? n - 1 : r);
    } else
      this.unplaced = new ye(va(t, n, 1), n, r);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: t, frontierDepth: n, parent: r, inject: i, wrap: o }) {
    for (; this.depth > n; )
      this.closeFrontierNode();
    if (o)
      for (let m = 0; m < o.length; m++)
        this.openFrontierNode(o[m]);
    let s = this.unplaced, a = r ? r.content : s.content, l = s.openStart - t, u = 0, c = [], { match: f, type: d } = this.frontier[n];
    if (i) {
      for (let m = 0; m < i.childCount; m++)
        c.push(i.child(m));
      f = f.matchFragment(i);
    }
    let p = a.size + t - (s.content.size - s.openEnd);
    for (; u < a.childCount; ) {
      let m = a.child(u), g = f.matchType(m.type);
      if (!g)
        break;
      u++, (u > 1 || l == 0 || m.content.size) && (f = g, c.push(EE(m.mark(d.allowedMarks(m.marks)), u == 1 ? l : 0, u == a.childCount ? p : -1)));
    }
    let h = u == a.childCount;
    h || (p = -1), this.placed = _a(this.placed, n, te.from(c)), this.frontier[n].match = f, h && p < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let m = 0, g = a; m < p; m++) {
      let y = g.lastChild;
      this.frontier.push({ type: y.type, match: y.contentMatchAt(y.childCount) }), g = y.content;
    }
    this.unplaced = h ? t == 0 ? ye.empty : new ye(va(s.content, t - 1, 1), t - 1, p < 0 ? s.openEnd : t - 1) : new ye(va(s.content, t, u), s.openStart, s.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let t = this.frontier[this.depth], n;
    if (!t.type.isTextblock || !np(this.$to, this.$to.depth, t.type, t.match, !1) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
      return -1;
    let { depth: r } = this.$to, i = this.$to.after(r);
    for (; r > 1 && i == this.$to.end(--r); )
      ++i;
    return i;
  }
  findCloseLevel(t) {
    e: for (let n = Math.min(this.depth, t.depth); n >= 0; n--) {
      let { match: r, type: i } = this.frontier[n], o = n < t.depth && t.end(n + 1) == t.pos + (t.depth - (n + 1)), s = np(t, n, i, r, o);
      if (s) {
        for (let a = n - 1; a >= 0; a--) {
          let { match: l, type: u } = this.frontier[a], c = np(t, a, u, l, !0);
          if (!c || c.childCount)
            continue e;
        }
        return { depth: n, fit: s, move: o ? t.doc.resolve(t.after(n + 1)) : t };
      }
    }
  }
  close(t) {
    let n = this.findCloseLevel(t);
    if (!n)
      return null;
    for (; this.depth > n.depth; )
      this.closeFrontierNode();
    n.fit.childCount && (this.placed = _a(this.placed, n.depth, n.fit)), t = n.move;
    for (let r = n.depth + 1; r <= t.depth; r++) {
      let i = t.node(r), o = i.type.contentMatch.fillBefore(i.content, !0, t.index(r));
      this.openFrontierNode(i.type, i.attrs, o);
    }
    return t;
  }
  openFrontierNode(t, n = null, r) {
    let i = this.frontier[this.depth];
    i.match = i.match.matchType(t), this.placed = _a(this.placed, this.depth, te.from(t.create(n, r))), this.frontier.push({ type: t, match: t.contentMatch });
  }
  closeFrontierNode() {
    let n = this.frontier.pop().match.fillBefore(te.empty, !0);
    n.childCount && (this.placed = _a(this.placed, this.frontier.length, n));
  }
}
function va(e, t, n) {
  return t == 0 ? e.cutByIndex(n, e.childCount) : e.replaceChild(0, e.firstChild.copy(va(e.firstChild.content, t - 1, n)));
}
function _a(e, t, n) {
  return t == 0 ? e.append(n) : e.replaceChild(e.childCount - 1, e.lastChild.copy(_a(e.lastChild.content, t - 1, n)));
}
function tp(e, t) {
  for (let n = 0; n < t; n++)
    e = e.firstChild.content;
  return e;
}
function EE(e, t, n) {
  if (t <= 0)
    return e;
  let r = e.content;
  return t > 1 && (r = r.replaceChild(0, EE(r.firstChild, t - 1, r.childCount == 1 ? n - 1 : 0))), t > 0 && (r = e.type.contentMatch.fillBefore(r).append(r), n <= 0 && (r = r.append(e.type.contentMatch.matchFragment(r).fillBefore(te.empty, !0)))), e.copy(r);
}
function np(e, t, n, r, i) {
  let o = e.node(t), s = i ? e.indexAfter(t) : e.index(t);
  if (s == o.childCount && !n.compatibleContent(o.type))
    return null;
  let a = r.fillBefore(o.content, !0, s);
  return a && !rN(n, o.content, s) ? a : null;
}
function rN(e, t, n) {
  for (let r = n; r < t.childCount; r++)
    if (!e.allowsMarks(t.child(r).marks))
      return !0;
  return !1;
}
function iN(e) {
  return e.spec.defining || e.spec.definingForContent;
}
function oN(e, t, n, r) {
  if (!r.size)
    return e.deleteRange(t, n);
  let i = e.doc.resolve(t), o = e.doc.resolve(n);
  if (_E(i, o, r))
    return e.step(new jt(t, n, r));
  let s = xE(i, e.doc.resolve(n));
  s[s.length - 1] == 0 && s.pop();
  let a = -(i.depth + 1);
  s.unshift(a);
  for (let d = i.depth, p = i.pos - 1; d > 0; d--, p--) {
    let h = i.node(d).type.spec;
    if (h.defining || h.definingAsContext || h.isolating)
      break;
    s.indexOf(d) > -1 ? a = d : i.before(d) == p && s.splice(1, 0, -d);
  }
  let l = s.indexOf(a), u = [], c = r.openStart;
  for (let d = r.content, p = 0; ; p++) {
    let h = d.firstChild;
    if (u.push(h), p == r.openStart)
      break;
    d = h.content;
  }
  for (let d = c - 1; d >= 0; d--) {
    let p = u[d], h = iN(p.type);
    if (h && !p.sameMarkup(i.node(Math.abs(a) - 1)))
      c = d;
    else if (h || !p.type.isTextblock)
      break;
  }
  for (let d = r.openStart; d >= 0; d--) {
    let p = (d + c + 1) % (r.openStart + 1), h = u[p];
    if (h)
      for (let m = 0; m < s.length; m++) {
        let g = s[(m + l) % s.length], y = !0;
        g < 0 && (y = !1, g = -g);
        let _ = i.node(g - 1), E = i.index(g - 1);
        if (_.canReplaceWith(E, E, h.type, h.marks))
          return e.replace(i.before(g), y ? o.after(g) : n, new ye(wE(r.content, 0, r.openStart, p), p, r.openEnd));
      }
  }
  let f = e.steps.length;
  for (let d = s.length - 1; d >= 0 && (e.replace(t, n, r), !(e.steps.length > f)); d--) {
    let p = s[d];
    p < 0 || (t = i.before(p), n = o.after(p));
  }
}
function wE(e, t, n, r, i) {
  if (t < n) {
    let o = e.firstChild;
    e = e.replaceChild(0, o.copy(wE(o.content, t + 1, n, r, o)));
  }
  if (t > r) {
    let o = i.contentMatchAt(0), s = o.fillBefore(e).append(e);
    e = s.append(o.matchFragment(s).fillBefore(te.empty, !0));
  }
  return e;
}
function sN(e, t, n, r) {
  if (!r.isInline && t == n && e.doc.resolve(t).parent.content.size) {
    let i = tN(e.doc, t, r.type);
    i != null && (t = n = i);
  }
  e.replaceRange(t, n, new ye(te.from(r), 0, 0));
}
function aN(e, t, n) {
  let r = e.doc.resolve(t), i = e.doc.resolve(n), o = xE(r, i);
  for (let s = 0; s < o.length; s++) {
    let a = o[s], l = s == o.length - 1;
    if (l && a == 0 || r.node(a).type.contentMatch.validEnd)
      return e.delete(r.start(a), i.end(a));
    if (a > 0 && (l || r.node(a - 1).canReplace(r.index(a - 1), i.indexAfter(a - 1))))
      return e.delete(r.before(a), i.after(a));
  }
  for (let s = 1; s <= r.depth && s <= i.depth; s++)
    if (t - r.start(s) == r.depth - s && n > r.end(s) && i.end(s) - n != i.depth - s && r.start(s - 1) == i.start(s - 1) && r.node(s - 1).canReplace(r.index(s - 1), i.index(s - 1)))
      return e.delete(r.before(s), n);
  e.delete(t, n);
}
function xE(e, t) {
  let n = [], r = Math.min(e.depth, t.depth);
  for (let i = r; i >= 0; i--) {
    let o = e.start(i);
    if (o < e.pos - (e.depth - i) || t.end(i) > t.pos + (t.depth - i) || e.node(i).type.spec.isolating || t.node(i).type.spec.isolating)
      break;
    (o == t.start(i) || i == e.depth && i == t.depth && e.parent.inlineContent && t.parent.inlineContent && i && t.start(i - 1) == o - 1) && n.push(i);
  }
  return n;
}
class ds extends ln {
  /**
  Construct an attribute step.
  */
  constructor(t, n, r) {
    super(), this.pos = t, this.attr = n, this.value = r;
  }
  apply(t) {
    let n = t.nodeAt(this.pos);
    if (!n)
      return It.fail("No node at attribute step's position");
    let r = /* @__PURE__ */ Object.create(null);
    for (let o in n.attrs)
      r[o] = n.attrs[o];
    r[this.attr] = this.value;
    let i = n.type.create(r, null, n.marks);
    return It.fromReplace(t, this.pos, this.pos + 1, new ye(te.from(i), 0, n.isLeaf ? 0 : 1));
  }
  getMap() {
    return $n.empty;
  }
  invert(t) {
    return new ds(this.pos, this.attr, t.nodeAt(this.pos).attrs[this.attr]);
  }
  map(t) {
    let n = t.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new ds(n.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(t, n) {
    if (typeof n.pos != "number" || typeof n.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new ds(n.pos, n.attr, n.value);
  }
}
ln.jsonID("attr", ds);
class tl extends ln {
  /**
  Construct an attribute step.
  */
  constructor(t, n) {
    super(), this.attr = t, this.value = n;
  }
  apply(t) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let i in t.attrs)
      n[i] = t.attrs[i];
    n[this.attr] = this.value;
    let r = t.type.create(n, t.content, t.marks);
    return It.ok(r);
  }
  getMap() {
    return $n.empty;
  }
  invert(t) {
    return new tl(this.attr, t.attrs[this.attr]);
  }
  map(t) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(t, n) {
    if (typeof n.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new tl(n.attr, n.value);
  }
}
ln.jsonID("docAttr", tl);
let xs = class extends Error {
};
xs = function e(t) {
  let n = Error.call(this, t);
  return n.__proto__ = e.prototype, n;
};
xs.prototype = Object.create(Error.prototype);
xs.prototype.constructor = xs;
xs.prototype.name = "TransformError";
class kE {
  /**
  Create a transform that starts with the given document.
  */
  constructor(t) {
    this.doc = t, this.steps = [], this.docs = [], this.mapping = new cs();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(t) {
    let n = this.maybeStep(t);
    if (n.failed)
      throw new xs(n.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(t) {
    let n = t.apply(this.doc);
    return n.failed || this.addStep(t, n.doc), n;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(t, n) {
    this.docs.push(this.doc), this.steps.push(t), this.mapping.appendMap(t.getMap()), this.doc = n;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(t, n = t, r = ye.empty) {
    let i = rd(this.doc, t, n, r);
    return i && this.step(i), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(t, n, r) {
    return this.replace(t, n, new ye(te.from(r), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(t, n) {
    return this.replace(t, n, ye.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(t, n) {
    return this.replaceWith(t, t, n);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(t, n, r) {
    return oN(this, t, n, r), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(t, n, r) {
    return sN(this, t, n, r), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(t, n) {
    return aN(this, t, n), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(t, n) {
    return qC(this, t, n), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(t, n = 1) {
    return eN(this, t, n), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(t, n) {
    return KC(this, t, n), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(t, n = t, r, i = null) {
    return YC(this, t, n, r, i), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(t, n, r = null, i) {
    return ZC(this, t, n, r, i), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(t, n, r) {
    return this.step(new ds(t, n, r)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(t, n) {
    return this.step(new tl(t, n)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(t, n) {
    return this.step(new Ii(t, n)), this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(t, n) {
    if (!(n instanceof rt)) {
      let r = this.doc.nodeAt(t);
      if (!r)
        throw new RangeError("No node at position " + t);
      if (n = n.isInSet(r.marks), !n)
        return this;
    }
    return this.step(new ws(t, n)), this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split.
  */
  split(t, n = 1, r) {
    return XC(this, t, n, r), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(t, n, r) {
    return UC(this, t, n, r), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(t, n, r) {
    return VC(this, t, n, r), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(t, n, r) {
    return q0(this, t, n, r), this;
  }
}
const rp = /* @__PURE__ */ Object.create(null);
let Be = class {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(t, n, r) {
    this.$anchor = t, this.$head = n, this.ranges = r || [new lN(t.min(n), t.max(n))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let t = this.ranges;
    for (let n = 0; n < t.length; n++)
      if (t[n].$from.pos != t[n].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(t, n = ye.empty) {
    let r = n.content.lastChild, i = null;
    for (let a = 0; a < n.openEnd; a++)
      i = r, r = r.lastChild;
    let o = t.steps.length, s = this.ranges;
    for (let a = 0; a < s.length; a++) {
      let { $from: l, $to: u } = s[a], c = t.mapping.slice(o);
      t.replaceRange(c.map(l.pos), c.map(u.pos), a ? ye.empty : n), a == 0 && fm(t, o, (r ? r.isInline : i && i.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(t, n) {
    let r = t.steps.length, i = this.ranges;
    for (let o = 0; o < i.length; o++) {
      let { $from: s, $to: a } = i[o], l = t.mapping.slice(r), u = l.map(s.pos), c = l.map(a.pos);
      o ? t.deleteRange(u, c) : (t.replaceRangeWith(u, c, n), fm(t, r, n.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(t, n, r = !1) {
    let i = t.parent.inlineContent ? new Oe(t) : Zo(t.node(0), t.parent, t.pos, t.index(), n, r);
    if (i)
      return i;
    for (let o = t.depth - 1; o >= 0; o--) {
      let s = n < 0 ? Zo(t.node(0), t.node(o), t.before(o + 1), t.index(o), n, r) : Zo(t.node(0), t.node(o), t.after(o + 1), t.index(o) + 1, n, r);
      if (s)
        return s;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(t, n = 1) {
    return this.findFrom(t, n) || this.findFrom(t, -n) || new cr(t.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(t) {
    return Zo(t, t, 0, 0, 1) || new cr(t);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(t) {
    return Zo(t, t, t.content.size, t.childCount, -1) || new cr(t);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(t, n) {
    if (!n || !n.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let r = rp[n.type];
    if (!r)
      throw new RangeError(`No selection type ${n.type} defined`);
    return r.fromJSON(t, n);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(t, n) {
    if (t in rp)
      throw new RangeError("Duplicate use of selection JSON ID " + t);
    return rp[t] = n, n.prototype.jsonID = t, n;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return Oe.between(this.$anchor, this.$head).getBookmark();
  }
};
Be.prototype.visible = !0;
class lN {
  /**
  Create a range.
  */
  constructor(t, n) {
    this.$from = t, this.$to = n;
  }
}
let um = !1;
function cm(e) {
  !um && !e.parent.inlineContent && (um = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + e.parent.type.name + ")"));
}
class Oe extends Be {
  /**
  Construct a text selection between the given points.
  */
  constructor(t, n = t) {
    cm(t), cm(n), super(t, n);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(t, n) {
    let r = t.resolve(n.map(this.head));
    if (!r.parent.inlineContent)
      return Be.near(r);
    let i = t.resolve(n.map(this.anchor));
    return new Oe(i.parent.inlineContent ? i : r, r);
  }
  replace(t, n = ye.empty) {
    if (super.replace(t, n), n == ye.empty) {
      let r = this.$from.marksAcross(this.$to);
      r && t.ensureMarks(r);
    }
  }
  eq(t) {
    return t instanceof Oe && t.anchor == this.anchor && t.head == this.head;
  }
  getBookmark() {
    return new id(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.anchor != "number" || typeof n.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new Oe(t.resolve(n.anchor), t.resolve(n.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(t, n, r = n) {
    let i = t.resolve(n);
    return new this(i, r == n ? i : t.resolve(r));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(t, n, r) {
    let i = t.pos - n.pos;
    if ((!r || i) && (r = i >= 0 ? 1 : -1), !n.parent.inlineContent) {
      let o = Be.findFrom(n, r, !0) || Be.findFrom(n, -r, !0);
      if (o)
        n = o.$head;
      else
        return Be.near(n, r);
    }
    return t.parent.inlineContent || (i == 0 ? t = n : (t = (Be.findFrom(t, -r, !0) || Be.findFrom(t, r, !0)).$anchor, t.pos < n.pos != i < 0 && (t = n))), new Oe(t, n);
  }
}
Be.jsonID("text", Oe);
class id {
  constructor(t, n) {
    this.anchor = t, this.head = n;
  }
  map(t) {
    return new id(t.map(this.anchor), t.map(this.head));
  }
  resolve(t) {
    return Oe.between(t.resolve(this.anchor), t.resolve(this.head));
  }
}
class Ce extends Be {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(t) {
    let n = t.nodeAfter, r = t.node(0).resolve(t.pos + n.nodeSize);
    super(t, r), this.node = n;
  }
  map(t, n) {
    let { deleted: r, pos: i } = n.mapResult(this.anchor), o = t.resolve(i);
    return r ? Be.near(o) : new Ce(o);
  }
  content() {
    return new ye(te.from(this.node), 0, 0);
  }
  eq(t) {
    return t instanceof Ce && t.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new W0(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new Ce(t.resolve(n.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(t, n) {
    return new Ce(t.resolve(n));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(t) {
    return !t.isText && t.type.spec.selectable !== !1;
  }
}
Ce.prototype.visible = !1;
Be.jsonID("node", Ce);
class W0 {
  constructor(t) {
    this.anchor = t;
  }
  map(t) {
    let { deleted: n, pos: r } = t.mapResult(this.anchor);
    return n ? new id(r, r) : new W0(r);
  }
  resolve(t) {
    let n = t.resolve(this.anchor), r = n.nodeAfter;
    return r && Ce.isSelectable(r) ? new Ce(n) : Be.near(n);
  }
}
class cr extends Be {
  /**
  Create an all-selection over the given document.
  */
  constructor(t) {
    super(t.resolve(0), t.resolve(t.content.size));
  }
  replace(t, n = ye.empty) {
    if (n == ye.empty) {
      t.delete(0, t.doc.content.size);
      let r = Be.atStart(t.doc);
      r.eq(t.selection) || t.setSelection(r);
    } else
      super.replace(t, n);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(t) {
    return new cr(t);
  }
  map(t) {
    return new cr(t);
  }
  eq(t) {
    return t instanceof cr;
  }
  getBookmark() {
    return uN;
  }
}
Be.jsonID("all", cr);
const uN = {
  map() {
    return this;
  },
  resolve(e) {
    return new cr(e);
  }
};
function Zo(e, t, n, r, i, o = !1) {
  if (t.inlineContent)
    return Oe.create(e, n);
  for (let s = r - (i > 0 ? 0 : 1); i > 0 ? s < t.childCount : s >= 0; s += i) {
    let a = t.child(s);
    if (a.isAtom) {
      if (!o && Ce.isSelectable(a))
        return Ce.create(e, n - (i < 0 ? a.nodeSize : 0));
    } else {
      let l = Zo(e, a, n + i, i < 0 ? a.childCount : 0, i, o);
      if (l)
        return l;
    }
    n += a.nodeSize * i;
  }
  return null;
}
function fm(e, t, n) {
  let r = e.steps.length - 1;
  if (r < t)
    return;
  let i = e.steps[r];
  if (!(i instanceof jt || i instanceof Vt))
    return;
  let o = e.mapping.maps[r], s;
  o.forEach((a, l, u, c) => {
    s == null && (s = c);
  }), e.setSelection(Be.near(e.doc.resolve(s), n));
}
const dm = 1, hu = 2, pm = 4;
class cN extends kE {
  /**
  @internal
  */
  constructor(t) {
    super(t.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = t.selection, this.storedMarks = t.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(t) {
    if (t.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = t, this.curSelectionFor = this.steps.length, this.updated = (this.updated | dm) & ~hu, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & dm) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(t) {
    return this.storedMarks = t, this.updated |= hu, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(t) {
    return rt.sameSet(this.storedMarks || this.selection.$from.marks(), t) || this.setStoredMarks(t), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(t) {
    return this.ensureMarks(t.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(t) {
    return this.ensureMarks(t.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & hu) > 0;
  }
  /**
  @internal
  */
  addStep(t, n) {
    super.addStep(t, n), this.updated = this.updated & ~hu, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(t) {
    return this.time = t, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(t) {
    return this.selection.replace(this, t), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(t, n = !0) {
    let r = this.selection;
    return n && (t = t.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || rt.none))), r.replaceWith(this, t), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(t, n, r) {
    let i = this.doc.type.schema;
    if (n == null)
      return t ? this.replaceSelectionWith(i.text(t), !0) : this.deleteSelection();
    {
      if (r == null && (r = n), r = r ?? n, !t)
        return this.deleteRange(n, r);
      let o = this.storedMarks;
      if (!o) {
        let s = this.doc.resolve(n);
        o = r == n ? s.marks() : s.marksAcross(this.doc.resolve(r));
      }
      return this.replaceRangeWith(n, r, i.text(t, o)), this.selection.empty || this.setSelection(Be.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(t, n) {
    return this.meta[typeof t == "string" ? t : t.key] = n, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(t) {
    return this.meta[typeof t == "string" ? t : t.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let t in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= pm, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & pm) > 0;
  }
}
function hm(e, t) {
  return !t || !e ? e : e.bind(t);
}
class Ea {
  constructor(t, n, r) {
    this.name = t, this.init = hm(n.init, r), this.apply = hm(n.apply, r);
  }
}
const fN = [
  new Ea("doc", {
    init(e) {
      return e.doc || e.schema.topNodeType.createAndFill();
    },
    apply(e) {
      return e.doc;
    }
  }),
  new Ea("selection", {
    init(e, t) {
      return e.selection || Be.atStart(t.doc);
    },
    apply(e) {
      return e.selection;
    }
  }),
  new Ea("storedMarks", {
    init(e) {
      return e.storedMarks || null;
    },
    apply(e, t, n, r) {
      return r.selection.$cursor ? e.storedMarks : null;
    }
  }),
  new Ea("scrollToSelection", {
    init() {
      return 0;
    },
    apply(e, t) {
      return e.scrolledIntoView ? t + 1 : t;
    }
  })
];
class ip {
  constructor(t, n) {
    this.schema = t, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = fN.slice(), n && n.forEach((r) => {
      if (this.pluginsByKey[r.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
      this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new Ea(r.key, r.spec.state, r));
    });
  }
}
class is {
  /**
  @internal
  */
  constructor(t) {
    this.config = t;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(t) {
    return this.applyTransaction(t).state;
  }
  /**
  @internal
  */
  filterTransaction(t, n = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != n) {
        let i = this.config.plugins[r];
        if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, t, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(t) {
    if (!this.filterTransaction(t))
      return { state: this, transactions: [] };
    let n = [t], r = this.applyInner(t), i = null;
    for (; ; ) {
      let o = !1;
      for (let s = 0; s < this.config.plugins.length; s++) {
        let a = this.config.plugins[s];
        if (a.spec.appendTransaction) {
          let l = i ? i[s].n : 0, u = i ? i[s].state : this, c = l < n.length && a.spec.appendTransaction.call(a, l ? n.slice(l) : n, u, r);
          if (c && r.filterTransaction(c, s)) {
            if (c.setMeta("appendedTransaction", t), !i) {
              i = [];
              for (let f = 0; f < this.config.plugins.length; f++)
                i.push(f < s ? { state: r, n: n.length } : { state: this, n: 0 });
            }
            n.push(c), r = r.applyInner(c), o = !0;
          }
          i && (i[s] = { state: r, n: n.length });
        }
      }
      if (!o)
        return { state: r, transactions: n };
    }
  }
  /**
  @internal
  */
  applyInner(t) {
    if (!t.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let n = new is(this.config), r = this.config.fields;
    for (let i = 0; i < r.length; i++) {
      let o = r[i];
      n[o.name] = o.apply(t, this[o.name], this, n);
    }
    return n;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new cN(this);
  }
  /**
  Create a new state.
  */
  static create(t) {
    let n = new ip(t.doc ? t.doc.type.schema : t.schema, t.plugins), r = new is(n);
    for (let i = 0; i < n.fields.length; i++)
      r[n.fields[i].name] = n.fields[i].init(t, r);
    return r;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(t) {
    let n = new ip(this.schema, t.plugins), r = n.fields, i = new is(n);
    for (let o = 0; o < r.length; o++) {
      let s = r[o].name;
      i[s] = this.hasOwnProperty(s) ? this[s] : r[o].init(t, i);
    }
    return i;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(t) {
    let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (n.storedMarks = this.storedMarks.map((r) => r.toJSON())), t && typeof t == "object")
      for (let r in t) {
        if (r == "doc" || r == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let i = t[r], o = i.spec.state;
        o && o.toJSON && (n[r] = o.toJSON.call(i, this[i.key]));
      }
    return n;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(t, n, r) {
    if (!n)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!t.schema)
      throw new RangeError("Required config field 'schema' missing");
    let i = new ip(t.schema, t.plugins), o = new is(i);
    return i.fields.forEach((s) => {
      if (s.name == "doc")
        o.doc = Fi.fromJSON(t.schema, n.doc);
      else if (s.name == "selection")
        o.selection = Be.fromJSON(o.doc, n.selection);
      else if (s.name == "storedMarks")
        n.storedMarks && (o.storedMarks = n.storedMarks.map(t.schema.markFromJSON));
      else {
        if (r)
          for (let a in r) {
            let l = r[a], u = l.spec.state;
            if (l.key == s.name && u && u.fromJSON && Object.prototype.hasOwnProperty.call(n, a)) {
              o[s.name] = u.fromJSON.call(l, t, n[a], o);
              return;
            }
          }
        o[s.name] = s.init(t, o);
      }
    }), o;
  }
}
function ME(e, t, n) {
  for (let r in e) {
    let i = e[r];
    i instanceof Function ? i = i.bind(t) : r == "handleDOMEvents" && (i = ME(i, t, {})), n[r] = i;
  }
  return n;
}
class mt {
  /**
  Create a plugin.
  */
  constructor(t) {
    this.spec = t, this.props = {}, t.props && ME(t.props, this, this.props), this.key = t.key ? t.key.key : AE("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(t) {
    return t[this.key];
  }
}
const op = /* @__PURE__ */ Object.create(null);
function AE(e) {
  return e in op ? e + "$" + ++op[e] : (op[e] = 0, e + "$");
}
class Pt {
  /**
  Create a plugin key.
  */
  constructor(t = "key") {
    this.key = AE(t);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(t) {
    return t.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(t) {
    return t[this.key];
  }
}
const Yt = function(e) {
  for (var t = 0; ; t++)
    if (e = e.previousSibling, !e)
      return t;
}, nl = function(e) {
  let t = e.assignedSlot || e.parentNode;
  return t && t.nodeType == 11 ? t.host : t;
};
let vh = null;
const ri = function(e, t, n) {
  let r = vh || (vh = document.createRange());
  return r.setEnd(e, n ?? e.nodeValue.length), r.setStart(e, t || 0), r;
}, dN = function() {
  vh = null;
}, Do = function(e, t, n, r) {
  return n && (gm(e, t, n, r, -1) || gm(e, t, n, r, 1));
}, pN = /^(img|br|input|textarea|hr)$/i;
function gm(e, t, n, r, i) {
  for (; ; ) {
    if (e == n && t == r)
      return !0;
    if (t == (i < 0 ? 0 : Yn(e))) {
      let o = e.parentNode;
      if (!o || o.nodeType != 1 || jl(e) || pN.test(e.nodeName) || e.contentEditable == "false")
        return !1;
      t = Yt(e) + (i < 0 ? 0 : 1), e = o;
    } else if (e.nodeType == 1) {
      if (e = e.childNodes[t + (i < 0 ? -1 : 0)], e.contentEditable == "false")
        return !1;
      t = i < 0 ? Yn(e) : 0;
    } else
      return !1;
  }
}
function Yn(e) {
  return e.nodeType == 3 ? e.nodeValue.length : e.childNodes.length;
}
function hN(e, t) {
  for (; ; ) {
    if (e.nodeType == 3 && t)
      return e;
    if (e.nodeType == 1 && t > 0) {
      if (e.contentEditable == "false")
        return null;
      e = e.childNodes[t - 1], t = Yn(e);
    } else if (e.parentNode && !jl(e))
      t = Yt(e), e = e.parentNode;
    else
      return null;
  }
}
function gN(e, t) {
  for (; ; ) {
    if (e.nodeType == 3 && t < e.nodeValue.length)
      return e;
    if (e.nodeType == 1 && t < e.childNodes.length) {
      if (e.contentEditable == "false")
        return null;
      e = e.childNodes[t], t = 0;
    } else if (e.parentNode && !jl(e))
      t = Yt(e) + 1, e = e.parentNode;
    else
      return null;
  }
}
function mN(e, t, n) {
  for (let r = t == 0, i = t == Yn(e); r || i; ) {
    if (e == n)
      return !0;
    let o = Yt(e);
    if (e = e.parentNode, !e)
      return !1;
    r = r && o == 0, i = i && o == Yn(e);
  }
}
function jl(e) {
  let t;
  for (let n = e; n && !(t = n.pmViewDesc); n = n.parentNode)
    ;
  return t && t.node && t.node.isBlock && (t.dom == e || t.contentDOM == e);
}
const od = function(e) {
  return e.focusNode && Do(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset);
};
function lo(e, t) {
  let n = document.createEvent("Event");
  return n.initEvent("keydown", !0, !0), n.keyCode = e, n.key = n.code = t, n;
}
function bN(e) {
  let t = e.activeElement;
  for (; t && t.shadowRoot; )
    t = t.shadowRoot.activeElement;
  return t;
}
function yN(e, t, n) {
  if (e.caretPositionFromPoint)
    try {
      let r = e.caretPositionFromPoint(t, n);
      if (r)
        return { node: r.offsetNode, offset: Math.min(Yn(r.offsetNode), r.offset) };
    } catch {
    }
  if (e.caretRangeFromPoint) {
    let r = e.caretRangeFromPoint(t, n);
    if (r)
      return { node: r.startContainer, offset: Math.min(Yn(r.startContainer), r.startOffset) };
  }
}
const Ur = typeof navigator < "u" ? navigator : null, mm = typeof document < "u" ? document : null, Zi = Ur && Ur.userAgent || "", _h = /Edge\/(\d+)/.exec(Zi), TE = /MSIE \d/.exec(Zi), Eh = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Zi), Mn = !!(TE || Eh || _h), ji = TE ? document.documentMode : Eh ? +Eh[1] : _h ? +_h[1] : 0, fr = !Mn && /gecko\/(\d+)/i.test(Zi);
fr && +(/Firefox\/(\d+)/.exec(Zi) || [0, 0])[1];
const wh = !Mn && /Chrome\/(\d+)/.exec(Zi), an = !!wh, SE = wh ? +wh[1] : 0, hn = !Mn && !!Ur && /Apple Computer/.test(Ur.vendor), ks = hn && (/Mobile\/\w+/.test(Zi) || !!Ur && Ur.maxTouchPoints > 2), Kn = ks || (Ur ? /Mac/.test(Ur.platform) : !1), vN = Ur ? /Win/.test(Ur.platform) : !1, or = /Android \d/.test(Zi), Ul = !!mm && "webkitFontSmoothing" in mm.documentElement.style, _N = Ul ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function EN(e) {
  let t = e.defaultView && e.defaultView.visualViewport;
  return t ? {
    left: 0,
    right: t.width,
    top: 0,
    bottom: t.height
  } : {
    left: 0,
    right: e.documentElement.clientWidth,
    top: 0,
    bottom: e.documentElement.clientHeight
  };
}
function Jr(e, t) {
  return typeof e == "number" ? e : e[t];
}
function wN(e) {
  let t = e.getBoundingClientRect(), n = t.width / e.offsetWidth || 1, r = t.height / e.offsetHeight || 1;
  return {
    left: t.left,
    right: t.left + e.clientWidth * n,
    top: t.top,
    bottom: t.top + e.clientHeight * r
  };
}
function bm(e, t, n) {
  let r = e.someProp("scrollThreshold") || 0, i = e.someProp("scrollMargin") || 5, o = e.dom.ownerDocument;
  for (let s = n || e.dom; s; s = nl(s)) {
    if (s.nodeType != 1)
      continue;
    let a = s, l = a == o.body, u = l ? EN(o) : wN(a), c = 0, f = 0;
    if (t.top < u.top + Jr(r, "top") ? f = -(u.top - t.top + Jr(i, "top")) : t.bottom > u.bottom - Jr(r, "bottom") && (f = t.bottom - t.top > u.bottom - u.top ? t.top + Jr(i, "top") - u.top : t.bottom - u.bottom + Jr(i, "bottom")), t.left < u.left + Jr(r, "left") ? c = -(u.left - t.left + Jr(i, "left")) : t.right > u.right - Jr(r, "right") && (c = t.right - u.right + Jr(i, "right")), c || f)
      if (l)
        o.defaultView.scrollBy(c, f);
      else {
        let d = a.scrollLeft, p = a.scrollTop;
        f && (a.scrollTop += f), c && (a.scrollLeft += c);
        let h = a.scrollLeft - d, m = a.scrollTop - p;
        t = { left: t.left - h, top: t.top - m, right: t.right - h, bottom: t.bottom - m };
      }
    if (l || /^(fixed|sticky)$/.test(getComputedStyle(s).position))
      break;
  }
}
function xN(e) {
  let t = e.dom.getBoundingClientRect(), n = Math.max(0, t.top), r, i;
  for (let o = (t.left + t.right) / 2, s = n + 1; s < Math.min(innerHeight, t.bottom); s += 5) {
    let a = e.root.elementFromPoint(o, s);
    if (!a || a == e.dom || !e.dom.contains(a))
      continue;
    let l = a.getBoundingClientRect();
    if (l.top >= n - 20) {
      r = a, i = l.top;
      break;
    }
  }
  return { refDOM: r, refTop: i, stack: CE(e.dom) };
}
function CE(e) {
  let t = [], n = e.ownerDocument;
  for (let r = e; r && (t.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), e != n); r = nl(r))
    ;
  return t;
}
function kN({ refDOM: e, refTop: t, stack: n }) {
  let r = e ? e.getBoundingClientRect().top : 0;
  NE(n, r == 0 ? 0 : r - t);
}
function NE(e, t) {
  for (let n = 0; n < e.length; n++) {
    let { dom: r, top: i, left: o } = e[n];
    r.scrollTop != i + t && (r.scrollTop = i + t), r.scrollLeft != o && (r.scrollLeft = o);
  }
}
let Vo = null;
function MN(e) {
  if (e.setActive)
    return e.setActive();
  if (Vo)
    return e.focus(Vo);
  let t = CE(e);
  e.focus(Vo == null ? {
    get preventScroll() {
      return Vo = { preventScroll: !0 }, !0;
    }
  } : void 0), Vo || (Vo = !1, NE(t, 0));
}
function DE(e, t) {
  let n, r = 2e8, i, o = 0, s = t.top, a = t.top, l, u;
  for (let c = e.firstChild, f = 0; c; c = c.nextSibling, f++) {
    let d;
    if (c.nodeType == 1)
      d = c.getClientRects();
    else if (c.nodeType == 3)
      d = ri(c).getClientRects();
    else
      continue;
    for (let p = 0; p < d.length; p++) {
      let h = d[p];
      if (h.top <= s && h.bottom >= a) {
        s = Math.max(h.bottom, s), a = Math.min(h.top, a);
        let m = h.left > t.left ? h.left - t.left : h.right < t.left ? t.left - h.right : 0;
        if (m < r) {
          n = c, r = m, i = m && n.nodeType == 3 ? {
            left: h.right < t.left ? h.right : h.left,
            top: t.top
          } : t, c.nodeType == 1 && m && (o = f + (t.left >= (h.left + h.right) / 2 ? 1 : 0));
          continue;
        }
      } else h.top > t.top && !l && h.left <= t.left && h.right >= t.left && (l = c, u = { left: Math.max(h.left, Math.min(h.right, t.left)), top: h.top });
      !n && (t.left >= h.right && t.top >= h.top || t.left >= h.left && t.top >= h.bottom) && (o = f + 1);
    }
  }
  return !n && l && (n = l, i = u, r = 0), n && n.nodeType == 3 ? AN(n, i) : !n || r && n.nodeType == 1 ? { node: e, offset: o } : DE(n, i);
}
function AN(e, t) {
  let n = e.nodeValue.length, r = document.createRange();
  for (let i = 0; i < n; i++) {
    r.setEnd(e, i + 1), r.setStart(e, i);
    let o = bi(r, 1);
    if (o.top != o.bottom && K0(t, o))
      return { node: e, offset: i + (t.left >= (o.left + o.right) / 2 ? 1 : 0) };
  }
  return { node: e, offset: 0 };
}
function K0(e, t) {
  return e.left >= t.left - 1 && e.left <= t.right + 1 && e.top >= t.top - 1 && e.top <= t.bottom + 1;
}
function TN(e, t) {
  let n = e.parentNode;
  return n && /^li$/i.test(n.nodeName) && t.left < e.getBoundingClientRect().left ? n : e;
}
function SN(e, t, n) {
  let { node: r, offset: i } = DE(t, n), o = -1;
  if (r.nodeType == 1 && !r.firstChild) {
    let s = r.getBoundingClientRect();
    o = s.left != s.right && n.left > (s.left + s.right) / 2 ? 1 : -1;
  }
  return e.docView.posFromDOM(r, i, o);
}
function CN(e, t, n, r) {
  let i = -1;
  for (let o = t, s = !1; o != e.dom; ) {
    let a = e.docView.nearestDesc(o, !0);
    if (!a)
      return null;
    if (a.dom.nodeType == 1 && (a.node.isBlock && a.parent || !a.contentDOM)) {
      let l = a.dom.getBoundingClientRect();
      if (a.node.isBlock && a.parent && (!s && l.left > r.left || l.top > r.top ? i = a.posBefore : (!s && l.right < r.left || l.bottom < r.top) && (i = a.posAfter), s = !0), !a.contentDOM && i < 0 && !a.node.isText)
        return (a.node.isBlock ? r.top < (l.top + l.bottom) / 2 : r.left < (l.left + l.right) / 2) ? a.posBefore : a.posAfter;
    }
    o = a.dom.parentNode;
  }
  return i > -1 ? i : e.docView.posFromDOM(t, n, -1);
}
function OE(e, t, n) {
  let r = e.childNodes.length;
  if (r && n.top < n.bottom)
    for (let i = Math.max(0, Math.min(r - 1, Math.floor(r * (t.top - n.top) / (n.bottom - n.top)) - 2)), o = i; ; ) {
      let s = e.childNodes[o];
      if (s.nodeType == 1) {
        let a = s.getClientRects();
        for (let l = 0; l < a.length; l++) {
          let u = a[l];
          if (K0(t, u))
            return OE(s, t, u);
        }
      }
      if ((o = (o + 1) % r) == i)
        break;
    }
  return e;
}
function NN(e, t) {
  let n = e.dom.ownerDocument, r, i = 0, o = yN(n, t.left, t.top);
  o && ({ node: r, offset: i } = o);
  let s = (e.root.elementFromPoint ? e.root : n).elementFromPoint(t.left, t.top), a;
  if (!s || !e.dom.contains(s.nodeType != 1 ? s.parentNode : s)) {
    let u = e.dom.getBoundingClientRect();
    if (!K0(t, u) || (s = OE(e.dom, t, u), !s))
      return null;
  }
  if (hn)
    for (let u = s; r && u; u = nl(u))
      u.draggable && (r = void 0);
  if (s = TN(s, t), r) {
    if (fr && r.nodeType == 1 && (i = Math.min(i, r.childNodes.length), i < r.childNodes.length)) {
      let c = r.childNodes[i], f;
      c.nodeName == "IMG" && (f = c.getBoundingClientRect()).right <= t.left && f.bottom > t.top && i++;
    }
    let u;
    Ul && i && r.nodeType == 1 && (u = r.childNodes[i - 1]).nodeType == 1 && u.contentEditable == "false" && u.getBoundingClientRect().top >= t.top && i--, r == e.dom && i == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && t.top > r.lastChild.getBoundingClientRect().bottom ? a = e.state.doc.content.size : (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != "BR") && (a = CN(e, r, i, t));
  }
  a == null && (a = SN(e, s, t));
  let l = e.docView.nearestDesc(s, !0);
  return { pos: a, inside: l ? l.posAtStart - l.border : -1 };
}
function ym(e) {
  return e.top < e.bottom || e.left < e.right;
}
function bi(e, t) {
  let n = e.getClientRects();
  if (n.length) {
    let r = n[t < 0 ? 0 : n.length - 1];
    if (ym(r))
      return r;
  }
  return Array.prototype.find.call(n, ym) || e.getBoundingClientRect();
}
const DN = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function IE(e, t, n) {
  let { node: r, offset: i, atom: o } = e.docView.domFromPos(t, n < 0 ? -1 : 1), s = Ul || fr;
  if (r.nodeType == 3)
    if (s && (DN.test(r.nodeValue) || (n < 0 ? !i : i == r.nodeValue.length))) {
      let l = bi(ri(r, i, i), n);
      if (fr && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) {
        let u = bi(ri(r, i - 1, i - 1), -1);
        if (u.top == l.top) {
          let c = bi(ri(r, i, i + 1), -1);
          if (c.top != l.top)
            return la(c, c.left < u.left);
        }
      }
      return l;
    } else {
      let l = i, u = i, c = n < 0 ? 1 : -1;
      return n < 0 && !i ? (u++, c = -1) : n >= 0 && i == r.nodeValue.length ? (l--, c = 1) : n < 0 ? l-- : u++, la(bi(ri(r, l, u), c), c < 0);
    }
  if (!e.state.doc.resolve(t - (o || 0)).parent.inlineContent) {
    if (o == null && i && (n < 0 || i == Yn(r))) {
      let l = r.childNodes[i - 1];
      if (l.nodeType == 1)
        return sp(l.getBoundingClientRect(), !1);
    }
    if (o == null && i < Yn(r)) {
      let l = r.childNodes[i];
      if (l.nodeType == 1)
        return sp(l.getBoundingClientRect(), !0);
    }
    return sp(r.getBoundingClientRect(), n >= 0);
  }
  if (o == null && i && (n < 0 || i == Yn(r))) {
    let l = r.childNodes[i - 1], u = l.nodeType == 3 ? ri(l, Yn(l) - (s ? 0 : 1)) : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling) ? l : null;
    if (u)
      return la(bi(u, 1), !1);
  }
  if (o == null && i < Yn(r)) {
    let l = r.childNodes[i];
    for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; )
      l = l.nextSibling;
    let u = l ? l.nodeType == 3 ? ri(l, 0, s ? 0 : 1) : l.nodeType == 1 ? l : null : null;
    if (u)
      return la(bi(u, -1), !0);
  }
  return la(bi(r.nodeType == 3 ? ri(r) : r, -n), n >= 0);
}
function la(e, t) {
  if (e.width == 0)
    return e;
  let n = t ? e.left : e.right;
  return { top: e.top, bottom: e.bottom, left: n, right: n };
}
function sp(e, t) {
  if (e.height == 0)
    return e;
  let n = t ? e.top : e.bottom;
  return { top: n, bottom: n, left: e.left, right: e.right };
}
function RE(e, t, n) {
  let r = e.state, i = e.root.activeElement;
  r != t && e.updateState(t), i != e.dom && e.focus();
  try {
    return n();
  } finally {
    r != t && e.updateState(r), i != e.dom && i && i.focus();
  }
}
function ON(e, t, n) {
  let r = t.selection, i = n == "up" ? r.$from : r.$to;
  return RE(e, t, () => {
    let { node: o } = e.docView.domFromPos(i.pos, n == "up" ? -1 : 1);
    for (; ; ) {
      let a = e.docView.nearestDesc(o, !0);
      if (!a)
        break;
      if (a.node.isBlock) {
        o = a.contentDOM || a.dom;
        break;
      }
      o = a.dom.parentNode;
    }
    let s = IE(e, i.pos, 1);
    for (let a = o.firstChild; a; a = a.nextSibling) {
      let l;
      if (a.nodeType == 1)
        l = a.getClientRects();
      else if (a.nodeType == 3)
        l = ri(a, 0, a.nodeValue.length).getClientRects();
      else
        continue;
      for (let u = 0; u < l.length; u++) {
        let c = l[u];
        if (c.bottom > c.top + 1 && (n == "up" ? s.top - c.top > (c.bottom - s.top) * 2 : c.bottom - s.bottom > (s.bottom - c.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const IN = /[\u0590-\u08ac]/;
function RN(e, t, n) {
  let { $head: r } = t.selection;
  if (!r.parent.isTextblock)
    return !1;
  let i = r.parentOffset, o = !i, s = i == r.parent.content.size, a = e.domSelection();
  return a ? !IN.test(r.parent.textContent) || !a.modify ? n == "left" || n == "backward" ? o : s : RE(e, t, () => {
    let { focusNode: l, focusOffset: u, anchorNode: c, anchorOffset: f } = e.domSelectionRange(), d = a.caretBidiLevel;
    a.modify("move", n, "character");
    let p = r.depth ? e.docView.domAfterPos(r.before()) : e.dom, { focusNode: h, focusOffset: m } = e.domSelectionRange(), g = h && !p.contains(h.nodeType == 1 ? h : h.parentNode) || l == h && u == m;
    try {
      a.collapse(c, f), l && (l != c || u != f) && a.extend && a.extend(l, u);
    } catch {
    }
    return d != null && (a.caretBidiLevel = d), g;
  }) : r.pos == r.start() || r.pos == r.end();
}
let vm = null, _m = null, Em = !1;
function LN(e, t, n) {
  return vm == t && _m == n ? Em : (vm = t, _m = n, Em = n == "up" || n == "down" ? ON(e, t, n) : RN(e, t, n));
}
const Qn = 0, wm = 1, co = 2, Vr = 3;
class Vl {
  constructor(t, n, r, i) {
    this.parent = t, this.children = n, this.dom = r, this.contentDOM = i, this.dirty = Qn, r.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(t) {
    return !1;
  }
  matchesMark(t) {
    return !1;
  }
  matchesNode(t, n, r) {
    return !1;
  }
  matchesHack(t) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(t) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let t = 0;
    for (let n = 0; n < this.children.length; n++)
      t += this.children[n].size;
    return t;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let t = 0; t < this.children.length; t++)
      this.children[t].destroy();
  }
  posBeforeChild(t) {
    for (let n = 0, r = this.posAtStart; ; n++) {
      let i = this.children[n];
      if (i == t)
        return r;
      r += i.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(t, n, r) {
    if (this.contentDOM && this.contentDOM.contains(t.nodeType == 1 ? t : t.parentNode))
      if (r < 0) {
        let o, s;
        if (t == this.contentDOM)
          o = t.childNodes[n - 1];
        else {
          for (; t.parentNode != this.contentDOM; )
            t = t.parentNode;
          o = t.previousSibling;
        }
        for (; o && !((s = o.pmViewDesc) && s.parent == this); )
          o = o.previousSibling;
        return o ? this.posBeforeChild(s) + s.size : this.posAtStart;
      } else {
        let o, s;
        if (t == this.contentDOM)
          o = t.childNodes[n];
        else {
          for (; t.parentNode != this.contentDOM; )
            t = t.parentNode;
          o = t.nextSibling;
        }
        for (; o && !((s = o.pmViewDesc) && s.parent == this); )
          o = o.nextSibling;
        return o ? this.posBeforeChild(s) : this.posAtEnd;
      }
    let i;
    if (t == this.dom && this.contentDOM)
      i = n > Yt(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      i = t.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (n == 0)
        for (let o = t; ; o = o.parentNode) {
          if (o == this.dom) {
            i = !1;
            break;
          }
          if (o.previousSibling)
            break;
        }
      if (i == null && n == t.childNodes.length)
        for (let o = t; ; o = o.parentNode) {
          if (o == this.dom) {
            i = !0;
            break;
          }
          if (o.nextSibling)
            break;
        }
    }
    return i ?? r > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(t, n = !1) {
    for (let r = !0, i = t; i; i = i.parentNode) {
      let o = this.getDesc(i), s;
      if (o && (!n || o.node))
        if (r && (s = o.nodeDOM) && !(s.nodeType == 1 ? s.contains(t.nodeType == 1 ? t : t.parentNode) : s == t))
          r = !1;
        else
          return o;
    }
  }
  getDesc(t) {
    let n = t.pmViewDesc;
    for (let r = n; r; r = r.parent)
      if (r == this)
        return n;
  }
  posFromDOM(t, n, r) {
    for (let i = t; i; i = i.parentNode) {
      let o = this.getDesc(i);
      if (o)
        return o.localPosFromDOM(t, n, r);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(t) {
    for (let n = 0, r = 0; n < this.children.length; n++) {
      let i = this.children[n], o = r + i.size;
      if (r == t && o != r) {
        for (; !i.border && i.children.length; )
          i = i.children[0];
        return i;
      }
      if (t < o)
        return i.descAt(t - r - i.border);
      r = o;
    }
  }
  domFromPos(t, n) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: t + 1 };
    let r = 0, i = 0;
    for (let o = 0; r < this.children.length; r++) {
      let s = this.children[r], a = o + s.size;
      if (a > t || s instanceof BE) {
        i = t - o;
        break;
      }
      o = a;
    }
    if (i)
      return this.children[r].domFromPos(i - this.children[r].border, n);
    for (let o; r && !(o = this.children[r - 1]).size && o instanceof LE && o.side >= 0; r--)
      ;
    if (n <= 0) {
      let o, s = !0;
      for (; o = r ? this.children[r - 1] : null, !(!o || o.dom.parentNode == this.contentDOM); r--, s = !1)
        ;
      return o && n && s && !o.border && !o.domAtom ? o.domFromPos(o.size, n) : { node: this.contentDOM, offset: o ? Yt(o.dom) + 1 : 0 };
    } else {
      let o, s = !0;
      for (; o = r < this.children.length ? this.children[r] : null, !(!o || o.dom.parentNode == this.contentDOM); r++, s = !1)
        ;
      return o && s && !o.border && !o.domAtom ? o.domFromPos(0, n) : { node: this.contentDOM, offset: o ? Yt(o.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(t, n, r = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: t, to: n, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let i = -1, o = -1;
    for (let s = r, a = 0; ; a++) {
      let l = this.children[a], u = s + l.size;
      if (i == -1 && t <= u) {
        let c = s + l.border;
        if (t >= c && n <= u - l.border && l.node && l.contentDOM && this.contentDOM.contains(l.contentDOM))
          return l.parseRange(t, n, c);
        t = s;
        for (let f = a; f > 0; f--) {
          let d = this.children[f - 1];
          if (d.size && d.dom.parentNode == this.contentDOM && !d.emptyChildAt(1)) {
            i = Yt(d.dom) + 1;
            break;
          }
          t -= d.size;
        }
        i == -1 && (i = 0);
      }
      if (i > -1 && (u > n || a == this.children.length - 1)) {
        n = u;
        for (let c = a + 1; c < this.children.length; c++) {
          let f = this.children[c];
          if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(-1)) {
            o = Yt(f.dom);
            break;
          }
          n += f.size;
        }
        o == -1 && (o = this.contentDOM.childNodes.length);
        break;
      }
      s = u;
    }
    return { node: this.contentDOM, from: t, to: n, fromOffset: i, toOffset: o };
  }
  emptyChildAt(t) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let n = this.children[t < 0 ? 0 : this.children.length - 1];
    return n.size == 0 || n.emptyChildAt(t);
  }
  domAfterPos(t) {
    let { node: n, offset: r } = this.domFromPos(t, 0);
    if (n.nodeType != 1 || r == n.childNodes.length)
      throw new RangeError("No node after pos " + t);
    return n.childNodes[r];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(t, n, r, i = !1) {
    let o = Math.min(t, n), s = Math.max(t, n);
    for (let d = 0, p = 0; d < this.children.length; d++) {
      let h = this.children[d], m = p + h.size;
      if (o > p && s < m)
        return h.setSelection(t - p - h.border, n - p - h.border, r, i);
      p = m;
    }
    let a = this.domFromPos(t, t ? -1 : 1), l = n == t ? a : this.domFromPos(n, n ? -1 : 1), u = r.getSelection(), c = !1;
    if ((fr || hn) && t == n) {
      let { node: d, offset: p } = a;
      if (d.nodeType == 3) {
        if (c = !!(p && d.nodeValue[p - 1] == `
`), c && p == d.nodeValue.length)
          for (let h = d, m; h; h = h.parentNode) {
            if (m = h.nextSibling) {
              m.nodeName == "BR" && (a = l = { node: m.parentNode, offset: Yt(m) + 1 });
              break;
            }
            let g = h.pmViewDesc;
            if (g && g.node && g.node.isBlock)
              break;
          }
      } else {
        let h = d.childNodes[p - 1];
        c = h && (h.nodeName == "BR" || h.contentEditable == "false");
      }
    }
    if (fr && u.focusNode && u.focusNode != l.node && u.focusNode.nodeType == 1) {
      let d = u.focusNode.childNodes[u.focusOffset];
      d && d.contentEditable == "false" && (i = !0);
    }
    if (!(i || c && hn) && Do(a.node, a.offset, u.anchorNode, u.anchorOffset) && Do(l.node, l.offset, u.focusNode, u.focusOffset))
      return;
    let f = !1;
    if ((u.extend || t == n) && !c) {
      u.collapse(a.node, a.offset);
      try {
        t != n && u.extend(l.node, l.offset), f = !0;
      } catch {
      }
    }
    if (!f) {
      if (t > n) {
        let p = a;
        a = l, l = p;
      }
      let d = document.createRange();
      d.setEnd(l.node, l.offset), d.setStart(a.node, a.offset), u.removeAllRanges(), u.addRange(d);
    }
  }
  ignoreMutation(t) {
    return !this.contentDOM && t.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(t, n) {
    for (let r = 0, i = 0; i < this.children.length; i++) {
      let o = this.children[i], s = r + o.size;
      if (r == s ? t <= s && n >= r : t < s && n > r) {
        let a = r + o.border, l = s - o.border;
        if (t >= a && n <= l) {
          this.dirty = t == r || n == s ? co : wm, t == a && n == l && (o.contentLost || o.dom.parentNode != this.contentDOM) ? o.dirty = Vr : o.markDirty(t - a, n - a);
          return;
        } else
          o.dirty = o.dom == o.contentDOM && o.dom.parentNode == this.contentDOM && !o.children.length ? co : Vr;
      }
      r = s;
    }
    this.dirty = co;
  }
  markParentsDirty() {
    let t = 1;
    for (let n = this.parent; n; n = n.parent, t++) {
      let r = t == 1 ? co : wm;
      n.dirty < r && (n.dirty = r);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  isText(t) {
    return !1;
  }
}
class LE extends Vl {
  constructor(t, n, r, i) {
    let o, s = n.type.toDOM;
    if (typeof s == "function" && (s = s(r, () => {
      if (!o)
        return i;
      if (o.parent)
        return o.parent.posBeforeChild(o);
    })), !n.type.spec.raw) {
      if (s.nodeType != 1) {
        let a = document.createElement("span");
        a.appendChild(s), s = a;
      }
      s.contentEditable = "false", s.classList.add("ProseMirror-widget");
    }
    super(t, [], s, null), this.widget = n, this.widget = n, o = this;
  }
  matchesWidget(t) {
    return this.dirty == Qn && t.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(t) {
    let n = this.widget.spec.stopEvent;
    return n ? n(t) : !1;
  }
  ignoreMutation(t) {
    return t.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get side() {
    return this.widget.type.side;
  }
}
class BN extends Vl {
  constructor(t, n, r, i) {
    super(t, [], n, null), this.textDOM = r, this.text = i;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(t, n) {
    return t != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n;
  }
  domFromPos(t) {
    return { node: this.textDOM, offset: t };
  }
  ignoreMutation(t) {
    return t.type === "characterData" && t.target.nodeValue == t.oldValue;
  }
}
class Oo extends Vl {
  constructor(t, n, r, i, o) {
    super(t, [], r, i), this.mark = n, this.spec = o;
  }
  static create(t, n, r, i) {
    let o = i.nodeViews[n.type.name], s = o && o(n, i, r);
    return (!s || !s.dom) && (s = $o.renderSpec(document, n.type.spec.toDOM(n, r), null, n.attrs)), new Oo(t, n, s.dom, s.contentDOM || s.dom, s);
  }
  parseRule() {
    return this.dirty & Vr || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(t) {
    return this.dirty != Vr && this.mark.eq(t);
  }
  markDirty(t, n) {
    if (super.markDirty(t, n), this.dirty != Qn) {
      let r = this.parent;
      for (; !r.node; )
        r = r.parent;
      r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = Qn;
    }
  }
  slice(t, n, r) {
    let i = Oo.create(this.parent, this.mark, !0, r), o = this.children, s = this.size;
    n < s && (o = kh(o, n, s, r)), t > 0 && (o = kh(o, 0, t, r));
    for (let a = 0; a < o.length; a++)
      o[a].parent = i;
    return i.children = o, i;
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
}
class Ui extends Vl {
  constructor(t, n, r, i, o, s, a, l, u) {
    super(t, [], o, s), this.node = n, this.outerDeco = r, this.innerDeco = i, this.nodeDOM = a;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(t, n, r, i, o, s) {
    let a = o.nodeViews[n.type.name], l, u = a && a(n, o, () => {
      if (!l)
        return s;
      if (l.parent)
        return l.parent.posBeforeChild(l);
    }, r, i), c = u && u.dom, f = u && u.contentDOM;
    if (n.isText) {
      if (!c)
        c = document.createTextNode(n.text);
      else if (c.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else c || ({ dom: c, contentDOM: f } = $o.renderSpec(document, n.type.spec.toDOM(n), null, n.attrs));
    !f && !n.isText && c.nodeName != "BR" && (c.hasAttribute("contenteditable") || (c.contentEditable = "false"), n.type.spec.draggable && (c.draggable = !0));
    let d = c;
    return c = zE(c, r, n), u ? l = new PN(t, n, r, i, c, f || null, d, u, o, s + 1) : n.isText ? new sd(t, n, r, i, c, d, o) : new Ui(t, n, r, i, c, f || null, d, o, s + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let t = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (t.preserveWhitespace = "full"), !this.contentDOM)
      t.getContent = () => this.node.content;
    else if (!this.contentLost)
      t.contentElement = this.contentDOM;
    else {
      for (let n = this.children.length - 1; n >= 0; n--) {
        let r = this.children[n];
        if (this.dom.contains(r.dom.parentNode)) {
          t.contentElement = r.dom.parentNode;
          break;
        }
      }
      t.contentElement || (t.getContent = () => te.empty);
    }
    return t;
  }
  matchesNode(t, n, r) {
    return this.dirty == Qn && t.eq(this.node) && Ic(n, this.outerDeco) && r.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(t, n) {
    let r = this.node.inlineContent, i = n, o = t.composing ? this.localCompositionInfo(t, n) : null, s = o && o.pos > -1 ? o : null, a = o && o.pos < 0, l = new zN(this, s && s.node, t);
    UN(this.node, this.innerDeco, (u, c, f) => {
      u.spec.marks ? l.syncToMarks(u.spec.marks, r, t) : u.type.side >= 0 && !f && l.syncToMarks(c == this.node.childCount ? rt.none : this.node.child(c).marks, r, t), l.placeWidget(u, t, i);
    }, (u, c, f, d) => {
      l.syncToMarks(u.marks, r, t);
      let p;
      l.findNodeMatch(u, c, f, d) || a && t.state.selection.from > i && t.state.selection.to < i + u.nodeSize && (p = l.findIndexWithChild(o.node)) > -1 && l.updateNodeAt(u, c, f, p, t) || l.updateNextNode(u, c, f, t, d, i) || l.addNode(u, c, f, t, i), i += u.nodeSize;
    }), l.syncToMarks([], r, t), this.node.isTextblock && l.addTextblockHacks(), l.destroyRest(), (l.changed || this.dirty == co) && (s && this.protectLocalComposition(t, s), PE(this.contentDOM, this.children, t), ks && VN(this.dom));
  }
  localCompositionInfo(t, n) {
    let { from: r, to: i } = t.state.selection;
    if (!(t.state.selection instanceof Oe) || r < n || i > n + this.node.content.size)
      return null;
    let o = t.input.compositionNode;
    if (!o || !this.dom.contains(o.parentNode))
      return null;
    if (this.node.inlineContent) {
      let s = o.nodeValue, a = HN(this.node.content, s, r - n, i - n);
      return a < 0 ? null : { node: o, pos: a, text: s };
    } else
      return { node: o, pos: -1, text: "" };
  }
  protectLocalComposition(t, { node: n, pos: r, text: i }) {
    if (this.getDesc(n))
      return;
    let o = n;
    for (; o.parentNode != this.contentDOM; o = o.parentNode) {
      for (; o.previousSibling; )
        o.parentNode.removeChild(o.previousSibling);
      for (; o.nextSibling; )
        o.parentNode.removeChild(o.nextSibling);
      o.pmViewDesc && (o.pmViewDesc = void 0);
    }
    let s = new BN(this, o, n, i);
    t.input.compositionNodes.push(s), this.children = kh(this.children, r, r + i.length, t, s);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(t, n, r, i) {
    return this.dirty == Vr || !t.sameMarkup(this.node) ? !1 : (this.updateInner(t, n, r, i), !0);
  }
  updateInner(t, n, r, i) {
    this.updateOuterDeco(n), this.node = t, this.innerDeco = r, this.contentDOM && this.updateChildren(i, this.posAtStart), this.dirty = Qn;
  }
  updateOuterDeco(t) {
    if (Ic(t, this.outerDeco))
      return;
    let n = this.nodeDOM.nodeType != 1, r = this.dom;
    this.dom = $E(this.dom, this.nodeDOM, xh(this.outerDeco, this.node, n), xh(t, this.node, n)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = t;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function xm(e, t, n, r, i) {
  zE(r, t, e);
  let o = new Ui(void 0, e, t, n, r, r, r, i, 0);
  return o.contentDOM && o.updateChildren(i, 0), o;
}
class sd extends Ui {
  constructor(t, n, r, i, o, s, a) {
    super(t, n, r, i, o, null, s, a, 0);
  }
  parseRule() {
    let t = this.nodeDOM.parentNode;
    for (; t && t != this.dom && !t.pmIsDeco; )
      t = t.parentNode;
    return { skip: t || !0 };
  }
  update(t, n, r, i) {
    return this.dirty == Vr || this.dirty != Qn && !this.inParent() || !t.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(n), (this.dirty != Qn || t.text != this.node.text) && t.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = t.text, i.trackWrites == this.nodeDOM && (i.trackWrites = null)), this.node = t, this.dirty = Qn, !0);
  }
  inParent() {
    let t = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == t)
        return !0;
    return !1;
  }
  domFromPos(t) {
    return { node: this.nodeDOM, offset: t };
  }
  localPosFromDOM(t, n, r) {
    return t == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(t, n, r);
  }
  ignoreMutation(t) {
    return t.type != "characterData" && t.type != "selection";
  }
  slice(t, n, r) {
    let i = this.node.cut(t, n), o = document.createTextNode(i.text);
    return new sd(this.parent, i, this.outerDeco, this.innerDeco, o, o, r);
  }
  markDirty(t, n) {
    super.markDirty(t, n), this.dom != this.nodeDOM && (t == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = Vr);
  }
  get domAtom() {
    return !1;
  }
  isText(t) {
    return this.node.text == t;
  }
}
class BE extends Vl {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(t) {
    return this.dirty == Qn && this.dom.nodeName == t;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class PN extends Ui {
  constructor(t, n, r, i, o, s, a, l, u, c) {
    super(t, n, r, i, o, s, a, u, c), this.spec = l;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(t, n, r, i) {
    if (this.dirty == Vr)
      return !1;
    if (this.spec.update && (this.node.type == t.type || this.spec.multiType)) {
      let o = this.spec.update(t, n, r);
      return o && this.updateInner(t, n, r, i), o;
    } else return !this.contentDOM && !t.isLeaf ? !1 : super.update(t, n, r, i);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(t, n, r, i) {
    this.spec.setSelection ? this.spec.setSelection(t, n, r) : super.setSelection(t, n, r, i);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(t) {
    return this.spec.stopEvent ? this.spec.stopEvent(t) : !1;
  }
  ignoreMutation(t) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(t) : super.ignoreMutation(t);
  }
}
function PE(e, t, n) {
  let r = e.firstChild, i = !1;
  for (let o = 0; o < t.length; o++) {
    let s = t[o], a = s.dom;
    if (a.parentNode == e) {
      for (; a != r; )
        r = km(r), i = !0;
      r = r.nextSibling;
    } else
      i = !0, e.insertBefore(a, r);
    if (s instanceof Oo) {
      let l = r ? r.previousSibling : e.lastChild;
      PE(s.contentDOM, s.children, n), r = l ? l.nextSibling : e.firstChild;
    }
  }
  for (; r; )
    r = km(r), i = !0;
  i && n.trackWrites == e && (n.trackWrites = null);
}
const Pa = function(e) {
  e && (this.nodeName = e);
};
Pa.prototype = /* @__PURE__ */ Object.create(null);
const fo = [new Pa()];
function xh(e, t, n) {
  if (e.length == 0)
    return fo;
  let r = n ? fo[0] : new Pa(), i = [r];
  for (let o = 0; o < e.length; o++) {
    let s = e[o].type.attrs;
    if (s) {
      s.nodeName && i.push(r = new Pa(s.nodeName));
      for (let a in s) {
        let l = s[a];
        l != null && (n && i.length == 1 && i.push(r = new Pa(t.isInline ? "span" : "div")), a == "class" ? r.class = (r.class ? r.class + " " : "") + l : a == "style" ? r.style = (r.style ? r.style + ";" : "") + l : a != "nodeName" && (r[a] = l));
      }
    }
  }
  return i;
}
function $E(e, t, n, r) {
  if (n == fo && r == fo)
    return t;
  let i = t;
  for (let o = 0; o < r.length; o++) {
    let s = r[o], a = n[o];
    if (o) {
      let l;
      a && a.nodeName == s.nodeName && i != e && (l = i.parentNode) && l.nodeName.toLowerCase() == s.nodeName || (l = document.createElement(s.nodeName), l.pmIsDeco = !0, l.appendChild(i), a = fo[0]), i = l;
    }
    $N(i, a || fo[0], s);
  }
  return i;
}
function $N(e, t, n) {
  for (let r in t)
    r != "class" && r != "style" && r != "nodeName" && !(r in n) && e.removeAttribute(r);
  for (let r in n)
    r != "class" && r != "style" && r != "nodeName" && n[r] != t[r] && e.setAttribute(r, n[r]);
  if (t.class != n.class) {
    let r = t.class ? t.class.split(" ").filter(Boolean) : [], i = n.class ? n.class.split(" ").filter(Boolean) : [];
    for (let o = 0; o < r.length; o++)
      i.indexOf(r[o]) == -1 && e.classList.remove(r[o]);
    for (let o = 0; o < i.length; o++)
      r.indexOf(i[o]) == -1 && e.classList.add(i[o]);
    e.classList.length == 0 && e.removeAttribute("class");
  }
  if (t.style != n.style) {
    if (t.style) {
      let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, i;
      for (; i = r.exec(t.style); )
        e.style.removeProperty(i[1]);
    }
    n.style && (e.style.cssText += n.style);
  }
}
function zE(e, t, n) {
  return $E(e, e, fo, xh(t, n, e.nodeType != 1));
}
function Ic(e, t) {
  if (e.length != t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (!e[n].type.eq(t[n].type))
      return !1;
  return !0;
}
function km(e) {
  let t = e.nextSibling;
  return e.parentNode.removeChild(e), t;
}
class zN {
  constructor(t, n, r) {
    this.lock = n, this.view = r, this.index = 0, this.stack = [], this.changed = !1, this.top = t, this.preMatch = FN(t.node.content, t);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(t, n) {
    if (t != n) {
      for (let r = t; r < n; r++)
        this.top.children[r].destroy();
      this.top.children.splice(t, n - t), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(t, n, r) {
    let i = 0, o = this.stack.length >> 1, s = Math.min(o, t.length);
    for (; i < s && (i == o - 1 ? this.top : this.stack[i + 1 << 1]).matchesMark(t[i]) && t[i].type.spec.spanning !== !1; )
      i++;
    for (; i < o; )
      this.destroyRest(), this.top.dirty = Qn, this.index = this.stack.pop(), this.top = this.stack.pop(), o--;
    for (; o < t.length; ) {
      this.stack.push(this.top, this.index + 1);
      let a = -1;
      for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) {
        let u = this.top.children[l];
        if (u.matchesMark(t[o]) && !this.isLocked(u.dom)) {
          a = l;
          break;
        }
      }
      if (a > -1)
        a > this.index && (this.changed = !0, this.destroyBetween(this.index, a)), this.top = this.top.children[this.index];
      else {
        let l = Oo.create(this.top, t[o], n, r);
        this.top.children.splice(this.index, 0, l), this.top = l, this.changed = !0;
      }
      this.index = 0, o++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(t, n, r, i) {
    let o = -1, s;
    if (i >= this.preMatch.index && (s = this.preMatch.matches[i - this.preMatch.index]).parent == this.top && s.matchesNode(t, n, r))
      o = this.top.children.indexOf(s, this.index);
    else
      for (let a = this.index, l = Math.min(this.top.children.length, a + 5); a < l; a++) {
        let u = this.top.children[a];
        if (u.matchesNode(t, n, r) && !this.preMatch.matched.has(u)) {
          o = a;
          break;
        }
      }
    return o < 0 ? !1 : (this.destroyBetween(this.index, o), this.index++, !0);
  }
  updateNodeAt(t, n, r, i, o) {
    let s = this.top.children[i];
    return s.dirty == Vr && s.dom == s.contentDOM && (s.dirty = co), s.update(t, n, r, o) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1;
  }
  findIndexWithChild(t) {
    for (; ; ) {
      let n = t.parentNode;
      if (!n)
        return -1;
      if (n == this.top.contentDOM) {
        let r = t.pmViewDesc;
        if (r) {
          for (let i = this.index; i < this.top.children.length; i++)
            if (this.top.children[i] == r)
              return i;
        }
        return -1;
      }
      t = n;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(t, n, r, i, o, s) {
    for (let a = this.index; a < this.top.children.length; a++) {
      let l = this.top.children[a];
      if (l instanceof Ui) {
        let u = this.preMatch.matched.get(l);
        if (u != null && u != o)
          return !1;
        let c = l.dom, f, d = this.isLocked(c) && !(t.isText && l.node && l.node.isText && l.nodeDOM.nodeValue == t.text && l.dirty != Vr && Ic(n, l.outerDeco));
        if (!d && l.update(t, n, r, i))
          return this.destroyBetween(this.index, a), l.dom != c && (this.changed = !0), this.index++, !0;
        if (!d && (f = this.recreateWrapper(l, t, n, r, i, s)))
          return this.destroyBetween(this.index, a), this.top.children[this.index] = f, f.contentDOM && (f.dirty = co, f.updateChildren(i, s + 1), f.dirty = Qn), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(t, n, r, i, o, s) {
    if (t.dirty || n.isAtom || !t.children.length || !t.node.content.eq(n.content) || !Ic(r, t.outerDeco) || !i.eq(t.innerDeco))
      return null;
    let a = Ui.create(this.top, n, r, i, o, s);
    if (a.contentDOM) {
      a.children = t.children, t.children = [];
      for (let l of a.children)
        l.parent = a;
    }
    return t.destroy(), a;
  }
  // Insert the node as a newly created node desc.
  addNode(t, n, r, i, o) {
    let s = Ui.create(this.top, t, n, r, i, o);
    s.contentDOM && s.updateChildren(i, o + 1), this.top.children.splice(this.index++, 0, s), this.changed = !0;
  }
  placeWidget(t, n, r) {
    let i = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (i && i.matchesWidget(t) && (t == i.widget || !i.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let o = new LE(this.top, t, n, r);
      this.top.children.splice(this.index++, 0, o), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let t = this.top.children[this.index - 1], n = this.top;
    for (; t instanceof Oo; )
      n = t, t = n.children[n.children.length - 1];
    (!t || // Empty textblock
    !(t instanceof sd) || /\n$/.test(t.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(t.node.text)) && ((hn || an) && t && t.dom.contentEditable == "false" && this.addHackNode("IMG", n), this.addHackNode("BR", this.top));
  }
  addHackNode(t, n) {
    if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(t))
      this.index++;
    else {
      let r = document.createElement(t);
      t == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), t == "BR" && (r.className = "ProseMirror-trailingBreak");
      let i = new BE(this.top, [], r, null);
      n != this.top ? n.children.push(i) : n.children.splice(this.index++, 0, i), this.changed = !0;
    }
  }
  isLocked(t) {
    return this.lock && (t == this.lock || t.nodeType == 1 && t.contains(this.lock.parentNode));
  }
}
function FN(e, t) {
  let n = t, r = n.children.length, i = e.childCount, o = /* @__PURE__ */ new Map(), s = [];
  e: for (; i > 0; ) {
    let a;
    for (; ; )
      if (r) {
        let u = n.children[r - 1];
        if (u instanceof Oo)
          n = u, r = u.children.length;
        else {
          a = u, r--;
          break;
        }
      } else {
        if (n == t)
          break e;
        r = n.parent.children.indexOf(n), n = n.parent;
      }
    let l = a.node;
    if (l) {
      if (l != e.child(i - 1))
        break;
      --i, o.set(a, i), s.push(a);
    }
  }
  return { index: i, matched: o, matches: s.reverse() };
}
function jN(e, t) {
  return e.type.side - t.type.side;
}
function UN(e, t, n, r) {
  let i = t.locals(e), o = 0;
  if (i.length == 0) {
    for (let u = 0; u < e.childCount; u++) {
      let c = e.child(u);
      r(c, i, t.forChild(o, c), u), o += c.nodeSize;
    }
    return;
  }
  let s = 0, a = [], l = null;
  for (let u = 0; ; ) {
    let c, f;
    for (; s < i.length && i[s].to == o; ) {
      let g = i[s++];
      g.widget && (c ? (f || (f = [c])).push(g) : c = g);
    }
    if (c)
      if (f) {
        f.sort(jN);
        for (let g = 0; g < f.length; g++)
          n(f[g], u, !!l);
      } else
        n(c, u, !!l);
    let d, p;
    if (l)
      p = -1, d = l, l = null;
    else if (u < e.childCount)
      p = u, d = e.child(u++);
    else
      break;
    for (let g = 0; g < a.length; g++)
      a[g].to <= o && a.splice(g--, 1);
    for (; s < i.length && i[s].from <= o && i[s].to > o; )
      a.push(i[s++]);
    let h = o + d.nodeSize;
    if (d.isText) {
      let g = h;
      s < i.length && i[s].from < g && (g = i[s].from);
      for (let y = 0; y < a.length; y++)
        a[y].to < g && (g = a[y].to);
      g < h && (l = d.cut(g - o), d = d.cut(0, g - o), h = g, p = -1);
    } else
      for (; s < i.length && i[s].to < h; )
        s++;
    let m = d.isInline && !d.isLeaf ? a.filter((g) => !g.inline) : a.slice();
    r(d, m, t.forChild(o, d), p), o = h;
  }
}
function VN(e) {
  if (e.nodeName == "UL" || e.nodeName == "OL") {
    let t = e.style.cssText;
    e.style.cssText = t + "; list-style: square !important", window.getComputedStyle(e).listStyle, e.style.cssText = t;
  }
}
function HN(e, t, n, r) {
  for (let i = 0, o = 0; i < e.childCount && o <= r; ) {
    let s = e.child(i++), a = o;
    if (o += s.nodeSize, !s.isText)
      continue;
    let l = s.text;
    for (; i < e.childCount; ) {
      let u = e.child(i++);
      if (o += u.nodeSize, !u.isText)
        break;
      l += u.text;
    }
    if (o >= n) {
      if (o >= r && l.slice(r - t.length - a, r - a) == t)
        return r - t.length;
      let u = a < r ? l.lastIndexOf(t, r - a - 1) : -1;
      if (u >= 0 && u + t.length + a >= n)
        return a + u;
      if (n == r && l.length >= r + t.length - a && l.slice(r - a, r - a + t.length) == t)
        return r;
    }
  }
  return -1;
}
function kh(e, t, n, r, i) {
  let o = [];
  for (let s = 0, a = 0; s < e.length; s++) {
    let l = e[s], u = a, c = a += l.size;
    u >= n || c <= t ? o.push(l) : (u < t && o.push(l.slice(0, t - u, r)), i && (o.push(i), i = void 0), c > n && o.push(l.slice(n - u, l.size, r)));
  }
  return o;
}
function Y0(e, t = null) {
  let n = e.domSelectionRange(), r = e.state.doc;
  if (!n.focusNode)
    return null;
  let i = e.docView.nearestDesc(n.focusNode), o = i && i.size == 0, s = e.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
  if (s < 0)
    return null;
  let a = r.resolve(s), l, u;
  if (od(n)) {
    for (l = s; i && !i.node; )
      i = i.parent;
    let f = i.node;
    if (i && f.isAtom && Ce.isSelectable(f) && i.parent && !(f.isInline && mN(n.focusNode, n.focusOffset, i.dom))) {
      let d = i.posBefore;
      u = new Ce(s == d ? a : r.resolve(d));
    }
  } else {
    if (n instanceof e.dom.ownerDocument.defaultView.Selection && n.rangeCount > 1) {
      let f = s, d = s;
      for (let p = 0; p < n.rangeCount; p++) {
        let h = n.getRangeAt(p);
        f = Math.min(f, e.docView.posFromDOM(h.startContainer, h.startOffset, 1)), d = Math.max(d, e.docView.posFromDOM(h.endContainer, h.endOffset, -1));
      }
      if (f < 0)
        return null;
      [l, s] = d == e.state.selection.anchor ? [d, f] : [f, d], a = r.resolve(s);
    } else
      l = e.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
    if (l < 0)
      return null;
  }
  let c = r.resolve(l);
  if (!u) {
    let f = t == "pointer" || e.state.selection.head < a.pos && !o ? 1 : -1;
    u = Q0(e, c, a, f);
  }
  return u;
}
function FE(e) {
  return e.editable ? e.hasFocus() : UE(e) && document.activeElement && document.activeElement.contains(e.dom);
}
function ui(e, t = !1) {
  let n = e.state.selection;
  if (jE(e, n), !!FE(e)) {
    if (!t && e.input.mouseDown && e.input.mouseDown.allowDefault && an) {
      let r = e.domSelectionRange(), i = e.domObserver.currentSelection;
      if (r.anchorNode && i.anchorNode && Do(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)) {
        e.input.mouseDown.delayedSelectionSync = !0, e.domObserver.setCurSelection();
        return;
      }
    }
    if (e.domObserver.disconnectSelection(), e.cursorWrapper)
      GN(e);
    else {
      let { anchor: r, head: i } = n, o, s;
      Mm && !(n instanceof Oe) && (n.$from.parent.inlineContent || (o = Am(e, n.from)), !n.empty && !n.$from.parent.inlineContent && (s = Am(e, n.to))), e.docView.setSelection(r, i, e.root, t), Mm && (o && Tm(o), s && Tm(s)), n.visible ? e.dom.classList.remove("ProseMirror-hideselection") : (e.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && qN(e));
    }
    e.domObserver.setCurSelection(), e.domObserver.connectSelection();
  }
}
const Mm = hn || an && SE < 63;
function Am(e, t) {
  let { node: n, offset: r } = e.docView.domFromPos(t, 0), i = r < n.childNodes.length ? n.childNodes[r] : null, o = r ? n.childNodes[r - 1] : null;
  if (hn && i && i.contentEditable == "false")
    return ap(i);
  if ((!i || i.contentEditable == "false") && (!o || o.contentEditable == "false")) {
    if (i)
      return ap(i);
    if (o)
      return ap(o);
  }
}
function ap(e) {
  return e.contentEditable = "true", hn && e.draggable && (e.draggable = !1, e.wasDraggable = !0), e;
}
function Tm(e) {
  e.contentEditable = "false", e.wasDraggable && (e.draggable = !0, e.wasDraggable = null);
}
function qN(e) {
  let t = e.dom.ownerDocument;
  t.removeEventListener("selectionchange", e.input.hideSelectionGuard);
  let n = e.domSelectionRange(), r = n.anchorNode, i = n.anchorOffset;
  t.addEventListener("selectionchange", e.input.hideSelectionGuard = () => {
    (n.anchorNode != r || n.anchorOffset != i) && (t.removeEventListener("selectionchange", e.input.hideSelectionGuard), setTimeout(() => {
      (!FE(e) || e.state.selection.visible) && e.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function GN(e) {
  let t = e.domSelection(), n = document.createRange();
  if (!t)
    return;
  let r = e.cursorWrapper.dom, i = r.nodeName == "IMG";
  i ? n.setStart(r.parentNode, Yt(r) + 1) : n.setStart(r, 0), n.collapse(!0), t.removeAllRanges(), t.addRange(n), !i && !e.state.selection.visible && Mn && ji <= 11 && (r.disabled = !0, r.disabled = !1);
}
function jE(e, t) {
  if (t instanceof Ce) {
    let n = e.docView.descAt(t.from);
    n != e.lastSelectedViewDesc && (Sm(e), n && n.selectNode(), e.lastSelectedViewDesc = n);
  } else
    Sm(e);
}
function Sm(e) {
  e.lastSelectedViewDesc && (e.lastSelectedViewDesc.parent && e.lastSelectedViewDesc.deselectNode(), e.lastSelectedViewDesc = void 0);
}
function Q0(e, t, n, r) {
  return e.someProp("createSelectionBetween", (i) => i(e, t, n)) || Oe.between(t, n, r);
}
function Cm(e) {
  return e.editable && !e.hasFocus() ? !1 : UE(e);
}
function UE(e) {
  let t = e.domSelectionRange();
  if (!t.anchorNode)
    return !1;
  try {
    return e.dom.contains(t.anchorNode.nodeType == 3 ? t.anchorNode.parentNode : t.anchorNode) && (e.editable || e.dom.contains(t.focusNode.nodeType == 3 ? t.focusNode.parentNode : t.focusNode));
  } catch {
    return !1;
  }
}
function WN(e) {
  let t = e.docView.domFromPos(e.state.selection.anchor, 0), n = e.domSelectionRange();
  return Do(t.node, t.offset, n.anchorNode, n.anchorOffset);
}
function Mh(e, t) {
  let { $anchor: n, $head: r } = e.selection, i = t > 0 ? n.max(r) : n.min(r), o = i.parent.inlineContent ? i.depth ? e.doc.resolve(t > 0 ? i.after() : i.before()) : null : i;
  return o && Be.findFrom(o, t);
}
function vi(e, t) {
  return e.dispatch(e.state.tr.setSelection(t).scrollIntoView()), !0;
}
function Nm(e, t, n) {
  let r = e.state.selection;
  if (r instanceof Oe)
    if (n.indexOf("s") > -1) {
      let { $head: i } = r, o = i.textOffset ? null : t < 0 ? i.nodeBefore : i.nodeAfter;
      if (!o || o.isText || !o.isLeaf)
        return !1;
      let s = e.state.doc.resolve(i.pos + o.nodeSize * (t < 0 ? -1 : 1));
      return vi(e, new Oe(r.$anchor, s));
    } else if (r.empty) {
      if (e.endOfTextblock(t > 0 ? "forward" : "backward")) {
        let i = Mh(e.state, t);
        return i && i instanceof Ce ? vi(e, i) : !1;
      } else if (!(Kn && n.indexOf("m") > -1)) {
        let i = r.$head, o = i.textOffset ? null : t < 0 ? i.nodeBefore : i.nodeAfter, s;
        if (!o || o.isText)
          return !1;
        let a = t < 0 ? i.pos - o.nodeSize : i.pos;
        return o.isAtom || (s = e.docView.descAt(a)) && !s.contentDOM ? Ce.isSelectable(o) ? vi(e, new Ce(t < 0 ? e.state.doc.resolve(i.pos - o.nodeSize) : i)) : Ul ? vi(e, new Oe(e.state.doc.resolve(t < 0 ? a : a + o.nodeSize))) : !1 : !1;
      }
    } else return !1;
  else {
    if (r instanceof Ce && r.node.isInline)
      return vi(e, new Oe(t > 0 ? r.$to : r.$from));
    {
      let i = Mh(e.state, t);
      return i ? vi(e, i) : !1;
    }
  }
}
function Rc(e) {
  return e.nodeType == 3 ? e.nodeValue.length : e.childNodes.length;
}
function $a(e, t) {
  let n = e.pmViewDesc;
  return n && n.size == 0 && (t < 0 || e.nextSibling || e.nodeName != "BR");
}
function Ho(e, t) {
  return t < 0 ? KN(e) : YN(e);
}
function KN(e) {
  let t = e.domSelectionRange(), n = t.focusNode, r = t.focusOffset;
  if (!n)
    return;
  let i, o, s = !1;
  for (fr && n.nodeType == 1 && r < Rc(n) && $a(n.childNodes[r], -1) && (s = !0); ; )
    if (r > 0) {
      if (n.nodeType != 1)
        break;
      {
        let a = n.childNodes[r - 1];
        if ($a(a, -1))
          i = n, o = --r;
        else if (a.nodeType == 3)
          n = a, r = n.nodeValue.length;
        else
          break;
      }
    } else {
      if (VE(n))
        break;
      {
        let a = n.previousSibling;
        for (; a && $a(a, -1); )
          i = n.parentNode, o = Yt(a), a = a.previousSibling;
        if (a)
          n = a, r = Rc(n);
        else {
          if (n = n.parentNode, n == e.dom)
            break;
          r = 0;
        }
      }
    }
  s ? Ah(e, n, r) : i && Ah(e, i, o);
}
function YN(e) {
  let t = e.domSelectionRange(), n = t.focusNode, r = t.focusOffset;
  if (!n)
    return;
  let i = Rc(n), o, s;
  for (; ; )
    if (r < i) {
      if (n.nodeType != 1)
        break;
      let a = n.childNodes[r];
      if ($a(a, 1))
        o = n, s = ++r;
      else
        break;
    } else {
      if (VE(n))
        break;
      {
        let a = n.nextSibling;
        for (; a && $a(a, 1); )
          o = a.parentNode, s = Yt(a) + 1, a = a.nextSibling;
        if (a)
          n = a, r = 0, i = Rc(n);
        else {
          if (n = n.parentNode, n == e.dom)
            break;
          r = i = 0;
        }
      }
    }
  o && Ah(e, o, s);
}
function VE(e) {
  let t = e.pmViewDesc;
  return t && t.node && t.node.isBlock;
}
function QN(e, t) {
  for (; e && t == e.childNodes.length && !jl(e); )
    t = Yt(e) + 1, e = e.parentNode;
  for (; e && t < e.childNodes.length; ) {
    let n = e.childNodes[t];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    e = n, t = 0;
  }
}
function ZN(e, t) {
  for (; e && !t && !jl(e); )
    t = Yt(e), e = e.parentNode;
  for (; e && t; ) {
    let n = e.childNodes[t - 1];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    e = n, t = e.childNodes.length;
  }
}
function Ah(e, t, n) {
  if (t.nodeType != 3) {
    let o, s;
    (s = QN(t, n)) ? (t = s, n = 0) : (o = ZN(t, n)) && (t = o, n = o.nodeValue.length);
  }
  let r = e.domSelection();
  if (!r)
    return;
  if (od(r)) {
    let o = document.createRange();
    o.setEnd(t, n), o.setStart(t, n), r.removeAllRanges(), r.addRange(o);
  } else r.extend && r.extend(t, n);
  e.domObserver.setCurSelection();
  let { state: i } = e;
  setTimeout(() => {
    e.state == i && ui(e);
  }, 50);
}
function Dm(e, t) {
  let n = e.state.doc.resolve(t);
  if (!(an || vN) && n.parent.inlineContent) {
    let i = e.coordsAtPos(t);
    if (t > n.start()) {
      let o = e.coordsAtPos(t - 1), s = (o.top + o.bottom) / 2;
      if (s > i.top && s < i.bottom && Math.abs(o.left - i.left) > 1)
        return o.left < i.left ? "ltr" : "rtl";
    }
    if (t < n.end()) {
      let o = e.coordsAtPos(t + 1), s = (o.top + o.bottom) / 2;
      if (s > i.top && s < i.bottom && Math.abs(o.left - i.left) > 1)
        return o.left > i.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(e.dom).direction == "rtl" ? "rtl" : "ltr";
}
function Om(e, t, n) {
  let r = e.state.selection;
  if (r instanceof Oe && !r.empty || n.indexOf("s") > -1 || Kn && n.indexOf("m") > -1)
    return !1;
  let { $from: i, $to: o } = r;
  if (!i.parent.inlineContent || e.endOfTextblock(t < 0 ? "up" : "down")) {
    let s = Mh(e.state, t);
    if (s && s instanceof Ce)
      return vi(e, s);
  }
  if (!i.parent.inlineContent) {
    let s = t < 0 ? i : o, a = r instanceof cr ? Be.near(s, t) : Be.findFrom(s, t);
    return a ? vi(e, a) : !1;
  }
  return !1;
}
function Im(e, t) {
  if (!(e.state.selection instanceof Oe))
    return !0;
  let { $head: n, $anchor: r, empty: i } = e.state.selection;
  if (!n.sameParent(r))
    return !0;
  if (!i)
    return !1;
  if (e.endOfTextblock(t > 0 ? "forward" : "backward"))
    return !0;
  let o = !n.textOffset && (t < 0 ? n.nodeBefore : n.nodeAfter);
  if (o && !o.isText) {
    let s = e.state.tr;
    return t < 0 ? s.delete(n.pos - o.nodeSize, n.pos) : s.delete(n.pos, n.pos + o.nodeSize), e.dispatch(s), !0;
  }
  return !1;
}
function Rm(e, t, n) {
  e.domObserver.stop(), t.contentEditable = n, e.domObserver.start();
}
function XN(e) {
  if (!hn || e.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: t, focusOffset: n } = e.domSelectionRange();
  if (t && t.nodeType == 1 && n == 0 && t.firstChild && t.firstChild.contentEditable == "false") {
    let r = t.firstChild;
    Rm(e, r, "true"), setTimeout(() => Rm(e, r, "false"), 20);
  }
  return !1;
}
function JN(e) {
  let t = "";
  return e.ctrlKey && (t += "c"), e.metaKey && (t += "m"), e.altKey && (t += "a"), e.shiftKey && (t += "s"), t;
}
function eD(e, t) {
  let n = t.keyCode, r = JN(t);
  if (n == 8 || Kn && n == 72 && r == "c")
    return Im(e, -1) || Ho(e, -1);
  if (n == 46 && !t.shiftKey || Kn && n == 68 && r == "c")
    return Im(e, 1) || Ho(e, 1);
  if (n == 13 || n == 27)
    return !0;
  if (n == 37 || Kn && n == 66 && r == "c") {
    let i = n == 37 ? Dm(e, e.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return Nm(e, i, r) || Ho(e, i);
  } else if (n == 39 || Kn && n == 70 && r == "c") {
    let i = n == 39 ? Dm(e, e.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return Nm(e, i, r) || Ho(e, i);
  } else {
    if (n == 38 || Kn && n == 80 && r == "c")
      return Om(e, -1, r) || Ho(e, -1);
    if (n == 40 || Kn && n == 78 && r == "c")
      return XN(e) || Om(e, 1, r) || Ho(e, 1);
    if (r == (Kn ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
      return !0;
  }
  return !1;
}
function HE(e, t) {
  e.someProp("transformCopied", (p) => {
    t = p(t, e);
  });
  let n = [], { content: r, openStart: i, openEnd: o } = t;
  for (; i > 1 && o > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
    i--, o--;
    let p = r.firstChild;
    n.push(p.type.name, p.attrs != p.type.defaultAttrs ? p.attrs : null), r = p.content;
  }
  let s = e.someProp("clipboardSerializer") || $o.fromSchema(e.state.schema), a = QE(), l = a.createElement("div");
  l.appendChild(s.serializeFragment(r, { document: a }));
  let u = l.firstChild, c, f = 0;
  for (; u && u.nodeType == 1 && (c = YE[u.nodeName.toLowerCase()]); ) {
    for (let p = c.length - 1; p >= 0; p--) {
      let h = a.createElement(c[p]);
      for (; l.firstChild; )
        h.appendChild(l.firstChild);
      l.appendChild(h), f++;
    }
    u = l.firstChild;
  }
  u && u.nodeType == 1 && u.setAttribute("data-pm-slice", `${i} ${o}${f ? ` -${f}` : ""} ${JSON.stringify(n)}`);
  let d = e.someProp("clipboardTextSerializer", (p) => p(t, e)) || t.content.textBetween(0, t.content.size, `

`);
  return { dom: l, text: d, slice: t };
}
function qE(e, t, n, r, i) {
  let o = i.parent.type.spec.code, s, a;
  if (!n && !t)
    return null;
  let l = t && (r || o || !n);
  if (l) {
    if (e.someProp("transformPastedText", (d) => {
      t = d(t, o || r, e);
    }), o)
      return t ? new ye(te.from(e.state.schema.text(t.replace(/\r\n?/g, `
`))), 0, 0) : ye.empty;
    let f = e.someProp("clipboardTextParser", (d) => d(t, i, r, e));
    if (f)
      a = f;
    else {
      let d = i.marks(), { schema: p } = e.state, h = $o.fromSchema(p);
      s = document.createElement("div"), t.split(/(?:\r\n?|\n)+/).forEach((m) => {
        let g = s.appendChild(document.createElement("p"));
        m && g.appendChild(h.serializeNode(p.text(m, d)));
      });
    }
  } else
    e.someProp("transformPastedHTML", (f) => {
      n = f(n, e);
    }), s = iD(n), Ul && oD(s);
  let u = s && s.querySelector("[data-pm-slice]"), c = u && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(u.getAttribute("data-pm-slice") || "");
  if (c && c[3])
    for (let f = +c[3]; f > 0; f--) {
      let d = s.firstChild;
      for (; d && d.nodeType != 1; )
        d = d.nextSibling;
      if (!d)
        break;
      s = d;
    }
  if (a || (a = (e.someProp("clipboardParser") || e.someProp("domParser") || li.fromSchema(e.state.schema)).parseSlice(s, {
    preserveWhitespace: !!(l || c),
    context: i,
    ruleFromNode(d) {
      return d.nodeName == "BR" && !d.nextSibling && d.parentNode && !tD.test(d.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), c)
    a = sD(Lm(a, +c[1], +c[2]), c[4]);
  else if (a = ye.maxOpen(nD(a.content, i), !0), a.openStart || a.openEnd) {
    let f = 0, d = 0;
    for (let p = a.content.firstChild; f < a.openStart && !p.type.spec.isolating; f++, p = p.firstChild)
      ;
    for (let p = a.content.lastChild; d < a.openEnd && !p.type.spec.isolating; d++, p = p.lastChild)
      ;
    a = Lm(a, f, d);
  }
  return e.someProp("transformPasted", (f) => {
    a = f(a, e);
  }), a;
}
const tD = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function nD(e, t) {
  if (e.childCount < 2)
    return e;
  for (let n = t.depth; n >= 0; n--) {
    let i = t.node(n).contentMatchAt(t.index(n)), o, s = [];
    if (e.forEach((a) => {
      if (!s)
        return;
      let l = i.findWrapping(a.type), u;
      if (!l)
        return s = null;
      if (u = s.length && o.length && WE(l, o, a, s[s.length - 1], 0))
        s[s.length - 1] = u;
      else {
        s.length && (s[s.length - 1] = KE(s[s.length - 1], o.length));
        let c = GE(a, l);
        s.push(c), i = i.matchType(c.type), o = l;
      }
    }), s)
      return te.from(s);
  }
  return e;
}
function GE(e, t, n = 0) {
  for (let r = t.length - 1; r >= n; r--)
    e = t[r].create(null, te.from(e));
  return e;
}
function WE(e, t, n, r, i) {
  if (i < e.length && i < t.length && e[i] == t[i]) {
    let o = WE(e, t, n, r.lastChild, i + 1);
    if (o)
      return r.copy(r.content.replaceChild(r.childCount - 1, o));
    if (r.contentMatchAt(r.childCount).matchType(i == e.length - 1 ? n.type : e[i + 1]))
      return r.copy(r.content.append(te.from(GE(n, e, i + 1))));
  }
}
function KE(e, t) {
  if (t == 0)
    return e;
  let n = e.content.replaceChild(e.childCount - 1, KE(e.lastChild, t - 1)), r = e.contentMatchAt(e.childCount).fillBefore(te.empty, !0);
  return e.copy(n.append(r));
}
function Th(e, t, n, r, i, o) {
  let s = t < 0 ? e.firstChild : e.lastChild, a = s.content;
  return e.childCount > 1 && (o = 0), i < r - 1 && (a = Th(a, t, n, r, i + 1, o)), i >= n && (a = t < 0 ? s.contentMatchAt(0).fillBefore(a, o <= i).append(a) : a.append(s.contentMatchAt(s.childCount).fillBefore(te.empty, !0))), e.replaceChild(t < 0 ? 0 : e.childCount - 1, s.copy(a));
}
function Lm(e, t, n) {
  return t < e.openStart && (e = new ye(Th(e.content, -1, t, e.openStart, 0, e.openEnd), t, e.openEnd)), n < e.openEnd && (e = new ye(Th(e.content, 1, n, e.openEnd, 0, 0), e.openStart, n)), e;
}
const YE = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let Bm = null;
function QE() {
  return Bm || (Bm = document.implementation.createHTMLDocument("title"));
}
let lp = null;
function rD(e) {
  let t = window.trustedTypes;
  return t ? (lp || (lp = t.createPolicy("ProseMirrorClipboard", { createHTML: (n) => n })), lp.createHTML(e)) : e;
}
function iD(e) {
  let t = /^(\s*<meta [^>]*>)*/.exec(e);
  t && (e = e.slice(t[0].length));
  let n = QE().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(e), i;
  if ((i = r && YE[r[1].toLowerCase()]) && (e = i.map((o) => "<" + o + ">").join("") + e + i.map((o) => "</" + o + ">").reverse().join("")), n.innerHTML = rD(e), i)
    for (let o = 0; o < i.length; o++)
      n = n.querySelector(i[o]) || n;
  return n;
}
function oD(e) {
  let t = e.querySelectorAll(an ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let n = 0; n < t.length; n++) {
    let r = t[n];
    r.childNodes.length == 1 && r.textContent == "" && r.parentNode && r.parentNode.replaceChild(e.ownerDocument.createTextNode(" "), r);
  }
}
function sD(e, t) {
  if (!e.size)
    return e;
  let n = e.content.firstChild.type.schema, r;
  try {
    r = JSON.parse(t);
  } catch {
    return e;
  }
  let { content: i, openStart: o, openEnd: s } = e;
  for (let a = r.length - 2; a >= 0; a -= 2) {
    let l = n.nodes[r[a]];
    if (!l || l.hasRequiredAttrs())
      break;
    i = te.from(l.create(r[a + 1], i)), o++, s++;
  }
  return new ye(i, o, s);
}
const gn = {}, mn = {}, aD = { touchstart: !0, touchmove: !0 };
class lD {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "" }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastAndroidDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function uD(e) {
  for (let t in gn) {
    let n = gn[t];
    e.dom.addEventListener(t, e.input.eventHandlers[t] = (r) => {
      fD(e, r) && !Z0(e, r) && (e.editable || !(r.type in mn)) && n(e, r);
    }, aD[t] ? { passive: !0 } : void 0);
  }
  hn && e.dom.addEventListener("input", () => null), Sh(e);
}
function Ri(e, t) {
  e.input.lastSelectionOrigin = t, e.input.lastSelectionTime = Date.now();
}
function cD(e) {
  e.domObserver.stop();
  for (let t in e.input.eventHandlers)
    e.dom.removeEventListener(t, e.input.eventHandlers[t]);
  clearTimeout(e.input.composingTimeout), clearTimeout(e.input.lastIOSEnterFallbackTimeout);
}
function Sh(e) {
  e.someProp("handleDOMEvents", (t) => {
    for (let n in t)
      e.input.eventHandlers[n] || e.dom.addEventListener(n, e.input.eventHandlers[n] = (r) => Z0(e, r));
  });
}
function Z0(e, t) {
  return e.someProp("handleDOMEvents", (n) => {
    let r = n[t.type];
    return r ? r(e, t) || t.defaultPrevented : !1;
  });
}
function fD(e, t) {
  if (!t.bubbles)
    return !0;
  if (t.defaultPrevented)
    return !1;
  for (let n = t.target; n != e.dom; n = n.parentNode)
    if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(t))
      return !1;
  return !0;
}
function dD(e, t) {
  !Z0(e, t) && gn[t.type] && (e.editable || !(t.type in mn)) && gn[t.type](e, t);
}
mn.keydown = (e, t) => {
  let n = t;
  if (e.input.shiftKey = n.keyCode == 16 || n.shiftKey, !XE(e, n) && (e.input.lastKeyCode = n.keyCode, e.input.lastKeyCodeTime = Date.now(), !(or && an && n.keyCode == 13)))
    if (n.keyCode != 229 && e.domObserver.forceFlush(), ks && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
      let r = Date.now();
      e.input.lastIOSEnter = r, e.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        e.input.lastIOSEnter == r && (e.someProp("handleKeyDown", (i) => i(e, lo(13, "Enter"))), e.input.lastIOSEnter = 0);
      }, 200);
    } else e.someProp("handleKeyDown", (r) => r(e, n)) || eD(e, n) ? n.preventDefault() : Ri(e, "key");
};
mn.keyup = (e, t) => {
  t.keyCode == 16 && (e.input.shiftKey = !1);
};
mn.keypress = (e, t) => {
  let n = t;
  if (XE(e, n) || !n.charCode || n.ctrlKey && !n.altKey || Kn && n.metaKey)
    return;
  if (e.someProp("handleKeyPress", (i) => i(e, n))) {
    n.preventDefault();
    return;
  }
  let r = e.state.selection;
  if (!(r instanceof Oe) || !r.$from.sameParent(r.$to)) {
    let i = String.fromCharCode(n.charCode);
    !/[\r\n]/.test(i) && !e.someProp("handleTextInput", (o) => o(e, r.$from.pos, r.$to.pos, i)) && e.dispatch(e.state.tr.insertText(i).scrollIntoView()), n.preventDefault();
  }
};
function ad(e) {
  return { left: e.clientX, top: e.clientY };
}
function pD(e, t) {
  let n = t.x - e.clientX, r = t.y - e.clientY;
  return n * n + r * r < 100;
}
function X0(e, t, n, r, i) {
  if (r == -1)
    return !1;
  let o = e.state.doc.resolve(r);
  for (let s = o.depth + 1; s > 0; s--)
    if (e.someProp(t, (a) => s > o.depth ? a(e, n, o.nodeAfter, o.before(s), i, !0) : a(e, n, o.node(s), o.before(s), i, !1)))
      return !0;
  return !1;
}
function ps(e, t, n) {
  if (e.focused || e.focus(), e.state.selection.eq(t))
    return;
  let r = e.state.tr.setSelection(t);
  r.setMeta("pointer", !0), e.dispatch(r);
}
function hD(e, t) {
  if (t == -1)
    return !1;
  let n = e.state.doc.resolve(t), r = n.nodeAfter;
  return r && r.isAtom && Ce.isSelectable(r) ? (ps(e, new Ce(n)), !0) : !1;
}
function gD(e, t) {
  if (t == -1)
    return !1;
  let n = e.state.selection, r, i;
  n instanceof Ce && (r = n.node);
  let o = e.state.doc.resolve(t);
  for (let s = o.depth + 1; s > 0; s--) {
    let a = s > o.depth ? o.nodeAfter : o.node(s);
    if (Ce.isSelectable(a)) {
      r && n.$from.depth > 0 && s >= n.$from.depth && o.before(n.$from.depth + 1) == n.$from.pos ? i = o.before(n.$from.depth) : i = o.before(s);
      break;
    }
  }
  return i != null ? (ps(e, Ce.create(e.state.doc, i)), !0) : !1;
}
function mD(e, t, n, r, i) {
  return X0(e, "handleClickOn", t, n, r) || e.someProp("handleClick", (o) => o(e, t, r)) || (i ? gD(e, n) : hD(e, n));
}
function bD(e, t, n, r) {
  return X0(e, "handleDoubleClickOn", t, n, r) || e.someProp("handleDoubleClick", (i) => i(e, t, r));
}
function yD(e, t, n, r) {
  return X0(e, "handleTripleClickOn", t, n, r) || e.someProp("handleTripleClick", (i) => i(e, t, r)) || vD(e, n, r);
}
function vD(e, t, n) {
  if (n.button != 0)
    return !1;
  let r = e.state.doc;
  if (t == -1)
    return r.inlineContent ? (ps(e, Oe.create(r, 0, r.content.size)), !0) : !1;
  let i = r.resolve(t);
  for (let o = i.depth + 1; o > 0; o--) {
    let s = o > i.depth ? i.nodeAfter : i.node(o), a = i.before(o);
    if (s.inlineContent)
      ps(e, Oe.create(r, a + 1, a + 1 + s.content.size));
    else if (Ce.isSelectable(s))
      ps(e, Ce.create(r, a));
    else
      continue;
    return !0;
  }
}
function J0(e) {
  return Lc(e);
}
const ZE = Kn ? "metaKey" : "ctrlKey";
gn.mousedown = (e, t) => {
  let n = t;
  e.input.shiftKey = n.shiftKey;
  let r = J0(e), i = Date.now(), o = "singleClick";
  i - e.input.lastClick.time < 500 && pD(n, e.input.lastClick) && !n[ZE] && (e.input.lastClick.type == "singleClick" ? o = "doubleClick" : e.input.lastClick.type == "doubleClick" && (o = "tripleClick")), e.input.lastClick = { time: i, x: n.clientX, y: n.clientY, type: o };
  let s = e.posAtCoords(ad(n));
  s && (o == "singleClick" ? (e.input.mouseDown && e.input.mouseDown.done(), e.input.mouseDown = new _D(e, s, n, !!r)) : (o == "doubleClick" ? bD : yD)(e, s.pos, s.inside, n) ? n.preventDefault() : Ri(e, "pointer"));
};
class _D {
  constructor(t, n, r, i) {
    this.view = t, this.pos = n, this.event = r, this.flushed = i, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = t.state.doc, this.selectNode = !!r[ZE], this.allowDefault = r.shiftKey;
    let o, s;
    if (n.inside > -1)
      o = t.state.doc.nodeAt(n.inside), s = n.inside;
    else {
      let c = t.state.doc.resolve(n.pos);
      o = c.parent, s = c.depth ? c.before() : 0;
    }
    const a = i ? null : r.target, l = a ? t.docView.nearestDesc(a, !0) : null;
    this.target = l && l.dom.nodeType == 1 ? l.dom : null;
    let { selection: u } = t.state;
    (r.button == 0 && o.type.spec.draggable && o.type.spec.selectable !== !1 || u instanceof Ce && u.from <= s && u.to > s) && (this.mightDrag = {
      node: o,
      pos: s,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && fr && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), t.root.addEventListener("mouseup", this.up = this.up.bind(this)), t.root.addEventListener("mousemove", this.move = this.move.bind(this)), Ri(t, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => ui(this.view)), this.view.input.mouseDown = null;
  }
  up(t) {
    if (this.done(), !this.view.dom.contains(t.target))
      return;
    let n = this.pos;
    this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(ad(t))), this.updateAllowDefault(t), this.allowDefault || !n ? Ri(this.view, "pointer") : mD(this.view, n.pos, n.inside, t, this.selectNode) ? t.preventDefault() : t.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    hn && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    an && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (ps(this.view, Be.near(this.view.state.doc.resolve(n.pos))), t.preventDefault()) : Ri(this.view, "pointer");
  }
  move(t) {
    this.updateAllowDefault(t), Ri(this.view, "pointer"), t.buttons == 0 && this.done();
  }
  updateAllowDefault(t) {
    !this.allowDefault && (Math.abs(this.event.x - t.clientX) > 4 || Math.abs(this.event.y - t.clientY) > 4) && (this.allowDefault = !0);
  }
}
gn.touchstart = (e) => {
  e.input.lastTouch = Date.now(), J0(e), Ri(e, "pointer");
};
gn.touchmove = (e) => {
  e.input.lastTouch = Date.now(), Ri(e, "pointer");
};
gn.contextmenu = (e) => J0(e);
function XE(e, t) {
  return e.composing ? !0 : hn && Math.abs(t.timeStamp - e.input.compositionEndedAt) < 500 ? (e.input.compositionEndedAt = -2e8, !0) : !1;
}
const ED = or ? 5e3 : -1;
mn.compositionstart = mn.compositionupdate = (e) => {
  if (!e.composing) {
    e.domObserver.flush();
    let { state: t } = e, n = t.selection.$to;
    if (t.selection instanceof Oe && (t.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
      e.markCursor = e.state.storedMarks || n.marks(), Lc(e, !0), e.markCursor = null;
    else if (Lc(e, !t.selection.empty), fr && t.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
      let r = e.domSelectionRange();
      for (let i = r.focusNode, o = r.focusOffset; i && i.nodeType == 1 && o != 0; ) {
        let s = o < 0 ? i.lastChild : i.childNodes[o - 1];
        if (!s)
          break;
        if (s.nodeType == 3) {
          let a = e.domSelection();
          a && a.collapse(s, s.nodeValue.length);
          break;
        } else
          i = s, o = -1;
      }
    }
    e.input.composing = !0;
  }
  JE(e, ED);
};
mn.compositionend = (e, t) => {
  e.composing && (e.input.composing = !1, e.input.compositionEndedAt = t.timeStamp, e.input.compositionPendingChanges = e.domObserver.pendingRecords().length ? e.input.compositionID : 0, e.input.compositionNode = null, e.input.compositionPendingChanges && Promise.resolve().then(() => e.domObserver.flush()), e.input.compositionID++, JE(e, 20));
};
function JE(e, t) {
  clearTimeout(e.input.composingTimeout), t > -1 && (e.input.composingTimeout = setTimeout(() => Lc(e), t));
}
function e3(e) {
  for (e.composing && (e.input.composing = !1, e.input.compositionEndedAt = xD()); e.input.compositionNodes.length > 0; )
    e.input.compositionNodes.pop().markParentsDirty();
}
function wD(e) {
  let t = e.domSelectionRange();
  if (!t.focusNode)
    return null;
  let n = hN(t.focusNode, t.focusOffset), r = gN(t.focusNode, t.focusOffset);
  if (n && r && n != r) {
    let i = r.pmViewDesc, o = e.domObserver.lastChangedTextNode;
    if (n == o || r == o)
      return o;
    if (!i || !i.isText(r.nodeValue))
      return r;
    if (e.input.compositionNode == r) {
      let s = n.pmViewDesc;
      if (!(!s || !s.isText(n.nodeValue)))
        return r;
    }
  }
  return n || r;
}
function xD() {
  let e = document.createEvent("Event");
  return e.initEvent("event", !0, !0), e.timeStamp;
}
function Lc(e, t = !1) {
  if (!(or && e.domObserver.flushingSoon >= 0)) {
    if (e.domObserver.forceFlush(), e3(e), t || e.docView && e.docView.dirty) {
      let n = Y0(e);
      return n && !n.eq(e.state.selection) ? e.dispatch(e.state.tr.setSelection(n)) : (e.markCursor || t) && !e.state.selection.empty ? e.dispatch(e.state.tr.deleteSelection()) : e.updateState(e.state), !0;
    }
    return !1;
  }
}
function kD(e, t) {
  if (!e.dom.parentNode)
    return;
  let n = e.dom.parentNode.appendChild(document.createElement("div"));
  n.appendChild(t), n.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let r = getSelection(), i = document.createRange();
  i.selectNodeContents(t), e.dom.blur(), r.removeAllRanges(), r.addRange(i), setTimeout(() => {
    n.parentNode && n.parentNode.removeChild(n), e.focus();
  }, 50);
}
const rl = Mn && ji < 15 || ks && _N < 604;
gn.copy = mn.cut = (e, t) => {
  let n = t, r = e.state.selection, i = n.type == "cut";
  if (r.empty)
    return;
  let o = rl ? null : n.clipboardData, s = r.content(), { dom: a, text: l } = HE(e, s);
  o ? (n.preventDefault(), o.clearData(), o.setData("text/html", a.innerHTML), o.setData("text/plain", l)) : kD(e, a), i && e.dispatch(e.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function MD(e) {
  return e.openStart == 0 && e.openEnd == 0 && e.content.childCount == 1 ? e.content.firstChild : null;
}
function AD(e, t) {
  if (!e.dom.parentNode)
    return;
  let n = e.input.shiftKey || e.state.selection.$from.parent.type.spec.code, r = e.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
  n || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus();
  let i = e.input.shiftKey && e.input.lastKeyCode != 45;
  setTimeout(() => {
    e.focus(), r.parentNode && r.parentNode.removeChild(r), n ? il(e, r.value, null, i, t) : il(e, r.textContent, r.innerHTML, i, t);
  }, 50);
}
function il(e, t, n, r, i) {
  let o = qE(e, t, n, r, e.state.selection.$from);
  if (e.someProp("handlePaste", (l) => l(e, i, o || ye.empty)))
    return !0;
  if (!o)
    return !1;
  let s = MD(o), a = s ? e.state.tr.replaceSelectionWith(s, r) : e.state.tr.replaceSelection(o);
  return e.dispatch(a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function t3(e) {
  let t = e.getData("text/plain") || e.getData("Text");
  if (t)
    return t;
  let n = e.getData("text/uri-list");
  return n ? n.replace(/\r?\n/g, " ") : "";
}
mn.paste = (e, t) => {
  let n = t;
  if (e.composing && !or)
    return;
  let r = rl ? null : n.clipboardData, i = e.input.shiftKey && e.input.lastKeyCode != 45;
  r && il(e, t3(r), r.getData("text/html"), i, n) ? n.preventDefault() : AD(e, n);
};
class n3 {
  constructor(t, n, r) {
    this.slice = t, this.move = n, this.node = r;
  }
}
const r3 = Kn ? "altKey" : "ctrlKey";
gn.dragstart = (e, t) => {
  let n = t, r = e.input.mouseDown;
  if (r && r.done(), !n.dataTransfer)
    return;
  let i = e.state.selection, o = i.empty ? null : e.posAtCoords(ad(n)), s;
  if (!(o && o.pos >= i.from && o.pos <= (i instanceof Ce ? i.to - 1 : i.to))) {
    if (r && r.mightDrag)
      s = Ce.create(e.state.doc, r.mightDrag.pos);
    else if (n.target && n.target.nodeType == 1) {
      let f = e.docView.nearestDesc(n.target, !0);
      f && f.node.type.spec.draggable && f != e.docView && (s = Ce.create(e.state.doc, f.posBefore));
    }
  }
  let a = (s || e.state.selection).content(), { dom: l, text: u, slice: c } = HE(e, a);
  (!n.dataTransfer.files.length || !an || SE > 120) && n.dataTransfer.clearData(), n.dataTransfer.setData(rl ? "Text" : "text/html", l.innerHTML), n.dataTransfer.effectAllowed = "copyMove", rl || n.dataTransfer.setData("text/plain", u), e.dragging = new n3(c, !n[r3], s);
};
gn.dragend = (e) => {
  let t = e.dragging;
  window.setTimeout(() => {
    e.dragging == t && (e.dragging = null);
  }, 50);
};
mn.dragover = mn.dragenter = (e, t) => t.preventDefault();
mn.drop = (e, t) => {
  let n = t, r = e.dragging;
  if (e.dragging = null, !n.dataTransfer)
    return;
  let i = e.posAtCoords(ad(n));
  if (!i)
    return;
  let o = e.state.doc.resolve(i.pos), s = r && r.slice;
  s ? e.someProp("transformPasted", (h) => {
    s = h(s, e);
  }) : s = qE(e, t3(n.dataTransfer), rl ? null : n.dataTransfer.getData("text/html"), !1, o);
  let a = !!(r && !n[r3]);
  if (e.someProp("handleDrop", (h) => h(e, n, s || ye.empty, a))) {
    n.preventDefault();
    return;
  }
  if (!s)
    return;
  n.preventDefault();
  let l = s ? vE(e.state.doc, o.pos, s) : o.pos;
  l == null && (l = o.pos);
  let u = e.state.tr;
  if (a) {
    let { node: h } = r;
    h ? h.replace(u) : u.deleteSelection();
  }
  let c = u.mapping.map(l), f = s.openStart == 0 && s.openEnd == 0 && s.content.childCount == 1, d = u.doc;
  if (f ? u.replaceRangeWith(c, c, s.content.firstChild) : u.replaceRange(c, c, s), u.doc.eq(d))
    return;
  let p = u.doc.resolve(c);
  if (f && Ce.isSelectable(s.content.firstChild) && p.nodeAfter && p.nodeAfter.sameMarkup(s.content.firstChild))
    u.setSelection(new Ce(p));
  else {
    let h = u.mapping.map(l);
    u.mapping.maps[u.mapping.maps.length - 1].forEach((m, g, y, _) => h = _), u.setSelection(Q0(e, p, u.doc.resolve(h)));
  }
  e.focus(), e.dispatch(u.setMeta("uiEvent", "drop"));
};
gn.focus = (e) => {
  e.input.lastFocus = Date.now(), e.focused || (e.domObserver.stop(), e.dom.classList.add("ProseMirror-focused"), e.domObserver.start(), e.focused = !0, setTimeout(() => {
    e.docView && e.hasFocus() && !e.domObserver.currentSelection.eq(e.domSelectionRange()) && ui(e);
  }, 20));
};
gn.blur = (e, t) => {
  let n = t;
  e.focused && (e.domObserver.stop(), e.dom.classList.remove("ProseMirror-focused"), e.domObserver.start(), n.relatedTarget && e.dom.contains(n.relatedTarget) && e.domObserver.currentSelection.clear(), e.focused = !1);
};
gn.beforeinput = (e, t) => {
  if (an && or && t.inputType == "deleteContentBackward") {
    e.domObserver.flushSoon();
    let { domChangeCount: r } = e.input;
    setTimeout(() => {
      if (e.input.domChangeCount != r || (e.dom.blur(), e.focus(), e.someProp("handleKeyDown", (o) => o(e, lo(8, "Backspace")))))
        return;
      let { $cursor: i } = e.state.selection;
      i && i.pos > 0 && e.dispatch(e.state.tr.delete(i.pos - 1, i.pos).scrollIntoView());
    }, 50);
  }
};
for (let e in mn)
  gn[e] = mn[e];
function ol(e, t) {
  if (e == t)
    return !0;
  for (let n in e)
    if (e[n] !== t[n])
      return !1;
  for (let n in t)
    if (!(n in e))
      return !1;
  return !0;
}
class Bc {
  constructor(t, n) {
    this.toDOM = t, this.spec = n || vo, this.side = this.spec.side || 0;
  }
  map(t, n, r, i) {
    let { pos: o, deleted: s } = t.mapResult(n.from + i, this.side < 0 ? -1 : 1);
    return s ? null : new dn(o - r, o - r, this);
  }
  valid() {
    return !0;
  }
  eq(t) {
    return this == t || t instanceof Bc && (this.spec.key && this.spec.key == t.spec.key || this.toDOM == t.toDOM && ol(this.spec, t.spec));
  }
  destroy(t) {
    this.spec.destroy && this.spec.destroy(t);
  }
}
class Vi {
  constructor(t, n) {
    this.attrs = t, this.spec = n || vo;
  }
  map(t, n, r, i) {
    let o = t.map(n.from + i, this.spec.inclusiveStart ? -1 : 1) - r, s = t.map(n.to + i, this.spec.inclusiveEnd ? 1 : -1) - r;
    return o >= s ? null : new dn(o, s, this);
  }
  valid(t, n) {
    return n.from < n.to;
  }
  eq(t) {
    return this == t || t instanceof Vi && ol(this.attrs, t.attrs) && ol(this.spec, t.spec);
  }
  static is(t) {
    return t.type instanceof Vi;
  }
  destroy() {
  }
}
class eg {
  constructor(t, n) {
    this.attrs = t, this.spec = n || vo;
  }
  map(t, n, r, i) {
    let o = t.mapResult(n.from + i, 1);
    if (o.deleted)
      return null;
    let s = t.mapResult(n.to + i, -1);
    return s.deleted || s.pos <= o.pos ? null : new dn(o.pos - r, s.pos - r, this);
  }
  valid(t, n) {
    let { index: r, offset: i } = t.content.findIndex(n.from), o;
    return i == n.from && !(o = t.child(r)).isText && i + o.nodeSize == n.to;
  }
  eq(t) {
    return this == t || t instanceof eg && ol(this.attrs, t.attrs) && ol(this.spec, t.spec);
  }
  destroy() {
  }
}
class dn {
  /**
  @internal
  */
  constructor(t, n, r) {
    this.from = t, this.to = n, this.type = r;
  }
  /**
  @internal
  */
  copy(t, n) {
    return new dn(t, n, this.type);
  }
  /**
  @internal
  */
  eq(t, n = 0) {
    return this.type.eq(t.type) && this.from + n == t.from && this.to + n == t.to;
  }
  /**
  @internal
  */
  map(t, n, r) {
    return this.type.map(t, this, n, r);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(t, n, r) {
    return new dn(t, t, new Bc(n, r));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(t, n, r, i) {
    return new dn(t, n, new Vi(r, i));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(t, n, r, i) {
    return new dn(t, n, new eg(r, i));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof Vi;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof Bc;
  }
}
const Xo = [], vo = {};
class xt {
  /**
  @internal
  */
  constructor(t, n) {
    this.local = t.length ? t : Xo, this.children = n.length ? n : Xo;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(t, n) {
    return n.length ? Pc(n, t, 0, vo) : on;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(t, n, r) {
    let i = [];
    return this.findInner(t ?? 0, n ?? 1e9, i, 0, r), i;
  }
  findInner(t, n, r, i, o) {
    for (let s = 0; s < this.local.length; s++) {
      let a = this.local[s];
      a.from <= n && a.to >= t && (!o || o(a.spec)) && r.push(a.copy(a.from + i, a.to + i));
    }
    for (let s = 0; s < this.children.length; s += 3)
      if (this.children[s] < n && this.children[s + 1] > t) {
        let a = this.children[s] + 1;
        this.children[s + 2].findInner(t - a, n - a, r, i + a, o);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(t, n, r) {
    return this == on || t.maps.length == 0 ? this : this.mapInner(t, n, 0, 0, r || vo);
  }
  /**
  @internal
  */
  mapInner(t, n, r, i, o) {
    let s;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a].map(t, r, i);
      l && l.type.valid(n, l) ? (s || (s = [])).push(l) : o.onRemove && o.onRemove(this.local[a].spec);
    }
    return this.children.length ? TD(this.children, s || [], t, n, r, i, o) : s ? new xt(s.sort(_o), Xo) : on;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(t, n) {
    return n.length ? this == on ? xt.create(t, n) : this.addInner(t, n, 0) : this;
  }
  addInner(t, n, r) {
    let i, o = 0;
    t.forEach((a, l) => {
      let u = l + r, c;
      if (c = o3(n, a, u)) {
        for (i || (i = this.children.slice()); o < i.length && i[o] < l; )
          o += 3;
        i[o] == l ? i[o + 2] = i[o + 2].addInner(a, c, u + 1) : i.splice(o, 0, l, l + a.nodeSize, Pc(c, a, u + 1, vo)), o += 3;
      }
    });
    let s = i3(o ? s3(n) : n, -r);
    for (let a = 0; a < s.length; a++)
      s[a].type.valid(t, s[a]) || s.splice(a--, 1);
    return new xt(s.length ? this.local.concat(s).sort(_o) : this.local, i || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(t) {
    return t.length == 0 || this == on ? this : this.removeInner(t, 0);
  }
  removeInner(t, n) {
    let r = this.children, i = this.local;
    for (let o = 0; o < r.length; o += 3) {
      let s, a = r[o] + n, l = r[o + 1] + n;
      for (let c = 0, f; c < t.length; c++)
        (f = t[c]) && f.from > a && f.to < l && (t[c] = null, (s || (s = [])).push(f));
      if (!s)
        continue;
      r == this.children && (r = this.children.slice());
      let u = r[o + 2].removeInner(s, a + 1);
      u != on ? r[o + 2] = u : (r.splice(o, 3), o -= 3);
    }
    if (i.length) {
      for (let o = 0, s; o < t.length; o++)
        if (s = t[o])
          for (let a = 0; a < i.length; a++)
            i[a].eq(s, n) && (i == this.local && (i = this.local.slice()), i.splice(a--, 1));
    }
    return r == this.children && i == this.local ? this : i.length || r.length ? new xt(i, r) : on;
  }
  forChild(t, n) {
    if (this == on)
      return this;
    if (n.isLeaf)
      return xt.empty;
    let r, i;
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] >= t) {
        this.children[a] == t && (r = this.children[a + 2]);
        break;
      }
    let o = t + 1, s = o + n.content.size;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a];
      if (l.from < s && l.to > o && l.type instanceof Vi) {
        let u = Math.max(o, l.from) - o, c = Math.min(s, l.to) - o;
        u < c && (i || (i = [])).push(l.copy(u, c));
      }
    }
    if (i) {
      let a = new xt(i.sort(_o), Xo);
      return r ? new Ti([a, r]) : a;
    }
    return r || on;
  }
  /**
  @internal
  */
  eq(t) {
    if (this == t)
      return !0;
    if (!(t instanceof xt) || this.local.length != t.local.length || this.children.length != t.children.length)
      return !1;
    for (let n = 0; n < this.local.length; n++)
      if (!this.local[n].eq(t.local[n]))
        return !1;
    for (let n = 0; n < this.children.length; n += 3)
      if (this.children[n] != t.children[n] || this.children[n + 1] != t.children[n + 1] || !this.children[n + 2].eq(t.children[n + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(t) {
    return tg(this.localsInner(t));
  }
  /**
  @internal
  */
  localsInner(t) {
    if (this == on)
      return Xo;
    if (t.inlineContent || !this.local.some(Vi.is))
      return this.local;
    let n = [];
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof Vi || n.push(this.local[r]);
    return n;
  }
  forEachSet(t) {
    t(this);
  }
}
xt.empty = new xt([], []);
xt.removeOverlap = tg;
const on = xt.empty;
class Ti {
  constructor(t) {
    this.members = t;
  }
  map(t, n) {
    const r = this.members.map((i) => i.map(t, n, vo));
    return Ti.from(r);
  }
  forChild(t, n) {
    if (n.isLeaf)
      return xt.empty;
    let r = [];
    for (let i = 0; i < this.members.length; i++) {
      let o = this.members[i].forChild(t, n);
      o != on && (o instanceof Ti ? r = r.concat(o.members) : r.push(o));
    }
    return Ti.from(r);
  }
  eq(t) {
    if (!(t instanceof Ti) || t.members.length != this.members.length)
      return !1;
    for (let n = 0; n < this.members.length; n++)
      if (!this.members[n].eq(t.members[n]))
        return !1;
    return !0;
  }
  locals(t) {
    let n, r = !0;
    for (let i = 0; i < this.members.length; i++) {
      let o = this.members[i].localsInner(t);
      if (o.length)
        if (!n)
          n = o;
        else {
          r && (n = n.slice(), r = !1);
          for (let s = 0; s < o.length; s++)
            n.push(o[s]);
        }
    }
    return n ? tg(r ? n : n.sort(_o)) : Xo;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(t) {
    switch (t.length) {
      case 0:
        return on;
      case 1:
        return t[0];
      default:
        return new Ti(t.every((n) => n instanceof xt) ? t : t.reduce((n, r) => n.concat(r instanceof xt ? r : r.members), []));
    }
  }
  forEachSet(t) {
    for (let n = 0; n < this.members.length; n++)
      this.members[n].forEachSet(t);
  }
}
function TD(e, t, n, r, i, o, s) {
  let a = e.slice();
  for (let u = 0, c = o; u < n.maps.length; u++) {
    let f = 0;
    n.maps[u].forEach((d, p, h, m) => {
      let g = m - h - (p - d);
      for (let y = 0; y < a.length; y += 3) {
        let _ = a[y + 1];
        if (_ < 0 || d > _ + c - f)
          continue;
        let E = a[y] + c - f;
        p >= E ? a[y + 1] = d <= E ? -2 : -1 : d >= c && g && (a[y] += g, a[y + 1] += g);
      }
      f += g;
    }), c = n.maps[u].map(c, -1);
  }
  let l = !1;
  for (let u = 0; u < a.length; u += 3)
    if (a[u + 1] < 0) {
      if (a[u + 1] == -2) {
        l = !0, a[u + 1] = -1;
        continue;
      }
      let c = n.map(e[u] + o), f = c - i;
      if (f < 0 || f >= r.content.size) {
        l = !0;
        continue;
      }
      let d = n.map(e[u + 1] + o, -1), p = d - i, { index: h, offset: m } = r.content.findIndex(f), g = r.maybeChild(h);
      if (g && m == f && m + g.nodeSize == p) {
        let y = a[u + 2].mapInner(n, g, c + 1, e[u] + o + 1, s);
        y != on ? (a[u] = f, a[u + 1] = p, a[u + 2] = y) : (a[u + 1] = -2, l = !0);
      } else
        l = !0;
    }
  if (l) {
    let u = SD(a, e, t, n, i, o, s), c = Pc(u, r, 0, s);
    t = c.local;
    for (let f = 0; f < a.length; f += 3)
      a[f + 1] < 0 && (a.splice(f, 3), f -= 3);
    for (let f = 0, d = 0; f < c.children.length; f += 3) {
      let p = c.children[f];
      for (; d < a.length && a[d] < p; )
        d += 3;
      a.splice(d, 0, c.children[f], c.children[f + 1], c.children[f + 2]);
    }
  }
  return new xt(t.sort(_o), a);
}
function i3(e, t) {
  if (!t || !e.length)
    return e;
  let n = [];
  for (let r = 0; r < e.length; r++) {
    let i = e[r];
    n.push(new dn(i.from + t, i.to + t, i.type));
  }
  return n;
}
function SD(e, t, n, r, i, o, s) {
  function a(l, u) {
    for (let c = 0; c < l.local.length; c++) {
      let f = l.local[c].map(r, i, u);
      f ? n.push(f) : s.onRemove && s.onRemove(l.local[c].spec);
    }
    for (let c = 0; c < l.children.length; c += 3)
      a(l.children[c + 2], l.children[c] + u + 1);
  }
  for (let l = 0; l < e.length; l += 3)
    e[l + 1] == -1 && a(e[l + 2], t[l] + o + 1);
  return n;
}
function o3(e, t, n) {
  if (t.isLeaf)
    return null;
  let r = n + t.nodeSize, i = null;
  for (let o = 0, s; o < e.length; o++)
    (s = e[o]) && s.from > n && s.to < r && ((i || (i = [])).push(s), e[o] = null);
  return i;
}
function s3(e) {
  let t = [];
  for (let n = 0; n < e.length; n++)
    e[n] != null && t.push(e[n]);
  return t;
}
function Pc(e, t, n, r) {
  let i = [], o = !1;
  t.forEach((a, l) => {
    let u = o3(e, a, l + n);
    if (u) {
      o = !0;
      let c = Pc(u, a, n + l + 1, r);
      c != on && i.push(l, l + a.nodeSize, c);
    }
  });
  let s = i3(o ? s3(e) : e, -n).sort(_o);
  for (let a = 0; a < s.length; a++)
    s[a].type.valid(t, s[a]) || (r.onRemove && r.onRemove(s[a].spec), s.splice(a--, 1));
  return s.length || i.length ? new xt(s, i) : on;
}
function _o(e, t) {
  return e.from - t.from || e.to - t.to;
}
function tg(e) {
  let t = e;
  for (let n = 0; n < t.length - 1; n++) {
    let r = t[n];
    if (r.from != r.to)
      for (let i = n + 1; i < t.length; i++) {
        let o = t[i];
        if (o.from == r.from) {
          o.to != r.to && (t == e && (t = e.slice()), t[i] = o.copy(o.from, r.to), Pm(t, i + 1, o.copy(r.to, o.to)));
          continue;
        } else {
          o.from < r.to && (t == e && (t = e.slice()), t[n] = r.copy(r.from, o.from), Pm(t, i, r.copy(o.from, r.to)));
          break;
        }
      }
  }
  return t;
}
function Pm(e, t, n) {
  for (; t < e.length && _o(n, e[t]) > 0; )
    t++;
  e.splice(t, 0, n);
}
function up(e) {
  let t = [];
  return e.someProp("decorations", (n) => {
    let r = n(e.state);
    r && r != on && t.push(r);
  }), e.cursorWrapper && t.push(xt.create(e.state.doc, [e.cursorWrapper.deco])), Ti.from(t);
}
const CD = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, ND = Mn && ji <= 11;
class DD {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(t) {
    this.anchorNode = t.anchorNode, this.anchorOffset = t.anchorOffset, this.focusNode = t.focusNode, this.focusOffset = t.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(t) {
    return t.anchorNode == this.anchorNode && t.anchorOffset == this.anchorOffset && t.focusNode == this.focusNode && t.focusOffset == this.focusOffset;
  }
}
class OD {
  constructor(t, n) {
    this.view = t, this.handleDOMChange = n, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new DD(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((r) => {
      for (let i = 0; i < r.length; i++)
        this.queue.push(r[i]);
      Mn && ji <= 11 && r.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), ND && (this.onCharData = (r) => {
      this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, CD)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let t = this.observer.takeRecords();
      if (t.length) {
        for (let n = 0; n < t.length; n++)
          this.queue.push(t[n]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (Cm(this.view)) {
      if (this.suppressingSelectionUpdates)
        return ui(this.view);
      if (Mn && ji <= 11 && !this.view.state.selection.empty) {
        let t = this.view.domSelectionRange();
        if (t.focusNode && Do(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(t) {
    if (!t.focusNode)
      return !0;
    let n = /* @__PURE__ */ new Set(), r;
    for (let o = t.focusNode; o; o = nl(o))
      n.add(o);
    for (let o = t.anchorNode; o; o = nl(o))
      if (n.has(o)) {
        r = o;
        break;
      }
    let i = r && this.view.docView.nearestDesc(r);
    if (i && i.ignoreMutation({
      type: "selection",
      target: r.nodeType == 3 ? r.parentNode : r
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let t of this.observer.takeRecords())
        this.queue.push(t);
    return this.queue;
  }
  flush() {
    let { view: t } = this;
    if (!t.docView || this.flushingSoon > -1)
      return;
    let n = this.pendingRecords();
    n.length && (this.queue = []);
    let r = t.domSelectionRange(), i = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && Cm(t) && !this.ignoreSelectionChange(r), o = -1, s = -1, a = !1, l = [];
    if (t.editable)
      for (let c = 0; c < n.length; c++) {
        let f = this.registerMutation(n[c], l);
        f && (o = o < 0 ? f.from : Math.min(f.from, o), s = s < 0 ? f.to : Math.max(f.to, s), f.typeOver && (a = !0));
      }
    if (fr && l.length) {
      let c = l.filter((f) => f.nodeName == "BR");
      if (c.length == 2) {
        let [f, d] = c;
        f.parentNode && f.parentNode.parentNode == d.parentNode ? d.remove() : f.remove();
      } else {
        let { focusNode: f } = this.currentSelection;
        for (let d of c) {
          let p = d.parentNode;
          p && p.nodeName == "LI" && (!f || LD(t, f) != p) && d.remove();
        }
      }
    }
    let u = null;
    o < 0 && i && t.input.lastFocus > Date.now() - 200 && Math.max(t.input.lastTouch, t.input.lastClick.time) < Date.now() - 300 && od(r) && (u = Y0(t)) && u.eq(Be.near(t.state.doc.resolve(0), 1)) ? (t.input.lastFocus = 0, ui(t), this.currentSelection.set(r), t.scrollToSelection()) : (o > -1 || i) && (o > -1 && (t.docView.markDirty(o, s), ID(t)), this.handleDOMChange(o, s, a, l), t.docView && t.docView.dirty ? t.updateState(t.state) : this.currentSelection.eq(r) || ui(t), this.currentSelection.set(r));
  }
  registerMutation(t, n) {
    if (n.indexOf(t.target) > -1)
      return null;
    let r = this.view.docView.nearestDesc(t.target);
    if (t.type == "attributes" && (r == this.view.docView || t.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    t.attributeName == "style" && !t.oldValue && !t.target.getAttribute("style")) || !r || r.ignoreMutation(t))
      return null;
    if (t.type == "childList") {
      for (let c = 0; c < t.addedNodes.length; c++) {
        let f = t.addedNodes[c];
        n.push(f), f.nodeType == 3 && (this.lastChangedTextNode = f);
      }
      if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(t.target))
        return { from: r.posBefore, to: r.posAfter };
      let i = t.previousSibling, o = t.nextSibling;
      if (Mn && ji <= 11 && t.addedNodes.length)
        for (let c = 0; c < t.addedNodes.length; c++) {
          let { previousSibling: f, nextSibling: d } = t.addedNodes[c];
          (!f || Array.prototype.indexOf.call(t.addedNodes, f) < 0) && (i = f), (!d || Array.prototype.indexOf.call(t.addedNodes, d) < 0) && (o = d);
        }
      let s = i && i.parentNode == t.target ? Yt(i) + 1 : 0, a = r.localPosFromDOM(t.target, s, -1), l = o && o.parentNode == t.target ? Yt(o) : t.target.childNodes.length, u = r.localPosFromDOM(t.target, l, 1);
      return { from: a, to: u };
    } else return t.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : (this.lastChangedTextNode = t.target, {
      from: r.posAtStart,
      to: r.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: t.target.nodeValue == t.oldValue
    });
  }
}
let $m = /* @__PURE__ */ new WeakMap(), zm = !1;
function ID(e) {
  if (!$m.has(e) && ($m.set(e, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(e.dom).whiteSpace) !== -1)) {
    if (e.requiresGeckoHackNode = fr, zm)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), zm = !0;
  }
}
function Fm(e, t) {
  let n = t.startContainer, r = t.startOffset, i = t.endContainer, o = t.endOffset, s = e.domAtPos(e.state.selection.anchor);
  return Do(s.node, s.offset, i, o) && ([n, r, i, o] = [i, o, n, r]), { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: o };
}
function RD(e, t) {
  if (t.getComposedRanges) {
    let i = t.getComposedRanges(e.root)[0];
    if (i)
      return Fm(e, i);
  }
  let n;
  function r(i) {
    i.preventDefault(), i.stopImmediatePropagation(), n = i.getTargetRanges()[0];
  }
  return e.dom.addEventListener("beforeinput", r, !0), document.execCommand("indent"), e.dom.removeEventListener("beforeinput", r, !0), n ? Fm(e, n) : null;
}
function LD(e, t) {
  for (let n = t.parentNode; n && n != e.dom; n = n.parentNode) {
    let r = e.docView.nearestDesc(n, !0);
    if (r && r.node.isBlock)
      return n;
  }
  return null;
}
function BD(e, t, n) {
  let { node: r, fromOffset: i, toOffset: o, from: s, to: a } = e.docView.parseRange(t, n), l = e.domSelectionRange(), u, c = l.anchorNode;
  if (c && e.dom.contains(c.nodeType == 1 ? c : c.parentNode) && (u = [{ node: c, offset: l.anchorOffset }], od(l) || u.push({ node: l.focusNode, offset: l.focusOffset })), an && e.input.lastKeyCode === 8)
    for (let g = o; g > i; g--) {
      let y = r.childNodes[g - 1], _ = y.pmViewDesc;
      if (y.nodeName == "BR" && !_) {
        o = g;
        break;
      }
      if (!_ || _.size)
        break;
    }
  let f = e.state.doc, d = e.someProp("domParser") || li.fromSchema(e.state.schema), p = f.resolve(s), h = null, m = d.parse(r, {
    topNode: p.parent,
    topMatch: p.parent.contentMatchAt(p.index()),
    topOpen: !0,
    from: i,
    to: o,
    preserveWhitespace: p.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: u,
    ruleFromNode: PD,
    context: p
  });
  if (u && u[0].pos != null) {
    let g = u[0].pos, y = u[1] && u[1].pos;
    y == null && (y = g), h = { anchor: g + s, head: y + s };
  }
  return { doc: m, sel: h, from: s, to: a };
}
function PD(e) {
  let t = e.pmViewDesc;
  if (t)
    return t.parseRule();
  if (e.nodeName == "BR" && e.parentNode) {
    if (hn && /^(ul|ol)$/i.test(e.parentNode.nodeName)) {
      let n = document.createElement("div");
      return n.appendChild(document.createElement("li")), { skip: n };
    } else if (e.parentNode.lastChild == e || hn && /^(tr|table)$/i.test(e.parentNode.nodeName))
      return { ignore: !0 };
  } else if (e.nodeName == "IMG" && e.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const $D = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function zD(e, t, n, r, i) {
  let o = e.input.compositionPendingChanges || (e.composing ? e.input.compositionID : 0);
  if (e.input.compositionPendingChanges = 0, t < 0) {
    let C = e.input.lastSelectionTime > Date.now() - 50 ? e.input.lastSelectionOrigin : null, z = Y0(e, C);
    if (z && !e.state.selection.eq(z)) {
      if (an && or && e.input.lastKeyCode === 13 && Date.now() - 100 < e.input.lastKeyCodeTime && e.someProp("handleKeyDown", (j) => j(e, lo(13, "Enter"))))
        return;
      let H = e.state.tr.setSelection(z);
      C == "pointer" ? H.setMeta("pointer", !0) : C == "key" && H.scrollIntoView(), o && H.setMeta("composition", o), e.dispatch(H);
    }
    return;
  }
  let s = e.state.doc.resolve(t), a = s.sharedDepth(n);
  t = s.before(a + 1), n = e.state.doc.resolve(n).after(a + 1);
  let l = e.state.selection, u = BD(e, t, n), c = e.state.doc, f = c.slice(u.from, u.to), d, p;
  e.input.lastKeyCode === 8 && Date.now() - 100 < e.input.lastKeyCodeTime ? (d = e.state.selection.to, p = "end") : (d = e.state.selection.from, p = "start"), e.input.lastKeyCode = null;
  let h = UD(f.content, u.doc.content, u.from, d, p);
  if (h && e.input.domChangeCount++, (ks && e.input.lastIOSEnter > Date.now() - 225 || or) && i.some((C) => C.nodeType == 1 && !$D.test(C.nodeName)) && (!h || h.endA >= h.endB) && e.someProp("handleKeyDown", (C) => C(e, lo(13, "Enter")))) {
    e.input.lastIOSEnter = 0;
    return;
  }
  if (!h)
    if (r && l instanceof Oe && !l.empty && l.$head.sameParent(l.$anchor) && !e.composing && !(u.sel && u.sel.anchor != u.sel.head))
      h = { start: l.from, endA: l.to, endB: l.to };
    else {
      if (u.sel) {
        let C = jm(e, e.state.doc, u.sel);
        if (C && !C.eq(e.state.selection)) {
          let z = e.state.tr.setSelection(C);
          o && z.setMeta("composition", o), e.dispatch(z);
        }
      }
      return;
    }
  e.state.selection.from < e.state.selection.to && h.start == h.endB && e.state.selection instanceof Oe && (h.start > e.state.selection.from && h.start <= e.state.selection.from + 2 && e.state.selection.from >= u.from ? h.start = e.state.selection.from : h.endA < e.state.selection.to && h.endA >= e.state.selection.to - 2 && e.state.selection.to <= u.to && (h.endB += e.state.selection.to - h.endA, h.endA = e.state.selection.to)), Mn && ji <= 11 && h.endB == h.start + 1 && h.endA == h.start && h.start > u.from && u.doc.textBetween(h.start - u.from - 1, h.start - u.from + 1) == " " && (h.start--, h.endA--, h.endB--);
  let m = u.doc.resolveNoCache(h.start - u.from), g = u.doc.resolveNoCache(h.endB - u.from), y = c.resolve(h.start), _ = m.sameParent(g) && m.parent.inlineContent && y.end() >= h.endA, E;
  if ((ks && e.input.lastIOSEnter > Date.now() - 225 && (!_ || i.some((C) => C.nodeName == "DIV" || C.nodeName == "P")) || !_ && m.pos < u.doc.content.size && !m.sameParent(g) && (E = Be.findFrom(u.doc.resolve(m.pos + 1), 1, !0)) && E.head == g.pos) && e.someProp("handleKeyDown", (C) => C(e, lo(13, "Enter")))) {
    e.input.lastIOSEnter = 0;
    return;
  }
  if (e.state.selection.anchor > h.start && jD(c, h.start, h.endA, m, g) && e.someProp("handleKeyDown", (C) => C(e, lo(8, "Backspace")))) {
    or && an && e.domObserver.suppressSelectionUpdates();
    return;
  }
  an && or && h.endB == h.start && (e.input.lastAndroidDelete = Date.now()), or && !_ && m.start() != g.start() && g.parentOffset == 0 && m.depth == g.depth && u.sel && u.sel.anchor == u.sel.head && u.sel.head == h.endA && (h.endB -= 2, g = u.doc.resolveNoCache(h.endB - u.from), setTimeout(() => {
    e.someProp("handleKeyDown", function(C) {
      return C(e, lo(13, "Enter"));
    });
  }, 20));
  let v = h.start, M = h.endA, k, T, U;
  if (_) {
    if (m.pos == g.pos)
      Mn && ji <= 11 && m.parentOffset == 0 && (e.domObserver.suppressSelectionUpdates(), setTimeout(() => ui(e), 20)), k = e.state.tr.delete(v, M), T = c.resolve(h.start).marksAcross(c.resolve(h.endA));
    else if (
      // Adding or removing a mark
      h.endA == h.endB && (U = FD(m.parent.content.cut(m.parentOffset, g.parentOffset), y.parent.content.cut(y.parentOffset, h.endA - y.start())))
    )
      k = e.state.tr, U.type == "add" ? k.addMark(v, M, U.mark) : k.removeMark(v, M, U.mark);
    else if (m.parent.child(m.index()).isText && m.index() == g.index() - (g.textOffset ? 0 : 1)) {
      let C = m.parent.textBetween(m.parentOffset, g.parentOffset);
      if (e.someProp("handleTextInput", (z) => z(e, v, M, C)))
        return;
      k = e.state.tr.insertText(C, v, M);
    }
  }
  if (k || (k = e.state.tr.replace(v, M, u.doc.slice(h.start - u.from, h.endB - u.from))), u.sel) {
    let C = jm(e, k.doc, u.sel);
    C && !(an && or && e.composing && C.empty && (h.start != h.endB || e.input.lastAndroidDelete < Date.now() - 100) && (C.head == v || C.head == k.mapping.map(M) - 1) || Mn && C.empty && C.head == v) && k.setSelection(C);
  }
  T && k.ensureMarks(T), o && k.setMeta("composition", o), e.dispatch(k.scrollIntoView());
}
function jm(e, t, n) {
  return Math.max(n.anchor, n.head) > t.content.size ? null : Q0(e, t.resolve(n.anchor), t.resolve(n.head));
}
function FD(e, t) {
  let n = e.firstChild.marks, r = t.firstChild.marks, i = n, o = r, s, a, l;
  for (let c = 0; c < r.length; c++)
    i = r[c].removeFromSet(i);
  for (let c = 0; c < n.length; c++)
    o = n[c].removeFromSet(o);
  if (i.length == 1 && o.length == 0)
    a = i[0], s = "add", l = (c) => c.mark(a.addToSet(c.marks));
  else if (i.length == 0 && o.length == 1)
    a = o[0], s = "remove", l = (c) => c.mark(a.removeFromSet(c.marks));
  else
    return null;
  let u = [];
  for (let c = 0; c < t.childCount; c++)
    u.push(l(t.child(c)));
  if (te.from(u).eq(e))
    return { mark: a, type: s };
}
function jD(e, t, n, r, i) {
  if (
    // The content must have shrunk
    n - t <= i.pos - r.pos || // newEnd must point directly at or after the end of the block that newStart points into
    cp(r, !0, !1) < i.pos
  )
    return !1;
  let o = e.resolve(t);
  if (!r.parent.isTextblock) {
    let a = o.nodeAfter;
    return a != null && n == t + a.nodeSize;
  }
  if (o.parentOffset < o.parent.content.size || !o.parent.isTextblock)
    return !1;
  let s = e.resolve(cp(o, !0, !0));
  return !s.parent.isTextblock || s.pos > n || cp(s, !0, !1) < n ? !1 : r.parent.content.cut(r.parentOffset).eq(s.parent.content);
}
function cp(e, t, n) {
  let r = e.depth, i = t ? e.end() : e.pos;
  for (; r > 0 && (t || e.indexAfter(r) == e.node(r).childCount); )
    r--, i++, t = !1;
  if (n) {
    let o = e.node(r).maybeChild(e.indexAfter(r));
    for (; o && !o.isLeaf; )
      o = o.firstChild, i++;
  }
  return i;
}
function UD(e, t, n, r, i) {
  let o = e.findDiffStart(t, n);
  if (o == null)
    return null;
  let { a: s, b: a } = e.findDiffEnd(t, n + e.size, n + t.size);
  if (i == "end") {
    let l = Math.max(0, o - Math.min(s, a));
    r -= s + l - o;
  }
  if (s < o && e.size < t.size) {
    let l = r <= o && r >= s ? o - r : 0;
    o -= l, o && o < t.size && Um(t.textBetween(o - 1, o + 1)) && (o += l ? 1 : -1), a = o + (a - s), s = o;
  } else if (a < o) {
    let l = r <= o && r >= a ? o - r : 0;
    o -= l, o && o < e.size && Um(e.textBetween(o - 1, o + 1)) && (o += l ? 1 : -1), s = o + (s - a), a = o;
  }
  return { start: o, endA: s, endB: a };
}
function Um(e) {
  if (e.length != 2)
    return !1;
  let t = e.charCodeAt(0), n = e.charCodeAt(1);
  return t >= 56320 && t <= 57343 && n >= 55296 && n <= 56319;
}
class VD {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(t, n) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new lD(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = n, this.state = n.state, this.directPlugins = n.plugins || [], this.directPlugins.forEach(Wm), this.dispatch = this.dispatch.bind(this), this.dom = t && t.mount || document.createElement("div"), t && (t.appendChild ? t.appendChild(this.dom) : typeof t == "function" ? t(this.dom) : t.mount && (this.mounted = !0)), this.editable = qm(this), Hm(this), this.nodeViews = Gm(this), this.docView = xm(this.state.doc, Vm(this), up(this), this.dom, this), this.domObserver = new OD(this, (r, i, o, s) => zD(this, r, i, o, s)), this.domObserver.start(), uD(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let t = this._props;
      this._props = {};
      for (let n in t)
        this._props[n] = t[n];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(t) {
    t.handleDOMEvents != this._props.handleDOMEvents && Sh(this);
    let n = this._props;
    this._props = t, t.plugins && (t.plugins.forEach(Wm), this.directPlugins = t.plugins), this.updateStateInner(t.state, n);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(t) {
    let n = {};
    for (let r in this._props)
      n[r] = this._props[r];
    n.state = this.state;
    for (let r in t)
      n[r] = t[r];
    this.update(n);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(t) {
    this.updateStateInner(t, this._props);
  }
  updateStateInner(t, n) {
    var r;
    let i = this.state, o = !1, s = !1;
    t.storedMarks && this.composing && (e3(this), s = !0), this.state = t;
    let a = i.plugins != t.plugins || this._props.plugins != n.plugins;
    if (a || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
      let p = Gm(this);
      qD(p, this.nodeViews) && (this.nodeViews = p, o = !0);
    }
    (a || n.handleDOMEvents != this._props.handleDOMEvents) && Sh(this), this.editable = qm(this), Hm(this);
    let l = up(this), u = Vm(this), c = i.plugins != t.plugins && !i.doc.eq(t.doc) ? "reset" : t.scrollToSelection > i.scrollToSelection ? "to selection" : "preserve", f = o || !this.docView.matchesNode(t.doc, u, l);
    (f || !t.selection.eq(i.selection)) && (s = !0);
    let d = c == "preserve" && s && this.dom.style.overflowAnchor == null && xN(this);
    if (s) {
      this.domObserver.stop();
      let p = f && (Mn || an) && !this.composing && !i.selection.empty && !t.selection.empty && HD(i.selection, t.selection);
      if (f) {
        let h = an ? this.trackWrites = this.domSelectionRange().focusNode : null;
        this.composing && (this.input.compositionNode = wD(this)), (o || !this.docView.update(t.doc, u, l, this)) && (this.docView.updateOuterDeco(u), this.docView.destroy(), this.docView = xm(t.doc, u, l, this.dom, this)), h && !this.trackWrites && (p = !0);
      }
      p || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && WN(this)) ? ui(this, p) : (jE(this, t.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(i), !((r = this.dragging) === null || r === void 0) && r.node && !i.doc.eq(t.doc) && this.updateDraggedNode(this.dragging, i), c == "reset" ? this.dom.scrollTop = 0 : c == "to selection" ? this.scrollToSelection() : d && kN(d);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let t = this.domSelectionRange().focusNode;
    if (!this.someProp("handleScrollToSelection", (n) => n(this))) if (this.state.selection instanceof Ce) {
      let n = this.docView.domAfterPos(this.state.selection.from);
      n.nodeType == 1 && bm(this, n.getBoundingClientRect(), t);
    } else
      bm(this, this.coordsAtPos(this.state.selection.head, 1), t);
  }
  destroyPluginViews() {
    let t;
    for (; t = this.pluginViews.pop(); )
      t.destroy && t.destroy();
  }
  updatePluginViews(t) {
    if (!t || t.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let n = 0; n < this.directPlugins.length; n++) {
        let r = this.directPlugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
      for (let n = 0; n < this.state.plugins.length; n++) {
        let r = this.state.plugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
    } else
      for (let n = 0; n < this.pluginViews.length; n++) {
        let r = this.pluginViews[n];
        r.update && r.update(this, t);
      }
  }
  updateDraggedNode(t, n) {
    let r = t.node, i = -1;
    if (this.state.doc.nodeAt(r.from) == r.node)
      i = r.from;
    else {
      let o = r.from + (this.state.doc.content.size - n.doc.content.size);
      (o > 0 && this.state.doc.nodeAt(o)) == r.node && (i = o);
    }
    this.dragging = new n3(t.slice, t.move, i < 0 ? void 0 : Ce.create(this.state.doc, i));
  }
  someProp(t, n) {
    let r = this._props && this._props[t], i;
    if (r != null && (i = n ? n(r) : r))
      return i;
    for (let s = 0; s < this.directPlugins.length; s++) {
      let a = this.directPlugins[s].props[t];
      if (a != null && (i = n ? n(a) : a))
        return i;
    }
    let o = this.state.plugins;
    if (o)
      for (let s = 0; s < o.length; s++) {
        let a = o[s].props[t];
        if (a != null && (i = n ? n(a) : a))
          return i;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (Mn) {
      let t = this.root.activeElement;
      if (t == this.dom)
        return !0;
      if (!t || !this.dom.contains(t))
        return !1;
      for (; t && this.dom != t && this.dom.contains(t); ) {
        if (t.contentEditable == "false")
          return !1;
        t = t.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && MN(this.dom), ui(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let t = this._root;
    if (t == null) {
      for (let n = this.dom.parentNode; n; n = n.parentNode)
        if (n.nodeType == 9 || n.nodeType == 11 && n.host)
          return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()), this._root = n;
    }
    return t || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(t) {
    return NN(this, t);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(t, n = 1) {
    return IE(this, t, n);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(t, n = 0) {
    return this.docView.domFromPos(t, n);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(t) {
    let n = this.docView.descAt(t);
    return n ? n.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimesfor example when interpreting an event
  targetyou don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(t, n, r = -1) {
    let i = this.docView.posFromDOM(t, n, r);
    if (i == null)
      throw new RangeError("DOM position not inside the editor");
    return i;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(t, n) {
    return LN(this, n || this.state, t);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(t, n) {
    return il(this, "", t, !1, n || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(t, n) {
    return il(this, t, null, !0, n || new ClipboardEvent("paste"));
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (cD(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], up(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, dN());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(t) {
    return dD(this, t);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(t) {
    let n = this._props.dispatchTransaction;
    n ? n.call(this, t) : this.updateState(this.state.apply(t));
  }
  /**
  @internal
  */
  domSelectionRange() {
    let t = this.domSelection();
    return t ? hn && this.root.nodeType === 11 && bN(this.dom.ownerDocument) == this.dom && RD(this, t) || t : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
function Vm(e) {
  let t = /* @__PURE__ */ Object.create(null);
  return t.class = "ProseMirror", t.contenteditable = String(e.editable), e.someProp("attributes", (n) => {
    if (typeof n == "function" && (n = n(e.state)), n)
      for (let r in n)
        r == "class" ? t.class += " " + n[r] : r == "style" ? t.style = (t.style ? t.style + ";" : "") + n[r] : !t[r] && r != "contenteditable" && r != "nodeName" && (t[r] = String(n[r]));
  }), t.translate || (t.translate = "no"), [dn.node(0, e.state.doc.content.size, t)];
}
function Hm(e) {
  if (e.markCursor) {
    let t = document.createElement("img");
    t.className = "ProseMirror-separator", t.setAttribute("mark-placeholder", "true"), t.setAttribute("alt", ""), e.cursorWrapper = { dom: t, deco: dn.widget(e.state.selection.from, t, { raw: !0, marks: e.markCursor }) };
  } else
    e.cursorWrapper = null;
}
function qm(e) {
  return !e.someProp("editable", (t) => t(e.state) === !1);
}
function HD(e, t) {
  let n = Math.min(e.$anchor.sharedDepth(e.head), t.$anchor.sharedDepth(t.head));
  return e.$anchor.start(n) != t.$anchor.start(n);
}
function Gm(e) {
  let t = /* @__PURE__ */ Object.create(null);
  function n(r) {
    for (let i in r)
      Object.prototype.hasOwnProperty.call(t, i) || (t[i] = r[i]);
  }
  return e.someProp("nodeViews", n), e.someProp("markViews", n), t;
}
function qD(e, t) {
  let n = 0, r = 0;
  for (let i in e) {
    if (e[i] != t[i])
      return !0;
    n++;
  }
  for (let i in t)
    r++;
  return n != r;
}
function Wm(e) {
  if (e.spec.state || e.spec.filterTransaction || e.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var Gi = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, $c = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, GD = typeof navigator < "u" && /Mac/.test(navigator.platform), WD = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Qt = 0; Qt < 10; Qt++) Gi[48 + Qt] = Gi[96 + Qt] = String(Qt);
for (var Qt = 1; Qt <= 24; Qt++) Gi[Qt + 111] = "F" + Qt;
for (var Qt = 65; Qt <= 90; Qt++)
  Gi[Qt] = String.fromCharCode(Qt + 32), $c[Qt] = String.fromCharCode(Qt);
for (var fp in Gi) $c.hasOwnProperty(fp) || ($c[fp] = Gi[fp]);
function KD(e) {
  var t = GD && e.metaKey && e.shiftKey && !e.ctrlKey && !e.altKey || WD && e.shiftKey && e.key && e.key.length == 1 || e.key == "Unidentified", n = !t && e.key || (e.shiftKey ? $c : Gi)[e.keyCode] || e.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
const YD = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
function QD(e) {
  let t = e.split(/-(?!$)/), n = t[t.length - 1];
  n == "Space" && (n = " ");
  let r, i, o, s;
  for (let a = 0; a < t.length - 1; a++) {
    let l = t[a];
    if (/^(cmd|meta|m)$/i.test(l))
      s = !0;
    else if (/^a(lt)?$/i.test(l))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      i = !0;
    else if (/^s(hift)?$/i.test(l))
      o = !0;
    else if (/^mod$/i.test(l))
      YD ? s = !0 : i = !0;
    else
      throw new Error("Unrecognized modifier name: " + l);
  }
  return r && (n = "Alt-" + n), i && (n = "Ctrl-" + n), s && (n = "Meta-" + n), o && (n = "Shift-" + n), n;
}
function ZD(e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let n in e)
    t[QD(n)] = e[n];
  return t;
}
function dp(e, t, n = !0) {
  return t.altKey && (e = "Alt-" + e), t.ctrlKey && (e = "Ctrl-" + e), t.metaKey && (e = "Meta-" + e), n && t.shiftKey && (e = "Shift-" + e), e;
}
function XD(e) {
  return new mt({ props: { handleKeyDown: a3(e) } });
}
function a3(e) {
  let t = ZD(e);
  return function(n, r) {
    let i = KD(r), o, s = t[dp(i, r)];
    if (s && s(n.state, n.dispatch, n))
      return !0;
    if (i.length == 1 && i != " ") {
      if (r.shiftKey) {
        let a = t[dp(i, r, !1)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
      if ((r.shiftKey || r.altKey || r.metaKey || i.charCodeAt(0) > 127) && (o = Gi[r.keyCode]) && o != i) {
        let a = t[dp(o, r)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
    }
    return !1;
  };
}
const JD = (e, t) => e.selection.empty ? !1 : (t && t(e.tr.deleteSelection().scrollIntoView()), !0);
function l3(e, t) {
  let { $cursor: n } = e.selection;
  return !n || (t ? !t.endOfTextblock("backward", e) : n.parentOffset > 0) ? null : n;
}
const eO = (e, t, n) => {
  let r = l3(e, n);
  if (!r)
    return !1;
  let i = ng(r);
  if (!i) {
    let s = r.blockRange(), a = s && ta(s);
    return a == null ? !1 : (t && t(e.tr.lift(s, a).scrollIntoView()), !0);
  }
  let o = i.nodeBefore;
  if (d3(e, i, t, -1))
    return !0;
  if (r.parent.content.size == 0 && (Ms(o, "end") || Ce.isSelectable(o)))
    for (let s = r.depth; ; s--) {
      let a = rd(e.doc, r.before(s), r.after(s), ye.empty);
      if (a && a.slice.size < a.to - a.from) {
        if (t) {
          let l = e.tr.step(a);
          l.setSelection(Ms(o, "end") ? Be.findFrom(l.doc.resolve(l.mapping.map(i.pos, -1)), -1) : Ce.create(l.doc, i.pos - o.nodeSize)), t(l.scrollIntoView());
        }
        return !0;
      }
      if (s == 1 || r.node(s - 1).childCount > 1)
        break;
    }
  return o.isAtom && i.depth == r.depth - 1 ? (t && t(e.tr.delete(i.pos - o.nodeSize, i.pos).scrollIntoView()), !0) : !1;
}, tO = (e, t, n) => {
  let r = l3(e, n);
  if (!r)
    return !1;
  let i = ng(r);
  return i ? u3(e, i, t) : !1;
}, nO = (e, t, n) => {
  let r = c3(e, n);
  if (!r)
    return !1;
  let i = rg(r);
  return i ? u3(e, i, t) : !1;
};
function u3(e, t, n) {
  let r = t.nodeBefore, i = r, o = t.pos - 1;
  for (; !i.isTextblock; o--) {
    if (i.type.spec.isolating)
      return !1;
    let c = i.lastChild;
    if (!c)
      return !1;
    i = c;
  }
  let s = t.nodeAfter, a = s, l = t.pos + 1;
  for (; !a.isTextblock; l++) {
    if (a.type.spec.isolating)
      return !1;
    let c = a.firstChild;
    if (!c)
      return !1;
    a = c;
  }
  let u = rd(e.doc, o, l, ye.empty);
  if (!u || u.from != o || u instanceof jt && u.slice.size >= l - o)
    return !1;
  if (n) {
    let c = e.tr.step(u);
    c.setSelection(Oe.create(c.doc, o)), n(c.scrollIntoView());
  }
  return !0;
}
function Ms(e, t, n = !1) {
  for (let r = e; r; r = t == "start" ? r.firstChild : r.lastChild) {
    if (r.isTextblock)
      return !0;
    if (n && r.childCount != 1)
      return !1;
  }
  return !1;
}
const rO = (e, t, n) => {
  let { $head: r, empty: i } = e.selection, o = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("backward", e) : r.parentOffset > 0)
      return !1;
    o = ng(r);
  }
  let s = o && o.nodeBefore;
  return !s || !Ce.isSelectable(s) ? !1 : (t && t(e.tr.setSelection(Ce.create(e.doc, o.pos - s.nodeSize)).scrollIntoView()), !0);
};
function ng(e) {
  if (!e.parent.type.spec.isolating)
    for (let t = e.depth - 1; t >= 0; t--) {
      if (e.index(t) > 0)
        return e.doc.resolve(e.before(t + 1));
      if (e.node(t).type.spec.isolating)
        break;
    }
  return null;
}
function c3(e, t) {
  let { $cursor: n } = e.selection;
  return !n || (t ? !t.endOfTextblock("forward", e) : n.parentOffset < n.parent.content.size) ? null : n;
}
const iO = (e, t, n) => {
  let r = c3(e, n);
  if (!r)
    return !1;
  let i = rg(r);
  if (!i)
    return !1;
  let o = i.nodeAfter;
  if (d3(e, i, t, 1))
    return !0;
  if (r.parent.content.size == 0 && (Ms(o, "start") || Ce.isSelectable(o))) {
    let s = rd(e.doc, r.before(), r.after(), ye.empty);
    if (s && s.slice.size < s.to - s.from) {
      if (t) {
        let a = e.tr.step(s);
        a.setSelection(Ms(o, "start") ? Be.findFrom(a.doc.resolve(a.mapping.map(i.pos)), 1) : Ce.create(a.doc, a.mapping.map(i.pos))), t(a.scrollIntoView());
      }
      return !0;
    }
  }
  return o.isAtom && i.depth == r.depth - 1 ? (t && t(e.tr.delete(i.pos, i.pos + o.nodeSize).scrollIntoView()), !0) : !1;
}, oO = (e, t, n) => {
  let { $head: r, empty: i } = e.selection, o = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("forward", e) : r.parentOffset < r.parent.content.size)
      return !1;
    o = rg(r);
  }
  let s = o && o.nodeAfter;
  return !s || !Ce.isSelectable(s) ? !1 : (t && t(e.tr.setSelection(Ce.create(e.doc, o.pos)).scrollIntoView()), !0);
};
function rg(e) {
  if (!e.parent.type.spec.isolating)
    for (let t = e.depth - 1; t >= 0; t--) {
      let n = e.node(t);
      if (e.index(t) + 1 < n.childCount)
        return e.doc.resolve(e.after(t + 1));
      if (n.type.spec.isolating)
        break;
    }
  return null;
}
const sO = (e, t) => {
  let n = e.selection, r = n instanceof Ce, i;
  if (r) {
    if (n.node.isTextblock || !Qi(e.doc, n.from))
      return !1;
    i = n.from;
  } else if (i = nd(e.doc, n.from, -1), i == null)
    return !1;
  if (t) {
    let o = e.tr.join(i);
    r && o.setSelection(Ce.create(o.doc, i - e.doc.resolve(i).nodeBefore.nodeSize)), t(o.scrollIntoView());
  }
  return !0;
}, aO = (e, t) => {
  let n = e.selection, r;
  if (n instanceof Ce) {
    if (n.node.isTextblock || !Qi(e.doc, n.to))
      return !1;
    r = n.to;
  } else if (r = nd(e.doc, n.to, 1), r == null)
    return !1;
  return t && t(e.tr.join(r).scrollIntoView()), !0;
}, lO = (e, t) => {
  let { $from: n, $to: r } = e.selection, i = n.blockRange(r), o = i && ta(i);
  return o == null ? !1 : (t && t(e.tr.lift(i, o).scrollIntoView()), !0);
}, uO = (e, t) => {
  let { $head: n, $anchor: r } = e.selection;
  return !n.parent.type.spec.code || !n.sameParent(r) ? !1 : (t && t(e.tr.insertText(`
`).scrollIntoView()), !0);
};
function f3(e) {
  for (let t = 0; t < e.edgeCount; t++) {
    let { type: n } = e.edge(t);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
const cO = (e, t) => {
  let { $head: n, $anchor: r } = e.selection;
  if (!n.parent.type.spec.code || !n.sameParent(r))
    return !1;
  let i = n.node(-1), o = n.indexAfter(-1), s = f3(i.contentMatchAt(o));
  if (!s || !i.canReplaceWith(o, o, s))
    return !1;
  if (t) {
    let a = n.after(), l = e.tr.replaceWith(a, a, s.createAndFill());
    l.setSelection(Be.near(l.doc.resolve(a), 1)), t(l.scrollIntoView());
  }
  return !0;
}, fO = (e, t) => {
  let n = e.selection, { $from: r, $to: i } = n;
  if (n instanceof cr || r.parent.inlineContent || i.parent.inlineContent)
    return !1;
  let o = f3(i.parent.contentMatchAt(i.indexAfter()));
  if (!o || !o.isTextblock)
    return !1;
  if (t) {
    let s = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos, a = e.tr.insert(s, o.createAndFill());
    a.setSelection(Oe.create(a.doc, s + 1)), t(a.scrollIntoView());
  }
  return !0;
}, dO = (e, t) => {
  let { $cursor: n } = e.selection;
  if (!n || n.parent.content.size)
    return !1;
  if (n.depth > 1 && n.after() != n.end(-1)) {
    let o = n.before();
    if (fs(e.doc, o))
      return t && t(e.tr.split(o).scrollIntoView()), !0;
  }
  let r = n.blockRange(), i = r && ta(r);
  return i == null ? !1 : (t && t(e.tr.lift(r, i).scrollIntoView()), !0);
}, pO = (e, t) => {
  let { $from: n, to: r } = e.selection, i, o = n.sharedDepth(r);
  return o == 0 ? !1 : (i = n.before(o), t && t(e.tr.setSelection(Ce.create(e.doc, i))), !0);
};
function hO(e, t, n) {
  let r = t.nodeBefore, i = t.nodeAfter, o = t.index();
  return !r || !i || !r.type.compatibleContent(i.type) ? !1 : !r.content.size && t.parent.canReplace(o - 1, o) ? (n && n(e.tr.delete(t.pos - r.nodeSize, t.pos).scrollIntoView()), !0) : !t.parent.canReplace(o, o + 1) || !(i.isTextblock || Qi(e.doc, t.pos)) ? !1 : (n && n(e.tr.join(t.pos).scrollIntoView()), !0);
}
function d3(e, t, n, r) {
  let i = t.nodeBefore, o = t.nodeAfter, s, a, l = i.type.spec.isolating || o.type.spec.isolating;
  if (!l && hO(e, t, n))
    return !0;
  let u = !l && t.parent.canReplace(t.index(), t.index() + 1);
  if (u && (s = (a = i.contentMatchAt(i.childCount)).findWrapping(o.type)) && a.matchType(s[0] || o.type).validEnd) {
    if (n) {
      let p = t.pos + o.nodeSize, h = te.empty;
      for (let y = s.length - 1; y >= 0; y--)
        h = te.from(s[y].create(null, h));
      h = te.from(i.copy(h));
      let m = e.tr.step(new Vt(t.pos - 1, p, t.pos, p, new ye(h, 1, 0), s.length, !0)), g = m.doc.resolve(p + 2 * s.length);
      g.nodeAfter && g.nodeAfter.type == i.type && Qi(m.doc, g.pos) && m.join(g.pos), n(m.scrollIntoView());
    }
    return !0;
  }
  let c = o.type.spec.isolating || r > 0 && l ? null : Be.findFrom(t, 1), f = c && c.$from.blockRange(c.$to), d = f && ta(f);
  if (d != null && d >= t.depth)
    return n && n(e.tr.lift(f, d).scrollIntoView()), !0;
  if (u && Ms(o, "start", !0) && Ms(i, "end")) {
    let p = i, h = [];
    for (; h.push(p), !p.isTextblock; )
      p = p.lastChild;
    let m = o, g = 1;
    for (; !m.isTextblock; m = m.firstChild)
      g++;
    if (p.canReplace(p.childCount, p.childCount, m.content)) {
      if (n) {
        let y = te.empty;
        for (let E = h.length - 1; E >= 0; E--)
          y = te.from(h[E].copy(y));
        let _ = e.tr.step(new Vt(t.pos - h.length, t.pos + o.nodeSize, t.pos + g, t.pos + o.nodeSize - g, new ye(y, h.length, 0), 0, !0));
        n(_.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function p3(e) {
  return function(t, n) {
    let r = t.selection, i = e < 0 ? r.$from : r.$to, o = i.depth;
    for (; i.node(o).isInline; ) {
      if (!o)
        return !1;
      o--;
    }
    return i.node(o).isTextblock ? (n && n(t.tr.setSelection(Oe.create(t.doc, e < 0 ? i.start(o) : i.end(o)))), !0) : !1;
  };
}
const gO = p3(-1), mO = p3(1);
function bO(e, t = null) {
  return function(n, r) {
    let { $from: i, $to: o } = n.selection, s = i.blockRange(o), a = s && G0(s, e, t);
    return a ? (r && r(n.tr.wrap(s, a).scrollIntoView()), !0) : !1;
  };
}
function Km(e, t = null) {
  return function(n, r) {
    let i = !1;
    for (let o = 0; o < n.selection.ranges.length && !i; o++) {
      let { $from: { pos: s }, $to: { pos: a } } = n.selection.ranges[o];
      n.doc.nodesBetween(s, a, (l, u) => {
        if (i)
          return !1;
        if (!(!l.isTextblock || l.hasMarkup(e, t)))
          if (l.type == e)
            i = !0;
          else {
            let c = n.doc.resolve(u), f = c.index();
            i = c.parent.canReplaceWith(f, f + 1, e);
          }
      });
    }
    if (!i)
      return !1;
    if (r) {
      let o = n.tr;
      for (let s = 0; s < n.selection.ranges.length; s++) {
        let { $from: { pos: a }, $to: { pos: l } } = n.selection.ranges[s];
        o.setBlockType(a, l, e, t);
      }
      r(o.scrollIntoView());
    }
    return !0;
  };
}
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function yO(e, t = null) {
  return function(n, r) {
    let { $from: i, $to: o } = n.selection, s = i.blockRange(o), a = !1, l = s;
    if (!s)
      return !1;
    if (s.depth >= 2 && i.node(s.depth - 1).type.compatibleContent(e) && s.startIndex == 0) {
      if (i.index(s.depth - 1) == 0)
        return !1;
      let c = n.doc.resolve(s.start - 2);
      l = new Cc(c, c, s.depth), s.endIndex < s.parent.childCount && (s = new Cc(i, n.doc.resolve(o.end(s.depth)), s.depth)), a = !0;
    }
    let u = G0(l, e, t, s);
    return u ? (r && r(vO(n.tr, s, u, a, e).scrollIntoView()), !0) : !1;
  };
}
function vO(e, t, n, r, i) {
  let o = te.empty;
  for (let c = n.length - 1; c >= 0; c--)
    o = te.from(n[c].type.create(n[c].attrs, o));
  e.step(new Vt(t.start - (r ? 2 : 0), t.end, t.start, t.end, new ye(o, 0, 0), n.length, !0));
  let s = 0;
  for (let c = 0; c < n.length; c++)
    n[c].type == i && (s = c + 1);
  let a = n.length - s, l = t.start + n.length - (r ? 2 : 0), u = t.parent;
  for (let c = t.startIndex, f = t.endIndex, d = !0; c < f; c++, d = !1)
    !d && fs(e.doc, l, a) && (e.split(l, a), l += 2 * a), l += u.child(c).nodeSize;
  return e;
}
function _O(e) {
  return function(t, n) {
    let { $from: r, $to: i } = t.selection, o = r.blockRange(i, (s) => s.childCount > 0 && s.firstChild.type == e);
    return o ? n ? r.node(o.depth - 1).type == e ? EO(t, n, e, o) : wO(t, n, o) : !0 : !1;
  };
}
function EO(e, t, n, r) {
  let i = e.tr, o = r.end, s = r.$to.end(r.depth);
  o < s && (i.step(new Vt(o - 1, s, o, s, new ye(te.from(n.create(null, r.parent.copy())), 1, 0), 1, !0)), r = new Cc(i.doc.resolve(r.$from.pos), i.doc.resolve(s), r.depth));
  const a = ta(r);
  if (a == null)
    return !1;
  i.lift(r, a);
  let l = i.mapping.map(o, -1) - 1;
  return Qi(i.doc, l) && i.join(l), t(i.scrollIntoView()), !0;
}
function wO(e, t, n) {
  let r = e.tr, i = n.parent;
  for (let p = n.end, h = n.endIndex - 1, m = n.startIndex; h > m; h--)
    p -= i.child(h).nodeSize, r.delete(p - 1, p + 1);
  let o = r.doc.resolve(n.start), s = o.nodeAfter;
  if (r.mapping.map(n.end) != n.start + o.nodeAfter.nodeSize)
    return !1;
  let a = n.startIndex == 0, l = n.endIndex == i.childCount, u = o.node(-1), c = o.index(-1);
  if (!u.canReplace(c + (a ? 0 : 1), c + 1, s.content.append(l ? te.empty : te.from(i))))
    return !1;
  let f = o.pos, d = f + s.nodeSize;
  return r.step(new Vt(f - (a ? 1 : 0), d + (l ? 1 : 0), f + 1, d - 1, new ye((a ? te.empty : te.from(i.copy(te.empty))).append(l ? te.empty : te.from(i.copy(te.empty))), a ? 0 : 1, l ? 0 : 1), a ? 0 : 1)), t(r.scrollIntoView()), !0;
}
function xO(e) {
  return function(t, n) {
    let { $from: r, $to: i } = t.selection, o = r.blockRange(i, (u) => u.childCount > 0 && u.firstChild.type == e);
    if (!o)
      return !1;
    let s = o.startIndex;
    if (s == 0)
      return !1;
    let a = o.parent, l = a.child(s - 1);
    if (l.type != e)
      return !1;
    if (n) {
      let u = l.lastChild && l.lastChild.type == a.type, c = te.from(u ? e.create() : null), f = new ye(te.from(e.create(null, te.from(a.type.create(null, c)))), u ? 3 : 1, 0), d = o.start, p = o.end;
      n(t.tr.step(new Vt(d - (u ? 3 : 1), p, d, p, f, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
function ld(e) {
  const { state: t, transaction: n } = e;
  let { selection: r } = n, { doc: i } = n, { storedMarks: o } = n;
  return {
    ...t,
    apply: t.apply.bind(t),
    applyTransaction: t.applyTransaction.bind(t),
    plugins: t.plugins,
    schema: t.schema,
    reconfigure: t.reconfigure.bind(t),
    toJSON: t.toJSON.bind(t),
    get storedMarks() {
      return o;
    },
    get selection() {
      return r;
    },
    get doc() {
      return i;
    },
    get tr() {
      return r = n.selection, i = n.doc, o = n.storedMarks, n;
    }
  };
}
class ud {
  constructor(t) {
    this.editor = t.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = t.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: t, editor: n, state: r } = this, { view: i } = n, { tr: o } = r, s = this.buildProps(o);
    return Object.fromEntries(Object.entries(t).map(([a, l]) => [a, (...c) => {
      const f = l(...c)(s);
      return !o.getMeta("preventDispatch") && !this.hasCustomState && i.dispatch(o), f;
    }]));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(t, n = !0) {
    const { rawCommands: r, editor: i, state: o } = this, { view: s } = i, a = [], l = !!t, u = t || o.tr, c = () => (!l && n && !u.getMeta("preventDispatch") && !this.hasCustomState && s.dispatch(u), a.every((d) => d === !0)), f = {
      ...Object.fromEntries(Object.entries(r).map(([d, p]) => [d, (...m) => {
        const g = this.buildProps(u, n), y = p(...m)(g);
        return a.push(y), f;
      }])),
      run: c
    };
    return f;
  }
  createCan(t) {
    const { rawCommands: n, state: r } = this, i = !1, o = t || r.tr, s = this.buildProps(o, i);
    return {
      ...Object.fromEntries(Object.entries(n).map(([l, u]) => [l, (...c) => u(...c)({ ...s, dispatch: void 0 })])),
      chain: () => this.createChain(o, i)
    };
  }
  buildProps(t, n = !0) {
    const { rawCommands: r, editor: i, state: o } = this, { view: s } = i, a = {
      tr: t,
      editor: i,
      view: s,
      state: ld({
        state: o,
        transaction: t
      }),
      dispatch: n ? () => {
      } : void 0,
      chain: () => this.createChain(t, n),
      can: () => this.createCan(t),
      get commands() {
        return Object.fromEntries(Object.entries(r).map(([l, u]) => [l, (...c) => u(...c)(a)]));
      }
    };
    return a;
  }
}
class kO {
  constructor() {
    this.callbacks = {};
  }
  on(t, n) {
    return this.callbacks[t] || (this.callbacks[t] = []), this.callbacks[t].push(n), this;
  }
  emit(t, ...n) {
    const r = this.callbacks[t];
    return r && r.forEach((i) => i.apply(this, n)), this;
  }
  off(t, n) {
    const r = this.callbacks[t];
    return r && (n ? this.callbacks[t] = r.filter((i) => i !== n) : delete this.callbacks[t]), this;
  }
  once(t, n) {
    const r = (...i) => {
      this.off(t, r), n.apply(this, i);
    };
    return this.on(t, r);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}
function ke(e, t, n) {
  return e.config[t] === void 0 && e.parent ? ke(e.parent, t, n) : typeof e.config[t] == "function" ? e.config[t].bind({
    ...n,
    parent: e.parent ? ke(e.parent, t, n) : null
  }) : e.config[t];
}
function cd(e) {
  const t = e.filter((i) => i.type === "extension"), n = e.filter((i) => i.type === "node"), r = e.filter((i) => i.type === "mark");
  return {
    baseExtensions: t,
    nodeExtensions: n,
    markExtensions: r
  };
}
function h3(e) {
  const t = [], { nodeExtensions: n, markExtensions: r } = cd(e), i = [...n, ...r], o = {
    default: null,
    rendered: !0,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: !0,
    isRequired: !1
  };
  return e.forEach((s) => {
    const a = {
      name: s.name,
      options: s.options,
      storage: s.storage,
      extensions: i
    }, l = ke(s, "addGlobalAttributes", a);
    if (!l)
      return;
    l().forEach((c) => {
      c.types.forEach((f) => {
        Object.entries(c.attributes).forEach(([d, p]) => {
          t.push({
            type: f,
            name: d,
            attribute: {
              ...o,
              ...p
            }
          });
        });
      });
    });
  }), i.forEach((s) => {
    const a = {
      name: s.name,
      options: s.options,
      storage: s.storage
    }, l = ke(s, "addAttributes", a);
    if (!l)
      return;
    const u = l();
    Object.entries(u).forEach(([c, f]) => {
      const d = {
        ...o,
        ...f
      };
      typeof (d == null ? void 0 : d.default) == "function" && (d.default = d.default()), d != null && d.isRequired && (d == null ? void 0 : d.default) === void 0 && delete d.default, t.push({
        type: s.name,
        name: c,
        attribute: d
      });
    });
  }), t;
}
function qt(e, t) {
  if (typeof e == "string") {
    if (!t.nodes[e])
      throw Error(`There is no node type named '${e}'. Maybe you forgot to add the extension?`);
    return t.nodes[e];
  }
  return e;
}
function At(...e) {
  return e.filter((t) => !!t).reduce((t, n) => {
    const r = { ...t };
    return Object.entries(n).forEach(([i, o]) => {
      if (!r[i]) {
        r[i] = o;
        return;
      }
      if (i === "class") {
        const a = o ? o.split(" ") : [], l = r[i] ? r[i].split(" ") : [], u = a.filter((c) => !l.includes(c));
        r[i] = [...l, ...u].join(" ");
      } else if (i === "style") {
        const a = o ? o.split(";").map((c) => c.trim()).filter(Boolean) : [], l = r[i] ? r[i].split(";").map((c) => c.trim()).filter(Boolean) : [], u = /* @__PURE__ */ new Map();
        l.forEach((c) => {
          const [f, d] = c.split(":").map((p) => p.trim());
          u.set(f, d);
        }), a.forEach((c) => {
          const [f, d] = c.split(":").map((p) => p.trim());
          u.set(f, d);
        }), r[i] = Array.from(u.entries()).map(([c, f]) => `${c}: ${f}`).join("; ");
      } else
        r[i] = o;
    }), r;
  }, {});
}
function Ch(e, t) {
  return t.filter((n) => n.type === e.type.name).filter((n) => n.attribute.rendered).map((n) => n.attribute.renderHTML ? n.attribute.renderHTML(e.attrs) || {} : {
    [n.name]: e.attrs[n.name]
  }).reduce((n, r) => At(n, r), {});
}
function g3(e) {
  return typeof e == "function";
}
function je(e, t = void 0, ...n) {
  return g3(e) ? t ? e.bind(t)(...n) : e(...n) : e;
}
function MO(e = {}) {
  return Object.keys(e).length === 0 && e.constructor === Object;
}
function AO(e) {
  return typeof e != "string" ? e : e.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(e) : e === "true" ? !0 : e === "false" ? !1 : e;
}
function Ym(e, t) {
  return "style" in e ? e : {
    ...e,
    getAttrs: (n) => {
      const r = e.getAttrs ? e.getAttrs(n) : e.attrs;
      if (r === !1)
        return !1;
      const i = t.reduce((o, s) => {
        const a = s.attribute.parseHTML ? s.attribute.parseHTML(n) : AO(n.getAttribute(s.name));
        return a == null ? o : {
          ...o,
          [s.name]: a
        };
      }, {});
      return { ...r, ...i };
    }
  };
}
function Qm(e) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(e).filter(([t, n]) => t === "attrs" && MO(n) ? !1 : n != null)
  );
}
function TO(e, t) {
  var n;
  const r = h3(e), { nodeExtensions: i, markExtensions: o } = cd(e), s = (n = i.find((u) => ke(u, "topNode"))) === null || n === void 0 ? void 0 : n.name, a = Object.fromEntries(i.map((u) => {
    const c = r.filter((y) => y.type === u.name), f = {
      name: u.name,
      options: u.options,
      storage: u.storage,
      editor: t
    }, d = e.reduce((y, _) => {
      const E = ke(_, "extendNodeSchema", f);
      return {
        ...y,
        ...E ? E(u) : {}
      };
    }, {}), p = Qm({
      ...d,
      content: je(ke(u, "content", f)),
      marks: je(ke(u, "marks", f)),
      group: je(ke(u, "group", f)),
      inline: je(ke(u, "inline", f)),
      atom: je(ke(u, "atom", f)),
      selectable: je(ke(u, "selectable", f)),
      draggable: je(ke(u, "draggable", f)),
      code: je(ke(u, "code", f)),
      whitespace: je(ke(u, "whitespace", f)),
      linebreakReplacement: je(ke(u, "linebreakReplacement", f)),
      defining: je(ke(u, "defining", f)),
      isolating: je(ke(u, "isolating", f)),
      attrs: Object.fromEntries(c.map((y) => {
        var _;
        return [y.name, { default: (_ = y == null ? void 0 : y.attribute) === null || _ === void 0 ? void 0 : _.default }];
      }))
    }), h = je(ke(u, "parseHTML", f));
    h && (p.parseDOM = h.map((y) => Ym(y, c)));
    const m = ke(u, "renderHTML", f);
    m && (p.toDOM = (y) => m({
      node: y,
      HTMLAttributes: Ch(y, c)
    }));
    const g = ke(u, "renderText", f);
    return g && (p.toText = g), [u.name, p];
  })), l = Object.fromEntries(o.map((u) => {
    const c = r.filter((g) => g.type === u.name), f = {
      name: u.name,
      options: u.options,
      storage: u.storage,
      editor: t
    }, d = e.reduce((g, y) => {
      const _ = ke(y, "extendMarkSchema", f);
      return {
        ...g,
        ..._ ? _(u) : {}
      };
    }, {}), p = Qm({
      ...d,
      inclusive: je(ke(u, "inclusive", f)),
      excludes: je(ke(u, "excludes", f)),
      group: je(ke(u, "group", f)),
      spanning: je(ke(u, "spanning", f)),
      code: je(ke(u, "code", f)),
      attrs: Object.fromEntries(c.map((g) => {
        var y;
        return [g.name, { default: (y = g == null ? void 0 : g.attribute) === null || y === void 0 ? void 0 : y.default }];
      }))
    }), h = je(ke(u, "parseHTML", f));
    h && (p.parseDOM = h.map((g) => Ym(g, c)));
    const m = ke(u, "renderHTML", f);
    return m && (p.toDOM = (g) => m({
      mark: g,
      HTMLAttributes: Ch(g, c)
    })), [u.name, p];
  }));
  return new V0({
    topNode: s,
    nodes: a,
    marks: l
  });
}
function pp(e, t) {
  return t.nodes[e] || t.marks[e] || null;
}
function Zm(e, t) {
  return Array.isArray(t) ? t.some((n) => (typeof n == "string" ? n : n.name) === e.name) : t;
}
function Hl(e, t) {
  const n = $o.fromSchema(t).serializeFragment(e), i = document.implementation.createHTMLDocument().createElement("div");
  return i.appendChild(n), i.innerHTML;
}
const SO = (e, t = 500) => {
  let n = "";
  const r = e.parentOffset;
  return e.parent.nodesBetween(Math.max(0, r - t), r, (i, o, s, a) => {
    var l, u;
    const c = ((u = (l = i.type.spec).toText) === null || u === void 0 ? void 0 : u.call(l, {
      node: i,
      pos: o,
      parent: s,
      index: a
    })) || i.textContent || "%leaf%";
    n += i.isAtom && !i.isText ? c : c.slice(0, Math.max(0, r - o));
  }), n;
};
function ig(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}
class ql {
  constructor(t) {
    this.find = t.find, this.handler = t.handler;
  }
}
const CO = (e, t) => {
  if (ig(t))
    return t.exec(e);
  const n = t(e);
  if (!n)
    return null;
  const r = [n.text];
  return r.index = n.index, r.input = e, r.data = n.data, n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), r.push(n.replaceWith)), r;
};
function gu(e) {
  var t;
  const { editor: n, from: r, to: i, text: o, rules: s, plugin: a } = e, { view: l } = n;
  if (l.composing)
    return !1;
  const u = l.state.doc.resolve(r);
  if (
    // check for code node
    u.parent.type.spec.code || !((t = u.nodeBefore || u.nodeAfter) === null || t === void 0) && t.marks.find((d) => d.type.spec.code)
  )
    return !1;
  let c = !1;
  const f = SO(u) + o;
  return s.forEach((d) => {
    if (c)
      return;
    const p = CO(f, d.find);
    if (!p)
      return;
    const h = l.state.tr, m = ld({
      state: l.state,
      transaction: h
    }), g = {
      from: r - (p[0].length - o.length),
      to: i
    }, { commands: y, chain: _, can: E } = new ud({
      editor: n,
      state: m
    });
    d.handler({
      state: m,
      range: g,
      match: p,
      commands: y,
      chain: _,
      can: E
    }) === null || !h.steps.length || (h.setMeta(a, {
      transform: h,
      from: r,
      to: i,
      text: o
    }), l.dispatch(h), c = !0);
  }), c;
}
function NO(e) {
  const { editor: t, rules: n } = e, r = new mt({
    state: {
      init() {
        return null;
      },
      apply(i, o, s) {
        const a = i.getMeta(r);
        if (a)
          return a;
        const l = i.getMeta("applyInputRules");
        return !!l && setTimeout(() => {
          let { text: c } = l;
          typeof c == "string" ? c = c : c = Hl(te.from(c), s.schema);
          const { from: f } = l, d = f + c.length;
          gu({
            editor: t,
            from: f,
            to: d,
            text: c,
            rules: n,
            plugin: r
          });
        }), i.selectionSet || i.docChanged ? null : o;
      }
    },
    props: {
      handleTextInput(i, o, s, a) {
        return gu({
          editor: t,
          from: o,
          to: s,
          text: a,
          rules: n,
          plugin: r
        });
      },
      handleDOMEvents: {
        compositionend: (i) => (setTimeout(() => {
          const { $cursor: o } = i.state.selection;
          o && gu({
            editor: t,
            from: o.pos,
            to: o.pos,
            text: "",
            rules: n,
            plugin: r
          });
        }), !1)
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(i, o) {
        if (o.key !== "Enter")
          return !1;
        const { $cursor: s } = i.state.selection;
        return s ? gu({
          editor: t,
          from: s.pos,
          to: s.pos,
          text: `
`,
          rules: n,
          plugin: r
        }) : !1;
      }
    },
    // @ts-ignore
    isInputRules: !0
  });
  return r;
}
function DO(e) {
  return Object.prototype.toString.call(e).slice(8, -1);
}
function mu(e) {
  return DO(e) !== "Object" ? !1 : e.constructor === Object && Object.getPrototypeOf(e) === Object.prototype;
}
function fd(e, t) {
  const n = { ...e };
  return mu(e) && mu(t) && Object.keys(t).forEach((r) => {
    mu(t[r]) && mu(e[r]) ? n[r] = fd(e[r], t[r]) : n[r] = t[r];
  }), n;
}
class Jt {
  constructor(t = {}) {
    this.type = "mark", this.name = "mark", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...t
    }, this.name = this.config.name, t.defaultOptions && Object.keys(t.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = je(ke(this, "addOptions", {
      name: this.name
    }))), this.storage = je(ke(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(t = {}) {
    return new Jt(t);
  }
  configure(t = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => fd(this.options, t)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(t = {}) {
    const n = new Jt(t);
    return n.parent = this, this.child = n, n.name = t.name ? t.name : n.parent.name, t.defaultOptions && Object.keys(t.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = je(ke(n, "addOptions", {
      name: n.name
    })), n.storage = je(ke(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
  static handleExit({ editor: t, mark: n }) {
    const { tr: r } = t.state, i = t.state.selection.$from;
    if (i.pos === i.end()) {
      const s = i.marks();
      if (!!!s.find((u) => (u == null ? void 0 : u.type.name) === n.name))
        return !1;
      const l = s.find((u) => (u == null ? void 0 : u.type.name) === n.name);
      return l && r.removeStoredMark(l), r.insertText(" ", i.pos), t.view.dispatch(r), !0;
    }
    return !1;
  }
}
function OO(e) {
  return typeof e == "number";
}
class IO {
  constructor(t) {
    this.find = t.find, this.handler = t.handler;
  }
}
const RO = (e, t, n) => {
  if (ig(t))
    return [...e.matchAll(t)];
  const r = t(e, n);
  return r ? r.map((i) => {
    const o = [i.text];
    return o.index = i.index, o.input = e, o.data = i.data, i.replaceWith && (i.text.includes(i.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), o.push(i.replaceWith)), o;
  }) : [];
};
function LO(e) {
  const { editor: t, state: n, from: r, to: i, rule: o, pasteEvent: s, dropEvent: a } = e, { commands: l, chain: u, can: c } = new ud({
    editor: t,
    state: n
  }), f = [];
  return n.doc.nodesBetween(r, i, (p, h) => {
    if (!p.isTextblock || p.type.spec.code)
      return;
    const m = Math.max(r, h), g = Math.min(i, h + p.content.size), y = p.textBetween(m - h, g - h, void 0, "");
    RO(y, o.find, s).forEach((E) => {
      if (E.index === void 0)
        return;
      const v = m + E.index + 1, M = v + E[0].length, k = {
        from: n.tr.mapping.map(v),
        to: n.tr.mapping.map(M)
      }, T = o.handler({
        state: n,
        range: k,
        match: E,
        commands: l,
        chain: u,
        can: c,
        pasteEvent: s,
        dropEvent: a
      });
      f.push(T);
    });
  }), f.every((p) => p !== null);
}
const BO = (e) => {
  var t;
  const n = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  return (t = n.clipboardData) === null || t === void 0 || t.setData("text/html", e), n;
};
function PO(e) {
  const { editor: t, rules: n } = e;
  let r = null, i = !1, o = !1, s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, a;
  try {
    a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
  } catch {
    a = null;
  }
  const l = ({ state: c, from: f, to: d, rule: p, pasteEvt: h }) => {
    const m = c.tr, g = ld({
      state: c,
      transaction: m
    });
    if (!(!LO({
      editor: t,
      state: g,
      from: Math.max(f - 1, 0),
      to: d.b - 1,
      rule: p,
      pasteEvent: h,
      dropEvent: a
    }) || !m.steps.length)) {
      try {
        a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
      } catch {
        a = null;
      }
      return s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, m;
    }
  };
  return n.map((c) => new mt({
    // we register a global drag handler to track the current drag source element
    view(f) {
      const d = (p) => {
        var h;
        r = !((h = f.dom.parentElement) === null || h === void 0) && h.contains(p.target) ? f.dom.parentElement : null;
      };
      return window.addEventListener("dragstart", d), {
        destroy() {
          window.removeEventListener("dragstart", d);
        }
      };
    },
    props: {
      handleDOMEvents: {
        drop: (f, d) => (o = r === f.dom.parentElement, a = d, !1),
        paste: (f, d) => {
          var p;
          const h = (p = d.clipboardData) === null || p === void 0 ? void 0 : p.getData("text/html");
          return s = d, i = !!(h != null && h.includes("data-pm-slice")), !1;
        }
      }
    },
    appendTransaction: (f, d, p) => {
      const h = f[0], m = h.getMeta("uiEvent") === "paste" && !i, g = h.getMeta("uiEvent") === "drop" && !o, y = h.getMeta("applyPasteRules"), _ = !!y;
      if (!m && !g && !_)
        return;
      if (_) {
        let { text: M } = y;
        typeof M == "string" ? M = M : M = Hl(te.from(M), p.schema);
        const { from: k } = y, T = k + M.length, U = BO(M);
        return l({
          rule: c,
          state: p,
          from: k,
          to: { b: T },
          pasteEvt: U
        });
      }
      const E = d.doc.content.findDiffStart(p.doc.content), v = d.doc.content.findDiffEnd(p.doc.content);
      if (!(!OO(E) || !v || E === v.b))
        return l({
          rule: c,
          state: p,
          from: E,
          to: v,
          pasteEvt: s
        });
    }
  }));
}
function $O(e) {
  const t = e.filter((n, r) => e.indexOf(n) !== r);
  return Array.from(new Set(t));
}
class ss {
  constructor(t, n) {
    this.splittableMarks = [], this.editor = n, this.extensions = ss.resolve(t), this.schema = TO(this.extensions, n), this.setupExtensions();
  }
  /**
   * Returns a flattened and sorted extension list while
   * also checking for duplicated extensions and warns the user.
   * @param extensions An array of Tiptap extensions
   * @returns An flattened and sorted array of Tiptap extensions
   */
  static resolve(t) {
    const n = ss.sort(ss.flatten(t)), r = $O(n.map((i) => i.name));
    return r.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${r.map((i) => `'${i}'`).join(", ")}]. This can lead to issues.`), n;
  }
  /**
   * Create a flattened array of extensions by traversing the `addExtensions` field.
   * @param extensions An array of Tiptap extensions
   * @returns A flattened array of Tiptap extensions
   */
  static flatten(t) {
    return t.map((n) => {
      const r = {
        name: n.name,
        options: n.options,
        storage: n.storage
      }, i = ke(n, "addExtensions", r);
      return i ? [n, ...this.flatten(i())] : n;
    }).flat(10);
  }
  /**
   * Sort extensions by priority.
   * @param extensions An array of Tiptap extensions
   * @returns A sorted array of Tiptap extensions by priority
   */
  static sort(t) {
    return t.sort((r, i) => {
      const o = ke(r, "priority") || 100, s = ke(i, "priority") || 100;
      return o > s ? -1 : o < s ? 1 : 0;
    });
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((t, n) => {
      const r = {
        name: n.name,
        options: n.options,
        storage: n.storage,
        editor: this.editor,
        type: pp(n.name, this.schema)
      }, i = ke(n, "addCommands", r);
      return i ? {
        ...t,
        ...i()
      } : t;
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor: t } = this, n = ss.sort([...this.extensions].reverse()), r = [], i = [], o = n.map((s) => {
      const a = {
        name: s.name,
        options: s.options,
        storage: s.storage,
        editor: t,
        type: pp(s.name, this.schema)
      }, l = [], u = ke(s, "addKeyboardShortcuts", a);
      let c = {};
      if (s.type === "mark" && ke(s, "exitable", a) && (c.ArrowRight = () => Jt.handleExit({ editor: t, mark: s })), u) {
        const m = Object.fromEntries(Object.entries(u()).map(([g, y]) => [g, () => y({ editor: t })]));
        c = { ...c, ...m };
      }
      const f = XD(c);
      l.push(f);
      const d = ke(s, "addInputRules", a);
      Zm(s, t.options.enableInputRules) && d && r.push(...d());
      const p = ke(s, "addPasteRules", a);
      Zm(s, t.options.enablePasteRules) && p && i.push(...p());
      const h = ke(s, "addProseMirrorPlugins", a);
      if (h) {
        const m = h();
        l.push(...m);
      }
      return l;
    }).flat();
    return [
      NO({
        editor: t,
        rules: r
      }),
      ...PO({
        editor: t,
        rules: i
      }),
      ...o
    ];
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return h3(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor: t } = this, { nodeExtensions: n } = cd(this.extensions);
    return Object.fromEntries(n.filter((r) => !!ke(r, "addNodeView")).map((r) => {
      const i = this.attributes.filter((l) => l.type === r.name), o = {
        name: r.name,
        options: r.options,
        storage: r.storage,
        editor: t,
        type: qt(r.name, this.schema)
      }, s = ke(r, "addNodeView", o);
      if (!s)
        return [];
      const a = (l, u, c, f, d) => {
        const p = Ch(l, i);
        return s()({
          // pass-through
          node: l,
          view: u,
          getPos: c,
          decorations: f,
          innerDecorations: d,
          // tiptap-specific
          editor: t,
          extension: r,
          HTMLAttributes: p
        });
      };
      return [r.name, a];
    }));
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    this.extensions.forEach((t) => {
      var n;
      this.editor.extensionStorage[t.name] = t.storage;
      const r = {
        name: t.name,
        options: t.options,
        storage: t.storage,
        editor: this.editor,
        type: pp(t.name, this.schema)
      };
      t.type === "mark" && (!((n = je(ke(t, "keepOnSplit", r))) !== null && n !== void 0) || n) && this.splittableMarks.push(t.name);
      const i = ke(t, "onBeforeCreate", r), o = ke(t, "onCreate", r), s = ke(t, "onUpdate", r), a = ke(t, "onSelectionUpdate", r), l = ke(t, "onTransaction", r), u = ke(t, "onFocus", r), c = ke(t, "onBlur", r), f = ke(t, "onDestroy", r);
      i && this.editor.on("beforeCreate", i), o && this.editor.on("create", o), s && this.editor.on("update", s), a && this.editor.on("selectionUpdate", a), l && this.editor.on("transaction", l), u && this.editor.on("focus", u), c && this.editor.on("blur", c), f && this.editor.on("destroy", f);
    });
  }
}
class ht {
  constructor(t = {}) {
    this.type = "extension", this.name = "extension", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...t
    }, this.name = this.config.name, t.defaultOptions && Object.keys(t.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = je(ke(this, "addOptions", {
      name: this.name
    }))), this.storage = je(ke(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(t = {}) {
    return new ht(t);
  }
  configure(t = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => fd(this.options, t)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(t = {}) {
    const n = new ht({ ...this.config, ...t });
    return n.parent = this, this.child = n, n.name = t.name ? t.name : n.parent.name, t.defaultOptions && Object.keys(t.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = je(ke(n, "addOptions", {
      name: n.name
    })), n.storage = je(ke(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
}
function m3(e, t, n) {
  const { from: r, to: i } = t, { blockSeparator: o = `

`, textSerializers: s = {} } = n || {};
  let a = "";
  return e.nodesBetween(r, i, (l, u, c, f) => {
    var d;
    l.isBlock && u > r && (a += o);
    const p = s == null ? void 0 : s[l.type.name];
    if (p)
      return c && (a += p({
        node: l,
        pos: u,
        parent: c,
        index: f,
        range: t
      })), !1;
    l.isText && (a += (d = l == null ? void 0 : l.text) === null || d === void 0 ? void 0 : d.slice(Math.max(r, u) - u, i - u));
  }), a;
}
function b3(e) {
  return Object.fromEntries(Object.entries(e.nodes).filter(([, t]) => t.spec.toText).map(([t, n]) => [t, n.spec.toText]));
}
const y3 = ht.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new mt({
        key: new Pt("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor: e } = this, { state: t, schema: n } = e, { doc: r, selection: i } = t, { ranges: o } = i, s = Math.min(...o.map((c) => c.$from.pos)), a = Math.max(...o.map((c) => c.$to.pos)), l = b3(n);
            return m3(r, { from: s, to: a }, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers: l
            });
          }
        }
      })
    ];
  }
}), zO = () => ({ editor: e, view: t }) => (requestAnimationFrame(() => {
  var n;
  e.isDestroyed || (t.dom.blur(), (n = window == null ? void 0 : window.getSelection()) === null || n === void 0 || n.removeAllRanges());
}), !0), FO = (e = !1) => ({ commands: t }) => t.setContent("", e), jO = () => ({ state: e, tr: t, dispatch: n }) => {
  const { selection: r } = t, { ranges: i } = r;
  return n && i.forEach(({ $from: o, $to: s }) => {
    e.doc.nodesBetween(o.pos, s.pos, (a, l) => {
      if (a.type.isText)
        return;
      const { doc: u, mapping: c } = t, f = u.resolve(c.map(l)), d = u.resolve(c.map(l + a.nodeSize)), p = f.blockRange(d);
      if (!p)
        return;
      const h = ta(p);
      if (a.type.isTextblock) {
        const { defaultType: m } = f.parent.contentMatchAt(f.index());
        t.setNodeMarkup(p.start, m);
      }
      (h || h === 0) && t.lift(p, h);
    });
  }), !0;
}, UO = (e) => (t) => e(t), VO = () => ({ state: e, dispatch: t }) => fO(e, t), HO = (e, t) => ({ editor: n, tr: r }) => {
  const { state: i } = n, o = i.doc.slice(e.from, e.to);
  r.deleteRange(e.from, e.to);
  const s = r.mapping.map(t);
  return r.insert(s, o.content), r.setSelection(new Oe(r.doc.resolve(s - 1))), !0;
}, qO = () => ({ tr: e, dispatch: t }) => {
  const { selection: n } = e, r = n.$anchor.node();
  if (r.content.size > 0)
    return !1;
  const i = e.selection.$anchor;
  for (let o = i.depth; o > 0; o -= 1)
    if (i.node(o).type === r.type) {
      if (t) {
        const a = i.before(o), l = i.after(o);
        e.delete(a, l).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, GO = (e) => ({ tr: t, state: n, dispatch: r }) => {
  const i = qt(e, n.schema), o = t.selection.$anchor;
  for (let s = o.depth; s > 0; s -= 1)
    if (o.node(s).type === i) {
      if (r) {
        const l = o.before(s), u = o.after(s);
        t.delete(l, u).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, WO = (e) => ({ tr: t, dispatch: n }) => {
  const { from: r, to: i } = e;
  return n && t.delete(r, i), !0;
}, KO = () => ({ state: e, dispatch: t }) => JD(e, t), YO = () => ({ commands: e }) => e.keyboardShortcut("Enter"), QO = () => ({ state: e, dispatch: t }) => cO(e, t);
function zc(e, t, n = { strict: !0 }) {
  const r = Object.keys(t);
  return r.length ? r.every((i) => n.strict ? t[i] === e[i] : ig(t[i]) ? t[i].test(e[i]) : t[i] === e[i]) : !0;
}
function v3(e, t, n = {}) {
  return e.find((r) => r.type === t && zc(
    // Only check equality for the attributes that are provided
    Object.fromEntries(Object.keys(n).map((i) => [i, r.attrs[i]])),
    n
  ));
}
function Xm(e, t, n = {}) {
  return !!v3(e, t, n);
}
function dd(e, t, n) {
  var r;
  if (!e || !t)
    return;
  let i = e.parent.childAfter(e.parentOffset);
  if ((!i.node || !i.node.marks.some((c) => c.type === t)) && (i = e.parent.childBefore(e.parentOffset)), !i.node || !i.node.marks.some((c) => c.type === t) || (n = n || ((r = i.node.marks[0]) === null || r === void 0 ? void 0 : r.attrs), !v3([...i.node.marks], t, n)))
    return;
  let s = i.index, a = e.start() + i.offset, l = s + 1, u = a + i.node.nodeSize;
  for (; s > 0 && Xm([...e.parent.child(s - 1).marks], t, n); )
    s -= 1, a -= e.parent.child(s).nodeSize;
  for (; l < e.parent.childCount && Xm([...e.parent.child(l).marks], t, n); )
    u += e.parent.child(l).nodeSize, l += 1;
  return {
    from: a,
    to: u
  };
}
function Xi(e, t) {
  if (typeof e == "string") {
    if (!t.marks[e])
      throw Error(`There is no mark type named '${e}'. Maybe you forgot to add the extension?`);
    return t.marks[e];
  }
  return e;
}
const ZO = (e, t = {}) => ({ tr: n, state: r, dispatch: i }) => {
  const o = Xi(e, r.schema), { doc: s, selection: a } = n, { $from: l, from: u, to: c } = a;
  if (i) {
    const f = dd(l, o, t);
    if (f && f.from <= u && f.to >= c) {
      const d = Oe.create(s, f.from, f.to);
      n.setSelection(d);
    }
  }
  return !0;
}, XO = (e) => (t) => {
  const n = typeof e == "function" ? e(t) : e;
  for (let r = 0; r < n.length; r += 1)
    if (n[r](t))
      return !0;
  return !1;
};
function og(e) {
  return e instanceof Oe;
}
function si(e = 0, t = 0, n = 0) {
  return Math.min(Math.max(e, t), n);
}
function _3(e, t = null) {
  if (!t)
    return null;
  const n = Be.atStart(e), r = Be.atEnd(e);
  if (t === "start" || t === !0)
    return n;
  if (t === "end")
    return r;
  const i = n.from, o = r.to;
  return t === "all" ? Oe.create(e, si(0, i, o), si(e.content.size, i, o)) : Oe.create(e, si(t, i, o), si(t, i, o));
}
function sg() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
const JO = (e = null, t = {}) => ({ editor: n, view: r, tr: i, dispatch: o }) => {
  t = {
    scrollIntoView: !0,
    ...t
  };
  const s = () => {
    sg() && r.dom.focus(), requestAnimationFrame(() => {
      n.isDestroyed || (r.focus(), t != null && t.scrollIntoView && n.commands.scrollIntoView());
    });
  };
  if (r.hasFocus() && e === null || e === !1)
    return !0;
  if (o && e === null && !og(n.state.selection))
    return s(), !0;
  const a = _3(i.doc, e) || n.state.selection, l = n.state.selection.eq(a);
  return o && (l || i.setSelection(a), l && i.storedMarks && i.setStoredMarks(i.storedMarks), s()), !0;
}, eI = (e, t) => (n) => e.every((r, i) => t(r, { ...n, index: i })), tI = (e, t) => ({ tr: n, commands: r }) => r.insertContentAt({ from: n.selection.from, to: n.selection.to }, e, t), E3 = (e) => {
  const t = e.childNodes;
  for (let n = t.length - 1; n >= 0; n -= 1) {
    const r = t[n];
    r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue) ? e.removeChild(r) : r.nodeType === 1 && E3(r);
  }
  return e;
};
function bu(e) {
  const t = `<body>${e}</body>`, n = new window.DOMParser().parseFromString(t, "text/html").body;
  return E3(n);
}
function Fc(e, t, n) {
  if (e instanceof Fi || e instanceof te)
    return e;
  n = {
    slice: !0,
    parseOptions: {},
    ...n
  };
  const r = typeof e == "object" && e !== null, i = typeof e == "string";
  if (r)
    try {
      if (Array.isArray(e) && e.length > 0)
        return te.fromArray(e.map((a) => t.nodeFromJSON(a)));
      const s = t.nodeFromJSON(e);
      return n.errorOnInvalidContent && s.check(), s;
    } catch (o) {
      if (n.errorOnInvalidContent)
        throw new Error("[tiptap error]: Invalid JSON content", { cause: o });
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", e, "Error:", o), Fc("", t, n);
    }
  if (i) {
    if (n.errorOnInvalidContent) {
      let s = !1, a = "";
      const l = new V0({
        topNode: t.spec.topNode,
        marks: t.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: t.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (u) => (s = !0, a = typeof u == "string" ? u : u.outerHTML, null)
              }
            ]
          }
        })
      });
      if (n.slice ? li.fromSchema(l).parseSlice(bu(e), n.parseOptions) : li.fromSchema(l).parse(bu(e), n.parseOptions), n.errorOnInvalidContent && s)
        throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${a}`) });
    }
    const o = li.fromSchema(t);
    return n.slice ? o.parseSlice(bu(e), n.parseOptions).content : o.parse(bu(e), n.parseOptions);
  }
  return Fc("", t, n);
}
function nI(e, t, n) {
  const r = e.steps.length - 1;
  if (r < t)
    return;
  const i = e.steps[r];
  if (!(i instanceof jt || i instanceof Vt))
    return;
  const o = e.mapping.maps[r];
  let s = 0;
  o.forEach((a, l, u, c) => {
    s === 0 && (s = c);
  }), e.setSelection(Be.near(e.doc.resolve(s), n));
}
const rI = (e) => !("type" in e), iI = (e, t, n) => ({ tr: r, dispatch: i, editor: o }) => {
  var s;
  if (i) {
    n = {
      parseOptions: o.options.parseOptions,
      updateSelection: !0,
      applyInputRules: !1,
      applyPasteRules: !1,
      ...n
    };
    let a;
    try {
      a = Fc(t, o.schema, {
        parseOptions: {
          preserveWhitespace: "full",
          ...n.parseOptions
        },
        errorOnInvalidContent: (s = n.errorOnInvalidContent) !== null && s !== void 0 ? s : o.options.enableContentCheck
      });
    } catch (h) {
      return o.emit("contentError", {
        editor: o,
        error: h,
        disableCollaboration: () => {
          o.storage.collaboration && (o.storage.collaboration.isDisabled = !0);
        }
      }), !1;
    }
    let { from: l, to: u } = typeof e == "number" ? { from: e, to: e } : { from: e.from, to: e.to }, c = !0, f = !0;
    if ((rI(a) ? a : [a]).forEach((h) => {
      h.check(), c = c ? h.isText && h.marks.length === 0 : !1, f = f ? h.isBlock : !1;
    }), l === u && f) {
      const { parent: h } = r.doc.resolve(l);
      h.isTextblock && !h.type.spec.code && !h.childCount && (l -= 1, u += 1);
    }
    let p;
    if (c) {
      if (Array.isArray(t))
        p = t.map((h) => h.text || "").join("");
      else if (t instanceof te) {
        let h = "";
        t.forEach((m) => {
          m.text && (h += m.text);
        }), p = h;
      } else typeof t == "object" && t && t.text ? p = t.text : p = t;
      r.insertText(p, l, u);
    } else
      p = a, r.replaceWith(l, u, p);
    n.updateSelection && nI(r, r.steps.length - 1, -1), n.applyInputRules && r.setMeta("applyInputRules", { from: l, text: p }), n.applyPasteRules && r.setMeta("applyPasteRules", { from: l, text: p });
  }
  return !0;
}, oI = () => ({ state: e, dispatch: t }) => sO(e, t), sI = () => ({ state: e, dispatch: t }) => aO(e, t), aI = () => ({ state: e, dispatch: t }) => eO(e, t), lI = () => ({ state: e, dispatch: t }) => iO(e, t), uI = () => ({ state: e, dispatch: t, tr: n }) => {
  try {
    const r = nd(e.doc, e.selection.$from.pos, -1);
    return r == null ? !1 : (n.join(r, 2), t && t(n), !0);
  } catch {
    return !1;
  }
}, cI = () => ({ state: e, dispatch: t, tr: n }) => {
  try {
    const r = nd(e.doc, e.selection.$from.pos, 1);
    return r == null ? !1 : (n.join(r, 2), t && t(n), !0);
  } catch {
    return !1;
  }
}, fI = () => ({ state: e, dispatch: t }) => tO(e, t), dI = () => ({ state: e, dispatch: t }) => nO(e, t);
function w3() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function pI(e) {
  const t = e.split(/-(?!$)/);
  let n = t[t.length - 1];
  n === "Space" && (n = " ");
  let r, i, o, s;
  for (let a = 0; a < t.length - 1; a += 1) {
    const l = t[a];
    if (/^(cmd|meta|m)$/i.test(l))
      s = !0;
    else if (/^a(lt)?$/i.test(l))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      i = !0;
    else if (/^s(hift)?$/i.test(l))
      o = !0;
    else if (/^mod$/i.test(l))
      sg() || w3() ? s = !0 : i = !0;
    else
      throw new Error(`Unrecognized modifier name: ${l}`);
  }
  return r && (n = `Alt-${n}`), i && (n = `Ctrl-${n}`), s && (n = `Meta-${n}`), o && (n = `Shift-${n}`), n;
}
const hI = (e) => ({ editor: t, view: n, tr: r, dispatch: i }) => {
  const o = pI(e).split(/-(?!$)/), s = o.find((u) => !["Alt", "Ctrl", "Meta", "Shift"].includes(u)), a = new KeyboardEvent("keydown", {
    key: s === "Space" ? " " : s,
    altKey: o.includes("Alt"),
    ctrlKey: o.includes("Ctrl"),
    metaKey: o.includes("Meta"),
    shiftKey: o.includes("Shift"),
    bubbles: !0,
    cancelable: !0
  }), l = t.captureTransaction(() => {
    n.someProp("handleKeyDown", (u) => u(n, a));
  });
  return l == null || l.steps.forEach((u) => {
    const c = u.map(r.mapping);
    c && i && r.maybeStep(c);
  }), !0;
};
function sl(e, t, n = {}) {
  const { from: r, to: i, empty: o } = e.selection, s = t ? qt(t, e.schema) : null, a = [];
  e.doc.nodesBetween(r, i, (f, d) => {
    if (f.isText)
      return;
    const p = Math.max(r, d), h = Math.min(i, d + f.nodeSize);
    a.push({
      node: f,
      from: p,
      to: h
    });
  });
  const l = i - r, u = a.filter((f) => s ? s.name === f.node.type.name : !0).filter((f) => zc(f.node.attrs, n, { strict: !1 }));
  return o ? !!u.length : u.reduce((f, d) => f + d.to - d.from, 0) >= l;
}
const gI = (e, t = {}) => ({ state: n, dispatch: r }) => {
  const i = qt(e, n.schema);
  return sl(n, i, t) ? lO(n, r) : !1;
}, mI = () => ({ state: e, dispatch: t }) => dO(e, t), bI = (e) => ({ state: t, dispatch: n }) => {
  const r = qt(e, t.schema);
  return _O(r)(t, n);
}, yI = () => ({ state: e, dispatch: t }) => uO(e, t);
function pd(e, t) {
  return t.nodes[e] ? "node" : t.marks[e] ? "mark" : null;
}
function Jm(e, t) {
  const n = typeof t == "string" ? [t] : t;
  return Object.keys(e).reduce((r, i) => (n.includes(i) || (r[i] = e[i]), r), {});
}
const vI = (e, t) => ({ tr: n, state: r, dispatch: i }) => {
  let o = null, s = null;
  const a = pd(typeof e == "string" ? e : e.name, r.schema);
  return a ? (a === "node" && (o = qt(e, r.schema)), a === "mark" && (s = Xi(e, r.schema)), i && n.selection.ranges.forEach((l) => {
    r.doc.nodesBetween(l.$from.pos, l.$to.pos, (u, c) => {
      o && o === u.type && n.setNodeMarkup(c, void 0, Jm(u.attrs, t)), s && u.marks.length && u.marks.forEach((f) => {
        s === f.type && n.addMark(c, c + u.nodeSize, s.create(Jm(f.attrs, t)));
      });
    });
  }), !0) : !1;
}, _I = () => ({ tr: e, dispatch: t }) => (t && e.scrollIntoView(), !0), EI = () => ({ tr: e, commands: t }) => t.setTextSelection({
  from: 0,
  to: e.doc.content.size
}), wI = () => ({ state: e, dispatch: t }) => rO(e, t), xI = () => ({ state: e, dispatch: t }) => oO(e, t), kI = () => ({ state: e, dispatch: t }) => pO(e, t), MI = () => ({ state: e, dispatch: t }) => mO(e, t), AI = () => ({ state: e, dispatch: t }) => gO(e, t);
function Nh(e, t, n = {}, r = {}) {
  return Fc(e, t, {
    slice: !1,
    parseOptions: n,
    errorOnInvalidContent: r.errorOnInvalidContent
  });
}
const TI = (e, t = !1, n = {}, r = {}) => ({ editor: i, tr: o, dispatch: s, commands: a }) => {
  var l, u;
  const { doc: c } = o;
  if (n.preserveWhitespace !== "full") {
    const f = Nh(e, i.schema, n, {
      errorOnInvalidContent: (l = r.errorOnInvalidContent) !== null && l !== void 0 ? l : i.options.enableContentCheck
    });
    return s && o.replaceWith(0, c.content.size, f).setMeta("preventUpdate", !t), !0;
  }
  return s && o.setMeta("preventUpdate", !t), a.insertContentAt({ from: 0, to: c.content.size }, e, {
    parseOptions: n,
    errorOnInvalidContent: (u = r.errorOnInvalidContent) !== null && u !== void 0 ? u : i.options.enableContentCheck
  });
};
function ag(e, t) {
  const n = Xi(t, e.schema), { from: r, to: i, empty: o } = e.selection, s = [];
  o ? (e.storedMarks && s.push(...e.storedMarks), s.push(...e.selection.$head.marks())) : e.doc.nodesBetween(r, i, (l) => {
    s.push(...l.marks);
  });
  const a = s.find((l) => l.type.name === n.name);
  return a ? { ...a.attrs } : {};
}
function SI(e, t) {
  const n = new kE(e);
  return t.forEach((r) => {
    r.steps.forEach((i) => {
      n.step(i);
    });
  }), n;
}
function CI(e) {
  for (let t = 0; t < e.edgeCount; t += 1) {
    const { type: n } = e.edge(t);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
function Dh(e, t) {
  const n = [];
  return e.descendants((r, i) => {
    t(r) && n.push({
      node: r,
      pos: i
    });
  }), n;
}
function NI(e, t, n) {
  const r = [];
  return e.nodesBetween(t.from, t.to, (i, o) => {
    n(i) && r.push({
      node: i,
      pos: o
    });
  }), r;
}
function DI(e, t) {
  for (let n = e.depth; n > 0; n -= 1) {
    const r = e.node(n);
    if (t(r))
      return {
        pos: n > 0 ? e.before(n) : 0,
        start: e.start(n),
        depth: n,
        node: r
      };
  }
}
function lg(e) {
  return (t) => DI(t.$from, e);
}
function OI(e, t) {
  const n = {
    from: 0,
    to: e.content.size
  };
  return m3(e, n, t);
}
function II(e, t) {
  const n = qt(t, e.schema), { from: r, to: i } = e.selection, o = [];
  e.doc.nodesBetween(r, i, (a) => {
    o.push(a);
  });
  const s = o.reverse().find((a) => a.type.name === n.name);
  return s ? { ...s.attrs } : {};
}
function x3(e, t) {
  const n = pd(typeof t == "string" ? t : t.name, e.schema);
  return n === "node" ? II(e, t) : n === "mark" ? ag(e, t) : {};
}
function RI(e, t = JSON.stringify) {
  const n = {};
  return e.filter((r) => {
    const i = t(r);
    return Object.prototype.hasOwnProperty.call(n, i) ? !1 : n[i] = !0;
  });
}
function LI(e) {
  const t = RI(e);
  return t.length === 1 ? t : t.filter((n, r) => !t.filter((o, s) => s !== r).some((o) => n.oldRange.from >= o.oldRange.from && n.oldRange.to <= o.oldRange.to && n.newRange.from >= o.newRange.from && n.newRange.to <= o.newRange.to));
}
function BI(e) {
  const { mapping: t, steps: n } = e, r = [];
  return t.maps.forEach((i, o) => {
    const s = [];
    if (i.ranges.length)
      i.forEach((a, l) => {
        s.push({ from: a, to: l });
      });
    else {
      const { from: a, to: l } = n[o];
      if (a === void 0 || l === void 0)
        return;
      s.push({ from: a, to: l });
    }
    s.forEach(({ from: a, to: l }) => {
      const u = t.slice(o).map(a, -1), c = t.slice(o).map(l), f = t.invert().map(u, -1), d = t.invert().map(c);
      r.push({
        oldRange: {
          from: f,
          to: d
        },
        newRange: {
          from: u,
          to: c
        }
      });
    });
  }), LI(r);
}
function ug(e, t, n) {
  const r = [];
  return e === t ? n.resolve(e).marks().forEach((i) => {
    const o = n.resolve(e), s = dd(o, i.type);
    s && r.push({
      mark: i,
      ...s
    });
  }) : n.nodesBetween(e, t, (i, o) => {
    !i || (i == null ? void 0 : i.nodeSize) === void 0 || r.push(...i.marks.map((s) => ({
      from: o,
      to: o + i.nodeSize,
      mark: s
    })));
  }), r;
}
function tc(e, t, n) {
  return Object.fromEntries(Object.entries(n).filter(([r]) => {
    const i = e.find((o) => o.type === t && o.name === r);
    return i ? i.attribute.keepOnSplit : !1;
  }));
}
function Oh(e, t, n = {}) {
  const { empty: r, ranges: i } = e.selection, o = t ? Xi(t, e.schema) : null;
  if (r)
    return !!(e.storedMarks || e.selection.$from.marks()).filter((f) => o ? o.name === f.type.name : !0).find((f) => zc(f.attrs, n, { strict: !1 }));
  let s = 0;
  const a = [];
  if (i.forEach(({ $from: f, $to: d }) => {
    const p = f.pos, h = d.pos;
    e.doc.nodesBetween(p, h, (m, g) => {
      if (!m.isText && !m.marks.length)
        return;
      const y = Math.max(p, g), _ = Math.min(h, g + m.nodeSize), E = _ - y;
      s += E, a.push(...m.marks.map((v) => ({
        mark: v,
        from: y,
        to: _
      })));
    });
  }), s === 0)
    return !1;
  const l = a.filter((f) => o ? o.name === f.mark.type.name : !0).filter((f) => zc(f.mark.attrs, n, { strict: !1 })).reduce((f, d) => f + d.to - d.from, 0), u = a.filter((f) => o ? f.mark.type !== o && f.mark.type.excludes(o) : !0).reduce((f, d) => f + d.to - d.from, 0);
  return (l > 0 ? l + u : l) >= s;
}
function PI(e, t, n = {}) {
  if (!t)
    return sl(e, null, n) || Oh(e, null, n);
  const r = pd(t, e.schema);
  return r === "node" ? sl(e, t, n) : r === "mark" ? Oh(e, t, n) : !1;
}
function eb(e, t) {
  const { nodeExtensions: n } = cd(t), r = n.find((s) => s.name === e);
  if (!r)
    return !1;
  const i = {
    name: r.name,
    options: r.options,
    storage: r.storage
  }, o = je(ke(r, "group", i));
  return typeof o != "string" ? !1 : o.split(" ").includes("list");
}
function hd(e, { checkChildren: t = !0, ignoreWhitespace: n = !1 } = {}) {
  var r;
  if (n) {
    if (e.type.name === "hardBreak")
      return !0;
    if (e.isText)
      return /^\s*$/m.test((r = e.text) !== null && r !== void 0 ? r : "");
  }
  if (e.isText)
    return !e.text;
  if (e.isAtom || e.isLeaf)
    return !1;
  if (e.content.childCount === 0)
    return !0;
  if (t) {
    let i = !0;
    return e.content.forEach((o) => {
      i !== !1 && (hd(o, { ignoreWhitespace: n, checkChildren: t }) || (i = !1));
    }), i;
  }
  return !1;
}
function k3(e) {
  return e instanceof Ce;
}
function M3(e, t, n) {
  const i = e.state.doc.content.size, o = si(t, 0, i), s = si(n, 0, i), a = e.coordsAtPos(o), l = e.coordsAtPos(s, -1), u = Math.min(a.top, l.top), c = Math.max(a.bottom, l.bottom), f = Math.min(a.left, l.left), d = Math.max(a.right, l.right), p = d - f, h = c - u, y = {
    top: u,
    bottom: c,
    left: f,
    right: d,
    width: p,
    height: h,
    x: f,
    y: u
  };
  return {
    ...y,
    toJSON: () => y
  };
}
function $I(e, t, n) {
  var r;
  const { selection: i } = t;
  let o = null;
  if (og(i) && (o = i.$cursor), o) {
    const a = (r = e.storedMarks) !== null && r !== void 0 ? r : o.marks();
    return !!n.isInSet(a) || !a.some((l) => l.type.excludes(n));
  }
  const { ranges: s } = i;
  return s.some(({ $from: a, $to: l }) => {
    let u = a.depth === 0 ? e.doc.inlineContent && e.doc.type.allowsMarkType(n) : !1;
    return e.doc.nodesBetween(a.pos, l.pos, (c, f, d) => {
      if (u)
        return !1;
      if (c.isInline) {
        const p = !d || d.type.allowsMarkType(n), h = !!n.isInSet(c.marks) || !c.marks.some((m) => m.type.excludes(n));
        u = p && h;
      }
      return !u;
    }), u;
  });
}
const zI = (e, t = {}) => ({ tr: n, state: r, dispatch: i }) => {
  const { selection: o } = n, { empty: s, ranges: a } = o, l = Xi(e, r.schema);
  if (i)
    if (s) {
      const u = ag(r, l);
      n.addStoredMark(l.create({
        ...u,
        ...t
      }));
    } else
      a.forEach((u) => {
        const c = u.$from.pos, f = u.$to.pos;
        r.doc.nodesBetween(c, f, (d, p) => {
          const h = Math.max(p, c), m = Math.min(p + d.nodeSize, f);
          d.marks.find((y) => y.type === l) ? d.marks.forEach((y) => {
            l === y.type && n.addMark(h, m, l.create({
              ...y.attrs,
              ...t
            }));
          }) : n.addMark(h, m, l.create(t));
        });
      });
  return $I(r, n, l);
}, FI = (e, t) => ({ tr: n }) => (n.setMeta(e, t), !0), jI = (e, t = {}) => ({ state: n, dispatch: r, chain: i }) => {
  const o = qt(e, n.schema);
  let s;
  return n.selection.$anchor.sameParent(n.selection.$head) && (s = n.selection.$anchor.parent.attrs), o.isTextblock ? i().command(({ commands: a }) => Km(o, { ...s, ...t })(n) ? !0 : a.clearNodes()).command(({ state: a }) => Km(o, { ...s, ...t })(a, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1);
}, UI = (e) => ({ tr: t, dispatch: n }) => {
  if (n) {
    const { doc: r } = t, i = si(e, 0, r.content.size), o = Ce.create(r, i);
    t.setSelection(o);
  }
  return !0;
}, VI = (e) => ({ tr: t, dispatch: n }) => {
  if (n) {
    const { doc: r } = t, { from: i, to: o } = typeof e == "number" ? { from: e, to: e } : e, s = Oe.atStart(r).from, a = Oe.atEnd(r).to, l = si(i, s, a), u = si(o, s, a), c = Oe.create(r, l, u);
    t.setSelection(c);
  }
  return !0;
}, HI = (e) => ({ state: t, dispatch: n }) => {
  const r = qt(e, t.schema);
  return xO(r)(t, n);
};
function tb(e, t) {
  const n = e.storedMarks || e.selection.$to.parentOffset && e.selection.$from.marks();
  if (n) {
    const r = n.filter((i) => t == null ? void 0 : t.includes(i.type.name));
    e.tr.ensureMarks(r);
  }
}
const qI = ({ keepMarks: e = !0 } = {}) => ({ tr: t, state: n, dispatch: r, editor: i }) => {
  const { selection: o, doc: s } = t, { $from: a, $to: l } = o, u = i.extensionManager.attributes, c = tc(u, a.node().type.name, a.node().attrs);
  if (o instanceof Ce && o.node.isBlock)
    return !a.parentOffset || !fs(s, a.pos) ? !1 : (r && (e && tb(n, i.extensionManager.splittableMarks), t.split(a.pos).scrollIntoView()), !0);
  if (!a.parent.isBlock)
    return !1;
  const f = l.parentOffset === l.parent.content.size, d = a.depth === 0 ? void 0 : CI(a.node(-1).contentMatchAt(a.indexAfter(-1)));
  let p = f && d ? [
    {
      type: d,
      attrs: c
    }
  ] : void 0, h = fs(t.doc, t.mapping.map(a.pos), 1, p);
  if (!p && !h && fs(t.doc, t.mapping.map(a.pos), 1, d ? [{ type: d }] : void 0) && (h = !0, p = d ? [
    {
      type: d,
      attrs: c
    }
  ] : void 0), r) {
    if (h && (o instanceof Oe && t.deleteSelection(), t.split(t.mapping.map(a.pos), 1, p), d && !f && !a.parentOffset && a.parent.type !== d)) {
      const m = t.mapping.map(a.before()), g = t.doc.resolve(m);
      a.node(-1).canReplaceWith(g.index(), g.index() + 1, d) && t.setNodeMarkup(t.mapping.map(a.before()), d);
    }
    e && tb(n, i.extensionManager.splittableMarks), t.scrollIntoView();
  }
  return h;
}, GI = (e, t = {}) => ({ tr: n, state: r, dispatch: i, editor: o }) => {
  var s;
  const a = qt(e, r.schema), { $from: l, $to: u } = r.selection, c = r.selection.node;
  if (c && c.isBlock || l.depth < 2 || !l.sameParent(u))
    return !1;
  const f = l.node(-1);
  if (f.type !== a)
    return !1;
  const d = o.extensionManager.attributes;
  if (l.parent.content.size === 0 && l.node(-1).childCount === l.indexAfter(-1)) {
    if (l.depth === 2 || l.node(-3).type !== a || l.index(-2) !== l.node(-2).childCount - 1)
      return !1;
    if (i) {
      let y = te.empty;
      const _ = l.index(-1) ? 1 : l.index(-2) ? 2 : 3;
      for (let U = l.depth - _; U >= l.depth - 3; U -= 1)
        y = te.from(l.node(U).copy(y));
      const E = l.indexAfter(-1) < l.node(-2).childCount ? 1 : l.indexAfter(-2) < l.node(-3).childCount ? 2 : 3, v = {
        ...tc(d, l.node().type.name, l.node().attrs),
        ...t
      }, M = ((s = a.contentMatch.defaultType) === null || s === void 0 ? void 0 : s.createAndFill(v)) || void 0;
      y = y.append(te.from(a.createAndFill(null, M) || void 0));
      const k = l.before(l.depth - (_ - 1));
      n.replace(k, l.after(-E), new ye(y, 4 - _, 0));
      let T = -1;
      n.doc.nodesBetween(k, n.doc.content.size, (U, C) => {
        if (T > -1)
          return !1;
        U.isTextblock && U.content.size === 0 && (T = C + 1);
      }), T > -1 && n.setSelection(Oe.near(n.doc.resolve(T))), n.scrollIntoView();
    }
    return !0;
  }
  const p = u.pos === l.end() ? f.contentMatchAt(0).defaultType : null, h = {
    ...tc(d, f.type.name, f.attrs),
    ...t
  }, m = {
    ...tc(d, l.node().type.name, l.node().attrs),
    ...t
  };
  n.delete(l.pos, u.pos);
  const g = p ? [
    { type: a, attrs: h },
    { type: p, attrs: m }
  ] : [{ type: a, attrs: h }];
  if (!fs(n.doc, l.pos, 2))
    return !1;
  if (i) {
    const { selection: y, storedMarks: _ } = r, { splittableMarks: E } = o.extensionManager, v = _ || y.$to.parentOffset && y.$from.marks();
    if (n.split(l.pos, 2, g).scrollIntoView(), !v || !i)
      return !0;
    const M = v.filter((k) => E.includes(k.type.name));
    n.ensureMarks(M);
  }
  return !0;
}, hp = (e, t) => {
  const n = lg((s) => s.type === t)(e.selection);
  if (!n)
    return !0;
  const r = e.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
  if (r === void 0)
    return !0;
  const i = e.doc.nodeAt(r);
  return n.node.type === (i == null ? void 0 : i.type) && Qi(e.doc, n.pos) && e.join(n.pos), !0;
}, gp = (e, t) => {
  const n = lg((s) => s.type === t)(e.selection);
  if (!n)
    return !0;
  const r = e.doc.resolve(n.start).after(n.depth);
  if (r === void 0)
    return !0;
  const i = e.doc.nodeAt(r);
  return n.node.type === (i == null ? void 0 : i.type) && Qi(e.doc, r) && e.join(r), !0;
}, WI = (e, t, n, r = {}) => ({ editor: i, tr: o, state: s, dispatch: a, chain: l, commands: u, can: c }) => {
  const { extensions: f, splittableMarks: d } = i.extensionManager, p = qt(e, s.schema), h = qt(t, s.schema), { selection: m, storedMarks: g } = s, { $from: y, $to: _ } = m, E = y.blockRange(_), v = g || m.$to.parentOffset && m.$from.marks();
  if (!E)
    return !1;
  const M = lg((k) => eb(k.type.name, f))(m);
  if (E.depth >= 1 && M && E.depth - M.depth <= 1) {
    if (M.node.type === p)
      return u.liftListItem(h);
    if (eb(M.node.type.name, f) && p.validContent(M.node.content) && a)
      return l().command(() => (o.setNodeMarkup(M.pos, p), !0)).command(() => hp(o, p)).command(() => gp(o, p)).run();
  }
  return !n || !v || !a ? l().command(() => c().wrapInList(p, r) ? !0 : u.clearNodes()).wrapInList(p, r).command(() => hp(o, p)).command(() => gp(o, p)).run() : l().command(() => {
    const k = c().wrapInList(p, r), T = v.filter((U) => d.includes(U.type.name));
    return o.ensureMarks(T), k ? !0 : u.clearNodes();
  }).wrapInList(p, r).command(() => hp(o, p)).command(() => gp(o, p)).run();
}, KI = (e, t = {}, n = {}) => ({ state: r, commands: i }) => {
  const { extendEmptyMarkRange: o = !1 } = n, s = Xi(e, r.schema);
  return Oh(r, s, t) ? i.unsetMark(s, { extendEmptyMarkRange: o }) : i.setMark(s, t);
}, YI = (e, t, n = {}) => ({ state: r, commands: i }) => {
  const o = qt(e, r.schema), s = qt(t, r.schema), a = sl(r, o, n);
  let l;
  return r.selection.$anchor.sameParent(r.selection.$head) && (l = r.selection.$anchor.parent.attrs), a ? i.setNode(s, l) : i.setNode(o, { ...l, ...n });
}, QI = (e, t = {}) => ({ state: n, commands: r }) => {
  const i = qt(e, n.schema);
  return sl(n, i, t) ? r.lift(i) : r.wrapIn(i, t);
}, ZI = () => ({ state: e, dispatch: t }) => {
  const n = e.plugins;
  for (let r = 0; r < n.length; r += 1) {
    const i = n[r];
    let o;
    if (i.spec.isInputRules && (o = i.getState(e))) {
      if (t) {
        const s = e.tr, a = o.transform;
        for (let l = a.steps.length - 1; l >= 0; l -= 1)
          s.step(a.steps[l].invert(a.docs[l]));
        if (o.text) {
          const l = s.doc.resolve(o.from).marks();
          s.replaceWith(o.from, o.to, e.schema.text(o.text, l));
        } else
          s.delete(o.from, o.to);
      }
      return !0;
    }
  }
  return !1;
}, XI = () => ({ tr: e, dispatch: t }) => {
  const { selection: n } = e, { empty: r, ranges: i } = n;
  return r || t && i.forEach((o) => {
    e.removeMark(o.$from.pos, o.$to.pos);
  }), !0;
}, JI = (e, t = {}) => ({ tr: n, state: r, dispatch: i }) => {
  var o;
  const { extendEmptyMarkRange: s = !1 } = t, { selection: a } = n, l = Xi(e, r.schema), { $from: u, empty: c, ranges: f } = a;
  if (!i)
    return !0;
  if (c && s) {
    let { from: d, to: p } = a;
    const h = (o = u.marks().find((g) => g.type === l)) === null || o === void 0 ? void 0 : o.attrs, m = dd(u, l, h);
    m && (d = m.from, p = m.to), n.removeMark(d, p, l);
  } else
    f.forEach((d) => {
      n.removeMark(d.$from.pos, d.$to.pos, l);
    });
  return n.removeStoredMark(l), !0;
}, e5 = (e, t = {}) => ({ tr: n, state: r, dispatch: i }) => {
  let o = null, s = null;
  const a = pd(typeof e == "string" ? e : e.name, r.schema);
  return a ? (a === "node" && (o = qt(e, r.schema)), a === "mark" && (s = Xi(e, r.schema)), i && n.selection.ranges.forEach((l) => {
    const u = l.$from.pos, c = l.$to.pos;
    let f, d, p, h;
    n.selection.empty ? r.doc.nodesBetween(u, c, (m, g) => {
      o && o === m.type && (p = Math.max(g, u), h = Math.min(g + m.nodeSize, c), f = g, d = m);
    }) : r.doc.nodesBetween(u, c, (m, g) => {
      g < u && o && o === m.type && (p = Math.max(g, u), h = Math.min(g + m.nodeSize, c), f = g, d = m), g >= u && g <= c && (o && o === m.type && n.setNodeMarkup(g, void 0, {
        ...m.attrs,
        ...t
      }), s && m.marks.length && m.marks.forEach((y) => {
        if (s === y.type) {
          const _ = Math.max(g, u), E = Math.min(g + m.nodeSize, c);
          n.addMark(_, E, s.create({
            ...y.attrs,
            ...t
          }));
        }
      }));
    }), d && (f !== void 0 && n.setNodeMarkup(f, void 0, {
      ...d.attrs,
      ...t
    }), s && d.marks.length && d.marks.forEach((m) => {
      s === m.type && n.addMark(p, h, s.create({
        ...m.attrs,
        ...t
      }));
    }));
  }), !0) : !1;
}, t5 = (e, t = {}) => ({ state: n, dispatch: r }) => {
  const i = qt(e, n.schema);
  return bO(i, t)(n, r);
}, n5 = (e, t = {}) => ({ state: n, dispatch: r }) => {
  const i = qt(e, n.schema);
  return yO(i, t)(n, r);
};
var r5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur: zO,
  clearContent: FO,
  clearNodes: jO,
  command: UO,
  createParagraphNear: VO,
  cut: HO,
  deleteCurrentNode: qO,
  deleteNode: GO,
  deleteRange: WO,
  deleteSelection: KO,
  enter: YO,
  exitCode: QO,
  extendMarkRange: ZO,
  first: XO,
  focus: JO,
  forEach: eI,
  insertContent: tI,
  insertContentAt: iI,
  joinBackward: aI,
  joinDown: sI,
  joinForward: lI,
  joinItemBackward: uI,
  joinItemForward: cI,
  joinTextblockBackward: fI,
  joinTextblockForward: dI,
  joinUp: oI,
  keyboardShortcut: hI,
  lift: gI,
  liftEmptyBlock: mI,
  liftListItem: bI,
  newlineInCode: yI,
  resetAttributes: vI,
  scrollIntoView: _I,
  selectAll: EI,
  selectNodeBackward: wI,
  selectNodeForward: xI,
  selectParentNode: kI,
  selectTextblockEnd: MI,
  selectTextblockStart: AI,
  setContent: TI,
  setMark: zI,
  setMeta: FI,
  setNode: jI,
  setNodeSelection: UI,
  setTextSelection: VI,
  sinkListItem: HI,
  splitBlock: qI,
  splitListItem: GI,
  toggleList: WI,
  toggleMark: KI,
  toggleNode: YI,
  toggleWrap: QI,
  undoInputRule: ZI,
  unsetAllMarks: XI,
  unsetMark: JI,
  updateAttributes: e5,
  wrapIn: t5,
  wrapInList: n5
});
const A3 = ht.create({
  name: "commands",
  addCommands() {
    return {
      ...r5
    };
  }
}), T3 = ht.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new mt({
        key: new Pt("tiptapDrop"),
        props: {
          handleDrop: (e, t, n, r) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: t,
              slice: n,
              moved: r
            });
          }
        }
      })
    ];
  }
}), S3 = ht.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new mt({
        key: new Pt("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
}), C3 = ht.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor: e } = this;
    return [
      new mt({
        key: new Pt("focusEvents"),
        props: {
          handleDOMEvents: {
            focus: (t, n) => {
              e.isFocused = !0;
              const r = e.state.tr.setMeta("focus", { event: n }).setMeta("addToHistory", !1);
              return t.dispatch(r), !1;
            },
            blur: (t, n) => {
              e.isFocused = !1;
              const r = e.state.tr.setMeta("blur", { event: n }).setMeta("addToHistory", !1);
              return t.dispatch(r), !1;
            }
          }
        }
      })
    ];
  }
}), N3 = ht.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const e = () => this.editor.commands.first(({ commands: s }) => [
      () => s.undoInputRule(),
      // maybe convert first text block node to default node
      () => s.command(({ tr: a }) => {
        const { selection: l, doc: u } = a, { empty: c, $anchor: f } = l, { pos: d, parent: p } = f, h = f.parent.isTextblock && d > 0 ? a.doc.resolve(d - 1) : f, m = h.parent.type.spec.isolating, g = f.pos - f.parentOffset, y = m && h.parent.childCount === 1 ? g === f.pos : Be.atStart(u).from === d;
        return !c || !p.type.isTextblock || p.textContent.length || !y || y && f.parent.type.name === "paragraph" ? !1 : s.clearNodes();
      }),
      () => s.deleteSelection(),
      () => s.joinBackward(),
      () => s.selectNodeBackward()
    ]), t = () => this.editor.commands.first(({ commands: s }) => [
      () => s.deleteSelection(),
      () => s.deleteCurrentNode(),
      () => s.joinForward(),
      () => s.selectNodeForward()
    ]), r = {
      Enter: () => this.editor.commands.first(({ commands: s }) => [
        () => s.newlineInCode(),
        () => s.createParagraphNear(),
        () => s.liftEmptyBlock(),
        () => s.splitBlock()
      ]),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: e,
      "Mod-Backspace": e,
      "Shift-Backspace": e,
      Delete: t,
      "Mod-Delete": t,
      "Mod-a": () => this.editor.commands.selectAll()
    }, i = {
      ...r
    }, o = {
      ...r,
      "Ctrl-h": e,
      "Alt-Backspace": e,
      "Ctrl-d": t,
      "Ctrl-Alt-Backspace": t,
      "Alt-Delete": t,
      "Alt-d": t,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    return sg() || w3() ? o : i;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well
      // with many other commands.
      new mt({
        key: new Pt("clearDocument"),
        appendTransaction: (e, t, n) => {
          const r = e.some((m) => m.docChanged) && !t.doc.eq(n.doc), i = e.some((m) => m.getMeta("preventClearDocument"));
          if (!r || i)
            return;
          const { empty: o, from: s, to: a } = t.selection, l = Be.atStart(t.doc).from, u = Be.atEnd(t.doc).to;
          if (o || !(s === l && a === u) || !hd(n.doc))
            return;
          const d = n.tr, p = ld({
            state: n,
            transaction: d
          }), { commands: h } = new ud({
            editor: this.editor,
            state: p
          });
          if (h.clearNodes(), !!d.steps.length)
            return d;
        }
      })
    ];
  }
}), D3 = ht.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new mt({
        key: new Pt("tiptapPaste"),
        props: {
          handlePaste: (e, t, n) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: t,
              slice: n
            });
          }
        }
      })
    ];
  }
}), O3 = ht.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new mt({
        key: new Pt("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
var i5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ClipboardTextSerializer: y3,
  Commands: A3,
  Drop: T3,
  Editable: S3,
  FocusEvents: C3,
  Keymap: N3,
  Paste: D3,
  Tabindex: O3
});
class uo {
  get name() {
    return this.node.type.name;
  }
  constructor(t, n, r = !1, i = null) {
    this.currentNode = null, this.actualDepth = null, this.isBlock = r, this.resolvedPos = t, this.editor = n, this.currentNode = i;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var t;
    return (t = this.actualDepth) !== null && t !== void 0 ? t : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(t) {
    let n = this.from, r = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You cant set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      n = this.from + 1, r = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: n, to: r }, t);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0)
      return null;
    const t = this.resolvedPos.start(this.resolvedPos.depth - 1), n = this.resolvedPos.doc.resolve(t);
    return new uo(n, this.editor);
  }
  get before() {
    let t = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    return t.depth !== this.depth && (t = this.resolvedPos.doc.resolve(this.from - 3)), new uo(t, this.editor);
  }
  get after() {
    let t = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    return t.depth !== this.depth && (t = this.resolvedPos.doc.resolve(this.to + 3)), new uo(t, this.editor);
  }
  get children() {
    const t = [];
    return this.node.content.forEach((n, r) => {
      const i = n.isBlock && !n.isTextblock, o = n.isAtom && !n.isText, s = this.pos + r + (o ? 0 : 1), a = this.resolvedPos.doc.resolve(s);
      if (!i && a.depth <= this.depth)
        return;
      const l = new uo(a, this.editor, i, i ? n : null);
      i && (l.actualDepth = this.depth + 1), t.push(new uo(a, this.editor, i, i ? n : null));
    }), t;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const t = this.children;
    return t[t.length - 1] || null;
  }
  closest(t, n = {}) {
    let r = null, i = this.parent;
    for (; i && !r; ) {
      if (i.node.type.name === t)
        if (Object.keys(n).length > 0) {
          const o = i.node.attrs, s = Object.keys(n);
          for (let a = 0; a < s.length; a += 1) {
            const l = s[a];
            if (o[l] !== n[l])
              break;
          }
        } else
          r = i;
      i = i.parent;
    }
    return r;
  }
  querySelector(t, n = {}) {
    return this.querySelectorAll(t, n, !0)[0] || null;
  }
  querySelectorAll(t, n = {}, r = !1) {
    let i = [];
    if (!this.children || this.children.length === 0)
      return i;
    const o = Object.keys(n);
    return this.children.forEach((s) => {
      r && i.length > 0 || (s.node.type.name === t && o.every((l) => n[l] === s.node.attrs[l]) && i.push(s), !(r && i.length > 0) && (i = i.concat(s.querySelectorAll(t, n, r))));
    }), i;
  }
  setAttribute(t) {
    const { tr: n } = this.editor.state;
    n.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...t
    }), this.editor.view.dispatch(n);
  }
}
const o5 = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function s5(e, t, n) {
  const r = document.querySelector("style[data-tiptap-style]");
  if (r !== null)
    return r;
  const i = document.createElement("style");
  return t && i.setAttribute("nonce", t), i.setAttribute("data-tiptap-style", ""), i.innerHTML = e, document.getElementsByTagName("head")[0].appendChild(i), i;
}
let a5 = class extends kO {
  constructor(t = {}) {
    super(), this.isFocused = !1, this.isInitialized = !1, this.extensionStorage = {}, this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: !0,
      injectNonce: void 0,
      extensions: [],
      autofocus: !1,
      editable: !0,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: !0,
      enablePasteRules: !0,
      enableCoreExtensions: !0,
      enableContentCheck: !1,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error: n }) => {
        throw n;
      },
      onPaste: () => null,
      onDrop: () => null
    }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.setOptions(t), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("contentError", this.options.onContentError), this.createView(), this.injectCSS(), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: n, slice: r, moved: i }) => this.options.onDrop(n, r, i)), this.on("paste", ({ event: n, slice: r }) => this.options.onPaste(n, r)), window.setTimeout(() => {
      this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = !0);
    }, 0);
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    this.options.injectCSS && document && (this.css = s5(o5, this.options.injectNonce));
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(t = {}) {
    this.options = {
      ...this.options,
      ...t
    }, !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(t, n = !0) {
    this.setOptions({ editable: t }), n && this.emit("update", { editor: this, transaction: this.state.tr });
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.view.state;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(t, n) {
    const r = g3(n) ? n(t, [...this.state.plugins]) : [...this.state.plugins, t], i = this.state.reconfigure({ plugins: r });
    return this.view.updateState(i), i;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(t) {
    if (this.isDestroyed)
      return;
    const n = this.state.plugins;
    let r = n;
    if ([].concat(t).forEach((o) => {
      const s = typeof o == "string" ? `${o}$` : o.key;
      r = n.filter((a) => !a.key.startsWith(s));
    }), n.length === r.length)
      return;
    const i = this.state.reconfigure({
      plugins: r
    });
    return this.view.updateState(i), i;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var t, n;
    const i = [...this.options.enableCoreExtensions ? [
      S3,
      y3.configure({
        blockSeparator: (n = (t = this.options.coreExtensionOptions) === null || t === void 0 ? void 0 : t.clipboardTextSerializer) === null || n === void 0 ? void 0 : n.blockSeparator
      }),
      A3,
      C3,
      N3,
      O3,
      T3,
      D3
    ].filter((o) => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[o.name] !== !1 : !0) : [], ...this.options.extensions].filter((o) => ["extension", "node", "mark"].includes(o == null ? void 0 : o.type));
    this.extensionManager = new ss(i, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new ud({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView() {
    var t;
    let n;
    try {
      n = Nh(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });
    } catch (s) {
      if (!(s instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(s.message))
        throw s;
      this.emit("contentError", {
        editor: this,
        error: s,
        disableCollaboration: () => {
          this.storage.collaboration && (this.storage.collaboration.isDisabled = !0), this.options.extensions = this.options.extensions.filter((a) => a.name !== "collaboration"), this.createExtensionManager();
        }
      }), n = Nh(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: !1 });
    }
    const r = _3(n, this.options.autofocus);
    this.view = new VD(this.options.element, {
      ...this.options.editorProps,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...(t = this.options.editorProps) === null || t === void 0 ? void 0 : t.attributes
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: is.create({
        doc: n,
        selection: r || void 0
      })
    });
    const i = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(i), this.createNodeViews(), this.prependClass();
    const o = this.view.dom;
    o.editor = this;
  }
  /**
   * Creates all node views.
   */
  createNodeViews() {
    this.view.isDestroyed || this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(t) {
    this.isCapturingTransaction = !0, t(), this.isCapturingTransaction = !1;
    const n = this.capturedTransaction;
    return this.capturedTransaction = null, n;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(t) {
    if (this.view.isDestroyed)
      return;
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = t;
        return;
      }
      t.steps.forEach((s) => {
        var a;
        return (a = this.capturedTransaction) === null || a === void 0 ? void 0 : a.step(s);
      });
      return;
    }
    const n = this.state.apply(t), r = !this.state.selection.eq(n.selection);
    this.emit("beforeTransaction", {
      editor: this,
      transaction: t,
      nextState: n
    }), this.view.updateState(n), this.emit("transaction", {
      editor: this,
      transaction: t
    }), r && this.emit("selectionUpdate", {
      editor: this,
      transaction: t
    });
    const i = t.getMeta("focus"), o = t.getMeta("blur");
    i && this.emit("focus", {
      editor: this,
      event: i.event,
      transaction: t
    }), o && this.emit("blur", {
      editor: this,
      event: o.event,
      transaction: t
    }), !(!t.docChanged || t.getMeta("preventUpdate")) && this.emit("update", {
      editor: this,
      transaction: t
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(t) {
    return x3(this.state, t);
  }
  isActive(t, n) {
    const r = typeof t == "string" ? t : null, i = typeof t == "string" ? n : t;
    return PI(this.state, r, i);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return Hl(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(t) {
    const { blockSeparator: n = `

`, textSerializers: r = {} } = t || {};
    return OI(this.state.doc, {
      blockSeparator: n,
      textSerializers: {
        ...b3(this.schema),
        ...r
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return hd(this.state.doc);
  }
  /**
   * Get the number of characters for the current document.
   *
   * @deprecated
   */
  getCharacterCount() {
    return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'), this.state.doc.content.size - 2;
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    if (this.emit("destroy"), this.view) {
      const t = this.view.dom;
      t && t.editor && delete t.editor, this.view.destroy();
    }
    this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var t;
    return !(!((t = this.view) === null || t === void 0) && t.docView);
  }
  $node(t, n) {
    var r;
    return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelector(t, n)) || null;
  }
  $nodes(t, n) {
    var r;
    return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelectorAll(t, n)) || null;
  }
  $pos(t) {
    const n = this.state.doc.resolve(t);
    return new uo(n, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function As(e) {
  return new ql({
    find: e.find,
    handler: ({ state: t, range: n, match: r }) => {
      const i = je(e.getAttributes, void 0, r);
      if (i === !1 || i === null)
        return null;
      const { tr: o } = t, s = r[r.length - 1], a = r[0];
      if (s) {
        const l = a.search(/\S/), u = n.from + a.indexOf(s), c = u + s.length;
        if (ug(n.from, n.to, t.doc).filter((p) => p.mark.type.excluded.find((m) => m === e.type && m !== p.mark.type)).filter((p) => p.to > u).length)
          return null;
        c < n.to && o.delete(c, n.to), u > n.from && o.delete(n.from + l, u);
        const d = n.from + l + s.length;
        o.addMark(n.from + l, d, e.type.create(i || {})), o.removeStoredMark(e.type);
      }
    }
  });
}
function l5(e) {
  return new ql({
    find: e.find,
    handler: ({ state: t, range: n, match: r }) => {
      const i = je(e.getAttributes, void 0, r) || {}, { tr: o } = t, s = n.from;
      let a = n.to;
      const l = e.type.create(i);
      if (r[1]) {
        const u = r[0].lastIndexOf(r[1]);
        let c = s + u;
        c > a ? c = a : a = c + r[1].length;
        const f = r[0][r[0].length - 1];
        o.insertText(f, s + r[0].length - 1), o.replaceWith(c, a, l);
      } else if (r[0]) {
        const u = e.type.isInline ? s : s - 1;
        o.insert(u, e.type.create(i)).delete(o.mapping.map(s), o.mapping.map(a));
      }
      o.scrollIntoView();
    }
  });
}
function Ih(e) {
  return new ql({
    find: e.find,
    handler: ({ state: t, range: n, match: r }) => {
      const i = t.doc.resolve(n.from), o = je(e.getAttributes, void 0, r) || {};
      if (!i.node(-1).canReplaceWith(i.index(-1), i.indexAfter(-1), e.type))
        return null;
      t.tr.delete(n.from, n.to).setBlockType(n.from, n.from, e.type, o);
    }
  });
}
function Tt(e) {
  return new ql({
    find: e.find,
    handler: ({ state: t, range: n, match: r }) => {
      let i = e.replace, o = n.from;
      const s = n.to;
      if (r[1]) {
        const a = r[0].lastIndexOf(r[1]);
        i += r[0].slice(a + r[1].length), o += a;
        const l = o - s;
        l > 0 && (i = r[0].slice(a - l, a) + i, o = s);
      }
      t.tr.insertText(i, o, s);
    }
  });
}
function Ts(e) {
  return new ql({
    find: e.find,
    handler: ({ state: t, range: n, match: r, chain: i }) => {
      const o = je(e.getAttributes, void 0, r) || {}, s = t.tr.delete(n.from, n.to), l = s.doc.resolve(n.from).blockRange(), u = l && G0(l, e.type, o);
      if (!u)
        return null;
      if (s.wrap(l, u), e.keepMarks && e.editor) {
        const { selection: f, storedMarks: d } = t, { splittableMarks: p } = e.editor.extensionManager, h = d || f.$to.parentOffset && f.$from.marks();
        if (h) {
          const m = h.filter((g) => p.includes(g.type.name));
          s.ensureMarks(m);
        }
      }
      if (e.keepAttributes) {
        const f = e.type.name === "bulletList" || e.type.name === "orderedList" ? "listItem" : "taskList";
        i().updateAttributes(f, o).run();
      }
      const c = s.doc.resolve(n.from - 1).nodeBefore;
      c && c.type === e.type && Qi(s.doc, n.from - 1) && (!e.joinPredicate || e.joinPredicate(r, c)) && s.join(n.from - 1);
    }
  });
}
let lt = class Rh {
  constructor(t = {}) {
    this.type = "node", this.name = "node", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...t
    }, this.name = this.config.name, t.defaultOptions && Object.keys(t.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = je(ke(this, "addOptions", {
      name: this.name
    }))), this.storage = je(ke(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(t = {}) {
    return new Rh(t);
  }
  configure(t = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => fd(this.options, t)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(t = {}) {
    const n = new Rh(t);
    return n.parent = this, this.child = n, n.name = t.name ? t.name : n.parent.name, t.defaultOptions && Object.keys(t.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = je(ke(n, "addOptions", {
      name: n.name
    })), n.storage = je(ke(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
};
function Io(e) {
  return new IO({
    find: e.find,
    handler: ({ state: t, range: n, match: r, pasteEvent: i }) => {
      const o = je(e.getAttributes, void 0, r, i);
      if (o === !1 || o === null)
        return null;
      const { tr: s } = t, a = r[r.length - 1], l = r[0];
      let u = n.to;
      if (a) {
        const c = l.search(/\S/), f = n.from + l.indexOf(a), d = f + a.length;
        if (ug(n.from, n.to, t.doc).filter((h) => h.mark.type.excluded.find((g) => g === e.type && g !== h.mark.type)).filter((h) => h.to > f).length)
          return null;
        d < n.to && s.delete(d, n.to), f > n.from && s.delete(n.from + c, f), u = n.from + c + a.length, s.addMark(n.from + c, u, e.type.create(o || {})), s.removeStoredMark(e.type);
      }
    }
  });
}
var An = "top", er = "bottom", tr = "right", Tn = "left", cg = "auto", Gl = [An, er, tr, Tn], Ss = "start", al = "end", u5 = "clippingParents", I3 = "viewport", ua = "popper", c5 = "reference", nb = /* @__PURE__ */ Gl.reduce(function(e, t) {
  return e.concat([t + "-" + Ss, t + "-" + al]);
}, []), R3 = /* @__PURE__ */ [].concat(Gl, [cg]).reduce(function(e, t) {
  return e.concat([t, t + "-" + Ss, t + "-" + al]);
}, []), f5 = "beforeRead", d5 = "read", p5 = "afterRead", h5 = "beforeMain", g5 = "main", m5 = "afterMain", b5 = "beforeWrite", y5 = "write", v5 = "afterWrite", _5 = [f5, d5, p5, h5, g5, m5, b5, y5, v5];
function Hr(e) {
  return e ? (e.nodeName || "").toLowerCase() : null;
}
function Un(e) {
  if (e == null)
    return window;
  if (e.toString() !== "[object Window]") {
    var t = e.ownerDocument;
    return t && t.defaultView || window;
  }
  return e;
}
function Ro(e) {
  var t = Un(e).Element;
  return e instanceof t || e instanceof Element;
}
function Zn(e) {
  var t = Un(e).HTMLElement;
  return e instanceof t || e instanceof HTMLElement;
}
function fg(e) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = Un(e).ShadowRoot;
  return e instanceof t || e instanceof ShadowRoot;
}
function E5(e) {
  var t = e.state;
  Object.keys(t.elements).forEach(function(n) {
    var r = t.styles[n] || {}, i = t.attributes[n] || {}, o = t.elements[n];
    !Zn(o) || !Hr(o) || (Object.assign(o.style, r), Object.keys(i).forEach(function(s) {
      var a = i[s];
      a === !1 ? o.removeAttribute(s) : o.setAttribute(s, a === !0 ? "" : a);
    }));
  });
}
function w5(e) {
  var t = e.state, n = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function() {
    Object.keys(t.elements).forEach(function(r) {
      var i = t.elements[r], o = t.attributes[r] || {}, s = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : n[r]), a = s.reduce(function(l, u) {
        return l[u] = "", l;
      }, {});
      !Zn(i) || !Hr(i) || (Object.assign(i.style, a), Object.keys(o).forEach(function(l) {
        i.removeAttribute(l);
      }));
    });
  };
}
const L3 = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: E5,
  effect: w5,
  requires: ["computeStyles"]
};
function Br(e) {
  return e.split("-")[0];
}
var Eo = Math.max, jc = Math.min, Cs = Math.round;
function Lh() {
  var e = navigator.userAgentData;
  return e != null && e.brands && Array.isArray(e.brands) ? e.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function B3() {
  return !/^((?!chrome|android).)*safari/i.test(Lh());
}
function Ns(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  var r = e.getBoundingClientRect(), i = 1, o = 1;
  t && Zn(e) && (i = e.offsetWidth > 0 && Cs(r.width) / e.offsetWidth || 1, o = e.offsetHeight > 0 && Cs(r.height) / e.offsetHeight || 1);
  var s = Ro(e) ? Un(e) : window, a = s.visualViewport, l = !B3() && n, u = (r.left + (l && a ? a.offsetLeft : 0)) / i, c = (r.top + (l && a ? a.offsetTop : 0)) / o, f = r.width / i, d = r.height / o;
  return {
    width: f,
    height: d,
    top: c,
    right: u + f,
    bottom: c + d,
    left: u,
    x: u,
    y: c
  };
}
function dg(e) {
  var t = Ns(e), n = e.offsetWidth, r = e.offsetHeight;
  return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), {
    x: e.offsetLeft,
    y: e.offsetTop,
    width: n,
    height: r
  };
}
function P3(e, t) {
  var n = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && fg(n)) {
    var r = t;
    do {
      if (r && e.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function di(e) {
  return Un(e).getComputedStyle(e);
}
function x5(e) {
  return ["table", "td", "th"].indexOf(Hr(e)) >= 0;
}
function Ji(e) {
  return ((Ro(e) ? e.ownerDocument : (
    // $FlowFixMe[prop-missing]
    e.document
  )) || window.document).documentElement;
}
function gd(e) {
  return Hr(e) === "html" ? e : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    e.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    e.parentNode || // DOM Element detected
    (fg(e) ? e.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    Ji(e)
  );
}
function rb(e) {
  return !Zn(e) || // https://github.com/popperjs/popper-core/issues/837
  di(e).position === "fixed" ? null : e.offsetParent;
}
function k5(e) {
  var t = /firefox/i.test(Lh()), n = /Trident/i.test(Lh());
  if (n && Zn(e)) {
    var r = di(e);
    if (r.position === "fixed")
      return null;
  }
  var i = gd(e);
  for (fg(i) && (i = i.host); Zn(i) && ["html", "body"].indexOf(Hr(i)) < 0; ) {
    var o = di(i);
    if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || t && o.willChange === "filter" || t && o.filter && o.filter !== "none")
      return i;
    i = i.parentNode;
  }
  return null;
}
function Wl(e) {
  for (var t = Un(e), n = rb(e); n && x5(n) && di(n).position === "static"; )
    n = rb(n);
  return n && (Hr(n) === "html" || Hr(n) === "body" && di(n).position === "static") ? t : n || k5(e) || t;
}
function pg(e) {
  return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
}
function za(e, t, n) {
  return Eo(e, jc(t, n));
}
function M5(e, t, n) {
  var r = za(e, t, n);
  return r > n ? n : r;
}
function $3() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function z3(e) {
  return Object.assign({}, $3(), e);
}
function F3(e, t) {
  return t.reduce(function(n, r) {
    return n[r] = e, n;
  }, {});
}
var A5 = function(t, n) {
  return t = typeof t == "function" ? t(Object.assign({}, n.rects, {
    placement: n.placement
  })) : t, z3(typeof t != "number" ? t : F3(t, Gl));
};
function T5(e) {
  var t, n = e.state, r = e.name, i = e.options, o = n.elements.arrow, s = n.modifiersData.popperOffsets, a = Br(n.placement), l = pg(a), u = [Tn, tr].indexOf(a) >= 0, c = u ? "height" : "width";
  if (!(!o || !s)) {
    var f = A5(i.padding, n), d = dg(o), p = l === "y" ? An : Tn, h = l === "y" ? er : tr, m = n.rects.reference[c] + n.rects.reference[l] - s[l] - n.rects.popper[c], g = s[l] - n.rects.reference[l], y = Wl(o), _ = y ? l === "y" ? y.clientHeight || 0 : y.clientWidth || 0 : 0, E = m / 2 - g / 2, v = f[p], M = _ - d[c] - f[h], k = _ / 2 - d[c] / 2 + E, T = za(v, k, M), U = l;
    n.modifiersData[r] = (t = {}, t[U] = T, t.centerOffset = T - k, t);
  }
}
function S5(e) {
  var t = e.state, n = e.options, r = n.element, i = r === void 0 ? "[data-popper-arrow]" : r;
  i != null && (typeof i == "string" && (i = t.elements.popper.querySelector(i), !i) || P3(t.elements.popper, i) && (t.elements.arrow = i));
}
const C5 = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: T5,
  effect: S5,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Ds(e) {
  return e.split("-")[1];
}
var N5 = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function D5(e, t) {
  var n = e.x, r = e.y, i = t.devicePixelRatio || 1;
  return {
    x: Cs(n * i) / i || 0,
    y: Cs(r * i) / i || 0
  };
}
function ib(e) {
  var t, n = e.popper, r = e.popperRect, i = e.placement, o = e.variation, s = e.offsets, a = e.position, l = e.gpuAcceleration, u = e.adaptive, c = e.roundOffsets, f = e.isFixed, d = s.x, p = d === void 0 ? 0 : d, h = s.y, m = h === void 0 ? 0 : h, g = typeof c == "function" ? c({
    x: p,
    y: m
  }) : {
    x: p,
    y: m
  };
  p = g.x, m = g.y;
  var y = s.hasOwnProperty("x"), _ = s.hasOwnProperty("y"), E = Tn, v = An, M = window;
  if (u) {
    var k = Wl(n), T = "clientHeight", U = "clientWidth";
    if (k === Un(n) && (k = Ji(n), di(k).position !== "static" && a === "absolute" && (T = "scrollHeight", U = "scrollWidth")), k = k, i === An || (i === Tn || i === tr) && o === al) {
      v = er;
      var C = f && k === M && M.visualViewport ? M.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        k[T]
      );
      m -= C - r.height, m *= l ? 1 : -1;
    }
    if (i === Tn || (i === An || i === er) && o === al) {
      E = tr;
      var z = f && k === M && M.visualViewport ? M.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        k[U]
      );
      p -= z - r.width, p *= l ? 1 : -1;
    }
  }
  var H = Object.assign({
    position: a
  }, u && N5), j = c === !0 ? D5({
    x: p,
    y: m
  }, Un(n)) : {
    x: p,
    y: m
  };
  if (p = j.x, m = j.y, l) {
    var V;
    return Object.assign({}, H, (V = {}, V[v] = _ ? "0" : "", V[E] = y ? "0" : "", V.transform = (M.devicePixelRatio || 1) <= 1 ? "translate(" + p + "px, " + m + "px)" : "translate3d(" + p + "px, " + m + "px, 0)", V));
  }
  return Object.assign({}, H, (t = {}, t[v] = _ ? m + "px" : "", t[E] = y ? p + "px" : "", t.transform = "", t));
}
function O5(e) {
  var t = e.state, n = e.options, r = n.gpuAcceleration, i = r === void 0 ? !0 : r, o = n.adaptive, s = o === void 0 ? !0 : o, a = n.roundOffsets, l = a === void 0 ? !0 : a, u = {
    placement: Br(t.placement),
    variation: Ds(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: i,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, ib(Object.assign({}, u, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: s,
    roundOffsets: l
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, ib(Object.assign({}, u, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const I5 = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: O5,
  data: {}
};
var yu = {
  passive: !0
};
function R5(e) {
  var t = e.state, n = e.instance, r = e.options, i = r.scroll, o = i === void 0 ? !0 : i, s = r.resize, a = s === void 0 ? !0 : s, l = Un(t.elements.popper), u = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return o && u.forEach(function(c) {
    c.addEventListener("scroll", n.update, yu);
  }), a && l.addEventListener("resize", n.update, yu), function() {
    o && u.forEach(function(c) {
      c.removeEventListener("scroll", n.update, yu);
    }), a && l.removeEventListener("resize", n.update, yu);
  };
}
const L5 = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: R5,
  data: {}
};
var B5 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function nc(e) {
  return e.replace(/left|right|bottom|top/g, function(t) {
    return B5[t];
  });
}
var P5 = {
  start: "end",
  end: "start"
};
function ob(e) {
  return e.replace(/start|end/g, function(t) {
    return P5[t];
  });
}
function hg(e) {
  var t = Un(e), n = t.pageXOffset, r = t.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: r
  };
}
function gg(e) {
  return Ns(Ji(e)).left + hg(e).scrollLeft;
}
function $5(e, t) {
  var n = Un(e), r = Ji(e), i = n.visualViewport, o = r.clientWidth, s = r.clientHeight, a = 0, l = 0;
  if (i) {
    o = i.width, s = i.height;
    var u = B3();
    (u || !u && t === "fixed") && (a = i.offsetLeft, l = i.offsetTop);
  }
  return {
    width: o,
    height: s,
    x: a + gg(e),
    y: l
  };
}
function z5(e) {
  var t, n = Ji(e), r = hg(e), i = (t = e.ownerDocument) == null ? void 0 : t.body, o = Eo(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), s = Eo(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), a = -r.scrollLeft + gg(e), l = -r.scrollTop;
  return di(i || n).direction === "rtl" && (a += Eo(n.clientWidth, i ? i.clientWidth : 0) - o), {
    width: o,
    height: s,
    x: a,
    y: l
  };
}
function mg(e) {
  var t = di(e), n = t.overflow, r = t.overflowX, i = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + i + r);
}
function j3(e) {
  return ["html", "body", "#document"].indexOf(Hr(e)) >= 0 ? e.ownerDocument.body : Zn(e) && mg(e) ? e : j3(gd(e));
}
function Fa(e, t) {
  var n;
  t === void 0 && (t = []);
  var r = j3(e), i = r === ((n = e.ownerDocument) == null ? void 0 : n.body), o = Un(r), s = i ? [o].concat(o.visualViewport || [], mg(r) ? r : []) : r, a = t.concat(s);
  return i ? a : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    a.concat(Fa(gd(s)))
  );
}
function Bh(e) {
  return Object.assign({}, e, {
    left: e.x,
    top: e.y,
    right: e.x + e.width,
    bottom: e.y + e.height
  });
}
function F5(e, t) {
  var n = Ns(e, !1, t === "fixed");
  return n.top = n.top + e.clientTop, n.left = n.left + e.clientLeft, n.bottom = n.top + e.clientHeight, n.right = n.left + e.clientWidth, n.width = e.clientWidth, n.height = e.clientHeight, n.x = n.left, n.y = n.top, n;
}
function sb(e, t, n) {
  return t === I3 ? Bh($5(e, n)) : Ro(t) ? F5(t, n) : Bh(z5(Ji(e)));
}
function j5(e) {
  var t = Fa(gd(e)), n = ["absolute", "fixed"].indexOf(di(e).position) >= 0, r = n && Zn(e) ? Wl(e) : e;
  return Ro(r) ? t.filter(function(i) {
    return Ro(i) && P3(i, r) && Hr(i) !== "body";
  }) : [];
}
function U5(e, t, n, r) {
  var i = t === "clippingParents" ? j5(e) : [].concat(t), o = [].concat(i, [n]), s = o[0], a = o.reduce(function(l, u) {
    var c = sb(e, u, r);
    return l.top = Eo(c.top, l.top), l.right = jc(c.right, l.right), l.bottom = jc(c.bottom, l.bottom), l.left = Eo(c.left, l.left), l;
  }, sb(e, s, r));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function U3(e) {
  var t = e.reference, n = e.element, r = e.placement, i = r ? Br(r) : null, o = r ? Ds(r) : null, s = t.x + t.width / 2 - n.width / 2, a = t.y + t.height / 2 - n.height / 2, l;
  switch (i) {
    case An:
      l = {
        x: s,
        y: t.y - n.height
      };
      break;
    case er:
      l = {
        x: s,
        y: t.y + t.height
      };
      break;
    case tr:
      l = {
        x: t.x + t.width,
        y: a
      };
      break;
    case Tn:
      l = {
        x: t.x - n.width,
        y: a
      };
      break;
    default:
      l = {
        x: t.x,
        y: t.y
      };
  }
  var u = i ? pg(i) : null;
  if (u != null) {
    var c = u === "y" ? "height" : "width";
    switch (o) {
      case Ss:
        l[u] = l[u] - (t[c] / 2 - n[c] / 2);
        break;
      case al:
        l[u] = l[u] + (t[c] / 2 - n[c] / 2);
        break;
    }
  }
  return l;
}
function ll(e, t) {
  t === void 0 && (t = {});
  var n = t, r = n.placement, i = r === void 0 ? e.placement : r, o = n.strategy, s = o === void 0 ? e.strategy : o, a = n.boundary, l = a === void 0 ? u5 : a, u = n.rootBoundary, c = u === void 0 ? I3 : u, f = n.elementContext, d = f === void 0 ? ua : f, p = n.altBoundary, h = p === void 0 ? !1 : p, m = n.padding, g = m === void 0 ? 0 : m, y = z3(typeof g != "number" ? g : F3(g, Gl)), _ = d === ua ? c5 : ua, E = e.rects.popper, v = e.elements[h ? _ : d], M = U5(Ro(v) ? v : v.contextElement || Ji(e.elements.popper), l, c, s), k = Ns(e.elements.reference), T = U3({
    reference: k,
    element: E,
    strategy: "absolute",
    placement: i
  }), U = Bh(Object.assign({}, E, T)), C = d === ua ? U : k, z = {
    top: M.top - C.top + y.top,
    bottom: C.bottom - M.bottom + y.bottom,
    left: M.left - C.left + y.left,
    right: C.right - M.right + y.right
  }, H = e.modifiersData.offset;
  if (d === ua && H) {
    var j = H[i];
    Object.keys(z).forEach(function(V) {
      var Q = [tr, er].indexOf(V) >= 0 ? 1 : -1, le = [An, er].indexOf(V) >= 0 ? "y" : "x";
      z[V] += j[le] * Q;
    });
  }
  return z;
}
function V5(e, t) {
  t === void 0 && (t = {});
  var n = t, r = n.placement, i = n.boundary, o = n.rootBoundary, s = n.padding, a = n.flipVariations, l = n.allowedAutoPlacements, u = l === void 0 ? R3 : l, c = Ds(r), f = c ? a ? nb : nb.filter(function(h) {
    return Ds(h) === c;
  }) : Gl, d = f.filter(function(h) {
    return u.indexOf(h) >= 0;
  });
  d.length === 0 && (d = f);
  var p = d.reduce(function(h, m) {
    return h[m] = ll(e, {
      placement: m,
      boundary: i,
      rootBoundary: o,
      padding: s
    })[Br(m)], h;
  }, {});
  return Object.keys(p).sort(function(h, m) {
    return p[h] - p[m];
  });
}
function H5(e) {
  if (Br(e) === cg)
    return [];
  var t = nc(e);
  return [ob(e), t, ob(t)];
}
function q5(e) {
  var t = e.state, n = e.options, r = e.name;
  if (!t.modifiersData[r]._skip) {
    for (var i = n.mainAxis, o = i === void 0 ? !0 : i, s = n.altAxis, a = s === void 0 ? !0 : s, l = n.fallbackPlacements, u = n.padding, c = n.boundary, f = n.rootBoundary, d = n.altBoundary, p = n.flipVariations, h = p === void 0 ? !0 : p, m = n.allowedAutoPlacements, g = t.options.placement, y = Br(g), _ = y === g, E = l || (_ || !h ? [nc(g)] : H5(g)), v = [g].concat(E).reduce(function(P, ie) {
      return P.concat(Br(ie) === cg ? V5(t, {
        placement: ie,
        boundary: c,
        rootBoundary: f,
        padding: u,
        flipVariations: h,
        allowedAutoPlacements: m
      }) : ie);
    }, []), M = t.rects.reference, k = t.rects.popper, T = /* @__PURE__ */ new Map(), U = !0, C = v[0], z = 0; z < v.length; z++) {
      var H = v[z], j = Br(H), V = Ds(H) === Ss, Q = [An, er].indexOf(j) >= 0, le = Q ? "width" : "height", ne = ll(t, {
        placement: H,
        boundary: c,
        rootBoundary: f,
        altBoundary: d,
        padding: u
      }), w = Q ? V ? tr : Tn : V ? er : An;
      M[le] > k[le] && (w = nc(w));
      var O = nc(w), q = [];
      if (o && q.push(ne[j] <= 0), a && q.push(ne[w] <= 0, ne[O] <= 0), q.every(function(P) {
        return P;
      })) {
        C = H, U = !1;
        break;
      }
      T.set(H, q);
    }
    if (U)
      for (var X = h ? 3 : 1, se = function(ie) {
        var Y = v.find(function(ge) {
          var me = T.get(ge);
          if (me)
            return me.slice(0, ie).every(function(xe) {
              return xe;
            });
        });
        if (Y)
          return C = Y, "break";
      }, fe = X; fe > 0; fe--) {
        var Se = se(fe);
        if (Se === "break") break;
      }
    t.placement !== C && (t.modifiersData[r]._skip = !0, t.placement = C, t.reset = !0);
  }
}
const G5 = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: q5,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function ab(e, t, n) {
  return n === void 0 && (n = {
    x: 0,
    y: 0
  }), {
    top: e.top - t.height - n.y,
    right: e.right - t.width + n.x,
    bottom: e.bottom - t.height + n.y,
    left: e.left - t.width - n.x
  };
}
function lb(e) {
  return [An, tr, er, Tn].some(function(t) {
    return e[t] >= 0;
  });
}
function W5(e) {
  var t = e.state, n = e.name, r = t.rects.reference, i = t.rects.popper, o = t.modifiersData.preventOverflow, s = ll(t, {
    elementContext: "reference"
  }), a = ll(t, {
    altBoundary: !0
  }), l = ab(s, r), u = ab(a, i, o), c = lb(l), f = lb(u);
  t.modifiersData[n] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: u,
    isReferenceHidden: c,
    hasPopperEscaped: f
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": c,
    "data-popper-escaped": f
  });
}
const K5 = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: W5
};
function Y5(e, t, n) {
  var r = Br(e), i = [Tn, An].indexOf(r) >= 0 ? -1 : 1, o = typeof n == "function" ? n(Object.assign({}, t, {
    placement: e
  })) : n, s = o[0], a = o[1];
  return s = s || 0, a = (a || 0) * i, [Tn, tr].indexOf(r) >= 0 ? {
    x: a,
    y: s
  } : {
    x: s,
    y: a
  };
}
function Q5(e) {
  var t = e.state, n = e.options, r = e.name, i = n.offset, o = i === void 0 ? [0, 0] : i, s = R3.reduce(function(c, f) {
    return c[f] = Y5(f, t.rects, o), c;
  }, {}), a = s[t.placement], l = a.x, u = a.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += u), t.modifiersData[r] = s;
}
const Z5 = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: Q5
};
function X5(e) {
  var t = e.state, n = e.name;
  t.modifiersData[n] = U3({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement
  });
}
const J5 = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: X5,
  data: {}
};
function e9(e) {
  return e === "x" ? "y" : "x";
}
function t9(e) {
  var t = e.state, n = e.options, r = e.name, i = n.mainAxis, o = i === void 0 ? !0 : i, s = n.altAxis, a = s === void 0 ? !1 : s, l = n.boundary, u = n.rootBoundary, c = n.altBoundary, f = n.padding, d = n.tether, p = d === void 0 ? !0 : d, h = n.tetherOffset, m = h === void 0 ? 0 : h, g = ll(t, {
    boundary: l,
    rootBoundary: u,
    padding: f,
    altBoundary: c
  }), y = Br(t.placement), _ = Ds(t.placement), E = !_, v = pg(y), M = e9(v), k = t.modifiersData.popperOffsets, T = t.rects.reference, U = t.rects.popper, C = typeof m == "function" ? m(Object.assign({}, t.rects, {
    placement: t.placement
  })) : m, z = typeof C == "number" ? {
    mainAxis: C,
    altAxis: C
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, C), H = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, j = {
    x: 0,
    y: 0
  };
  if (k) {
    if (o) {
      var V, Q = v === "y" ? An : Tn, le = v === "y" ? er : tr, ne = v === "y" ? "height" : "width", w = k[v], O = w + g[Q], q = w - g[le], X = p ? -U[ne] / 2 : 0, se = _ === Ss ? T[ne] : U[ne], fe = _ === Ss ? -U[ne] : -T[ne], Se = t.elements.arrow, P = p && Se ? dg(Se) : {
        width: 0,
        height: 0
      }, ie = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : $3(), Y = ie[Q], ge = ie[le], me = za(0, T[ne], P[ne]), xe = E ? T[ne] / 2 - X - me - Y - z.mainAxis : se - me - Y - z.mainAxis, Ve = E ? -T[ne] / 2 + X + me + ge + z.mainAxis : fe + me + ge + z.mainAxis, qe = t.elements.arrow && Wl(t.elements.arrow), ot = qe ? v === "y" ? qe.clientTop || 0 : qe.clientLeft || 0 : 0, Ie = (V = H == null ? void 0 : H[v]) != null ? V : 0, ct = w + xe - Ie - ot, yt = w + Ve - Ie, Fe = za(p ? jc(O, ct) : O, w, p ? Eo(q, yt) : q);
      k[v] = Fe, j[v] = Fe - w;
    }
    if (a) {
      var $t, St = v === "x" ? An : Tn, ee = v === "x" ? er : tr, Ke = k[M], Te = M === "y" ? "height" : "width", we = Ke + g[St], ut = Ke - g[ee], Xe = [An, Tn].indexOf(y) !== -1, Ct = ($t = H == null ? void 0 : H[M]) != null ? $t : 0, vt = Xe ? we : Ke - T[Te] - U[Te] - Ct + z.altAxis, F = Xe ? Ke + T[Te] + U[Te] - Ct - z.altAxis : ut, K = p && Xe ? M5(vt, Ke, F) : za(p ? vt : we, Ke, p ? F : ut);
      k[M] = K, j[M] = K - Ke;
    }
    t.modifiersData[r] = j;
  }
}
const n9 = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: t9,
  requiresIfExists: ["offset"]
};
function r9(e) {
  return {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  };
}
function i9(e) {
  return e === Un(e) || !Zn(e) ? hg(e) : r9(e);
}
function o9(e) {
  var t = e.getBoundingClientRect(), n = Cs(t.width) / e.offsetWidth || 1, r = Cs(t.height) / e.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function s9(e, t, n) {
  n === void 0 && (n = !1);
  var r = Zn(t), i = Zn(t) && o9(t), o = Ji(t), s = Ns(e, i, n), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (r || !r && !n) && ((Hr(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  mg(o)) && (a = i9(t)), Zn(t) ? (l = Ns(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : o && (l.x = gg(o))), {
    x: s.left + a.scrollLeft - l.x,
    y: s.top + a.scrollTop - l.y,
    width: s.width,
    height: s.height
  };
}
function a9(e) {
  var t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
  e.forEach(function(o) {
    t.set(o.name, o);
  });
  function i(o) {
    n.add(o.name);
    var s = [].concat(o.requires || [], o.requiresIfExists || []);
    s.forEach(function(a) {
      if (!n.has(a)) {
        var l = t.get(a);
        l && i(l);
      }
    }), r.push(o);
  }
  return e.forEach(function(o) {
    n.has(o.name) || i(o);
  }), r;
}
function l9(e) {
  var t = a9(e);
  return _5.reduce(function(n, r) {
    return n.concat(t.filter(function(i) {
      return i.phase === r;
    }));
  }, []);
}
function u9(e) {
  var t;
  return function() {
    return t || (t = new Promise(function(n) {
      Promise.resolve().then(function() {
        t = void 0, n(e());
      });
    })), t;
  };
}
function c9(e) {
  var t = e.reduce(function(n, r) {
    var i = n[r.name];
    return n[r.name] = i ? Object.assign({}, i, r, {
      options: Object.assign({}, i.options, r.options),
      data: Object.assign({}, i.data, r.data)
    }) : r, n;
  }, {});
  return Object.keys(t).map(function(n) {
    return t[n];
  });
}
var ub = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function cb() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return !t.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function f9(e) {
  e === void 0 && (e = {});
  var t = e, n = t.defaultModifiers, r = n === void 0 ? [] : n, i = t.defaultOptions, o = i === void 0 ? ub : i;
  return function(a, l, u) {
    u === void 0 && (u = o);
    var c = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, ub, o),
      modifiersData: {},
      elements: {
        reference: a,
        popper: l
      },
      attributes: {},
      styles: {}
    }, f = [], d = !1, p = {
      state: c,
      setOptions: function(y) {
        var _ = typeof y == "function" ? y(c.options) : y;
        m(), c.options = Object.assign({}, o, c.options, _), c.scrollParents = {
          reference: Ro(a) ? Fa(a) : a.contextElement ? Fa(a.contextElement) : [],
          popper: Fa(l)
        };
        var E = l9(c9([].concat(r, c.options.modifiers)));
        return c.orderedModifiers = E.filter(function(v) {
          return v.enabled;
        }), h(), p.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!d) {
          var y = c.elements, _ = y.reference, E = y.popper;
          if (cb(_, E)) {
            c.rects = {
              reference: s9(_, Wl(E), c.options.strategy === "fixed"),
              popper: dg(E)
            }, c.reset = !1, c.placement = c.options.placement, c.orderedModifiers.forEach(function(z) {
              return c.modifiersData[z.name] = Object.assign({}, z.data);
            });
            for (var v = 0; v < c.orderedModifiers.length; v++) {
              if (c.reset === !0) {
                c.reset = !1, v = -1;
                continue;
              }
              var M = c.orderedModifiers[v], k = M.fn, T = M.options, U = T === void 0 ? {} : T, C = M.name;
              typeof k == "function" && (c = k({
                state: c,
                options: U,
                name: C,
                instance: p
              }) || c);
            }
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: u9(function() {
        return new Promise(function(g) {
          p.forceUpdate(), g(c);
        });
      }),
      destroy: function() {
        m(), d = !0;
      }
    };
    if (!cb(a, l))
      return p;
    p.setOptions(u).then(function(g) {
      !d && u.onFirstUpdate && u.onFirstUpdate(g);
    });
    function h() {
      c.orderedModifiers.forEach(function(g) {
        var y = g.name, _ = g.options, E = _ === void 0 ? {} : _, v = g.effect;
        if (typeof v == "function") {
          var M = v({
            state: c,
            name: y,
            instance: p,
            options: E
          }), k = function() {
          };
          f.push(M || k);
        }
      });
    }
    function m() {
      f.forEach(function(g) {
        return g();
      }), f = [];
    }
    return p;
  };
}
var d9 = [L5, J5, I5, L3, Z5, G5, n9, C5, K5], p9 = /* @__PURE__ */ f9({
  defaultModifiers: d9
}), h9 = "tippy-box", V3 = "tippy-content", g9 = "tippy-backdrop", H3 = "tippy-arrow", q3 = "tippy-svg-arrow", so = {
  passive: !0,
  capture: !0
}, G3 = function() {
  return document.body;
};
function m9(e, t) {
  return {}.hasOwnProperty.call(e, t);
}
function mp(e, t, n) {
  if (Array.isArray(e)) {
    var r = e[t];
    return r ?? (Array.isArray(n) ? n[t] : n);
  }
  return e;
}
function bg(e, t) {
  var n = {}.toString.call(e);
  return n.indexOf("[object") === 0 && n.indexOf(t + "]") > -1;
}
function W3(e, t) {
  return typeof e == "function" ? e.apply(void 0, t) : e;
}
function fb(e, t) {
  if (t === 0)
    return e;
  var n;
  return function(r) {
    clearTimeout(n), n = setTimeout(function() {
      e(r);
    }, t);
  };
}
function b9(e, t) {
  var n = Object.assign({}, e);
  return t.forEach(function(r) {
    delete n[r];
  }), n;
}
function y9(e) {
  return e.split(/\s+/).filter(Boolean);
}
function Jo(e) {
  return [].concat(e);
}
function db(e, t) {
  e.indexOf(t) === -1 && e.push(t);
}
function v9(e) {
  return e.filter(function(t, n) {
    return e.indexOf(t) === n;
  });
}
function _9(e) {
  return e.split("-")[0];
}
function Uc(e) {
  return [].slice.call(e);
}
function pb(e) {
  return Object.keys(e).reduce(function(t, n) {
    return e[n] !== void 0 && (t[n] = e[n]), t;
  }, {});
}
function ja() {
  return document.createElement("div");
}
function ul(e) {
  return ["Element", "Fragment"].some(function(t) {
    return bg(e, t);
  });
}
function E9(e) {
  return bg(e, "NodeList");
}
function w9(e) {
  return bg(e, "MouseEvent");
}
function x9(e) {
  return !!(e && e._tippy && e._tippy.reference === e);
}
function k9(e) {
  return ul(e) ? [e] : E9(e) ? Uc(e) : Array.isArray(e) ? e : Uc(document.querySelectorAll(e));
}
function bp(e, t) {
  e.forEach(function(n) {
    n && (n.style.transitionDuration = t + "ms");
  });
}
function hb(e, t) {
  e.forEach(function(n) {
    n && n.setAttribute("data-state", t);
  });
}
function M9(e) {
  var t, n = Jo(e), r = n[0];
  return r != null && (t = r.ownerDocument) != null && t.body ? r.ownerDocument : document;
}
function A9(e, t) {
  var n = t.clientX, r = t.clientY;
  return e.every(function(i) {
    var o = i.popperRect, s = i.popperState, a = i.props, l = a.interactiveBorder, u = _9(s.placement), c = s.modifiersData.offset;
    if (!c)
      return !0;
    var f = u === "bottom" ? c.top.y : 0, d = u === "top" ? c.bottom.y : 0, p = u === "right" ? c.left.x : 0, h = u === "left" ? c.right.x : 0, m = o.top - r + f > l, g = r - o.bottom - d > l, y = o.left - n + p > l, _ = n - o.right - h > l;
    return m || g || y || _;
  });
}
function yp(e, t, n) {
  var r = t + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(i) {
    e[r](i, n);
  });
}
function gb(e, t) {
  for (var n = t; n; ) {
    var r;
    if (e.contains(n))
      return !0;
    n = n.getRootNode == null || (r = n.getRootNode()) == null ? void 0 : r.host;
  }
  return !1;
}
var Tr = {
  isTouch: !1
}, mb = 0;
function T9() {
  Tr.isTouch || (Tr.isTouch = !0, window.performance && document.addEventListener("mousemove", K3));
}
function K3() {
  var e = performance.now();
  e - mb < 20 && (Tr.isTouch = !1, document.removeEventListener("mousemove", K3)), mb = e;
}
function S9() {
  var e = document.activeElement;
  if (x9(e)) {
    var t = e._tippy;
    e.blur && !t.state.isVisible && e.blur();
  }
}
function C9() {
  document.addEventListener("touchstart", T9, so), window.addEventListener("blur", S9);
}
var N9 = typeof window < "u" && typeof document < "u", D9 = N9 ? (
  // @ts-ignore
  !!window.msCrypto
) : !1;
function qo(e) {
  var t = e === "destroy" ? "n already-" : " ";
  return [e + "() was called on a" + t + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
}
function bb(e) {
  var t = /[ \t]{2,}/g, n = /^[ \t]*/gm;
  return e.replace(t, " ").replace(n, "").trim();
}
function O9(e) {
  return bb(`
  %ctippy.js

  %c` + bb(e) + `

  %c This is a development-only message. It will be removed in production.
  `);
}
function Y3(e) {
  return [
    O9(e),
    // title
    "color: #00C584; font-size: 1.3em; font-weight: bold;",
    // message
    "line-height: 1.5",
    // footer
    "color: #a6a095;"
  ];
}
var cl;
process.env.NODE_ENV !== "production" && I9();
function I9() {
  cl = /* @__PURE__ */ new Set();
}
function ii(e, t) {
  if (e && !cl.has(t)) {
    var n;
    cl.add(t), (n = console).warn.apply(n, Y3(t));
  }
}
function Ph(e, t) {
  if (e && !cl.has(t)) {
    var n;
    cl.add(t), (n = console).error.apply(n, Y3(t));
  }
}
function R9(e) {
  var t = !e, n = Object.prototype.toString.call(e) === "[object Object]" && !e.addEventListener;
  Ph(t, ["tippy() was passed", "`" + String(e) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" ")), Ph(n, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
}
var Q3 = {
  animateFill: !1,
  followCursor: !1,
  inlinePositioning: !1,
  sticky: !1
}, L9 = {
  allowHTML: !1,
  animation: "fade",
  arrow: !0,
  content: "",
  inertia: !1,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
}, zn = Object.assign({
  appendTo: G3,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: !0,
  ignoreAttributes: !1,
  interactive: !1,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function() {
  },
  onBeforeUpdate: function() {
  },
  onCreate: function() {
  },
  onDestroy: function() {
  },
  onHidden: function() {
  },
  onHide: function() {
  },
  onMount: function() {
  },
  onShow: function() {
  },
  onShown: function() {
  },
  onTrigger: function() {
  },
  onUntrigger: function() {
  },
  onClickOutside: function() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: !1,
  touch: !0,
  trigger: "mouseenter focus",
  triggerTarget: null
}, Q3, L9), B9 = Object.keys(zn), P9 = function(t) {
  process.env.NODE_ENV !== "production" && X3(t, []);
  var n = Object.keys(t);
  n.forEach(function(r) {
    zn[r] = t[r];
  });
};
function Z3(e) {
  var t = e.plugins || [], n = t.reduce(function(r, i) {
    var o = i.name, s = i.defaultValue;
    if (o) {
      var a;
      r[o] = e[o] !== void 0 ? e[o] : (a = zn[o]) != null ? a : s;
    }
    return r;
  }, {});
  return Object.assign({}, e, n);
}
function $9(e, t) {
  var n = t ? Object.keys(Z3(Object.assign({}, zn, {
    plugins: t
  }))) : B9, r = n.reduce(function(i, o) {
    var s = (e.getAttribute("data-tippy-" + o) || "").trim();
    if (!s)
      return i;
    if (o === "content")
      i[o] = s;
    else
      try {
        i[o] = JSON.parse(s);
      } catch {
        i[o] = s;
      }
    return i;
  }, {});
  return r;
}
function yb(e, t) {
  var n = Object.assign({}, t, {
    content: W3(t.content, [e])
  }, t.ignoreAttributes ? {} : $9(e, t.plugins));
  return n.aria = Object.assign({}, zn.aria, n.aria), n.aria = {
    expanded: n.aria.expanded === "auto" ? t.interactive : n.aria.expanded,
    content: n.aria.content === "auto" ? t.interactive ? null : "describedby" : n.aria.content
  }, n;
}
function X3(e, t) {
  e === void 0 && (e = {}), t === void 0 && (t = []);
  var n = Object.keys(e);
  n.forEach(function(r) {
    var i = b9(zn, Object.keys(Q3)), o = !m9(i, r);
    o && (o = t.filter(function(s) {
      return s.name === r;
    }).length === 0), ii(o, ["`" + r + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", `

`, `All props: https://atomiks.github.io/tippyjs/v6/all-props/
`, "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
  });
}
var z9 = function() {
  return "innerHTML";
};
function $h(e, t) {
  e[z9()] = t;
}
function vb(e) {
  var t = ja();
  return e === !0 ? t.className = H3 : (t.className = q3, ul(e) ? t.appendChild(e) : $h(t, e)), t;
}
function _b(e, t) {
  ul(t.content) ? ($h(e, ""), e.appendChild(t.content)) : typeof t.content != "function" && (t.allowHTML ? $h(e, t.content) : e.textContent = t.content);
}
function zh(e) {
  var t = e.firstElementChild, n = Uc(t.children);
  return {
    box: t,
    content: n.find(function(r) {
      return r.classList.contains(V3);
    }),
    arrow: n.find(function(r) {
      return r.classList.contains(H3) || r.classList.contains(q3);
    }),
    backdrop: n.find(function(r) {
      return r.classList.contains(g9);
    })
  };
}
function J3(e) {
  var t = ja(), n = ja();
  n.className = h9, n.setAttribute("data-state", "hidden"), n.setAttribute("tabindex", "-1");
  var r = ja();
  r.className = V3, r.setAttribute("data-state", "hidden"), _b(r, e.props), t.appendChild(n), n.appendChild(r), i(e.props, e.props);
  function i(o, s) {
    var a = zh(t), l = a.box, u = a.content, c = a.arrow;
    s.theme ? l.setAttribute("data-theme", s.theme) : l.removeAttribute("data-theme"), typeof s.animation == "string" ? l.setAttribute("data-animation", s.animation) : l.removeAttribute("data-animation"), s.inertia ? l.setAttribute("data-inertia", "") : l.removeAttribute("data-inertia"), l.style.maxWidth = typeof s.maxWidth == "number" ? s.maxWidth + "px" : s.maxWidth, s.role ? l.setAttribute("role", s.role) : l.removeAttribute("role"), (o.content !== s.content || o.allowHTML !== s.allowHTML) && _b(u, e.props), s.arrow ? c ? o.arrow !== s.arrow && (l.removeChild(c), l.appendChild(vb(s.arrow))) : l.appendChild(vb(s.arrow)) : c && l.removeChild(c);
  }
  return {
    popper: t,
    onUpdate: i
  };
}
J3.$$tippy = !0;
var F9 = 1, vu = [], vp = [];
function j9(e, t) {
  var n = yb(e, Object.assign({}, zn, Z3(pb(t)))), r, i, o, s = !1, a = !1, l = !1, u = !1, c, f, d, p = [], h = fb(ct, n.interactiveDebounce), m, g = F9++, y = null, _ = v9(n.plugins), E = {
    // Is the instance currently enabled?
    isEnabled: !0,
    // Is the tippy currently showing and not transitioning out?
    isVisible: !1,
    // Has the instance been destroyed?
    isDestroyed: !1,
    // Is the tippy currently mounted to the DOM?
    isMounted: !1,
    // Has the tippy finished transitioning in?
    isShown: !1
  }, v = {
    // properties
    id: g,
    reference: e,
    popper: ja(),
    popperInstance: y,
    props: n,
    state: E,
    plugins: _,
    // methods
    clearDelayTimeouts: vt,
    setProps: F,
    setContent: K,
    show: ue,
    hide: ve,
    hideWithInteractivity: N,
    enable: Xe,
    disable: Ct,
    unmount: I,
    destroy: J
  };
  if (!n.render)
    return process.env.NODE_ENV !== "production" && Ph(!0, "render() function has not been supplied."), v;
  var M = n.render(v), k = M.popper, T = M.onUpdate;
  k.setAttribute("data-tippy-root", ""), k.id = "tippy-" + v.id, v.popper = k, e._tippy = v, k._tippy = v;
  var U = _.map(function(D) {
    return D.fn(v);
  }), C = e.hasAttribute("aria-expanded");
  return qe(), X(), w(), O("onCreate", [v]), n.showOnCreate && we(), k.addEventListener("mouseenter", function() {
    v.props.interactive && v.state.isVisible && v.clearDelayTimeouts();
  }), k.addEventListener("mouseleave", function() {
    v.props.interactive && v.props.trigger.indexOf("mouseenter") >= 0 && Q().addEventListener("mousemove", h);
  }), v;
  function z() {
    var D = v.props.touch;
    return Array.isArray(D) ? D : [D, 0];
  }
  function H() {
    return z()[0] === "hold";
  }
  function j() {
    var D;
    return !!((D = v.props.render) != null && D.$$tippy);
  }
  function V() {
    return m || e;
  }
  function Q() {
    var D = V().parentNode;
    return D ? M9(D) : document;
  }
  function le() {
    return zh(k);
  }
  function ne(D) {
    return v.state.isMounted && !v.state.isVisible || Tr.isTouch || c && c.type === "focus" ? 0 : mp(v.props.delay, D ? 0 : 1, zn.delay);
  }
  function w(D) {
    D === void 0 && (D = !1), k.style.pointerEvents = v.props.interactive && !D ? "" : "none", k.style.zIndex = "" + v.props.zIndex;
  }
  function O(D, Z, ae) {
    if (ae === void 0 && (ae = !0), U.forEach(function(Ae) {
      Ae[D] && Ae[D].apply(Ae, Z);
    }), ae) {
      var he;
      (he = v.props)[D].apply(he, Z);
    }
  }
  function q() {
    var D = v.props.aria;
    if (D.content) {
      var Z = "aria-" + D.content, ae = k.id, he = Jo(v.props.triggerTarget || e);
      he.forEach(function(Ae) {
        var He = Ae.getAttribute(Z);
        if (v.state.isVisible)
          Ae.setAttribute(Z, He ? He + " " + ae : ae);
        else {
          var it = He && He.replace(ae, "").trim();
          it ? Ae.setAttribute(Z, it) : Ae.removeAttribute(Z);
        }
      });
    }
  }
  function X() {
    if (!(C || !v.props.aria.expanded)) {
      var D = Jo(v.props.triggerTarget || e);
      D.forEach(function(Z) {
        v.props.interactive ? Z.setAttribute("aria-expanded", v.state.isVisible && Z === V() ? "true" : "false") : Z.removeAttribute("aria-expanded");
      });
    }
  }
  function se() {
    Q().removeEventListener("mousemove", h), vu = vu.filter(function(D) {
      return D !== h;
    });
  }
  function fe(D) {
    if (!(Tr.isTouch && (l || D.type === "mousedown"))) {
      var Z = D.composedPath && D.composedPath()[0] || D.target;
      if (!(v.props.interactive && gb(k, Z))) {
        if (Jo(v.props.triggerTarget || e).some(function(ae) {
          return gb(ae, Z);
        })) {
          if (Tr.isTouch || v.state.isVisible && v.props.trigger.indexOf("click") >= 0)
            return;
        } else
          O("onClickOutside", [v, D]);
        v.props.hideOnClick === !0 && (v.clearDelayTimeouts(), v.hide(), a = !0, setTimeout(function() {
          a = !1;
        }), v.state.isMounted || Y());
      }
    }
  }
  function Se() {
    l = !0;
  }
  function P() {
    l = !1;
  }
  function ie() {
    var D = Q();
    D.addEventListener("mousedown", fe, !0), D.addEventListener("touchend", fe, so), D.addEventListener("touchstart", P, so), D.addEventListener("touchmove", Se, so);
  }
  function Y() {
    var D = Q();
    D.removeEventListener("mousedown", fe, !0), D.removeEventListener("touchend", fe, so), D.removeEventListener("touchstart", P, so), D.removeEventListener("touchmove", Se, so);
  }
  function ge(D, Z) {
    xe(D, function() {
      !v.state.isVisible && k.parentNode && k.parentNode.contains(k) && Z();
    });
  }
  function me(D, Z) {
    xe(D, Z);
  }
  function xe(D, Z) {
    var ae = le().box;
    function he(Ae) {
      Ae.target === ae && (yp(ae, "remove", he), Z());
    }
    if (D === 0)
      return Z();
    yp(ae, "remove", f), yp(ae, "add", he), f = he;
  }
  function Ve(D, Z, ae) {
    ae === void 0 && (ae = !1);
    var he = Jo(v.props.triggerTarget || e);
    he.forEach(function(Ae) {
      Ae.addEventListener(D, Z, ae), p.push({
        node: Ae,
        eventType: D,
        handler: Z,
        options: ae
      });
    });
  }
  function qe() {
    H() && (Ve("touchstart", Ie, {
      passive: !0
    }), Ve("touchend", yt, {
      passive: !0
    })), y9(v.props.trigger).forEach(function(D) {
      if (D !== "manual")
        switch (Ve(D, Ie), D) {
          case "mouseenter":
            Ve("mouseleave", yt);
            break;
          case "focus":
            Ve(D9 ? "focusout" : "blur", Fe);
            break;
          case "focusin":
            Ve("focusout", Fe);
            break;
        }
    });
  }
  function ot() {
    p.forEach(function(D) {
      var Z = D.node, ae = D.eventType, he = D.handler, Ae = D.options;
      Z.removeEventListener(ae, he, Ae);
    }), p = [];
  }
  function Ie(D) {
    var Z, ae = !1;
    if (!(!v.state.isEnabled || $t(D) || a)) {
      var he = ((Z = c) == null ? void 0 : Z.type) === "focus";
      c = D, m = D.currentTarget, X(), !v.state.isVisible && w9(D) && vu.forEach(function(Ae) {
        return Ae(D);
      }), D.type === "click" && (v.props.trigger.indexOf("mouseenter") < 0 || s) && v.props.hideOnClick !== !1 && v.state.isVisible ? ae = !0 : we(D), D.type === "click" && (s = !ae), ae && !he && ut(D);
    }
  }
  function ct(D) {
    var Z = D.target, ae = V().contains(Z) || k.contains(Z);
    if (!(D.type === "mousemove" && ae)) {
      var he = Te().concat(k).map(function(Ae) {
        var He, it = Ae._tippy, Ze = (He = it.popperInstance) == null ? void 0 : He.state;
        return Ze ? {
          popperRect: Ae.getBoundingClientRect(),
          popperState: Ze,
          props: n
        } : null;
      }).filter(Boolean);
      A9(he, D) && (se(), ut(D));
    }
  }
  function yt(D) {
    var Z = $t(D) || v.props.trigger.indexOf("click") >= 0 && s;
    if (!Z) {
      if (v.props.interactive) {
        v.hideWithInteractivity(D);
        return;
      }
      ut(D);
    }
  }
  function Fe(D) {
    v.props.trigger.indexOf("focusin") < 0 && D.target !== V() || v.props.interactive && D.relatedTarget && k.contains(D.relatedTarget) || ut(D);
  }
  function $t(D) {
    return Tr.isTouch ? H() !== D.type.indexOf("touch") >= 0 : !1;
  }
  function St() {
    ee();
    var D = v.props, Z = D.popperOptions, ae = D.placement, he = D.offset, Ae = D.getReferenceClientRect, He = D.moveTransition, it = j() ? zh(k).arrow : null, Ze = Ae ? {
      getBoundingClientRect: Ae,
      contextElement: Ae.contextElement || V()
    } : e, Rt = {
      name: "$$tippy",
      enabled: !0,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function(mr) {
        var br = mr.state;
        if (j()) {
          var aa = le(), to = aa.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(gi) {
            gi === "placement" ? to.setAttribute("data-placement", br.placement) : br.attributes.popper["data-popper-" + gi] ? to.setAttribute("data-" + gi, "") : to.removeAttribute("data-" + gi);
          }), br.attributes.popper = {};
        }
      }
    }, _t = [{
      name: "offset",
      options: {
        offset: he
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !He
      }
    }, Rt];
    j() && it && _t.push({
      name: "arrow",
      options: {
        element: it,
        padding: 3
      }
    }), _t.push.apply(_t, (Z == null ? void 0 : Z.modifiers) || []), v.popperInstance = p9(Ze, k, Object.assign({}, Z, {
      placement: ae,
      onFirstUpdate: d,
      modifiers: _t
    }));
  }
  function ee() {
    v.popperInstance && (v.popperInstance.destroy(), v.popperInstance = null);
  }
  function Ke() {
    var D = v.props.appendTo, Z, ae = V();
    v.props.interactive && D === G3 || D === "parent" ? Z = ae.parentNode : Z = W3(D, [ae]), Z.contains(k) || Z.appendChild(k), v.state.isMounted = !0, St(), process.env.NODE_ENV !== "production" && ii(v.props.interactive && D === zn.appendTo && ae.nextElementSibling !== k, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", `

`, "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", `

`, "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", `

`, "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
  }
  function Te() {
    return Uc(k.querySelectorAll("[data-tippy-root]"));
  }
  function we(D) {
    v.clearDelayTimeouts(), D && O("onTrigger", [v, D]), ie();
    var Z = ne(!0), ae = z(), he = ae[0], Ae = ae[1];
    Tr.isTouch && he === "hold" && Ae && (Z = Ae), Z ? r = setTimeout(function() {
      v.show();
    }, Z) : v.show();
  }
  function ut(D) {
    if (v.clearDelayTimeouts(), O("onUntrigger", [v, D]), !v.state.isVisible) {
      Y();
      return;
    }
    if (!(v.props.trigger.indexOf("mouseenter") >= 0 && v.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(D.type) >= 0 && s)) {
      var Z = ne(!1);
      Z ? i = setTimeout(function() {
        v.state.isVisible && v.hide();
      }, Z) : o = requestAnimationFrame(function() {
        v.hide();
      });
    }
  }
  function Xe() {
    v.state.isEnabled = !0;
  }
  function Ct() {
    v.hide(), v.state.isEnabled = !1;
  }
  function vt() {
    clearTimeout(r), clearTimeout(i), cancelAnimationFrame(o);
  }
  function F(D) {
    if (process.env.NODE_ENV !== "production" && ii(v.state.isDestroyed, qo("setProps")), !v.state.isDestroyed) {
      O("onBeforeUpdate", [v, D]), ot();
      var Z = v.props, ae = yb(e, Object.assign({}, Z, pb(D), {
        ignoreAttributes: !0
      }));
      v.props = ae, qe(), Z.interactiveDebounce !== ae.interactiveDebounce && (se(), h = fb(ct, ae.interactiveDebounce)), Z.triggerTarget && !ae.triggerTarget ? Jo(Z.triggerTarget).forEach(function(he) {
        he.removeAttribute("aria-expanded");
      }) : ae.triggerTarget && e.removeAttribute("aria-expanded"), X(), w(), T && T(Z, ae), v.popperInstance && (St(), Te().forEach(function(he) {
        requestAnimationFrame(he._tippy.popperInstance.forceUpdate);
      })), O("onAfterUpdate", [v, D]);
    }
  }
  function K(D) {
    v.setProps({
      content: D
    });
  }
  function ue() {
    process.env.NODE_ENV !== "production" && ii(v.state.isDestroyed, qo("show"));
    var D = v.state.isVisible, Z = v.state.isDestroyed, ae = !v.state.isEnabled, he = Tr.isTouch && !v.props.touch, Ae = mp(v.props.duration, 0, zn.duration);
    if (!(D || Z || ae || he) && !V().hasAttribute("disabled") && (O("onShow", [v], !1), v.props.onShow(v) !== !1)) {
      if (v.state.isVisible = !0, j() && (k.style.visibility = "visible"), w(), ie(), v.state.isMounted || (k.style.transition = "none"), j()) {
        var He = le(), it = He.box, Ze = He.content;
        bp([it, Ze], 0);
      }
      d = function() {
        var _t;
        if (!(!v.state.isVisible || u)) {
          if (u = !0, k.offsetHeight, k.style.transition = v.props.moveTransition, j() && v.props.animation) {
            var en = le(), mr = en.box, br = en.content;
            bp([mr, br], Ae), hb([mr, br], "visible");
          }
          q(), X(), db(vp, v), (_t = v.popperInstance) == null || _t.forceUpdate(), O("onMount", [v]), v.props.animation && j() && me(Ae, function() {
            v.state.isShown = !0, O("onShown", [v]);
          });
        }
      }, Ke();
    }
  }
  function ve() {
    process.env.NODE_ENV !== "production" && ii(v.state.isDestroyed, qo("hide"));
    var D = !v.state.isVisible, Z = v.state.isDestroyed, ae = !v.state.isEnabled, he = mp(v.props.duration, 1, zn.duration);
    if (!(D || Z || ae) && (O("onHide", [v], !1), v.props.onHide(v) !== !1)) {
      if (v.state.isVisible = !1, v.state.isShown = !1, u = !1, s = !1, j() && (k.style.visibility = "hidden"), se(), Y(), w(!0), j()) {
        var Ae = le(), He = Ae.box, it = Ae.content;
        v.props.animation && (bp([He, it], he), hb([He, it], "hidden"));
      }
      q(), X(), v.props.animation ? j() && ge(he, v.unmount) : v.unmount();
    }
  }
  function N(D) {
    process.env.NODE_ENV !== "production" && ii(v.state.isDestroyed, qo("hideWithInteractivity")), Q().addEventListener("mousemove", h), db(vu, h), h(D);
  }
  function I() {
    process.env.NODE_ENV !== "production" && ii(v.state.isDestroyed, qo("unmount")), v.state.isVisible && v.hide(), v.state.isMounted && (ee(), Te().forEach(function(D) {
      D._tippy.unmount();
    }), k.parentNode && k.parentNode.removeChild(k), vp = vp.filter(function(D) {
      return D !== v;
    }), v.state.isMounted = !1, O("onHidden", [v]));
  }
  function J() {
    process.env.NODE_ENV !== "production" && ii(v.state.isDestroyed, qo("destroy")), !v.state.isDestroyed && (v.clearDelayTimeouts(), v.unmount(), ot(), delete e._tippy, v.state.isDestroyed = !0, O("onDestroy", [v]));
  }
}
function na(e, t) {
  t === void 0 && (t = {});
  var n = zn.plugins.concat(t.plugins || []);
  process.env.NODE_ENV !== "production" && (R9(e), X3(t, n)), C9();
  var r = Object.assign({}, t, {
    plugins: n
  }), i = k9(e);
  if (process.env.NODE_ENV !== "production") {
    var o = ul(r.content), s = i.length > 1;
    ii(o && s, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", `

`, "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", `

`, `1) content: element.innerHTML
`, "2) content: () => element.cloneNode(true)"].join(" "));
  }
  var a = i.reduce(function(l, u) {
    var c = u && j9(u, r);
    return c && l.push(c), l;
  }, []);
  return ul(e) ? a[0] : a;
}
na.defaultProps = zn;
na.setDefaultProps = P9;
na.currentInput = Tr;
Object.assign({}, L3, {
  effect: function(t) {
    var n = t.state, r = {
      popper: {
        position: n.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(n.elements.popper.style, r.popper), n.styles = r, n.elements.arrow && Object.assign(n.elements.arrow.style, r.arrow);
  }
});
na.setDefaultProps({
  render: J3
});
class U9 {
  constructor({ editor: t, element: n, view: r, tippyOptions: i = {}, updateDelay: o = 250, shouldShow: s }) {
    this.preventHide = !1, this.shouldShow = ({ view: a, state: l, from: u, to: c }) => {
      const { doc: f, selection: d } = l, { empty: p } = d, h = !f.textBetween(u, c).length && og(l.selection), m = this.element.contains(document.activeElement);
      return !(!(a.hasFocus() || m) || p || h || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.dragstartHandler = () => {
      this.hide();
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: a }) => {
      var l;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      a != null && a.relatedTarget && (!((l = this.element.parentNode) === null || l === void 0) && l.contains(a.relatedTarget)) || (a == null ? void 0 : a.relatedTarget) !== this.editor.view.dom && this.hide();
    }, this.tippyBlurHandler = (a) => {
      this.blurHandler({ event: a });
    }, this.handleDebouncedUpdate = (a, l) => {
      const u = !(l != null && l.selection.eq(a.state.selection)), c = !(l != null && l.doc.eq(a.state.doc));
      !u && !c || (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer), this.updateDebounceTimer = window.setTimeout(() => {
        this.updateHandler(a, u, c, l);
      }, this.updateDelay));
    }, this.updateHandler = (a, l, u, c) => {
      var f, d, p;
      const { state: h, composing: m } = a, { selection: g } = h;
      if (m || !l && !u)
        return;
      this.createTooltip();
      const { ranges: _ } = g, E = Math.min(..._.map((k) => k.$from.pos)), v = Math.max(..._.map((k) => k.$to.pos));
      if (!((f = this.shouldShow) === null || f === void 0 ? void 0 : f.call(this, {
        editor: this.editor,
        element: this.element,
        view: a,
        state: h,
        oldState: c,
        from: E,
        to: v
      }))) {
        this.hide();
        return;
      }
      (d = this.tippy) === null || d === void 0 || d.setProps({
        getReferenceClientRect: ((p = this.tippyOptions) === null || p === void 0 ? void 0 : p.getReferenceClientRect) || (() => {
          if (k3(h.selection)) {
            let k = a.nodeDOM(E);
            if (k) {
              const T = k.dataset.nodeViewWrapper ? k : k.querySelector("[data-node-view-wrapper]");
              if (T && (k = T.firstChild), k)
                return k.getBoundingClientRect();
            }
          }
          return M3(a, E, v);
        })
      }), this.show();
    }, this.editor = t, this.element = n, this.view = r, this.updateDelay = o, s && (this.shouldShow = s), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.addEventListener("dragstart", this.dragstartHandler), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = i, this.element.remove(), this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: t } = this.editor.options, n = !!t.parentElement;
    this.tippy || !n || (this.tippy = na(t, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: !0,
      trigger: "manual",
      placement: "top",
      hideOnClick: "toggle",
      ...this.tippyOptions
    }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
  }
  update(t, n) {
    const { state: r } = t, i = r.selection.from !== r.selection.to;
    if (this.updateDelay > 0 && i) {
      this.handleDebouncedUpdate(t, n);
      return;
    }
    const o = !(n != null && n.selection.eq(t.state.selection)), s = !(n != null && n.doc.eq(t.state.doc));
    this.updateHandler(t, o, s, n);
  }
  show() {
    var t;
    (t = this.tippy) === null || t === void 0 || t.show();
  }
  hide() {
    var t;
    (t = this.tippy) === null || t === void 0 || t.hide();
  }
  destroy() {
    var t, n;
    !((t = this.tippy) === null || t === void 0) && t.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (n = this.tippy) === null || n === void 0 || n.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.removeEventListener("dragstart", this.dragstartHandler), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
  }
}
const ew = (e) => new mt({
  key: typeof e.pluginKey == "string" ? new Pt(e.pluginKey) : e.pluginKey,
  view: (t) => new U9({ view: t, ...e })
});
ht.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      ew({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        updateDelay: this.options.updateDelay,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
class V9 {
  constructor({ editor: t, element: n, view: r, tippyOptions: i = {}, shouldShow: o }) {
    this.preventHide = !1, this.shouldShow = ({ view: s, state: a }) => {
      const { selection: l } = a, { $anchor: u, empty: c } = l, f = u.depth === 1, d = u.parent.isTextblock && !u.parent.type.spec.code && !u.parent.textContent;
      return !(!s.hasFocus() || !c || !f || !d || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: s }) => {
      var a;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      s != null && s.relatedTarget && (!((a = this.element.parentNode) === null || a === void 0) && a.contains(s.relatedTarget)) || (s == null ? void 0 : s.relatedTarget) !== this.editor.view.dom && this.hide();
    }, this.tippyBlurHandler = (s) => {
      this.blurHandler({ event: s });
    }, this.editor = t, this.element = n, this.view = r, o && (this.shouldShow = o), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = i, this.element.remove(), this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: t } = this.editor.options, n = !!t.parentElement;
    this.tippy || !n || (this.tippy = na(t, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: !0,
      trigger: "manual",
      placement: "right",
      hideOnClick: "toggle",
      ...this.tippyOptions
    }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
  }
  update(t, n) {
    var r, i, o;
    const { state: s } = t, { doc: a, selection: l } = s, { from: u, to: c } = l;
    if (n && n.doc.eq(a) && n.selection.eq(l))
      return;
    if (this.createTooltip(), !((r = this.shouldShow) === null || r === void 0 ? void 0 : r.call(this, {
      editor: this.editor,
      view: t,
      state: s,
      oldState: n
    }))) {
      this.hide();
      return;
    }
    (i = this.tippy) === null || i === void 0 || i.setProps({
      getReferenceClientRect: ((o = this.tippyOptions) === null || o === void 0 ? void 0 : o.getReferenceClientRect) || (() => M3(t, u, c))
    }), this.show();
  }
  show() {
    var t;
    (t = this.tippy) === null || t === void 0 || t.show();
  }
  hide() {
    var t;
    (t = this.tippy) === null || t === void 0 || t.hide();
  }
  destroy() {
    var t, n;
    !((t = this.tippy) === null || t === void 0) && t.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (n = this.tippy) === null || n === void 0 || n.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
  }
}
const tw = (e) => new mt({
  key: typeof e.pluginKey == "string" ? new Pt(e.pluginKey) : e.pluginKey,
  view: (t) => new V9({ view: t, ...e })
});
ht.create({
  name: "floatingMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "floatingMenu",
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      tw({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
S({
  name: "BubbleMenu",
  props: {
    pluginKey: {
      type: [String, Object],
      default: "bubbleMenu"
    },
    editor: {
      type: Object,
      required: !0
    },
    updateDelay: {
      type: Number,
      default: void 0
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    }
  },
  setup(e, { slots: t }) {
    const n = _e(null);
    return Jn(() => {
      const { updateDelay: r, editor: i, pluginKey: o, shouldShow: s, tippyOptions: a } = e;
      i.registerPlugin(ew({
        updateDelay: r,
        editor: i,
        element: n.value,
        pluginKey: o,
        shouldShow: s,
        tippyOptions: a
      }));
    }), Qs(() => {
      const { pluginKey: r, editor: i } = e;
      i.unregisterPlugin(r);
    }), () => {
      var r;
      return Fr("div", { ref: n }, (r = t.default) === null || r === void 0 ? void 0 : r.call(t));
    };
  }
});
function Eb(e) {
  return Y_((t, n) => ({
    get() {
      return t(), e;
    },
    set(r) {
      e = r, requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          n();
        });
      });
    }
  }));
}
class H9 extends a5 {
  constructor(t = {}) {
    return super(t), this.contentComponent = null, this.appContext = null, this.reactiveState = Eb(this.view.state), this.reactiveExtensionStorage = Eb(this.extensionStorage), this.on("beforeTransaction", ({ nextState: n }) => {
      this.reactiveState.value = n, this.reactiveExtensionStorage.value = this.extensionStorage;
    }), bM(this);
  }
  get state() {
    return this.reactiveState ? this.reactiveState.value : this.view.state;
  }
  get storage() {
    return this.reactiveExtensionStorage ? this.reactiveExtensionStorage.value : super.storage;
  }
  /**
   * Register a ProseMirror plugin.
   */
  registerPlugin(t, n) {
    const r = super.registerPlugin(t, n);
    return this.reactiveState && (this.reactiveState.value = r), r;
  }
  /**
   * Unregister a ProseMirror plugin.
   */
  unregisterPlugin(t) {
    const n = super.unregisterPlugin(t);
    return this.reactiveState && n && (this.reactiveState.value = n), n;
  }
}
const q9 = S({
  name: "EditorContent",
  props: {
    editor: {
      default: null,
      type: Object
    }
  },
  setup(e) {
    const t = _e(), n = jn();
    return lr(() => {
      const r = e.editor;
      r && r.options.element && t.value && Ft(() => {
        if (!t.value || !r.options.element.firstChild)
          return;
        const i = b(t.value);
        t.value.append(...r.options.element.childNodes), r.contentComponent = n.ctx._, n && (r.appContext = {
          ...n.appContext,
          // Vue internally uses prototype chain to forward/shadow injects across the entire component chain
          // so don't use object spread operator or 'Object.assign' and just set `provides` as is on editor's appContext
          // @ts-expect-error forward instance's 'provides' into appContext
          provides: n.provides
        }), r.setOptions({
          element: i
        }), r.createNodeViews();
      });
    }), Qs(() => {
      const r = e.editor;
      r && (r.contentComponent = null, r.appContext = null);
    }), { rootEl: t };
  },
  render() {
    return Fr("div", {
      ref: (e) => {
        this.rootEl = e;
      }
    });
  }
});
S({
  name: "FloatingMenu",
  props: {
    pluginKey: {
      // TODO: TypeScript breaks :(
      // type: [String, Object as PropType<Exclude<FloatingMenuPluginProps['pluginKey'], string>>],
      type: null,
      default: "floatingMenu"
    },
    editor: {
      type: Object,
      required: !0
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    }
  },
  setup(e, { slots: t }) {
    const n = _e(null);
    return Jn(() => {
      const { pluginKey: r, editor: i, tippyOptions: o, shouldShow: s } = e;
      i.registerPlugin(tw({
        pluginKey: r,
        editor: i,
        element: n.value,
        tippyOptions: o,
        shouldShow: s
      }));
    }), Qs(() => {
      const { pluginKey: r, editor: i } = e;
      i.unregisterPlugin(r);
    }), () => {
      var r;
      return Fr("div", { ref: n }, (r = t.default) === null || r === void 0 ? void 0 : r.call(t));
    };
  }
});
S({
  name: "NodeViewContent",
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  render() {
    return Fr(this.as, {
      style: {
        whiteSpace: "pre-wrap"
      },
      "data-node-view-content": ""
    });
  }
});
S({
  name: "NodeViewWrapper",
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  inject: ["onDragStart", "decorationClasses"],
  render() {
    var e, t;
    return Fr(this.as, {
      // @ts-ignore
      class: this.decorationClasses,
      style: {
        whiteSpace: "normal"
      },
      "data-node-view-wrapper": "",
      // @ts-ignore (https://github.com/vuejs/vue-next/issues/3031)
      onDragstart: this.onDragStart
    }, (t = (e = this.$slots).default) === null || t === void 0 ? void 0 : t.call(e));
  }
});
const G9 = (e = {}) => {
  const t = I0();
  return Jn(() => {
    t.value = new H9(e);
  }), Qs(() => {
    var n, r, i;
    const o = (n = t.value) === null || n === void 0 ? void 0 : n.options.element, s = o == null ? void 0 : o.cloneNode(!0);
    (r = o == null ? void 0 : o.parentNode) === null || r === void 0 || r.replaceChild(s, o), (i = t.value) === null || i === void 0 || i.destroy();
  }), t;
}, _p = /* @__PURE__ */ S({
  __name: "Separator",
  props: {
    orientation: {},
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: r, ...i } = t;
      return i;
    });
    return (r, i) => (x(), L(b(WA), oe(n.value, {
      class: b(G)(
        "shrink-0 bg-border",
        t.orientation === "vertical" ? "h-full w-px" : "h-px w-full",
        t.class
      )
    }), null, 16, ["class"]));
  }
}), Kte = /* @__PURE__ */ S({
  __name: "TooltipProvider",
  props: {
    delayDuration: {},
    skipDelayDuration: {},
    disableHoverableContent: { type: Boolean },
    disableClosingTrigger: { type: Boolean },
    disabled: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(KA), Pe(Ue(t)), {
      default: A(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), W9 = /* @__PURE__ */ S({
  __name: "Toggle",
  props: {
    defaultValue: { type: Boolean },
    pressed: { type: Boolean },
    disabled: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {},
    class: {},
    variant: { default: "default" },
    size: { default: "default" }
  },
  emits: ["update:pressed"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: s, size: a, variant: l, ...u } = n;
      return u;
    }), o = Le(i, r);
    return (s, a) => (x(), L(b(YA), oe(b(o), {
      class: b(G)(b(K9)({ variant: s.variant, size: s.size }), n.class)
    }), {
      default: A(() => [
        B(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), K9 = Js(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline: "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground"
      },
      size: {
        default: "h-10 px-3",
        sm: "h-9 px-2.5",
        lg: "h-11 px-5"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), Y9 = { class: "flex flex-col items-center text-center" }, Vc = /* @__PURE__ */ S({
  __name: "ToolbarButton",
  props: {
    className: {},
    isActive: {},
    tooltip: {},
    handleAction: { type: Function },
    tooltipOptions: {}
  },
  setup(e) {
    const t = e;
    function n() {
      t.handleAction && t.handleAction();
    }
    return (r, i) => (x(), L(b(q2), null, {
      default: A(() => [
        $(b(G2), { asChild: "" }, {
          default: A(() => [
            $(b(W9), {
              size: "sm",
              class: ce(["", b(G)("size-8 p-0", { "bg-muted": Me(r.isActive) == !0 }, r.className)]),
              onClick: i[0] || (i[0] = (o) => n())
            }, {
              default: A(() => [
                be("span", null, [
                  B(r.$slots, "icon")
                ])
              ]),
              _: 3
            }, 8, ["class"])
          ]),
          _: 3
        }),
        $(b(W2), Pe(Ue(r.tooltipOptions)), {
          default: A(() => [
            be("div", Y9, ze(r.tooltip), 1)
          ]),
          _: 1
        }, 16)
      ]),
      _: 3
    }));
  }
}), Q9 = () => typeof window < "u", wb = () => Q9() && window.navigator.platform === "MacIntel", Z9 = {
  mod: wb() ? { symbol: "", readable: "Command" } : { symbol: "Ctrl", readable: "Control" },
  alt: wb() ? { symbol: "", readable: "Option" } : { symbol: "Alt", readable: "Alt" },
  shift: { symbol: "", readable: "Shift" }
}, nw = (e) => Z9[e.toLowerCase()] || { symbol: e, readable: e }, xb = (e, t) => {
  switch (t) {
    case "json":
      return e.getJSON();
    case "html":
      return e.getText() ? e.getHTML() : "";
    default:
      return e.getText();
  }
}, X9 = ["aria-label"], rw = /* @__PURE__ */ S({
  __name: "ShortcutKey",
  props: {
    className: {},
    keys: {}
  },
  setup(e) {
    const n = e.keys.map((i) => nw(i)), r = n.map((i) => i.readable).join(" + ");
    return (i, o) => (x(!0), W(Ge, null, ft(b(n), (s) => (x(), W("span", {
      key: s.symbol,
      "aria-label": b(r),
      class: ce(b(G)("inline-flex items-center gap-0.5", i.className))
    }, [
      be("kbd", {
        class: ce(
          b(G)(
            "inline-block min-w-2.5 text-center align-baseline font-sans text-xs font-medium capitalize text-[rgb(156,157,160)]",
            i.className
          )
        )
      }, ze(s.symbol), 3)
    ], 10, X9))), 128));
  }
}), J9 = { class: "flex items-center gap-1" }, eR = /* @__PURE__ */ S({
  __name: "Headings",
  props: {
    editor: {},
    activeLevels: {}
  },
  setup(e) {
    const t = [
      {
        label: "Normal Text",
        element: "span",
        className: "grow",
        shortcuts: ["mod", "alt", "0"]
      },
      {
        label: "Heading 1",
        element: "h1",
        level: 1,
        className: "m-0 grow text-3xl font-extrabold",
        shortcuts: ["mod", "alt", "1"]
      },
      {
        label: "Heading 2",
        element: "h2",
        level: 2,
        className: "m-0 grow text-xl font-bold",
        shortcuts: ["mod", "alt", "2"]
      },
      {
        label: "Heading 3",
        element: "h3",
        level: 3,
        className: "m-0 grow text-lg font-semibold",
        shortcuts: ["mod", "alt", "3"]
      },
      {
        label: "Heading 4",
        element: "h4",
        level: 4,
        className: "m-0 grow text-base font-semibold",
        shortcuts: ["mod", "alt", "4"]
      },
      {
        label: "Heading 5",
        element: "h5",
        level: 5,
        className: "m-0 grow text-sm font-normal",
        shortcuts: ["mod", "alt", "5"]
      },
      {
        label: "Heading 6",
        element: "h6",
        level: 6,
        className: "m-0 grow text-sm font-normal",
        shortcuts: ["mod", "alt", "6"]
      }
    ], n = e, r = _e(!1), i = R(
      () => t.filter((s) => {
        var a;
        return !s.level || ((a = n.activeLevels) == null ? void 0 : a.includes(s.level));
      })
    );
    function o(s) {
      s ? n.editor.chain().focus().toggleHeading({ level: s }).run() : n.editor.chain().focus().setParagraph().run();
    }
    return (s, a) => (x(), L(b(p2), {
      open: r.value,
      "onUpdate:open": a[0] || (a[0] = (l) => r.value = l)
    }, {
      default: A(() => [
        $(b(h2), { asChild: "" }, {
          default: A(() => [
            $(Vc, {
              isActive: s.editor.isActive("heading"),
              tooltip: "Text styles",
              "aria-label": "Text styles",
              pressed: s.editor.isActive("heading"),
              className: "w-12",
              disabled: s.editor.isActive("codeBlock"),
              handleAction: () => r.value = !0
            }, {
              icon: A(() => [
                be("span", J9, [
                  $(b(nS), { class: "size-5" }),
                  $(b(Xs), { class: "size-5" })
                ])
              ]),
              _: 1
            }, 8, ["isActive", "pressed", "disabled", "handleAction"])
          ]),
          _: 1
        }),
        $(b(g2), {
          align: "start",
          class: "w-full"
        }, {
          default: A(() => [
            (x(!0), W(Ge, null, ft(i.value, (l) => (x(), L(b(m2), {
              key: l.label,
              onClick: (u) => o(l.level),
              class: ce(
                b(G)("flex flex-row items-center justify-between gap-4", {
                  "bg-accent": l.level ? s.editor.isActive("heading", { level: l.level }) : s.editor.isActive("paragraph")
                })
              ),
              "aria-label": l.label
            }, {
              default: A(() => [
                (x(), L(Nr(l.element), {
                  class: ce(l.className)
                }, {
                  default: A(() => [
                    Xt(ze(l.label), 1)
                  ]),
                  _: 2
                }, 1032, ["class"])),
                $(rw, {
                  keys: l.shortcuts
                }, null, 8, ["keys"])
              ]),
              _: 2
            }, 1032, ["onClick", "class", "aria-label"]))), 128))
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["open"]));
  }
}), tR = { class: "grow" }, iw = /* @__PURE__ */ S({
  __name: "ToolbarSection",
  props: {
    editor: {},
    actions: {},
    mainActionCount: { default: 0 },
    dropdownIcon: {},
    dropdownTooltip: { default: "More Options" },
    dropdownClassName: { default: "w-12" }
  },
  setup(e) {
    const t = _e(!1), n = e, r = R(() => n.actions), i = R(() => r.value.slice(0, n.mainActionCount)), o = R(() => r.value.slice(n.mainActionCount)), s = R(
      () => o.value.some((l) => l.isActive.value)
    );
    function a(l) {
      return `${l.label} ${l.shortcuts.map((u) => nw(u).symbol).join(" ")}`;
    }
    return (l, u) => (x(), W(Ge, null, [
      (x(!0), W(Ge, null, ft(i.value, (c) => (x(), L(Vc, {
        key: c.label,
        disabled: !(c != null && c.canExecute),
        isActive: c == null ? void 0 : c.isActive,
        "handle-action": c == null ? void 0 : c.action,
        tooltip: a(c),
        "aria-label": c.label
      }, {
        icon: A(() => [
          c != null && c.icon ? (x(), L(Nr(c == null ? void 0 : c.icon), {
            key: 0,
            class: "size-5"
          })) : Qe("", !0)
        ]),
        _: 2
      }, 1032, ["disabled", "isActive", "handle-action", "tooltip", "aria-label"]))), 128)),
      o.value.length ? (x(), L(b(p2), {
        key: 0,
        open: t.value,
        "onUpdate:open": u[0] || (u[0] = (c) => t.value = c)
      }, {
        default: A(() => [
          $(b(h2), { asChild: "" }, {
            default: A(() => [
              $(Vc, {
                isActive: s.value,
                tooltip: l.dropdownTooltip,
                "aria-label": l.dropdownTooltip,
                class: ce(b(G)(l.dropdownClassName)),
                "handle-action": () => t.value = !0
              }, {
                icon: A(() => [
                  $(b(l2), { class: "size-5" })
                ]),
                _: 1
              }, 8, ["isActive", "tooltip", "aria-label", "class", "handle-action"])
            ]),
            _: 1
          }),
          $(b(g2), {
            align: "start",
            class: "w-full"
          }, {
            default: A(() => [
              (x(!0), W(Ge, null, ft(o.value, (c) => (x(), L(b(m2), {
                key: c.label,
                onClick: () => c == null ? void 0 : c.action(),
                disabled: !(c != null && c.canExecute),
                class: ce(
                  b(G)("flex flex-row items-center justify-between gap-4", {
                    "bg-muted": Me(c == null ? void 0 : c.isActive) == !0
                  })
                ),
                "aria-label": c.label
              }, {
                default: A(() => [
                  be("span", tR, ze(c.label), 1),
                  $(rw, {
                    keys: c.shortcuts
                  }, null, 8, ["keys"])
                ]),
                _: 2
              }, 1032, ["onClick", "disabled", "class", "aria-label"]))), 128))
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["open"])) : Qe("", !0)
    ], 64));
  }
}), nR = /* @__PURE__ */ S({
  __name: "Typography",
  props: {
    editor: {},
    mainActionCount: {},
    actions: {}
  },
  setup(e) {
    const t = [
      {
        value: "bold",
        label: "Bold",
        icon: rS,
        action: () => n.editor.chain().focus().toggleBold().run(),
        isActive: R(() => n.editor.isActive("bold")),
        canExecute: R(
          () => n.editor.can().chain().focus().toggleBold().run() && !n.editor.isActive("codeBlock")
        ),
        shortcuts: ["mod", "B"]
      },
      {
        value: "italic",
        label: "Italic",
        icon: iS,
        action: () => n.editor.chain().focus().toggleItalic().run(),
        isActive: R(() => n.editor.isActive("italic")),
        canExecute: R(
          () => n.editor.can().chain().focus().toggleItalic().run() && !n.editor.isActive("codeBlock")
        ),
        shortcuts: ["mod", "I"]
      },
      {
        value: "underline",
        label: "Underline",
        icon: oS,
        action: () => n.editor.chain().focus().toggleUnderline().run(),
        isActive: R(() => n.editor.isActive("underline")),
        canExecute: R(
          () => n.editor.can().chain().focus().toggleUnderline().run() && !n.editor.isActive("codeBlock")
        ),
        shortcuts: ["mod", "U"]
      },
      {
        value: "strikethrough",
        label: "Strikethrough",
        icon: sS,
        action: () => n.editor.chain().focus().toggleStrike().run(),
        isActive: R(() => n.editor.isActive("strike")),
        canExecute: R(
          () => n.editor.can().chain().focus().toggleStrike().run() && !n.editor.isActive("codeBlock")
        ),
        shortcuts: ["mod", "shift", "S"]
      },
      {
        value: "code",
        label: "Code",
        icon: aS,
        action: () => n.editor.chain().focus().toggleCode().run(),
        isActive: R(() => n.editor.isActive("code")),
        canExecute: R(
          () => n.editor.can().chain().focus().toggleCode().run() && !n.editor.isActive("codeBlock")
        ),
        shortcuts: ["mod", "E"]
      },
      {
        value: "clearFormatting",
        label: "Clear formatting",
        icon: lS,
        action: () => n.editor.chain().focus().unsetAllMarks().run(),
        isActive: R(() => !1),
        canExecute: R(
          () => n.editor.can().chain().focus().unsetAllMarks().run() && !n.editor.isActive("codeBlock")
        ),
        shortcuts: ["mod", "\\"]
      }
    ], n = e, r = R(() => t.filter((i) => n.actions.includes(i.value)));
    return (i, o) => (x(), L(iw, {
      editor: i.editor,
      actions: r.value,
      mainActionCount: 3,
      dropdownTooltip: "More formatting",
      dropdownClassName: "w-8"
    }, null, 8, ["editor", "actions"]));
  }
}), rR = /* @__PURE__ */ S({
  __name: "Lists",
  props: {
    editor: {},
    actions: {},
    mainActionCount: {}
  },
  setup(e) {
    const t = [
      {
        value: "orderedList",
        label: "Numbered list",
        icon: uS,
        isActive: R(() => n.editor.isActive("orderedList")),
        action: () => n.editor.chain().focus().toggleOrderedList().run(),
        canExecute: R(() => n.editor.can().chain().focus().toggleOrderedList().run()),
        shortcuts: ["mod", "shift", "7"]
      },
      {
        value: "bulletList",
        label: "Bullet list",
        icon: cS,
        isActive: R(() => n.editor.isActive("bulletList")),
        action: () => n.editor.chain().focus().toggleBulletList().run(),
        canExecute: R(() => n.editor.can().chain().focus().toggleBulletList().run()),
        shortcuts: ["mod", "shift", "8"]
      },
      {
        value: "checkList",
        label: "Check list",
        icon: fS,
        isActive: R(() => n.editor.isActive("taskList")),
        action: () => n.editor.chain().focus().toggleTaskList().run(),
        canExecute: R(() => n.editor.can().chain().focus().toggleTaskList().run()),
        shortcuts: ["mod", "shift", "9"]
      }
    ], n = e, r = R(() => t.filter((i) => {
      var o;
      return (o = n.actions) == null ? void 0 : o.includes(i.value);
    }));
    return (i, o) => (x(), L(iw, {
      editor: i.editor,
      actions: r.value,
      "main-action-count": i.mainActionCount
    }, null, 8, ["editor", "actions", "main-action-count"]));
  }
}), ow = "https://cdn.jsdelivr.net/npm/emoji-datasource-apple@6.0.1/img/apple/64", sw = {
  recent: "Recently used",
  smileys_people: "Smiles & People",
  animals_nature: "Animals & Nature",
  food_drink: "Food & Drink",
  activities: "Activities",
  travel_places: "Travel places",
  objects: "Objects",
  symbols: "Symbols",
  flags: "Flags"
}, aw = "u", md = "n", _u = "v", fl = "r", iR = {
  [md]: ["grinning face", "grinning"],
  [aw]: "1f600",
  [fl]: "1f600"
}, Hc = "neutral", oR = "1f3fb", sR = "1f3fc", aR = "1f3fd", lR = "1f3fe", uR = "1f3ff", cR = [
  Hc,
  oR,
  sR,
  aR,
  lR,
  uR
], fR = {
  placeholder: "Search emoji",
  skinTone: "Skin tone"
}, dR = ["light", "dark", "auto"], pR = [
  {
    n: [
      "grinning face",
      "grinning"
    ],
    u: "1f600"
  },
  {
    n: [
      "grinning face with smiling eyes",
      "grin"
    ],
    u: "1f601"
  },
  {
    n: [
      "face with tears of joy",
      "joy"
    ],
    u: "1f602"
  },
  {
    n: [
      "rolling on the floor laughing",
      "rolling_on_the_floor_laughing"
    ],
    u: "1f923"
  },
  {
    n: [
      "smiling face with open mouth",
      "smiley"
    ],
    u: "1f603"
  },
  {
    n: [
      "smiling face with open mouth and smiling eyes",
      "smile"
    ],
    u: "1f604"
  },
  {
    n: [
      "smiling face with open mouth and cold sweat",
      "sweat_smile"
    ],
    u: "1f605"
  },
  {
    n: [
      "smiling face with open mouth and tightly-closed eyes",
      "laughing",
      "satisfied"
    ],
    u: "1f606"
  },
  {
    n: [
      "winking face",
      "wink"
    ],
    u: "1f609"
  },
  {
    n: [
      "smiling face with smiling eyes",
      "blush"
    ],
    u: "1f60a"
  },
  {
    n: [
      "face savouring delicious food",
      "yum"
    ],
    u: "1f60b"
  },
  {
    n: [
      "smiling face with sunglasses",
      "sunglasses"
    ],
    u: "1f60e"
  },
  {
    n: [
      "smiling face with heart-shaped eyes",
      "heart_eyes"
    ],
    u: "1f60d"
  },
  {
    n: [
      "face throwing a kiss",
      "kissing_heart"
    ],
    u: "1f618"
  },
  {
    n: [
      "kissing face",
      "kissing"
    ],
    u: "1f617"
  },
  {
    n: [
      "kissing face with smiling eyes",
      "kissing_smiling_eyes"
    ],
    u: "1f619"
  },
  {
    n: [
      "kissing face with closed eyes",
      "kissing_closed_eyes"
    ],
    u: "1f61a"
  },
  {
    n: [
      "white smiling face",
      "relaxed"
    ],
    u: "263a-fe0f"
  },
  {
    n: [
      "slightly smiling face",
      "slightly_smiling_face"
    ],
    u: "1f642"
  },
  {
    n: [
      "hugging face",
      "hugging_face"
    ],
    u: "1f917"
  },
  {
    n: [
      "grinning face with star eyes",
      "star-struck",
      "grinning_face_with_star_eyes"
    ],
    u: "1f929"
  },
  {
    n: [
      "thinking face",
      "thinking_face"
    ],
    u: "1f914"
  },
  {
    n: [
      "face with one eyebrow raised",
      "face_with_raised_eyebrow",
      "face_with_one_eyebrow_raised"
    ],
    u: "1f928"
  },
  {
    n: [
      "neutral face",
      "neutral_face"
    ],
    u: "1f610"
  },
  {
    n: [
      "expressionless face",
      "expressionless"
    ],
    u: "1f611"
  },
  {
    n: [
      "face without mouth",
      "no_mouth"
    ],
    u: "1f636"
  },
  {
    n: [
      "face with rolling eyes",
      "face_with_rolling_eyes"
    ],
    u: "1f644"
  },
  {
    n: [
      "smirking face",
      "smirk"
    ],
    u: "1f60f"
  },
  {
    n: [
      "persevering face",
      "persevere"
    ],
    u: "1f623"
  },
  {
    n: [
      "disappointed but relieved face",
      "disappointed_relieved"
    ],
    u: "1f625"
  },
  {
    n: [
      "face with open mouth",
      "open_mouth"
    ],
    u: "1f62e"
  },
  {
    n: [
      "zipper-mouth face",
      "zipper_mouth_face"
    ],
    u: "1f910"
  },
  {
    n: [
      "hushed face",
      "hushed"
    ],
    u: "1f62f"
  },
  {
    n: [
      "sleepy face",
      "sleepy"
    ],
    u: "1f62a"
  },
  {
    n: [
      "tired face",
      "tired_face"
    ],
    u: "1f62b"
  },
  {
    n: [
      "sleeping face",
      "sleeping"
    ],
    u: "1f634"
  },
  {
    n: [
      "relieved face",
      "relieved"
    ],
    u: "1f60c"
  },
  {
    n: [
      "face with stuck-out tongue",
      "stuck_out_tongue"
    ],
    u: "1f61b"
  },
  {
    n: [
      "face with stuck-out tongue and winking eye",
      "stuck_out_tongue_winking_eye"
    ],
    u: "1f61c"
  },
  {
    n: [
      "face with stuck-out tongue and tightly-closed eyes",
      "stuck_out_tongue_closed_eyes"
    ],
    u: "1f61d"
  },
  {
    n: [
      "drooling face",
      "drooling_face"
    ],
    u: "1f924"
  },
  {
    n: [
      "unamused face",
      "unamused"
    ],
    u: "1f612"
  },
  {
    n: [
      "face with cold sweat",
      "sweat"
    ],
    u: "1f613"
  },
  {
    n: [
      "pensive face",
      "pensive"
    ],
    u: "1f614"
  },
  {
    n: [
      "confused face",
      "confused"
    ],
    u: "1f615"
  },
  {
    n: [
      "upside-down face",
      "upside_down_face"
    ],
    u: "1f643"
  },
  {
    n: [
      "money-mouth face",
      "money_mouth_face"
    ],
    u: "1f911"
  },
  {
    n: [
      "astonished face",
      "astonished"
    ],
    u: "1f632"
  },
  {
    n: [
      "white_frowning_face"
    ],
    u: "2639-fe0f"
  },
  {
    n: [
      "slightly frowning face",
      "slightly_frowning_face"
    ],
    u: "1f641"
  },
  {
    n: [
      "confounded face",
      "confounded"
    ],
    u: "1f616"
  },
  {
    n: [
      "disappointed face",
      "disappointed"
    ],
    u: "1f61e"
  },
  {
    n: [
      "worried face",
      "worried"
    ],
    u: "1f61f"
  },
  {
    n: [
      "face with look of triumph",
      "triumph"
    ],
    u: "1f624"
  },
  {
    n: [
      "crying face",
      "cry"
    ],
    u: "1f622"
  },
  {
    n: [
      "loudly crying face",
      "sob"
    ],
    u: "1f62d"
  },
  {
    n: [
      "frowning face with open mouth",
      "frowning"
    ],
    u: "1f626"
  },
  {
    n: [
      "anguished face",
      "anguished"
    ],
    u: "1f627"
  },
  {
    n: [
      "fearful face",
      "fearful"
    ],
    u: "1f628"
  },
  {
    n: [
      "weary face",
      "weary"
    ],
    u: "1f629"
  },
  {
    n: [
      "shocked face with exploding head",
      "exploding_head",
      "shocked_face_with_exploding_head"
    ],
    u: "1f92f"
  },
  {
    n: [
      "grimacing face",
      "grimacing"
    ],
    u: "1f62c"
  },
  {
    n: [
      "face with open mouth and cold sweat",
      "cold_sweat"
    ],
    u: "1f630"
  },
  {
    n: [
      "face screaming in fear",
      "scream"
    ],
    u: "1f631"
  },
  {
    n: [
      "flushed face",
      "flushed"
    ],
    u: "1f633"
  },
  {
    n: [
      "grinning face with one large and one small eye",
      "zany_face",
      "grinning_face_with_one_large_and_one_small_eye"
    ],
    u: "1f92a"
  },
  {
    n: [
      "dizzy face",
      "dizzy_face"
    ],
    u: "1f635"
  },
  {
    n: [
      "pouting face",
      "rage"
    ],
    u: "1f621"
  },
  {
    n: [
      "angry face",
      "angry"
    ],
    u: "1f620"
  },
  {
    n: [
      "serious face with symbols covering mouth",
      "face_with_symbols_on_mouth",
      "serious_face_with_symbols_covering_mouth"
    ],
    u: "1f92c"
  },
  {
    n: [
      "face with medical mask",
      "mask"
    ],
    u: "1f637"
  },
  {
    n: [
      "face with thermometer",
      "face_with_thermometer"
    ],
    u: "1f912"
  },
  {
    n: [
      "face with head-bandage",
      "face_with_head_bandage"
    ],
    u: "1f915"
  },
  {
    n: [
      "nauseated face",
      "nauseated_face"
    ],
    u: "1f922"
  },
  {
    n: [
      "face with open mouth vomiting",
      "face_vomiting",
      "face_with_open_mouth_vomiting"
    ],
    u: "1f92e"
  },
  {
    n: [
      "sneezing face",
      "sneezing_face"
    ],
    u: "1f927"
  },
  {
    n: [
      "smiling face with halo",
      "innocent"
    ],
    u: "1f607"
  },
  {
    n: [
      "face with cowboy hat",
      "face_with_cowboy_hat"
    ],
    u: "1f920"
  },
  {
    n: [
      "clown face",
      "clown_face"
    ],
    u: "1f921"
  },
  {
    n: [
      "lying face",
      "lying_face"
    ],
    u: "1f925"
  },
  {
    n: [
      "face with finger covering closed lips",
      "shushing_face",
      "face_with_finger_covering_closed_lips"
    ],
    u: "1f92b"
  },
  {
    n: [
      "smiling face with smiling eyes and hand covering mouth",
      "face_with_hand_over_mouth",
      "smiling_face_with_smiling_eyes_and_hand_covering_mouth"
    ],
    u: "1f92d"
  },
  {
    n: [
      "face with monocle",
      "face_with_monocle"
    ],
    u: "1f9d0"
  },
  {
    n: [
      "nerd face",
      "nerd_face"
    ],
    u: "1f913"
  },
  {
    n: [
      "smiling face with horns",
      "smiling_imp"
    ],
    u: "1f608"
  },
  {
    n: [
      "imp"
    ],
    u: "1f47f"
  },
  {
    n: [
      "japanese ogre",
      "japanese_ogre"
    ],
    u: "1f479"
  },
  {
    n: [
      "japanese goblin",
      "japanese_goblin"
    ],
    u: "1f47a"
  },
  {
    n: [
      "skull"
    ],
    u: "1f480"
  },
  {
    n: [
      "skull_and_crossbones"
    ],
    u: "2620-fe0f"
  },
  {
    n: [
      "ghost"
    ],
    u: "1f47b"
  },
  {
    n: [
      "extraterrestrial alien",
      "alien"
    ],
    u: "1f47d"
  },
  {
    n: [
      "alien monster",
      "space_invader"
    ],
    u: "1f47e"
  },
  {
    n: [
      "robot face",
      "robot_face"
    ],
    u: "1f916"
  },
  {
    n: [
      "pile of poo",
      "hankey",
      "poop",
      "shit"
    ],
    u: "1f4a9"
  },
  {
    n: [
      "smiling cat face with open mouth",
      "smiley_cat"
    ],
    u: "1f63a"
  },
  {
    n: [
      "grinning cat face with smiling eyes",
      "smile_cat"
    ],
    u: "1f638"
  },
  {
    n: [
      "cat face with tears of joy",
      "joy_cat"
    ],
    u: "1f639"
  },
  {
    n: [
      "smiling cat face with heart-shaped eyes",
      "heart_eyes_cat"
    ],
    u: "1f63b"
  },
  {
    n: [
      "cat face with wry smile",
      "smirk_cat"
    ],
    u: "1f63c"
  },
  {
    n: [
      "kissing cat face with closed eyes",
      "kissing_cat"
    ],
    u: "1f63d"
  },
  {
    n: [
      "weary cat face",
      "scream_cat"
    ],
    u: "1f640"
  },
  {
    n: [
      "crying cat face",
      "crying_cat_face"
    ],
    u: "1f63f"
  },
  {
    n: [
      "pouting cat face",
      "pouting_cat"
    ],
    u: "1f63e"
  },
  {
    n: [
      "see-no-evil monkey",
      "see_no_evil"
    ],
    u: "1f648"
  },
  {
    n: [
      "hear-no-evil monkey",
      "hear_no_evil"
    ],
    u: "1f649"
  },
  {
    n: [
      "speak-no-evil monkey",
      "speak_no_evil"
    ],
    u: "1f64a"
  },
  {
    n: [
      "baby"
    ],
    u: "1f476",
    v: [
      "1f476-1f3fb",
      "1f476-1f3fc",
      "1f476-1f3fd",
      "1f476-1f3fe",
      "1f476-1f3ff"
    ]
  },
  {
    n: [
      "child"
    ],
    u: "1f9d2",
    v: [
      "1f9d2-1f3fb",
      "1f9d2-1f3fc",
      "1f9d2-1f3fd",
      "1f9d2-1f3fe",
      "1f9d2-1f3ff"
    ]
  },
  {
    n: [
      "boy"
    ],
    u: "1f466",
    v: [
      "1f466-1f3fb",
      "1f466-1f3fc",
      "1f466-1f3fd",
      "1f466-1f3fe",
      "1f466-1f3ff"
    ]
  },
  {
    n: [
      "girl"
    ],
    u: "1f467",
    v: [
      "1f467-1f3fb",
      "1f467-1f3fc",
      "1f467-1f3fd",
      "1f467-1f3fe",
      "1f467-1f3ff"
    ]
  },
  {
    n: [
      "adult"
    ],
    u: "1f9d1",
    v: [
      "1f9d1-1f3fb",
      "1f9d1-1f3fc",
      "1f9d1-1f3fd",
      "1f9d1-1f3fe",
      "1f9d1-1f3ff"
    ]
  },
  {
    n: [
      "man"
    ],
    u: "1f468",
    v: [
      "1f468-1f3fb",
      "1f468-1f3fc",
      "1f468-1f3fd",
      "1f468-1f3fe",
      "1f468-1f3ff"
    ]
  },
  {
    n: [
      "woman"
    ],
    u: "1f469",
    v: [
      "1f469-1f3fb",
      "1f469-1f3fc",
      "1f469-1f3fd",
      "1f469-1f3fe",
      "1f469-1f3ff"
    ]
  },
  {
    n: [
      "older adult",
      "older_adult"
    ],
    u: "1f9d3",
    v: [
      "1f9d3-1f3fb",
      "1f9d3-1f3fc",
      "1f9d3-1f3fd",
      "1f9d3-1f3fe",
      "1f9d3-1f3ff"
    ]
  },
  {
    n: [
      "older man",
      "older_man"
    ],
    u: "1f474",
    v: [
      "1f474-1f3fb",
      "1f474-1f3fc",
      "1f474-1f3fd",
      "1f474-1f3fe",
      "1f474-1f3ff"
    ]
  },
  {
    n: [
      "older woman",
      "older_woman"
    ],
    u: "1f475",
    v: [
      "1f475-1f3fb",
      "1f475-1f3fc",
      "1f475-1f3fd",
      "1f475-1f3fe",
      "1f475-1f3ff"
    ]
  },
  {
    n: [
      "male-doctor"
    ],
    u: "1f468-200d-2695-fe0f",
    v: [
      "1f468-1f3fb-200d-2695-fe0f",
      "1f468-1f3fc-200d-2695-fe0f",
      "1f468-1f3fd-200d-2695-fe0f",
      "1f468-1f3fe-200d-2695-fe0f",
      "1f468-1f3ff-200d-2695-fe0f"
    ]
  },
  {
    n: [
      "female-doctor"
    ],
    u: "1f469-200d-2695-fe0f",
    v: [
      "1f469-1f3fb-200d-2695-fe0f",
      "1f469-1f3fc-200d-2695-fe0f",
      "1f469-1f3fd-200d-2695-fe0f",
      "1f469-1f3fe-200d-2695-fe0f",
      "1f469-1f3ff-200d-2695-fe0f"
    ]
  },
  {
    n: [
      "male-student"
    ],
    u: "1f468-200d-1f393",
    v: [
      "1f468-1f3fb-200d-1f393",
      "1f468-1f3fc-200d-1f393",
      "1f468-1f3fd-200d-1f393",
      "1f468-1f3fe-200d-1f393",
      "1f468-1f3ff-200d-1f393"
    ]
  },
  {
    n: [
      "female-student"
    ],
    u: "1f469-200d-1f393",
    v: [
      "1f469-1f3fb-200d-1f393",
      "1f469-1f3fc-200d-1f393",
      "1f469-1f3fd-200d-1f393",
      "1f469-1f3fe-200d-1f393",
      "1f469-1f3ff-200d-1f393"
    ]
  },
  {
    n: [
      "male-teacher"
    ],
    u: "1f468-200d-1f3eb",
    v: [
      "1f468-1f3fb-200d-1f3eb",
      "1f468-1f3fc-200d-1f3eb",
      "1f468-1f3fd-200d-1f3eb",
      "1f468-1f3fe-200d-1f3eb",
      "1f468-1f3ff-200d-1f3eb"
    ]
  },
  {
    n: [
      "female-teacher"
    ],
    u: "1f469-200d-1f3eb",
    v: [
      "1f469-1f3fb-200d-1f3eb",
      "1f469-1f3fc-200d-1f3eb",
      "1f469-1f3fd-200d-1f3eb",
      "1f469-1f3fe-200d-1f3eb",
      "1f469-1f3ff-200d-1f3eb"
    ]
  },
  {
    n: [
      "male-judge"
    ],
    u: "1f468-200d-2696-fe0f",
    v: [
      "1f468-1f3fb-200d-2696-fe0f",
      "1f468-1f3fc-200d-2696-fe0f",
      "1f468-1f3fd-200d-2696-fe0f",
      "1f468-1f3fe-200d-2696-fe0f",
      "1f468-1f3ff-200d-2696-fe0f"
    ]
  },
  {
    n: [
      "female-judge"
    ],
    u: "1f469-200d-2696-fe0f",
    v: [
      "1f469-1f3fb-200d-2696-fe0f",
      "1f469-1f3fc-200d-2696-fe0f",
      "1f469-1f3fd-200d-2696-fe0f",
      "1f469-1f3fe-200d-2696-fe0f",
      "1f469-1f3ff-200d-2696-fe0f"
    ]
  },
  {
    n: [
      "male-farmer"
    ],
    u: "1f468-200d-1f33e",
    v: [
      "1f468-1f3fb-200d-1f33e",
      "1f468-1f3fc-200d-1f33e",
      "1f468-1f3fd-200d-1f33e",
      "1f468-1f3fe-200d-1f33e",
      "1f468-1f3ff-200d-1f33e"
    ]
  },
  {
    n: [
      "female-farmer"
    ],
    u: "1f469-200d-1f33e",
    v: [
      "1f469-1f3fb-200d-1f33e",
      "1f469-1f3fc-200d-1f33e",
      "1f469-1f3fd-200d-1f33e",
      "1f469-1f3fe-200d-1f33e",
      "1f469-1f3ff-200d-1f33e"
    ]
  },
  {
    n: [
      "male-cook"
    ],
    u: "1f468-200d-1f373",
    v: [
      "1f468-1f3fb-200d-1f373",
      "1f468-1f3fc-200d-1f373",
      "1f468-1f3fd-200d-1f373",
      "1f468-1f3fe-200d-1f373",
      "1f468-1f3ff-200d-1f373"
    ]
  },
  {
    n: [
      "female-cook"
    ],
    u: "1f469-200d-1f373",
    v: [
      "1f469-1f3fb-200d-1f373",
      "1f469-1f3fc-200d-1f373",
      "1f469-1f3fd-200d-1f373",
      "1f469-1f3fe-200d-1f373",
      "1f469-1f3ff-200d-1f373"
    ]
  },
  {
    n: [
      "male-mechanic"
    ],
    u: "1f468-200d-1f527",
    v: [
      "1f468-1f3fb-200d-1f527",
      "1f468-1f3fc-200d-1f527",
      "1f468-1f3fd-200d-1f527",
      "1f468-1f3fe-200d-1f527",
      "1f468-1f3ff-200d-1f527"
    ]
  },
  {
    n: [
      "female-mechanic"
    ],
    u: "1f469-200d-1f527",
    v: [
      "1f469-1f3fb-200d-1f527",
      "1f469-1f3fc-200d-1f527",
      "1f469-1f3fd-200d-1f527",
      "1f469-1f3fe-200d-1f527",
      "1f469-1f3ff-200d-1f527"
    ]
  },
  {
    n: [
      "male-factory-worker"
    ],
    u: "1f468-200d-1f3ed",
    v: [
      "1f468-1f3fb-200d-1f3ed",
      "1f468-1f3fc-200d-1f3ed",
      "1f468-1f3fd-200d-1f3ed",
      "1f468-1f3fe-200d-1f3ed",
      "1f468-1f3ff-200d-1f3ed"
    ]
  },
  {
    n: [
      "female-factory-worker"
    ],
    u: "1f469-200d-1f3ed",
    v: [
      "1f469-1f3fb-200d-1f3ed",
      "1f469-1f3fc-200d-1f3ed",
      "1f469-1f3fd-200d-1f3ed",
      "1f469-1f3fe-200d-1f3ed",
      "1f469-1f3ff-200d-1f3ed"
    ]
  },
  {
    n: [
      "male-office-worker"
    ],
    u: "1f468-200d-1f4bc",
    v: [
      "1f468-1f3fb-200d-1f4bc",
      "1f468-1f3fc-200d-1f4bc",
      "1f468-1f3fd-200d-1f4bc",
      "1f468-1f3fe-200d-1f4bc",
      "1f468-1f3ff-200d-1f4bc"
    ]
  },
  {
    n: [
      "female-office-worker"
    ],
    u: "1f469-200d-1f4bc",
    v: [
      "1f469-1f3fb-200d-1f4bc",
      "1f469-1f3fc-200d-1f4bc",
      "1f469-1f3fd-200d-1f4bc",
      "1f469-1f3fe-200d-1f4bc",
      "1f469-1f3ff-200d-1f4bc"
    ]
  },
  {
    n: [
      "male-scientist"
    ],
    u: "1f468-200d-1f52c",
    v: [
      "1f468-1f3fb-200d-1f52c",
      "1f468-1f3fc-200d-1f52c",
      "1f468-1f3fd-200d-1f52c",
      "1f468-1f3fe-200d-1f52c",
      "1f468-1f3ff-200d-1f52c"
    ]
  },
  {
    n: [
      "female-scientist"
    ],
    u: "1f469-200d-1f52c",
    v: [
      "1f469-1f3fb-200d-1f52c",
      "1f469-1f3fc-200d-1f52c",
      "1f469-1f3fd-200d-1f52c",
      "1f469-1f3fe-200d-1f52c",
      "1f469-1f3ff-200d-1f52c"
    ]
  },
  {
    n: [
      "male-technologist"
    ],
    u: "1f468-200d-1f4bb",
    v: [
      "1f468-1f3fb-200d-1f4bb",
      "1f468-1f3fc-200d-1f4bb",
      "1f468-1f3fd-200d-1f4bb",
      "1f468-1f3fe-200d-1f4bb",
      "1f468-1f3ff-200d-1f4bb"
    ]
  },
  {
    n: [
      "female-technologist"
    ],
    u: "1f469-200d-1f4bb",
    v: [
      "1f469-1f3fb-200d-1f4bb",
      "1f469-1f3fc-200d-1f4bb",
      "1f469-1f3fd-200d-1f4bb",
      "1f469-1f3fe-200d-1f4bb",
      "1f469-1f3ff-200d-1f4bb"
    ]
  },
  {
    n: [
      "male-singer"
    ],
    u: "1f468-200d-1f3a4",
    v: [
      "1f468-1f3fb-200d-1f3a4",
      "1f468-1f3fc-200d-1f3a4",
      "1f468-1f3fd-200d-1f3a4",
      "1f468-1f3fe-200d-1f3a4",
      "1f468-1f3ff-200d-1f3a4"
    ]
  },
  {
    n: [
      "female-singer"
    ],
    u: "1f469-200d-1f3a4",
    v: [
      "1f469-1f3fb-200d-1f3a4",
      "1f469-1f3fc-200d-1f3a4",
      "1f469-1f3fd-200d-1f3a4",
      "1f469-1f3fe-200d-1f3a4",
      "1f469-1f3ff-200d-1f3a4"
    ]
  },
  {
    n: [
      "male-artist"
    ],
    u: "1f468-200d-1f3a8",
    v: [
      "1f468-1f3fb-200d-1f3a8",
      "1f468-1f3fc-200d-1f3a8",
      "1f468-1f3fd-200d-1f3a8",
      "1f468-1f3fe-200d-1f3a8",
      "1f468-1f3ff-200d-1f3a8"
    ]
  },
  {
    n: [
      "female-artist"
    ],
    u: "1f469-200d-1f3a8",
    v: [
      "1f469-1f3fb-200d-1f3a8",
      "1f469-1f3fc-200d-1f3a8",
      "1f469-1f3fd-200d-1f3a8",
      "1f469-1f3fe-200d-1f3a8",
      "1f469-1f3ff-200d-1f3a8"
    ]
  },
  {
    n: [
      "male-pilot"
    ],
    u: "1f468-200d-2708-fe0f",
    v: [
      "1f468-1f3fb-200d-2708-fe0f",
      "1f468-1f3fc-200d-2708-fe0f",
      "1f468-1f3fd-200d-2708-fe0f",
      "1f468-1f3fe-200d-2708-fe0f",
      "1f468-1f3ff-200d-2708-fe0f"
    ]
  },
  {
    n: [
      "female-pilot"
    ],
    u: "1f469-200d-2708-fe0f",
    v: [
      "1f469-1f3fb-200d-2708-fe0f",
      "1f469-1f3fc-200d-2708-fe0f",
      "1f469-1f3fd-200d-2708-fe0f",
      "1f469-1f3fe-200d-2708-fe0f",
      "1f469-1f3ff-200d-2708-fe0f"
    ]
  },
  {
    n: [
      "male-astronaut"
    ],
    u: "1f468-200d-1f680",
    v: [
      "1f468-1f3fb-200d-1f680",
      "1f468-1f3fc-200d-1f680",
      "1f468-1f3fd-200d-1f680",
      "1f468-1f3fe-200d-1f680",
      "1f468-1f3ff-200d-1f680"
    ]
  },
  {
    n: [
      "female-astronaut"
    ],
    u: "1f469-200d-1f680",
    v: [
      "1f469-1f3fb-200d-1f680",
      "1f469-1f3fc-200d-1f680",
      "1f469-1f3fd-200d-1f680",
      "1f469-1f3fe-200d-1f680",
      "1f469-1f3ff-200d-1f680"
    ]
  },
  {
    n: [
      "male-firefighter"
    ],
    u: "1f468-200d-1f692",
    v: [
      "1f468-1f3fb-200d-1f692",
      "1f468-1f3fc-200d-1f692",
      "1f468-1f3fd-200d-1f692",
      "1f468-1f3fe-200d-1f692",
      "1f468-1f3ff-200d-1f692"
    ]
  },
  {
    n: [
      "female-firefighter"
    ],
    u: "1f469-200d-1f692",
    v: [
      "1f469-1f3fb-200d-1f692",
      "1f469-1f3fc-200d-1f692",
      "1f469-1f3fd-200d-1f692",
      "1f469-1f3fe-200d-1f692",
      "1f469-1f3ff-200d-1f692"
    ]
  },
  {
    n: [
      "police officer",
      "cop"
    ],
    u: "1f46e",
    v: [
      "1f46e-1f3fb",
      "1f46e-1f3fc",
      "1f46e-1f3fd",
      "1f46e-1f3fe",
      "1f46e-1f3ff"
    ]
  },
  {
    n: [
      "male-police-officer"
    ],
    u: "1f46e-200d-2642-fe0f",
    v: [
      "1f46e-1f3fb-200d-2642-fe0f",
      "1f46e-1f3fc-200d-2642-fe0f",
      "1f46e-1f3fd-200d-2642-fe0f",
      "1f46e-1f3fe-200d-2642-fe0f",
      "1f46e-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "female-police-officer"
    ],
    u: "1f46e-200d-2640-fe0f",
    v: [
      "1f46e-1f3fb-200d-2640-fe0f",
      "1f46e-1f3fc-200d-2640-fe0f",
      "1f46e-1f3fd-200d-2640-fe0f",
      "1f46e-1f3fe-200d-2640-fe0f",
      "1f46e-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "sleuth_or_spy"
    ],
    u: "1f575-fe0f",
    v: [
      "1f575-1f3fb",
      "1f575-1f3fc",
      "1f575-1f3fd",
      "1f575-1f3fe",
      "1f575-1f3ff"
    ]
  },
  {
    n: [
      "male-detective"
    ],
    u: "1f575-fe0f-200d-2642-fe0f",
    v: [
      "1f575-1f3fb-200d-2642-fe0f",
      "1f575-1f3fc-200d-2642-fe0f",
      "1f575-1f3fd-200d-2642-fe0f",
      "1f575-1f3fe-200d-2642-fe0f",
      "1f575-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "female-detective"
    ],
    u: "1f575-fe0f-200d-2640-fe0f",
    v: [
      "1f575-1f3fb-200d-2640-fe0f",
      "1f575-1f3fc-200d-2640-fe0f",
      "1f575-1f3fd-200d-2640-fe0f",
      "1f575-1f3fe-200d-2640-fe0f",
      "1f575-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "guardsman"
    ],
    u: "1f482",
    v: [
      "1f482-1f3fb",
      "1f482-1f3fc",
      "1f482-1f3fd",
      "1f482-1f3fe",
      "1f482-1f3ff"
    ]
  },
  {
    n: [
      "male-guard"
    ],
    u: "1f482-200d-2642-fe0f",
    v: [
      "1f482-1f3fb-200d-2642-fe0f",
      "1f482-1f3fc-200d-2642-fe0f",
      "1f482-1f3fd-200d-2642-fe0f",
      "1f482-1f3fe-200d-2642-fe0f",
      "1f482-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "female-guard"
    ],
    u: "1f482-200d-2640-fe0f",
    v: [
      "1f482-1f3fb-200d-2640-fe0f",
      "1f482-1f3fc-200d-2640-fe0f",
      "1f482-1f3fd-200d-2640-fe0f",
      "1f482-1f3fe-200d-2640-fe0f",
      "1f482-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "construction worker",
      "construction_worker"
    ],
    u: "1f477",
    v: [
      "1f477-1f3fb",
      "1f477-1f3fc",
      "1f477-1f3fd",
      "1f477-1f3fe",
      "1f477-1f3ff"
    ]
  },
  {
    n: [
      "male-construction-worker"
    ],
    u: "1f477-200d-2642-fe0f",
    v: [
      "1f477-1f3fb-200d-2642-fe0f",
      "1f477-1f3fc-200d-2642-fe0f",
      "1f477-1f3fd-200d-2642-fe0f",
      "1f477-1f3fe-200d-2642-fe0f",
      "1f477-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "female-construction-worker"
    ],
    u: "1f477-200d-2640-fe0f",
    v: [
      "1f477-1f3fb-200d-2640-fe0f",
      "1f477-1f3fc-200d-2640-fe0f",
      "1f477-1f3fd-200d-2640-fe0f",
      "1f477-1f3fe-200d-2640-fe0f",
      "1f477-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "prince"
    ],
    u: "1f934",
    v: [
      "1f934-1f3fb",
      "1f934-1f3fc",
      "1f934-1f3fd",
      "1f934-1f3fe",
      "1f934-1f3ff"
    ]
  },
  {
    n: [
      "princess"
    ],
    u: "1f478",
    v: [
      "1f478-1f3fb",
      "1f478-1f3fc",
      "1f478-1f3fd",
      "1f478-1f3fe",
      "1f478-1f3ff"
    ]
  },
  {
    n: [
      "man with turban",
      "man_with_turban"
    ],
    u: "1f473",
    v: [
      "1f473-1f3fb",
      "1f473-1f3fc",
      "1f473-1f3fd",
      "1f473-1f3fe",
      "1f473-1f3ff"
    ]
  },
  {
    n: [
      "man-wearing-turban"
    ],
    u: "1f473-200d-2642-fe0f",
    v: [
      "1f473-1f3fb-200d-2642-fe0f",
      "1f473-1f3fc-200d-2642-fe0f",
      "1f473-1f3fd-200d-2642-fe0f",
      "1f473-1f3fe-200d-2642-fe0f",
      "1f473-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-wearing-turban"
    ],
    u: "1f473-200d-2640-fe0f",
    v: [
      "1f473-1f3fb-200d-2640-fe0f",
      "1f473-1f3fc-200d-2640-fe0f",
      "1f473-1f3fd-200d-2640-fe0f",
      "1f473-1f3fe-200d-2640-fe0f",
      "1f473-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "man with gua pi mao",
      "man_with_gua_pi_mao"
    ],
    u: "1f472",
    v: [
      "1f472-1f3fb",
      "1f472-1f3fc",
      "1f472-1f3fd",
      "1f472-1f3fe",
      "1f472-1f3ff"
    ]
  },
  {
    n: [
      "person with headscarf",
      "person_with_headscarf"
    ],
    u: "1f9d5",
    v: [
      "1f9d5-1f3fb",
      "1f9d5-1f3fc",
      "1f9d5-1f3fd",
      "1f9d5-1f3fe",
      "1f9d5-1f3ff"
    ]
  },
  {
    n: [
      "bearded person",
      "bearded_person"
    ],
    u: "1f9d4",
    v: [
      "1f9d4-1f3fb",
      "1f9d4-1f3fc",
      "1f9d4-1f3fd",
      "1f9d4-1f3fe",
      "1f9d4-1f3ff"
    ]
  },
  {
    n: [
      "person with blond hair",
      "person_with_blond_hair"
    ],
    u: "1f471",
    v: [
      "1f471-1f3fb",
      "1f471-1f3fc",
      "1f471-1f3fd",
      "1f471-1f3fe",
      "1f471-1f3ff"
    ]
  },
  {
    n: [
      "blond-haired-man"
    ],
    u: "1f471-200d-2642-fe0f",
    v: [
      "1f471-1f3fb-200d-2642-fe0f",
      "1f471-1f3fc-200d-2642-fe0f",
      "1f471-1f3fd-200d-2642-fe0f",
      "1f471-1f3fe-200d-2642-fe0f",
      "1f471-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "blond-haired-woman"
    ],
    u: "1f471-200d-2640-fe0f",
    v: [
      "1f471-1f3fb-200d-2640-fe0f",
      "1f471-1f3fc-200d-2640-fe0f",
      "1f471-1f3fd-200d-2640-fe0f",
      "1f471-1f3fe-200d-2640-fe0f",
      "1f471-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "man in tuxedo",
      "man_in_tuxedo"
    ],
    u: "1f935",
    v: [
      "1f935-1f3fb",
      "1f935-1f3fc",
      "1f935-1f3fd",
      "1f935-1f3fe",
      "1f935-1f3ff"
    ]
  },
  {
    n: [
      "bride with veil",
      "bride_with_veil"
    ],
    u: "1f470",
    v: [
      "1f470-1f3fb",
      "1f470-1f3fc",
      "1f470-1f3fd",
      "1f470-1f3fe",
      "1f470-1f3ff"
    ]
  },
  {
    n: [
      "pregnant woman",
      "pregnant_woman"
    ],
    u: "1f930",
    v: [
      "1f930-1f3fb",
      "1f930-1f3fc",
      "1f930-1f3fd",
      "1f930-1f3fe",
      "1f930-1f3ff"
    ]
  },
  {
    n: [
      "breast-feeding"
    ],
    u: "1f931",
    v: [
      "1f931-1f3fb",
      "1f931-1f3fc",
      "1f931-1f3fd",
      "1f931-1f3fe",
      "1f931-1f3ff"
    ]
  },
  {
    n: [
      "baby angel",
      "angel"
    ],
    u: "1f47c",
    v: [
      "1f47c-1f3fb",
      "1f47c-1f3fc",
      "1f47c-1f3fd",
      "1f47c-1f3fe",
      "1f47c-1f3ff"
    ]
  },
  {
    n: [
      "father christmas",
      "santa"
    ],
    u: "1f385",
    v: [
      "1f385-1f3fb",
      "1f385-1f3fc",
      "1f385-1f3fd",
      "1f385-1f3fe",
      "1f385-1f3ff"
    ]
  },
  {
    n: [
      "mother christmas",
      "mrs_claus",
      "mother_christmas"
    ],
    u: "1f936",
    v: [
      "1f936-1f3fb",
      "1f936-1f3fc",
      "1f936-1f3fd",
      "1f936-1f3fe",
      "1f936-1f3ff"
    ]
  },
  {
    n: [
      "mage"
    ],
    u: "1f9d9",
    v: [
      "1f9d9-1f3fb",
      "1f9d9-1f3fc",
      "1f9d9-1f3fd",
      "1f9d9-1f3fe",
      "1f9d9-1f3ff"
    ]
  },
  {
    n: [
      "female_mage"
    ],
    u: "1f9d9-200d-2640-fe0f",
    v: [
      "1f9d9-1f3fb-200d-2640-fe0f",
      "1f9d9-1f3fc-200d-2640-fe0f",
      "1f9d9-1f3fd-200d-2640-fe0f",
      "1f9d9-1f3fe-200d-2640-fe0f",
      "1f9d9-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "male_mage"
    ],
    u: "1f9d9-200d-2642-fe0f",
    v: [
      "1f9d9-1f3fb-200d-2642-fe0f",
      "1f9d9-1f3fc-200d-2642-fe0f",
      "1f9d9-1f3fd-200d-2642-fe0f",
      "1f9d9-1f3fe-200d-2642-fe0f",
      "1f9d9-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "fairy"
    ],
    u: "1f9da",
    v: [
      "1f9da-1f3fb",
      "1f9da-1f3fc",
      "1f9da-1f3fd",
      "1f9da-1f3fe",
      "1f9da-1f3ff"
    ]
  },
  {
    n: [
      "female_fairy"
    ],
    u: "1f9da-200d-2640-fe0f",
    v: [
      "1f9da-1f3fb-200d-2640-fe0f",
      "1f9da-1f3fc-200d-2640-fe0f",
      "1f9da-1f3fd-200d-2640-fe0f",
      "1f9da-1f3fe-200d-2640-fe0f",
      "1f9da-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "male_fairy"
    ],
    u: "1f9da-200d-2642-fe0f",
    v: [
      "1f9da-1f3fb-200d-2642-fe0f",
      "1f9da-1f3fc-200d-2642-fe0f",
      "1f9da-1f3fd-200d-2642-fe0f",
      "1f9da-1f3fe-200d-2642-fe0f",
      "1f9da-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "vampire"
    ],
    u: "1f9db",
    v: [
      "1f9db-1f3fb",
      "1f9db-1f3fc",
      "1f9db-1f3fd",
      "1f9db-1f3fe",
      "1f9db-1f3ff"
    ]
  },
  {
    n: [
      "female_vampire"
    ],
    u: "1f9db-200d-2640-fe0f",
    v: [
      "1f9db-1f3fb-200d-2640-fe0f",
      "1f9db-1f3fc-200d-2640-fe0f",
      "1f9db-1f3fd-200d-2640-fe0f",
      "1f9db-1f3fe-200d-2640-fe0f",
      "1f9db-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "male_vampire"
    ],
    u: "1f9db-200d-2642-fe0f",
    v: [
      "1f9db-1f3fb-200d-2642-fe0f",
      "1f9db-1f3fc-200d-2642-fe0f",
      "1f9db-1f3fd-200d-2642-fe0f",
      "1f9db-1f3fe-200d-2642-fe0f",
      "1f9db-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "merperson"
    ],
    u: "1f9dc",
    v: [
      "1f9dc-1f3fb",
      "1f9dc-1f3fc",
      "1f9dc-1f3fd",
      "1f9dc-1f3fe",
      "1f9dc-1f3ff"
    ]
  },
  {
    n: [
      "mermaid"
    ],
    u: "1f9dc-200d-2640-fe0f",
    v: [
      "1f9dc-1f3fb-200d-2640-fe0f",
      "1f9dc-1f3fc-200d-2640-fe0f",
      "1f9dc-1f3fd-200d-2640-fe0f",
      "1f9dc-1f3fe-200d-2640-fe0f",
      "1f9dc-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "merman"
    ],
    u: "1f9dc-200d-2642-fe0f",
    v: [
      "1f9dc-1f3fb-200d-2642-fe0f",
      "1f9dc-1f3fc-200d-2642-fe0f",
      "1f9dc-1f3fd-200d-2642-fe0f",
      "1f9dc-1f3fe-200d-2642-fe0f",
      "1f9dc-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "elf"
    ],
    u: "1f9dd",
    v: [
      "1f9dd-1f3fb",
      "1f9dd-1f3fc",
      "1f9dd-1f3fd",
      "1f9dd-1f3fe",
      "1f9dd-1f3ff"
    ]
  },
  {
    n: [
      "female_elf"
    ],
    u: "1f9dd-200d-2640-fe0f",
    v: [
      "1f9dd-1f3fb-200d-2640-fe0f",
      "1f9dd-1f3fc-200d-2640-fe0f",
      "1f9dd-1f3fd-200d-2640-fe0f",
      "1f9dd-1f3fe-200d-2640-fe0f",
      "1f9dd-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "male_elf"
    ],
    u: "1f9dd-200d-2642-fe0f",
    v: [
      "1f9dd-1f3fb-200d-2642-fe0f",
      "1f9dd-1f3fc-200d-2642-fe0f",
      "1f9dd-1f3fd-200d-2642-fe0f",
      "1f9dd-1f3fe-200d-2642-fe0f",
      "1f9dd-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "genie"
    ],
    u: "1f9de"
  },
  {
    n: [
      "female_genie"
    ],
    u: "1f9de-200d-2640-fe0f"
  },
  {
    n: [
      "male_genie"
    ],
    u: "1f9de-200d-2642-fe0f"
  },
  {
    n: [
      "zombie"
    ],
    u: "1f9df"
  },
  {
    n: [
      "female_zombie"
    ],
    u: "1f9df-200d-2640-fe0f"
  },
  {
    n: [
      "male_zombie"
    ],
    u: "1f9df-200d-2642-fe0f"
  },
  {
    n: [
      "person frowning",
      "person_frowning"
    ],
    u: "1f64d",
    v: [
      "1f64d-1f3fb",
      "1f64d-1f3fc",
      "1f64d-1f3fd",
      "1f64d-1f3fe",
      "1f64d-1f3ff"
    ]
  },
  {
    n: [
      "man-frowning"
    ],
    u: "1f64d-200d-2642-fe0f",
    v: [
      "1f64d-1f3fb-200d-2642-fe0f",
      "1f64d-1f3fc-200d-2642-fe0f",
      "1f64d-1f3fd-200d-2642-fe0f",
      "1f64d-1f3fe-200d-2642-fe0f",
      "1f64d-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-frowning"
    ],
    u: "1f64d-200d-2640-fe0f",
    v: [
      "1f64d-1f3fb-200d-2640-fe0f",
      "1f64d-1f3fc-200d-2640-fe0f",
      "1f64d-1f3fd-200d-2640-fe0f",
      "1f64d-1f3fe-200d-2640-fe0f",
      "1f64d-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "person with pouting face",
      "person_with_pouting_face"
    ],
    u: "1f64e",
    v: [
      "1f64e-1f3fb",
      "1f64e-1f3fc",
      "1f64e-1f3fd",
      "1f64e-1f3fe",
      "1f64e-1f3ff"
    ]
  },
  {
    n: [
      "man-pouting"
    ],
    u: "1f64e-200d-2642-fe0f",
    v: [
      "1f64e-1f3fb-200d-2642-fe0f",
      "1f64e-1f3fc-200d-2642-fe0f",
      "1f64e-1f3fd-200d-2642-fe0f",
      "1f64e-1f3fe-200d-2642-fe0f",
      "1f64e-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-pouting"
    ],
    u: "1f64e-200d-2640-fe0f",
    v: [
      "1f64e-1f3fb-200d-2640-fe0f",
      "1f64e-1f3fc-200d-2640-fe0f",
      "1f64e-1f3fd-200d-2640-fe0f",
      "1f64e-1f3fe-200d-2640-fe0f",
      "1f64e-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "face with no good gesture",
      "no_good"
    ],
    u: "1f645",
    v: [
      "1f645-1f3fb",
      "1f645-1f3fc",
      "1f645-1f3fd",
      "1f645-1f3fe",
      "1f645-1f3ff"
    ]
  },
  {
    n: [
      "man-gesturing-no"
    ],
    u: "1f645-200d-2642-fe0f",
    v: [
      "1f645-1f3fb-200d-2642-fe0f",
      "1f645-1f3fc-200d-2642-fe0f",
      "1f645-1f3fd-200d-2642-fe0f",
      "1f645-1f3fe-200d-2642-fe0f",
      "1f645-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-gesturing-no"
    ],
    u: "1f645-200d-2640-fe0f",
    v: [
      "1f645-1f3fb-200d-2640-fe0f",
      "1f645-1f3fc-200d-2640-fe0f",
      "1f645-1f3fd-200d-2640-fe0f",
      "1f645-1f3fe-200d-2640-fe0f",
      "1f645-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "face with ok gesture",
      "ok_woman"
    ],
    u: "1f646",
    v: [
      "1f646-1f3fb",
      "1f646-1f3fc",
      "1f646-1f3fd",
      "1f646-1f3fe",
      "1f646-1f3ff"
    ]
  },
  {
    n: [
      "man-gesturing-ok"
    ],
    u: "1f646-200d-2642-fe0f",
    v: [
      "1f646-1f3fb-200d-2642-fe0f",
      "1f646-1f3fc-200d-2642-fe0f",
      "1f646-1f3fd-200d-2642-fe0f",
      "1f646-1f3fe-200d-2642-fe0f",
      "1f646-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-gesturing-ok"
    ],
    u: "1f646-200d-2640-fe0f",
    v: [
      "1f646-1f3fb-200d-2640-fe0f",
      "1f646-1f3fc-200d-2640-fe0f",
      "1f646-1f3fd-200d-2640-fe0f",
      "1f646-1f3fe-200d-2640-fe0f",
      "1f646-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "information desk person",
      "information_desk_person"
    ],
    u: "1f481",
    v: [
      "1f481-1f3fb",
      "1f481-1f3fc",
      "1f481-1f3fd",
      "1f481-1f3fe",
      "1f481-1f3ff"
    ]
  },
  {
    n: [
      "man-tipping-hand"
    ],
    u: "1f481-200d-2642-fe0f",
    v: [
      "1f481-1f3fb-200d-2642-fe0f",
      "1f481-1f3fc-200d-2642-fe0f",
      "1f481-1f3fd-200d-2642-fe0f",
      "1f481-1f3fe-200d-2642-fe0f",
      "1f481-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-tipping-hand"
    ],
    u: "1f481-200d-2640-fe0f",
    v: [
      "1f481-1f3fb-200d-2640-fe0f",
      "1f481-1f3fc-200d-2640-fe0f",
      "1f481-1f3fd-200d-2640-fe0f",
      "1f481-1f3fe-200d-2640-fe0f",
      "1f481-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "happy person raising one hand",
      "raising_hand"
    ],
    u: "1f64b",
    v: [
      "1f64b-1f3fb",
      "1f64b-1f3fc",
      "1f64b-1f3fd",
      "1f64b-1f3fe",
      "1f64b-1f3ff"
    ]
  },
  {
    n: [
      "man-raising-hand"
    ],
    u: "1f64b-200d-2642-fe0f",
    v: [
      "1f64b-1f3fb-200d-2642-fe0f",
      "1f64b-1f3fc-200d-2642-fe0f",
      "1f64b-1f3fd-200d-2642-fe0f",
      "1f64b-1f3fe-200d-2642-fe0f",
      "1f64b-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-raising-hand"
    ],
    u: "1f64b-200d-2640-fe0f",
    v: [
      "1f64b-1f3fb-200d-2640-fe0f",
      "1f64b-1f3fc-200d-2640-fe0f",
      "1f64b-1f3fd-200d-2640-fe0f",
      "1f64b-1f3fe-200d-2640-fe0f",
      "1f64b-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "person bowing deeply",
      "bow"
    ],
    u: "1f647",
    v: [
      "1f647-1f3fb",
      "1f647-1f3fc",
      "1f647-1f3fd",
      "1f647-1f3fe",
      "1f647-1f3ff"
    ]
  },
  {
    n: [
      "man-bowing"
    ],
    u: "1f647-200d-2642-fe0f",
    v: [
      "1f647-1f3fb-200d-2642-fe0f",
      "1f647-1f3fc-200d-2642-fe0f",
      "1f647-1f3fd-200d-2642-fe0f",
      "1f647-1f3fe-200d-2642-fe0f",
      "1f647-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-bowing"
    ],
    u: "1f647-200d-2640-fe0f",
    v: [
      "1f647-1f3fb-200d-2640-fe0f",
      "1f647-1f3fc-200d-2640-fe0f",
      "1f647-1f3fd-200d-2640-fe0f",
      "1f647-1f3fe-200d-2640-fe0f",
      "1f647-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "face palm",
      "face_palm"
    ],
    u: "1f926",
    v: [
      "1f926-1f3fb",
      "1f926-1f3fc",
      "1f926-1f3fd",
      "1f926-1f3fe",
      "1f926-1f3ff"
    ]
  },
  {
    n: [
      "man-facepalming"
    ],
    u: "1f926-200d-2642-fe0f",
    v: [
      "1f926-1f3fb-200d-2642-fe0f",
      "1f926-1f3fc-200d-2642-fe0f",
      "1f926-1f3fd-200d-2642-fe0f",
      "1f926-1f3fe-200d-2642-fe0f",
      "1f926-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-facepalming"
    ],
    u: "1f926-200d-2640-fe0f",
    v: [
      "1f926-1f3fb-200d-2640-fe0f",
      "1f926-1f3fc-200d-2640-fe0f",
      "1f926-1f3fd-200d-2640-fe0f",
      "1f926-1f3fe-200d-2640-fe0f",
      "1f926-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "shrug"
    ],
    u: "1f937",
    v: [
      "1f937-1f3fb",
      "1f937-1f3fc",
      "1f937-1f3fd",
      "1f937-1f3fe",
      "1f937-1f3ff"
    ]
  },
  {
    n: [
      "man-shrugging"
    ],
    u: "1f937-200d-2642-fe0f",
    v: [
      "1f937-1f3fb-200d-2642-fe0f",
      "1f937-1f3fc-200d-2642-fe0f",
      "1f937-1f3fd-200d-2642-fe0f",
      "1f937-1f3fe-200d-2642-fe0f",
      "1f937-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-shrugging"
    ],
    u: "1f937-200d-2640-fe0f",
    v: [
      "1f937-1f3fb-200d-2640-fe0f",
      "1f937-1f3fc-200d-2640-fe0f",
      "1f937-1f3fd-200d-2640-fe0f",
      "1f937-1f3fe-200d-2640-fe0f",
      "1f937-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "face massage",
      "massage"
    ],
    u: "1f486",
    v: [
      "1f486-1f3fb",
      "1f486-1f3fc",
      "1f486-1f3fd",
      "1f486-1f3fe",
      "1f486-1f3ff"
    ]
  },
  {
    n: [
      "man-getting-massage"
    ],
    u: "1f486-200d-2642-fe0f",
    v: [
      "1f486-1f3fb-200d-2642-fe0f",
      "1f486-1f3fc-200d-2642-fe0f",
      "1f486-1f3fd-200d-2642-fe0f",
      "1f486-1f3fe-200d-2642-fe0f",
      "1f486-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-getting-massage"
    ],
    u: "1f486-200d-2640-fe0f",
    v: [
      "1f486-1f3fb-200d-2640-fe0f",
      "1f486-1f3fc-200d-2640-fe0f",
      "1f486-1f3fd-200d-2640-fe0f",
      "1f486-1f3fe-200d-2640-fe0f",
      "1f486-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "haircut"
    ],
    u: "1f487",
    v: [
      "1f487-1f3fb",
      "1f487-1f3fc",
      "1f487-1f3fd",
      "1f487-1f3fe",
      "1f487-1f3ff"
    ]
  },
  {
    n: [
      "man-getting-haircut"
    ],
    u: "1f487-200d-2642-fe0f",
    v: [
      "1f487-1f3fb-200d-2642-fe0f",
      "1f487-1f3fc-200d-2642-fe0f",
      "1f487-1f3fd-200d-2642-fe0f",
      "1f487-1f3fe-200d-2642-fe0f",
      "1f487-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-getting-haircut"
    ],
    u: "1f487-200d-2640-fe0f",
    v: [
      "1f487-1f3fb-200d-2640-fe0f",
      "1f487-1f3fc-200d-2640-fe0f",
      "1f487-1f3fd-200d-2640-fe0f",
      "1f487-1f3fe-200d-2640-fe0f",
      "1f487-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "pedestrian",
      "walking"
    ],
    u: "1f6b6",
    v: [
      "1f6b6-1f3fb",
      "1f6b6-1f3fc",
      "1f6b6-1f3fd",
      "1f6b6-1f3fe",
      "1f6b6-1f3ff"
    ]
  },
  {
    n: [
      "man-walking"
    ],
    u: "1f6b6-200d-2642-fe0f",
    v: [
      "1f6b6-1f3fb-200d-2642-fe0f",
      "1f6b6-1f3fc-200d-2642-fe0f",
      "1f6b6-1f3fd-200d-2642-fe0f",
      "1f6b6-1f3fe-200d-2642-fe0f",
      "1f6b6-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-walking"
    ],
    u: "1f6b6-200d-2640-fe0f",
    v: [
      "1f6b6-1f3fb-200d-2640-fe0f",
      "1f6b6-1f3fc-200d-2640-fe0f",
      "1f6b6-1f3fd-200d-2640-fe0f",
      "1f6b6-1f3fe-200d-2640-fe0f",
      "1f6b6-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "runner",
      "running"
    ],
    u: "1f3c3",
    v: [
      "1f3c3-1f3fb",
      "1f3c3-1f3fc",
      "1f3c3-1f3fd",
      "1f3c3-1f3fe",
      "1f3c3-1f3ff"
    ]
  },
  {
    n: [
      "man-running"
    ],
    u: "1f3c3-200d-2642-fe0f",
    v: [
      "1f3c3-1f3fb-200d-2642-fe0f",
      "1f3c3-1f3fc-200d-2642-fe0f",
      "1f3c3-1f3fd-200d-2642-fe0f",
      "1f3c3-1f3fe-200d-2642-fe0f",
      "1f3c3-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-running"
    ],
    u: "1f3c3-200d-2640-fe0f",
    v: [
      "1f3c3-1f3fb-200d-2640-fe0f",
      "1f3c3-1f3fc-200d-2640-fe0f",
      "1f3c3-1f3fd-200d-2640-fe0f",
      "1f3c3-1f3fe-200d-2640-fe0f",
      "1f3c3-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "dancer"
    ],
    u: "1f483",
    v: [
      "1f483-1f3fb",
      "1f483-1f3fc",
      "1f483-1f3fd",
      "1f483-1f3fe",
      "1f483-1f3ff"
    ]
  },
  {
    n: [
      "man dancing",
      "man_dancing"
    ],
    u: "1f57a",
    v: [
      "1f57a-1f3fb",
      "1f57a-1f3fc",
      "1f57a-1f3fd",
      "1f57a-1f3fe",
      "1f57a-1f3ff"
    ]
  },
  {
    n: [
      "woman with bunny ears",
      "dancers"
    ],
    u: "1f46f"
  },
  {
    n: [
      "man-with-bunny-ears-partying"
    ],
    u: "1f46f-200d-2642-fe0f"
  },
  {
    n: [
      "woman-with-bunny-ears-partying"
    ],
    u: "1f46f-200d-2640-fe0f"
  },
  {
    n: [
      "person in steamy room",
      "person_in_steamy_room"
    ],
    u: "1f9d6",
    v: [
      "1f9d6-1f3fb",
      "1f9d6-1f3fc",
      "1f9d6-1f3fd",
      "1f9d6-1f3fe",
      "1f9d6-1f3ff"
    ]
  },
  {
    n: [
      "woman_in_steamy_room"
    ],
    u: "1f9d6-200d-2640-fe0f",
    v: [
      "1f9d6-1f3fb-200d-2640-fe0f",
      "1f9d6-1f3fc-200d-2640-fe0f",
      "1f9d6-1f3fd-200d-2640-fe0f",
      "1f9d6-1f3fe-200d-2640-fe0f",
      "1f9d6-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "man_in_steamy_room"
    ],
    u: "1f9d6-200d-2642-fe0f",
    v: [
      "1f9d6-1f3fb-200d-2642-fe0f",
      "1f9d6-1f3fc-200d-2642-fe0f",
      "1f9d6-1f3fd-200d-2642-fe0f",
      "1f9d6-1f3fe-200d-2642-fe0f",
      "1f9d6-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "person climbing",
      "person_climbing"
    ],
    u: "1f9d7",
    v: [
      "1f9d7-1f3fb",
      "1f9d7-1f3fc",
      "1f9d7-1f3fd",
      "1f9d7-1f3fe",
      "1f9d7-1f3ff"
    ]
  },
  {
    n: [
      "woman_climbing"
    ],
    u: "1f9d7-200d-2640-fe0f",
    v: [
      "1f9d7-1f3fb-200d-2640-fe0f",
      "1f9d7-1f3fc-200d-2640-fe0f",
      "1f9d7-1f3fd-200d-2640-fe0f",
      "1f9d7-1f3fe-200d-2640-fe0f",
      "1f9d7-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "man_climbing"
    ],
    u: "1f9d7-200d-2642-fe0f",
    v: [
      "1f9d7-1f3fb-200d-2642-fe0f",
      "1f9d7-1f3fc-200d-2642-fe0f",
      "1f9d7-1f3fd-200d-2642-fe0f",
      "1f9d7-1f3fe-200d-2642-fe0f",
      "1f9d7-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "person in lotus position",
      "person_in_lotus_position"
    ],
    u: "1f9d8",
    v: [
      "1f9d8-1f3fb",
      "1f9d8-1f3fc",
      "1f9d8-1f3fd",
      "1f9d8-1f3fe",
      "1f9d8-1f3ff"
    ]
  },
  {
    n: [
      "woman_in_lotus_position"
    ],
    u: "1f9d8-200d-2640-fe0f",
    v: [
      "1f9d8-1f3fb-200d-2640-fe0f",
      "1f9d8-1f3fc-200d-2640-fe0f",
      "1f9d8-1f3fd-200d-2640-fe0f",
      "1f9d8-1f3fe-200d-2640-fe0f",
      "1f9d8-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "man_in_lotus_position"
    ],
    u: "1f9d8-200d-2642-fe0f",
    v: [
      "1f9d8-1f3fb-200d-2642-fe0f",
      "1f9d8-1f3fc-200d-2642-fe0f",
      "1f9d8-1f3fd-200d-2642-fe0f",
      "1f9d8-1f3fe-200d-2642-fe0f",
      "1f9d8-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "bath"
    ],
    u: "1f6c0",
    v: [
      "1f6c0-1f3fb",
      "1f6c0-1f3fc",
      "1f6c0-1f3fd",
      "1f6c0-1f3fe",
      "1f6c0-1f3ff"
    ]
  },
  {
    n: [
      "sleeping accommodation",
      "sleeping_accommodation"
    ],
    u: "1f6cc",
    v: [
      "1f6cc-1f3fb",
      "1f6cc-1f3fc",
      "1f6cc-1f3fd",
      "1f6cc-1f3fe",
      "1f6cc-1f3ff"
    ]
  },
  {
    n: [
      "man_in_business_suit_levitating"
    ],
    u: "1f574-fe0f",
    v: [
      "1f574-1f3fb",
      "1f574-1f3fc",
      "1f574-1f3fd",
      "1f574-1f3fe",
      "1f574-1f3ff"
    ]
  },
  {
    n: [
      "speaking_head_in_silhouette"
    ],
    u: "1f5e3-fe0f"
  },
  {
    n: [
      "bust in silhouette",
      "bust_in_silhouette"
    ],
    u: "1f464"
  },
  {
    n: [
      "busts in silhouette",
      "busts_in_silhouette"
    ],
    u: "1f465"
  },
  {
    n: [
      "fencer"
    ],
    u: "1f93a"
  },
  {
    n: [
      "horse racing",
      "horse_racing"
    ],
    u: "1f3c7",
    v: [
      "1f3c7-1f3fb",
      "1f3c7-1f3fc",
      "1f3c7-1f3fd",
      "1f3c7-1f3fe",
      "1f3c7-1f3ff"
    ]
  },
  {
    n: [
      "skier"
    ],
    u: "26f7-fe0f"
  },
  {
    n: [
      "snowboarder"
    ],
    u: "1f3c2",
    v: [
      "1f3c2-1f3fb",
      "1f3c2-1f3fc",
      "1f3c2-1f3fd",
      "1f3c2-1f3fe",
      "1f3c2-1f3ff"
    ]
  },
  {
    n: [
      "golfer"
    ],
    u: "1f3cc-fe0f",
    v: [
      "1f3cc-1f3fb",
      "1f3cc-1f3fc",
      "1f3cc-1f3fd",
      "1f3cc-1f3fe",
      "1f3cc-1f3ff"
    ]
  },
  {
    n: [
      "man-golfing"
    ],
    u: "1f3cc-fe0f-200d-2642-fe0f",
    v: [
      "1f3cc-1f3fb-200d-2642-fe0f",
      "1f3cc-1f3fc-200d-2642-fe0f",
      "1f3cc-1f3fd-200d-2642-fe0f",
      "1f3cc-1f3fe-200d-2642-fe0f",
      "1f3cc-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-golfing"
    ],
    u: "1f3cc-fe0f-200d-2640-fe0f",
    v: [
      "1f3cc-1f3fb-200d-2640-fe0f",
      "1f3cc-1f3fc-200d-2640-fe0f",
      "1f3cc-1f3fd-200d-2640-fe0f",
      "1f3cc-1f3fe-200d-2640-fe0f",
      "1f3cc-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "surfer"
    ],
    u: "1f3c4",
    v: [
      "1f3c4-1f3fb",
      "1f3c4-1f3fc",
      "1f3c4-1f3fd",
      "1f3c4-1f3fe",
      "1f3c4-1f3ff"
    ]
  },
  {
    n: [
      "man-surfing"
    ],
    u: "1f3c4-200d-2642-fe0f",
    v: [
      "1f3c4-1f3fb-200d-2642-fe0f",
      "1f3c4-1f3fc-200d-2642-fe0f",
      "1f3c4-1f3fd-200d-2642-fe0f",
      "1f3c4-1f3fe-200d-2642-fe0f",
      "1f3c4-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-surfing"
    ],
    u: "1f3c4-200d-2640-fe0f",
    v: [
      "1f3c4-1f3fb-200d-2640-fe0f",
      "1f3c4-1f3fc-200d-2640-fe0f",
      "1f3c4-1f3fd-200d-2640-fe0f",
      "1f3c4-1f3fe-200d-2640-fe0f",
      "1f3c4-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "rowboat"
    ],
    u: "1f6a3",
    v: [
      "1f6a3-1f3fb",
      "1f6a3-1f3fc",
      "1f6a3-1f3fd",
      "1f6a3-1f3fe",
      "1f6a3-1f3ff"
    ]
  },
  {
    n: [
      "man-rowing-boat"
    ],
    u: "1f6a3-200d-2642-fe0f",
    v: [
      "1f6a3-1f3fb-200d-2642-fe0f",
      "1f6a3-1f3fc-200d-2642-fe0f",
      "1f6a3-1f3fd-200d-2642-fe0f",
      "1f6a3-1f3fe-200d-2642-fe0f",
      "1f6a3-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-rowing-boat"
    ],
    u: "1f6a3-200d-2640-fe0f",
    v: [
      "1f6a3-1f3fb-200d-2640-fe0f",
      "1f6a3-1f3fc-200d-2640-fe0f",
      "1f6a3-1f3fd-200d-2640-fe0f",
      "1f6a3-1f3fe-200d-2640-fe0f",
      "1f6a3-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "swimmer"
    ],
    u: "1f3ca",
    v: [
      "1f3ca-1f3fb",
      "1f3ca-1f3fc",
      "1f3ca-1f3fd",
      "1f3ca-1f3fe",
      "1f3ca-1f3ff"
    ]
  },
  {
    n: [
      "man-swimming"
    ],
    u: "1f3ca-200d-2642-fe0f",
    v: [
      "1f3ca-1f3fb-200d-2642-fe0f",
      "1f3ca-1f3fc-200d-2642-fe0f",
      "1f3ca-1f3fd-200d-2642-fe0f",
      "1f3ca-1f3fe-200d-2642-fe0f",
      "1f3ca-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-swimming"
    ],
    u: "1f3ca-200d-2640-fe0f",
    v: [
      "1f3ca-1f3fb-200d-2640-fe0f",
      "1f3ca-1f3fc-200d-2640-fe0f",
      "1f3ca-1f3fd-200d-2640-fe0f",
      "1f3ca-1f3fe-200d-2640-fe0f",
      "1f3ca-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "person_with_ball"
    ],
    u: "26f9-fe0f",
    v: [
      "26f9-1f3fb",
      "26f9-1f3fc",
      "26f9-1f3fd",
      "26f9-1f3fe",
      "26f9-1f3ff"
    ]
  },
  {
    n: [
      "man-bouncing-ball"
    ],
    u: "26f9-fe0f-200d-2642-fe0f",
    v: [
      "26f9-1f3fb-200d-2642-fe0f",
      "26f9-1f3fc-200d-2642-fe0f",
      "26f9-1f3fd-200d-2642-fe0f",
      "26f9-1f3fe-200d-2642-fe0f",
      "26f9-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-bouncing-ball"
    ],
    u: "26f9-fe0f-200d-2640-fe0f",
    v: [
      "26f9-1f3fb-200d-2640-fe0f",
      "26f9-1f3fc-200d-2640-fe0f",
      "26f9-1f3fd-200d-2640-fe0f",
      "26f9-1f3fe-200d-2640-fe0f",
      "26f9-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "weight_lifter"
    ],
    u: "1f3cb-fe0f",
    v: [
      "1f3cb-1f3fb",
      "1f3cb-1f3fc",
      "1f3cb-1f3fd",
      "1f3cb-1f3fe",
      "1f3cb-1f3ff"
    ]
  },
  {
    n: [
      "man-lifting-weights"
    ],
    u: "1f3cb-fe0f-200d-2642-fe0f",
    v: [
      "1f3cb-1f3fb-200d-2642-fe0f",
      "1f3cb-1f3fc-200d-2642-fe0f",
      "1f3cb-1f3fd-200d-2642-fe0f",
      "1f3cb-1f3fe-200d-2642-fe0f",
      "1f3cb-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-lifting-weights"
    ],
    u: "1f3cb-fe0f-200d-2640-fe0f",
    v: [
      "1f3cb-1f3fb-200d-2640-fe0f",
      "1f3cb-1f3fc-200d-2640-fe0f",
      "1f3cb-1f3fd-200d-2640-fe0f",
      "1f3cb-1f3fe-200d-2640-fe0f",
      "1f3cb-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "bicyclist"
    ],
    u: "1f6b4",
    v: [
      "1f6b4-1f3fb",
      "1f6b4-1f3fc",
      "1f6b4-1f3fd",
      "1f6b4-1f3fe",
      "1f6b4-1f3ff"
    ]
  },
  {
    n: [
      "man-biking"
    ],
    u: "1f6b4-200d-2642-fe0f",
    v: [
      "1f6b4-1f3fb-200d-2642-fe0f",
      "1f6b4-1f3fc-200d-2642-fe0f",
      "1f6b4-1f3fd-200d-2642-fe0f",
      "1f6b4-1f3fe-200d-2642-fe0f",
      "1f6b4-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-biking"
    ],
    u: "1f6b4-200d-2640-fe0f",
    v: [
      "1f6b4-1f3fb-200d-2640-fe0f",
      "1f6b4-1f3fc-200d-2640-fe0f",
      "1f6b4-1f3fd-200d-2640-fe0f",
      "1f6b4-1f3fe-200d-2640-fe0f",
      "1f6b4-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "mountain bicyclist",
      "mountain_bicyclist"
    ],
    u: "1f6b5",
    v: [
      "1f6b5-1f3fb",
      "1f6b5-1f3fc",
      "1f6b5-1f3fd",
      "1f6b5-1f3fe",
      "1f6b5-1f3ff"
    ]
  },
  {
    n: [
      "man-mountain-biking"
    ],
    u: "1f6b5-200d-2642-fe0f",
    v: [
      "1f6b5-1f3fb-200d-2642-fe0f",
      "1f6b5-1f3fc-200d-2642-fe0f",
      "1f6b5-1f3fd-200d-2642-fe0f",
      "1f6b5-1f3fe-200d-2642-fe0f",
      "1f6b5-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-mountain-biking"
    ],
    u: "1f6b5-200d-2640-fe0f",
    v: [
      "1f6b5-1f3fb-200d-2640-fe0f",
      "1f6b5-1f3fc-200d-2640-fe0f",
      "1f6b5-1f3fd-200d-2640-fe0f",
      "1f6b5-1f3fe-200d-2640-fe0f",
      "1f6b5-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "racing_car"
    ],
    u: "1f3ce-fe0f"
  },
  {
    n: [
      "racing_motorcycle"
    ],
    u: "1f3cd-fe0f"
  },
  {
    n: [
      "person doing cartwheel",
      "person_doing_cartwheel"
    ],
    u: "1f938",
    v: [
      "1f938-1f3fb",
      "1f938-1f3fc",
      "1f938-1f3fd",
      "1f938-1f3fe",
      "1f938-1f3ff"
    ]
  },
  {
    n: [
      "man-cartwheeling"
    ],
    u: "1f938-200d-2642-fe0f",
    v: [
      "1f938-1f3fb-200d-2642-fe0f",
      "1f938-1f3fc-200d-2642-fe0f",
      "1f938-1f3fd-200d-2642-fe0f",
      "1f938-1f3fe-200d-2642-fe0f",
      "1f938-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-cartwheeling"
    ],
    u: "1f938-200d-2640-fe0f",
    v: [
      "1f938-1f3fb-200d-2640-fe0f",
      "1f938-1f3fc-200d-2640-fe0f",
      "1f938-1f3fd-200d-2640-fe0f",
      "1f938-1f3fe-200d-2640-fe0f",
      "1f938-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "wrestlers"
    ],
    u: "1f93c"
  },
  {
    n: [
      "man-wrestling"
    ],
    u: "1f93c-200d-2642-fe0f"
  },
  {
    n: [
      "woman-wrestling"
    ],
    u: "1f93c-200d-2640-fe0f"
  },
  {
    n: [
      "water polo",
      "water_polo"
    ],
    u: "1f93d",
    v: [
      "1f93d-1f3fb",
      "1f93d-1f3fc",
      "1f93d-1f3fd",
      "1f93d-1f3fe",
      "1f93d-1f3ff"
    ]
  },
  {
    n: [
      "man-playing-water-polo"
    ],
    u: "1f93d-200d-2642-fe0f",
    v: [
      "1f93d-1f3fb-200d-2642-fe0f",
      "1f93d-1f3fc-200d-2642-fe0f",
      "1f93d-1f3fd-200d-2642-fe0f",
      "1f93d-1f3fe-200d-2642-fe0f",
      "1f93d-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-playing-water-polo"
    ],
    u: "1f93d-200d-2640-fe0f",
    v: [
      "1f93d-1f3fb-200d-2640-fe0f",
      "1f93d-1f3fc-200d-2640-fe0f",
      "1f93d-1f3fd-200d-2640-fe0f",
      "1f93d-1f3fe-200d-2640-fe0f",
      "1f93d-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "handball"
    ],
    u: "1f93e",
    v: [
      "1f93e-1f3fb",
      "1f93e-1f3fc",
      "1f93e-1f3fd",
      "1f93e-1f3fe",
      "1f93e-1f3ff"
    ]
  },
  {
    n: [
      "man-playing-handball"
    ],
    u: "1f93e-200d-2642-fe0f",
    v: [
      "1f93e-1f3fb-200d-2642-fe0f",
      "1f93e-1f3fc-200d-2642-fe0f",
      "1f93e-1f3fd-200d-2642-fe0f",
      "1f93e-1f3fe-200d-2642-fe0f",
      "1f93e-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-playing-handball"
    ],
    u: "1f93e-200d-2640-fe0f",
    v: [
      "1f93e-1f3fb-200d-2640-fe0f",
      "1f93e-1f3fc-200d-2640-fe0f",
      "1f93e-1f3fd-200d-2640-fe0f",
      "1f93e-1f3fe-200d-2640-fe0f",
      "1f93e-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "juggling"
    ],
    u: "1f939",
    v: [
      "1f939-1f3fb",
      "1f939-1f3fc",
      "1f939-1f3fd",
      "1f939-1f3fe",
      "1f939-1f3ff"
    ]
  },
  {
    n: [
      "man-juggling"
    ],
    u: "1f939-200d-2642-fe0f",
    v: [
      "1f939-1f3fb-200d-2642-fe0f",
      "1f939-1f3fc-200d-2642-fe0f",
      "1f939-1f3fd-200d-2642-fe0f",
      "1f939-1f3fe-200d-2642-fe0f",
      "1f939-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-juggling"
    ],
    u: "1f939-200d-2640-fe0f",
    v: [
      "1f939-1f3fb-200d-2640-fe0f",
      "1f939-1f3fc-200d-2640-fe0f",
      "1f939-1f3fd-200d-2640-fe0f",
      "1f939-1f3fe-200d-2640-fe0f",
      "1f939-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "man and woman holding hands",
      "couple",
      "man_and_woman_holding_hands"
    ],
    u: "1f46b"
  },
  {
    n: [
      "two men holding hands",
      "two_men_holding_hands"
    ],
    u: "1f46c"
  },
  {
    n: [
      "two women holding hands",
      "two_women_holding_hands"
    ],
    u: "1f46d"
  },
  {
    n: [
      "kiss",
      "couplekiss"
    ],
    u: "1f48f"
  },
  {
    n: [
      "woman-kiss-man"
    ],
    u: "1f469-200d-2764-fe0f-200d-1f48b-200d-1f468"
  },
  {
    n: [
      "man-kiss-man"
    ],
    u: "1f468-200d-2764-fe0f-200d-1f48b-200d-1f468"
  },
  {
    n: [
      "woman-kiss-woman"
    ],
    u: "1f469-200d-2764-fe0f-200d-1f48b-200d-1f469"
  },
  {
    n: [
      "couple with heart",
      "couple_with_heart"
    ],
    u: "1f491"
  },
  {
    n: [
      "woman-heart-man"
    ],
    u: "1f469-200d-2764-fe0f-200d-1f468"
  },
  {
    n: [
      "man-heart-man"
    ],
    u: "1f468-200d-2764-fe0f-200d-1f468"
  },
  {
    n: [
      "woman-heart-woman"
    ],
    u: "1f469-200d-2764-fe0f-200d-1f469"
  },
  {
    n: [
      "family",
      "man-woman-boy"
    ],
    u: "1f46a"
  },
  {
    n: [
      "man-woman-boy",
      "family"
    ],
    u: "1f468-200d-1f469-200d-1f466"
  },
  {
    n: [
      "man-woman-girl"
    ],
    u: "1f468-200d-1f469-200d-1f467"
  },
  {
    n: [
      "man-woman-girl-boy"
    ],
    u: "1f468-200d-1f469-200d-1f467-200d-1f466"
  },
  {
    n: [
      "man-woman-boy-boy"
    ],
    u: "1f468-200d-1f469-200d-1f466-200d-1f466"
  },
  {
    n: [
      "man-woman-girl-girl"
    ],
    u: "1f468-200d-1f469-200d-1f467-200d-1f467"
  },
  {
    n: [
      "man-man-boy"
    ],
    u: "1f468-200d-1f468-200d-1f466"
  },
  {
    n: [
      "man-man-girl"
    ],
    u: "1f468-200d-1f468-200d-1f467"
  },
  {
    n: [
      "man-man-girl-boy"
    ],
    u: "1f468-200d-1f468-200d-1f467-200d-1f466"
  },
  {
    n: [
      "man-man-boy-boy"
    ],
    u: "1f468-200d-1f468-200d-1f466-200d-1f466"
  },
  {
    n: [
      "man-man-girl-girl"
    ],
    u: "1f468-200d-1f468-200d-1f467-200d-1f467"
  },
  {
    n: [
      "woman-woman-boy"
    ],
    u: "1f469-200d-1f469-200d-1f466"
  },
  {
    n: [
      "woman-woman-girl"
    ],
    u: "1f469-200d-1f469-200d-1f467"
  },
  {
    n: [
      "woman-woman-girl-boy"
    ],
    u: "1f469-200d-1f469-200d-1f467-200d-1f466"
  },
  {
    n: [
      "woman-woman-boy-boy"
    ],
    u: "1f469-200d-1f469-200d-1f466-200d-1f466"
  },
  {
    n: [
      "woman-woman-girl-girl"
    ],
    u: "1f469-200d-1f469-200d-1f467-200d-1f467"
  },
  {
    n: [
      "man-boy"
    ],
    u: "1f468-200d-1f466"
  },
  {
    n: [
      "man-boy-boy"
    ],
    u: "1f468-200d-1f466-200d-1f466"
  },
  {
    n: [
      "man-girl"
    ],
    u: "1f468-200d-1f467"
  },
  {
    n: [
      "man-girl-boy"
    ],
    u: "1f468-200d-1f467-200d-1f466"
  },
  {
    n: [
      "man-girl-girl"
    ],
    u: "1f468-200d-1f467-200d-1f467"
  },
  {
    n: [
      "woman-boy"
    ],
    u: "1f469-200d-1f466"
  },
  {
    n: [
      "woman-boy-boy"
    ],
    u: "1f469-200d-1f466-200d-1f466"
  },
  {
    n: [
      "woman-girl"
    ],
    u: "1f469-200d-1f467"
  },
  {
    n: [
      "woman-girl-boy"
    ],
    u: "1f469-200d-1f467-200d-1f466"
  },
  {
    n: [
      "woman-girl-girl"
    ],
    u: "1f469-200d-1f467-200d-1f467"
  },
  {
    n: [
      "selfie"
    ],
    u: "1f933",
    v: [
      "1f933-1f3fb",
      "1f933-1f3fc",
      "1f933-1f3fd",
      "1f933-1f3fe",
      "1f933-1f3ff"
    ]
  },
  {
    n: [
      "flexed biceps",
      "muscle"
    ],
    u: "1f4aa",
    v: [
      "1f4aa-1f3fb",
      "1f4aa-1f3fc",
      "1f4aa-1f3fd",
      "1f4aa-1f3fe",
      "1f4aa-1f3ff"
    ]
  },
  {
    n: [
      "white left pointing backhand index",
      "point_left"
    ],
    u: "1f448",
    v: [
      "1f448-1f3fb",
      "1f448-1f3fc",
      "1f448-1f3fd",
      "1f448-1f3fe",
      "1f448-1f3ff"
    ]
  },
  {
    n: [
      "white right pointing backhand index",
      "point_right"
    ],
    u: "1f449",
    v: [
      "1f449-1f3fb",
      "1f449-1f3fc",
      "1f449-1f3fd",
      "1f449-1f3fe",
      "1f449-1f3ff"
    ]
  },
  {
    n: [
      "white up pointing index",
      "point_up"
    ],
    u: "261d-fe0f",
    v: [
      "261d-1f3fb",
      "261d-1f3fc",
      "261d-1f3fd",
      "261d-1f3fe",
      "261d-1f3ff"
    ]
  },
  {
    n: [
      "white up pointing backhand index",
      "point_up_2"
    ],
    u: "1f446",
    v: [
      "1f446-1f3fb",
      "1f446-1f3fc",
      "1f446-1f3fd",
      "1f446-1f3fe",
      "1f446-1f3ff"
    ]
  },
  {
    n: [
      "reversed hand with middle finger extended",
      "middle_finger",
      "reversed_hand_with_middle_finger_extended"
    ],
    u: "1f595",
    v: [
      "1f595-1f3fb",
      "1f595-1f3fc",
      "1f595-1f3fd",
      "1f595-1f3fe",
      "1f595-1f3ff"
    ]
  },
  {
    n: [
      "white down pointing backhand index",
      "point_down"
    ],
    u: "1f447",
    v: [
      "1f447-1f3fb",
      "1f447-1f3fc",
      "1f447-1f3fd",
      "1f447-1f3fe",
      "1f447-1f3ff"
    ]
  },
  {
    n: [
      "victory hand",
      "v"
    ],
    u: "270c-fe0f",
    v: [
      "270c-1f3fb",
      "270c-1f3fc",
      "270c-1f3fd",
      "270c-1f3fe",
      "270c-1f3ff"
    ]
  },
  {
    n: [
      "hand with index and middle fingers crossed",
      "crossed_fingers",
      "hand_with_index_and_middle_fingers_crossed"
    ],
    u: "1f91e",
    v: [
      "1f91e-1f3fb",
      "1f91e-1f3fc",
      "1f91e-1f3fd",
      "1f91e-1f3fe",
      "1f91e-1f3ff"
    ]
  },
  {
    n: [
      "raised hand with part between middle and ring fingers",
      "spock-hand"
    ],
    u: "1f596",
    v: [
      "1f596-1f3fb",
      "1f596-1f3fc",
      "1f596-1f3fd",
      "1f596-1f3fe",
      "1f596-1f3ff"
    ]
  },
  {
    n: [
      "sign of the horns",
      "the_horns",
      "sign_of_the_horns"
    ],
    u: "1f918",
    v: [
      "1f918-1f3fb",
      "1f918-1f3fc",
      "1f918-1f3fd",
      "1f918-1f3fe",
      "1f918-1f3ff"
    ]
  },
  {
    n: [
      "call me hand",
      "call_me_hand"
    ],
    u: "1f919",
    v: [
      "1f919-1f3fb",
      "1f919-1f3fc",
      "1f919-1f3fd",
      "1f919-1f3fe",
      "1f919-1f3ff"
    ]
  },
  {
    n: [
      "raised_hand_with_fingers_splayed"
    ],
    u: "1f590-fe0f",
    v: [
      "1f590-1f3fb",
      "1f590-1f3fc",
      "1f590-1f3fd",
      "1f590-1f3fe",
      "1f590-1f3ff"
    ]
  },
  {
    n: [
      "raised hand",
      "hand",
      "raised_hand"
    ],
    u: "270b",
    v: [
      "270b-1f3fb",
      "270b-1f3fc",
      "270b-1f3fd",
      "270b-1f3fe",
      "270b-1f3ff"
    ]
  },
  {
    n: [
      "ok hand sign",
      "ok_hand"
    ],
    u: "1f44c",
    v: [
      "1f44c-1f3fb",
      "1f44c-1f3fc",
      "1f44c-1f3fd",
      "1f44c-1f3fe",
      "1f44c-1f3ff"
    ]
  },
  {
    n: [
      "thumbs up sign",
      "+1",
      "thumbsup"
    ],
    u: "1f44d",
    v: [
      "1f44d-1f3fb",
      "1f44d-1f3fc",
      "1f44d-1f3fd",
      "1f44d-1f3fe",
      "1f44d-1f3ff"
    ]
  },
  {
    n: [
      "thumbs down sign",
      "-1",
      "thumbsdown"
    ],
    u: "1f44e",
    v: [
      "1f44e-1f3fb",
      "1f44e-1f3fc",
      "1f44e-1f3fd",
      "1f44e-1f3fe",
      "1f44e-1f3ff"
    ]
  },
  {
    n: [
      "raised fist",
      "fist"
    ],
    u: "270a",
    v: [
      "270a-1f3fb",
      "270a-1f3fc",
      "270a-1f3fd",
      "270a-1f3fe",
      "270a-1f3ff"
    ]
  },
  {
    n: [
      "fisted hand sign",
      "facepunch",
      "punch"
    ],
    u: "1f44a",
    v: [
      "1f44a-1f3fb",
      "1f44a-1f3fc",
      "1f44a-1f3fd",
      "1f44a-1f3fe",
      "1f44a-1f3ff"
    ]
  },
  {
    n: [
      "left-facing fist",
      "left-facing_fist"
    ],
    u: "1f91b",
    v: [
      "1f91b-1f3fb",
      "1f91b-1f3fc",
      "1f91b-1f3fd",
      "1f91b-1f3fe",
      "1f91b-1f3ff"
    ]
  },
  {
    n: [
      "right-facing fist",
      "right-facing_fist"
    ],
    u: "1f91c",
    v: [
      "1f91c-1f3fb",
      "1f91c-1f3fc",
      "1f91c-1f3fd",
      "1f91c-1f3fe",
      "1f91c-1f3ff"
    ]
  },
  {
    n: [
      "raised back of hand",
      "raised_back_of_hand"
    ],
    u: "1f91a",
    v: [
      "1f91a-1f3fb",
      "1f91a-1f3fc",
      "1f91a-1f3fd",
      "1f91a-1f3fe",
      "1f91a-1f3ff"
    ]
  },
  {
    n: [
      "waving hand sign",
      "wave"
    ],
    u: "1f44b",
    v: [
      "1f44b-1f3fb",
      "1f44b-1f3fc",
      "1f44b-1f3fd",
      "1f44b-1f3fe",
      "1f44b-1f3ff"
    ]
  },
  {
    n: [
      "i love you hand sign",
      "i_love_you_hand_sign"
    ],
    u: "1f91f",
    v: [
      "1f91f-1f3fb",
      "1f91f-1f3fc",
      "1f91f-1f3fd",
      "1f91f-1f3fe",
      "1f91f-1f3ff"
    ]
  },
  {
    n: [
      "writing_hand"
    ],
    u: "270d-fe0f",
    v: [
      "270d-1f3fb",
      "270d-1f3fc",
      "270d-1f3fd",
      "270d-1f3fe",
      "270d-1f3ff"
    ]
  },
  {
    n: [
      "clapping hands sign",
      "clap"
    ],
    u: "1f44f",
    v: [
      "1f44f-1f3fb",
      "1f44f-1f3fc",
      "1f44f-1f3fd",
      "1f44f-1f3fe",
      "1f44f-1f3ff"
    ]
  },
  {
    n: [
      "open hands sign",
      "open_hands"
    ],
    u: "1f450",
    v: [
      "1f450-1f3fb",
      "1f450-1f3fc",
      "1f450-1f3fd",
      "1f450-1f3fe",
      "1f450-1f3ff"
    ]
  },
  {
    n: [
      "person raising both hands in celebration",
      "raised_hands"
    ],
    u: "1f64c",
    v: [
      "1f64c-1f3fb",
      "1f64c-1f3fc",
      "1f64c-1f3fd",
      "1f64c-1f3fe",
      "1f64c-1f3ff"
    ]
  },
  {
    n: [
      "palms up together",
      "palms_up_together"
    ],
    u: "1f932",
    v: [
      "1f932-1f3fb",
      "1f932-1f3fc",
      "1f932-1f3fd",
      "1f932-1f3fe",
      "1f932-1f3ff"
    ]
  },
  {
    n: [
      "person with folded hands",
      "pray"
    ],
    u: "1f64f",
    v: [
      "1f64f-1f3fb",
      "1f64f-1f3fc",
      "1f64f-1f3fd",
      "1f64f-1f3fe",
      "1f64f-1f3ff"
    ]
  },
  {
    n: [
      "handshake"
    ],
    u: "1f91d"
  },
  {
    n: [
      "nail polish",
      "nail_care"
    ],
    u: "1f485",
    v: [
      "1f485-1f3fb",
      "1f485-1f3fc",
      "1f485-1f3fd",
      "1f485-1f3fe",
      "1f485-1f3ff"
    ]
  },
  {
    n: [
      "ear"
    ],
    u: "1f442",
    v: [
      "1f442-1f3fb",
      "1f442-1f3fc",
      "1f442-1f3fd",
      "1f442-1f3fe",
      "1f442-1f3ff"
    ]
  },
  {
    n: [
      "nose"
    ],
    u: "1f443",
    v: [
      "1f443-1f3fb",
      "1f443-1f3fc",
      "1f443-1f3fd",
      "1f443-1f3fe",
      "1f443-1f3ff"
    ]
  },
  {
    n: [
      "footprints"
    ],
    u: "1f463"
  },
  {
    n: [
      "eyes"
    ],
    u: "1f440"
  },
  {
    n: [
      "eye"
    ],
    u: "1f441-fe0f"
  },
  {
    n: [
      "eye-in-speech-bubble"
    ],
    u: "1f441-fe0f-200d-1f5e8-fe0f"
  },
  {
    n: [
      "brain"
    ],
    u: "1f9e0"
  },
  {
    n: [
      "tongue"
    ],
    u: "1f445"
  },
  {
    n: [
      "mouth",
      "lips"
    ],
    u: "1f444"
  },
  {
    n: [
      "kiss mark",
      "kiss"
    ],
    u: "1f48b"
  },
  {
    n: [
      "heart with arrow",
      "cupid"
    ],
    u: "1f498"
  },
  {
    n: [
      "heavy black heart",
      "heart"
    ],
    u: "2764-fe0f"
  },
  {
    n: [
      "beating heart",
      "heartbeat"
    ],
    u: "1f493"
  },
  {
    n: [
      "broken heart",
      "broken_heart"
    ],
    u: "1f494"
  },
  {
    n: [
      "two hearts",
      "two_hearts"
    ],
    u: "1f495"
  },
  {
    n: [
      "sparkling heart",
      "sparkling_heart"
    ],
    u: "1f496"
  },
  {
    n: [
      "growing heart",
      "heartpulse"
    ],
    u: "1f497"
  },
  {
    n: [
      "blue heart",
      "blue_heart"
    ],
    u: "1f499"
  },
  {
    n: [
      "green heart",
      "green_heart"
    ],
    u: "1f49a"
  },
  {
    n: [
      "yellow heart",
      "yellow_heart"
    ],
    u: "1f49b"
  },
  {
    n: [
      "orange heart",
      "orange_heart"
    ],
    u: "1f9e1"
  },
  {
    n: [
      "purple heart",
      "purple_heart"
    ],
    u: "1f49c"
  },
  {
    n: [
      "black heart",
      "black_heart"
    ],
    u: "1f5a4"
  },
  {
    n: [
      "heart with ribbon",
      "gift_heart"
    ],
    u: "1f49d"
  },
  {
    n: [
      "revolving hearts",
      "revolving_hearts"
    ],
    u: "1f49e"
  },
  {
    n: [
      "heart decoration",
      "heart_decoration"
    ],
    u: "1f49f"
  },
  {
    n: [
      "heavy_heart_exclamation_mark_ornament"
    ],
    u: "2763-fe0f"
  },
  {
    n: [
      "love letter",
      "love_letter"
    ],
    u: "1f48c"
  },
  {
    n: [
      "sleeping symbol",
      "zzz"
    ],
    u: "1f4a4"
  },
  {
    n: [
      "anger symbol",
      "anger"
    ],
    u: "1f4a2"
  },
  {
    n: [
      "bomb"
    ],
    u: "1f4a3"
  },
  {
    n: [
      "collision symbol",
      "boom",
      "collision"
    ],
    u: "1f4a5"
  },
  {
    n: [
      "splashing sweat symbol",
      "sweat_drops"
    ],
    u: "1f4a6"
  },
  {
    n: [
      "dash symbol",
      "dash"
    ],
    u: "1f4a8"
  },
  {
    n: [
      "dizzy symbol",
      "dizzy"
    ],
    u: "1f4ab"
  },
  {
    n: [
      "speech balloon",
      "speech_balloon"
    ],
    u: "1f4ac"
  },
  {
    n: [
      "left_speech_bubble"
    ],
    u: "1f5e8-fe0f"
  },
  {
    n: [
      "right_anger_bubble"
    ],
    u: "1f5ef-fe0f"
  },
  {
    n: [
      "thought balloon",
      "thought_balloon"
    ],
    u: "1f4ad"
  },
  {
    n: [
      "hole"
    ],
    u: "1f573-fe0f"
  },
  {
    n: [
      "eyeglasses"
    ],
    u: "1f453"
  },
  {
    n: [
      "dark_sunglasses"
    ],
    u: "1f576-fe0f"
  },
  {
    n: [
      "necktie"
    ],
    u: "1f454"
  },
  {
    n: [
      "t-shirt",
      "shirt",
      "tshirt"
    ],
    u: "1f455"
  },
  {
    n: [
      "jeans"
    ],
    u: "1f456"
  },
  {
    n: [
      "scarf"
    ],
    u: "1f9e3"
  },
  {
    n: [
      "gloves"
    ],
    u: "1f9e4"
  },
  {
    n: [
      "coat"
    ],
    u: "1f9e5"
  },
  {
    n: [
      "socks"
    ],
    u: "1f9e6"
  },
  {
    n: [
      "dress"
    ],
    u: "1f457"
  },
  {
    n: [
      "kimono"
    ],
    u: "1f458"
  },
  {
    n: [
      "bikini"
    ],
    u: "1f459"
  },
  {
    n: [
      "womans clothes",
      "womans_clothes"
    ],
    u: "1f45a"
  },
  {
    n: [
      "purse"
    ],
    u: "1f45b"
  },
  {
    n: [
      "handbag"
    ],
    u: "1f45c"
  },
  {
    n: [
      "pouch"
    ],
    u: "1f45d"
  },
  {
    n: [
      "shopping_bags"
    ],
    u: "1f6cd-fe0f"
  },
  {
    n: [
      "school satchel",
      "school_satchel"
    ],
    u: "1f392"
  },
  {
    n: [
      "mans shoe",
      "mans_shoe",
      "shoe"
    ],
    u: "1f45e"
  },
  {
    n: [
      "athletic shoe",
      "athletic_shoe"
    ],
    u: "1f45f"
  },
  {
    n: [
      "high-heeled shoe",
      "high_heel"
    ],
    u: "1f460"
  },
  {
    n: [
      "womans sandal",
      "sandal"
    ],
    u: "1f461"
  },
  {
    n: [
      "womans boots",
      "boot"
    ],
    u: "1f462"
  },
  {
    n: [
      "crown"
    ],
    u: "1f451"
  },
  {
    n: [
      "womans hat",
      "womans_hat"
    ],
    u: "1f452"
  },
  {
    n: [
      "top hat",
      "tophat"
    ],
    u: "1f3a9"
  },
  {
    n: [
      "graduation cap",
      "mortar_board"
    ],
    u: "1f393"
  },
  {
    n: [
      "billed cap",
      "billed_cap"
    ],
    u: "1f9e2"
  },
  {
    n: [
      "helmet_with_white_cross"
    ],
    u: "26d1-fe0f"
  },
  {
    n: [
      "prayer beads",
      "prayer_beads"
    ],
    u: "1f4ff"
  },
  {
    n: [
      "lipstick"
    ],
    u: "1f484"
  },
  {
    n: [
      "ring"
    ],
    u: "1f48d"
  },
  {
    n: [
      "gem stone",
      "gem"
    ],
    u: "1f48e"
  }
], hR = [
  {
    n: [
      "monkey face",
      "monkey_face"
    ],
    u: "1f435"
  },
  {
    n: [
      "monkey"
    ],
    u: "1f412"
  },
  {
    n: [
      "gorilla"
    ],
    u: "1f98d"
  },
  {
    n: [
      "dog face",
      "dog"
    ],
    u: "1f436"
  },
  {
    n: [
      "dog",
      "dog2"
    ],
    u: "1f415"
  },
  {
    n: [
      "poodle"
    ],
    u: "1f429"
  },
  {
    n: [
      "wolf face",
      "wolf"
    ],
    u: "1f43a"
  },
  {
    n: [
      "fox face",
      "fox_face"
    ],
    u: "1f98a"
  },
  {
    n: [
      "cat face",
      "cat"
    ],
    u: "1f431"
  },
  {
    n: [
      "cat",
      "cat2"
    ],
    u: "1f408"
  },
  {
    n: [
      "lion face",
      "lion_face"
    ],
    u: "1f981"
  },
  {
    n: [
      "tiger face",
      "tiger"
    ],
    u: "1f42f"
  },
  {
    n: [
      "tiger",
      "tiger2"
    ],
    u: "1f405"
  },
  {
    n: [
      "leopard"
    ],
    u: "1f406"
  },
  {
    n: [
      "horse face",
      "horse"
    ],
    u: "1f434"
  },
  {
    n: [
      "horse",
      "racehorse"
    ],
    u: "1f40e"
  },
  {
    n: [
      "unicorn face",
      "unicorn_face"
    ],
    u: "1f984"
  },
  {
    n: [
      "zebra face",
      "zebra_face"
    ],
    u: "1f993"
  },
  {
    n: [
      "deer"
    ],
    u: "1f98c"
  },
  {
    n: [
      "cow face",
      "cow"
    ],
    u: "1f42e"
  },
  {
    n: [
      "ox"
    ],
    u: "1f402"
  },
  {
    n: [
      "water buffalo",
      "water_buffalo"
    ],
    u: "1f403"
  },
  {
    n: [
      "cow",
      "cow2"
    ],
    u: "1f404"
  },
  {
    n: [
      "pig face",
      "pig"
    ],
    u: "1f437"
  },
  {
    n: [
      "pig",
      "pig2"
    ],
    u: "1f416"
  },
  {
    n: [
      "boar"
    ],
    u: "1f417"
  },
  {
    n: [
      "pig nose",
      "pig_nose"
    ],
    u: "1f43d"
  },
  {
    n: [
      "ram"
    ],
    u: "1f40f"
  },
  {
    n: [
      "sheep"
    ],
    u: "1f411"
  },
  {
    n: [
      "goat"
    ],
    u: "1f410"
  },
  {
    n: [
      "dromedary camel",
      "dromedary_camel"
    ],
    u: "1f42a"
  },
  {
    n: [
      "bactrian camel",
      "camel"
    ],
    u: "1f42b"
  },
  {
    n: [
      "giraffe face",
      "giraffe_face"
    ],
    u: "1f992"
  },
  {
    n: [
      "elephant"
    ],
    u: "1f418"
  },
  {
    n: [
      "rhinoceros"
    ],
    u: "1f98f"
  },
  {
    n: [
      "mouse face",
      "mouse"
    ],
    u: "1f42d"
  },
  {
    n: [
      "mouse",
      "mouse2"
    ],
    u: "1f401"
  },
  {
    n: [
      "rat"
    ],
    u: "1f400"
  },
  {
    n: [
      "hamster face",
      "hamster"
    ],
    u: "1f439"
  },
  {
    n: [
      "rabbit face",
      "rabbit"
    ],
    u: "1f430"
  },
  {
    n: [
      "rabbit",
      "rabbit2"
    ],
    u: "1f407"
  },
  {
    n: [
      "chipmunk"
    ],
    u: "1f43f-fe0f"
  },
  {
    n: [
      "hedgehog"
    ],
    u: "1f994"
  },
  {
    n: [
      "bat"
    ],
    u: "1f987"
  },
  {
    n: [
      "bear face",
      "bear"
    ],
    u: "1f43b"
  },
  {
    n: [
      "koala"
    ],
    u: "1f428"
  },
  {
    n: [
      "panda face",
      "panda_face"
    ],
    u: "1f43c"
  },
  {
    n: [
      "paw prints",
      "feet",
      "paw_prints"
    ],
    u: "1f43e"
  },
  {
    n: [
      "turkey"
    ],
    u: "1f983"
  },
  {
    n: [
      "chicken"
    ],
    u: "1f414"
  },
  {
    n: [
      "rooster"
    ],
    u: "1f413"
  },
  {
    n: [
      "hatching chick",
      "hatching_chick"
    ],
    u: "1f423"
  },
  {
    n: [
      "baby chick",
      "baby_chick"
    ],
    u: "1f424"
  },
  {
    n: [
      "front-facing baby chick",
      "hatched_chick"
    ],
    u: "1f425"
  },
  {
    n: [
      "bird"
    ],
    u: "1f426"
  },
  {
    n: [
      "penguin"
    ],
    u: "1f427"
  },
  {
    n: [
      "dove_of_peace"
    ],
    u: "1f54a-fe0f"
  },
  {
    n: [
      "eagle"
    ],
    u: "1f985"
  },
  {
    n: [
      "duck"
    ],
    u: "1f986"
  },
  {
    n: [
      "owl"
    ],
    u: "1f989"
  },
  {
    n: [
      "frog face",
      "frog"
    ],
    u: "1f438"
  },
  {
    n: [
      "crocodile"
    ],
    u: "1f40a"
  },
  {
    n: [
      "turtle"
    ],
    u: "1f422"
  },
  {
    n: [
      "lizard"
    ],
    u: "1f98e"
  },
  {
    n: [
      "snake"
    ],
    u: "1f40d"
  },
  {
    n: [
      "dragon face",
      "dragon_face"
    ],
    u: "1f432"
  },
  {
    n: [
      "dragon"
    ],
    u: "1f409"
  },
  {
    n: [
      "sauropod"
    ],
    u: "1f995"
  },
  {
    n: [
      "t-rex"
    ],
    u: "1f996"
  },
  {
    n: [
      "spouting whale",
      "whale"
    ],
    u: "1f433"
  },
  {
    n: [
      "whale",
      "whale2"
    ],
    u: "1f40b"
  },
  {
    n: [
      "dolphin",
      "flipper"
    ],
    u: "1f42c"
  },
  {
    n: [
      "fish"
    ],
    u: "1f41f"
  },
  {
    n: [
      "tropical fish",
      "tropical_fish"
    ],
    u: "1f420"
  },
  {
    n: [
      "blowfish"
    ],
    u: "1f421"
  },
  {
    n: [
      "shark"
    ],
    u: "1f988"
  },
  {
    n: [
      "octopus"
    ],
    u: "1f419"
  },
  {
    n: [
      "spiral shell",
      "shell"
    ],
    u: "1f41a"
  },
  {
    n: [
      "crab"
    ],
    u: "1f980"
  },
  {
    n: [
      "shrimp"
    ],
    u: "1f990"
  },
  {
    n: [
      "squid"
    ],
    u: "1f991"
  },
  {
    n: [
      "snail"
    ],
    u: "1f40c"
  },
  {
    n: [
      "butterfly"
    ],
    u: "1f98b"
  },
  {
    n: [
      "bug"
    ],
    u: "1f41b"
  },
  {
    n: [
      "ant"
    ],
    u: "1f41c"
  },
  {
    n: [
      "honeybee",
      "bee"
    ],
    u: "1f41d"
  },
  {
    n: [
      "lady beetle",
      "beetle"
    ],
    u: "1f41e"
  },
  {
    n: [
      "cricket"
    ],
    u: "1f997"
  },
  {
    n: [
      "spider"
    ],
    u: "1f577-fe0f"
  },
  {
    n: [
      "spider_web"
    ],
    u: "1f578-fe0f"
  },
  {
    n: [
      "scorpion"
    ],
    u: "1f982"
  },
  {
    n: [
      "bouquet"
    ],
    u: "1f490"
  },
  {
    n: [
      "cherry blossom",
      "cherry_blossom"
    ],
    u: "1f338"
  },
  {
    n: [
      "white flower",
      "white_flower"
    ],
    u: "1f4ae"
  },
  {
    n: [
      "rosette"
    ],
    u: "1f3f5-fe0f"
  },
  {
    n: [
      "rose"
    ],
    u: "1f339"
  },
  {
    n: [
      "wilted flower",
      "wilted_flower"
    ],
    u: "1f940"
  },
  {
    n: [
      "hibiscus"
    ],
    u: "1f33a"
  },
  {
    n: [
      "sunflower"
    ],
    u: "1f33b"
  },
  {
    n: [
      "blossom"
    ],
    u: "1f33c"
  },
  {
    n: [
      "tulip"
    ],
    u: "1f337"
  },
  {
    n: [
      "seedling"
    ],
    u: "1f331"
  },
  {
    n: [
      "evergreen tree",
      "evergreen_tree"
    ],
    u: "1f332"
  },
  {
    n: [
      "deciduous tree",
      "deciduous_tree"
    ],
    u: "1f333"
  },
  {
    n: [
      "palm tree",
      "palm_tree"
    ],
    u: "1f334"
  },
  {
    n: [
      "cactus"
    ],
    u: "1f335"
  },
  {
    n: [
      "ear of rice",
      "ear_of_rice"
    ],
    u: "1f33e"
  },
  {
    n: [
      "herb"
    ],
    u: "1f33f"
  },
  {
    n: [
      "shamrock"
    ],
    u: "2618-fe0f"
  },
  {
    n: [
      "four leaf clover",
      "four_leaf_clover"
    ],
    u: "1f340"
  },
  {
    n: [
      "maple leaf",
      "maple_leaf"
    ],
    u: "1f341"
  },
  {
    n: [
      "fallen leaf",
      "fallen_leaf"
    ],
    u: "1f342"
  },
  {
    n: [
      "leaf fluttering in wind",
      "leaves"
    ],
    u: "1f343"
  }
], gR = [
  {
    n: [
      "grapes"
    ],
    u: "1f347"
  },
  {
    n: [
      "melon"
    ],
    u: "1f348"
  },
  {
    n: [
      "watermelon"
    ],
    u: "1f349"
  },
  {
    n: [
      "tangerine"
    ],
    u: "1f34a"
  },
  {
    n: [
      "lemon"
    ],
    u: "1f34b"
  },
  {
    n: [
      "banana"
    ],
    u: "1f34c"
  },
  {
    n: [
      "pineapple"
    ],
    u: "1f34d"
  },
  {
    n: [
      "red apple",
      "apple"
    ],
    u: "1f34e"
  },
  {
    n: [
      "green apple",
      "green_apple"
    ],
    u: "1f34f"
  },
  {
    n: [
      "pear"
    ],
    u: "1f350"
  },
  {
    n: [
      "peach"
    ],
    u: "1f351"
  },
  {
    n: [
      "cherries"
    ],
    u: "1f352"
  },
  {
    n: [
      "strawberry"
    ],
    u: "1f353"
  },
  {
    n: [
      "kiwifruit"
    ],
    u: "1f95d"
  },
  {
    n: [
      "tomato"
    ],
    u: "1f345"
  },
  {
    n: [
      "coconut"
    ],
    u: "1f965"
  },
  {
    n: [
      "avocado"
    ],
    u: "1f951"
  },
  {
    n: [
      "aubergine",
      "eggplant"
    ],
    u: "1f346"
  },
  {
    n: [
      "potato"
    ],
    u: "1f954"
  },
  {
    n: [
      "carrot"
    ],
    u: "1f955"
  },
  {
    n: [
      "ear of maize",
      "corn"
    ],
    u: "1f33d"
  },
  {
    n: [
      "hot_pepper"
    ],
    u: "1f336-fe0f"
  },
  {
    n: [
      "cucumber"
    ],
    u: "1f952"
  },
  {
    n: [
      "broccoli"
    ],
    u: "1f966"
  },
  {
    n: [
      "mushroom"
    ],
    u: "1f344"
  },
  {
    n: [
      "peanuts"
    ],
    u: "1f95c"
  },
  {
    n: [
      "chestnut"
    ],
    u: "1f330"
  },
  {
    n: [
      "bread"
    ],
    u: "1f35e"
  },
  {
    n: [
      "croissant"
    ],
    u: "1f950"
  },
  {
    n: [
      "baguette bread",
      "baguette_bread"
    ],
    u: "1f956"
  },
  {
    n: [
      "pretzel"
    ],
    u: "1f968"
  },
  {
    n: [
      "pancakes"
    ],
    u: "1f95e"
  },
  {
    n: [
      "cheese wedge",
      "cheese_wedge"
    ],
    u: "1f9c0"
  },
  {
    n: [
      "meat on bone",
      "meat_on_bone"
    ],
    u: "1f356"
  },
  {
    n: [
      "poultry leg",
      "poultry_leg"
    ],
    u: "1f357"
  },
  {
    n: [
      "cut of meat",
      "cut_of_meat"
    ],
    u: "1f969"
  },
  {
    n: [
      "bacon"
    ],
    u: "1f953"
  },
  {
    n: [
      "hamburger"
    ],
    u: "1f354"
  },
  {
    n: [
      "french fries",
      "fries"
    ],
    u: "1f35f"
  },
  {
    n: [
      "slice of pizza",
      "pizza"
    ],
    u: "1f355"
  },
  {
    n: [
      "hot dog",
      "hotdog"
    ],
    u: "1f32d"
  },
  {
    n: [
      "sandwich"
    ],
    u: "1f96a"
  },
  {
    n: [
      "taco"
    ],
    u: "1f32e"
  },
  {
    n: [
      "burrito"
    ],
    u: "1f32f"
  },
  {
    n: [
      "stuffed flatbread",
      "stuffed_flatbread"
    ],
    u: "1f959"
  },
  {
    n: [
      "egg"
    ],
    u: "1f95a"
  },
  {
    n: [
      "cooking",
      "fried_egg"
    ],
    u: "1f373"
  },
  {
    n: [
      "shallow pan of food",
      "shallow_pan_of_food"
    ],
    u: "1f958"
  },
  {
    n: [
      "pot of food",
      "stew"
    ],
    u: "1f372"
  },
  {
    n: [
      "bowl with spoon",
      "bowl_with_spoon"
    ],
    u: "1f963"
  },
  {
    n: [
      "green salad",
      "green_salad"
    ],
    u: "1f957"
  },
  {
    n: [
      "popcorn"
    ],
    u: "1f37f"
  },
  {
    n: [
      "canned food",
      "canned_food"
    ],
    u: "1f96b"
  },
  {
    n: [
      "bento box",
      "bento"
    ],
    u: "1f371"
  },
  {
    n: [
      "rice cracker",
      "rice_cracker"
    ],
    u: "1f358"
  },
  {
    n: [
      "rice ball",
      "rice_ball"
    ],
    u: "1f359"
  },
  {
    n: [
      "cooked rice",
      "rice"
    ],
    u: "1f35a"
  },
  {
    n: [
      "curry and rice",
      "curry"
    ],
    u: "1f35b"
  },
  {
    n: [
      "steaming bowl",
      "ramen"
    ],
    u: "1f35c"
  },
  {
    n: [
      "spaghetti"
    ],
    u: "1f35d"
  },
  {
    n: [
      "roasted sweet potato",
      "sweet_potato"
    ],
    u: "1f360"
  },
  {
    n: [
      "oden"
    ],
    u: "1f362"
  },
  {
    n: [
      "sushi"
    ],
    u: "1f363"
  },
  {
    n: [
      "fried shrimp",
      "fried_shrimp"
    ],
    u: "1f364"
  },
  {
    n: [
      "fish cake with swirl design",
      "fish_cake"
    ],
    u: "1f365"
  },
  {
    n: [
      "dango"
    ],
    u: "1f361"
  },
  {
    n: [
      "dumpling"
    ],
    u: "1f95f"
  },
  {
    n: [
      "fortune cookie",
      "fortune_cookie"
    ],
    u: "1f960"
  },
  {
    n: [
      "takeout box",
      "takeout_box"
    ],
    u: "1f961"
  },
  {
    n: [
      "soft ice cream",
      "icecream"
    ],
    u: "1f366"
  },
  {
    n: [
      "shaved ice",
      "shaved_ice"
    ],
    u: "1f367"
  },
  {
    n: [
      "ice cream",
      "ice_cream"
    ],
    u: "1f368"
  },
  {
    n: [
      "doughnut"
    ],
    u: "1f369"
  },
  {
    n: [
      "cookie"
    ],
    u: "1f36a"
  },
  {
    n: [
      "birthday cake",
      "birthday"
    ],
    u: "1f382"
  },
  {
    n: [
      "shortcake",
      "cake"
    ],
    u: "1f370"
  },
  {
    n: [
      "pie"
    ],
    u: "1f967"
  },
  {
    n: [
      "chocolate bar",
      "chocolate_bar"
    ],
    u: "1f36b"
  },
  {
    n: [
      "candy"
    ],
    u: "1f36c"
  },
  {
    n: [
      "lollipop"
    ],
    u: "1f36d"
  },
  {
    n: [
      "custard"
    ],
    u: "1f36e"
  },
  {
    n: [
      "honey pot",
      "honey_pot"
    ],
    u: "1f36f"
  },
  {
    n: [
      "baby bottle",
      "baby_bottle"
    ],
    u: "1f37c"
  },
  {
    n: [
      "glass of milk",
      "glass_of_milk"
    ],
    u: "1f95b"
  },
  {
    n: [
      "hot beverage",
      "coffee"
    ],
    u: "2615"
  },
  {
    n: [
      "teacup without handle",
      "tea"
    ],
    u: "1f375"
  },
  {
    n: [
      "sake bottle and cup",
      "sake"
    ],
    u: "1f376"
  },
  {
    n: [
      "bottle with popping cork",
      "champagne"
    ],
    u: "1f37e"
  },
  {
    n: [
      "wine glass",
      "wine_glass"
    ],
    u: "1f377"
  },
  {
    n: [
      "cocktail glass",
      "cocktail"
    ],
    u: "1f378"
  },
  {
    n: [
      "tropical drink",
      "tropical_drink"
    ],
    u: "1f379"
  },
  {
    n: [
      "beer mug",
      "beer"
    ],
    u: "1f37a"
  },
  {
    n: [
      "clinking beer mugs",
      "beers"
    ],
    u: "1f37b"
  },
  {
    n: [
      "clinking glasses",
      "clinking_glasses"
    ],
    u: "1f942"
  },
  {
    n: [
      "tumbler glass",
      "tumbler_glass"
    ],
    u: "1f943"
  },
  {
    n: [
      "cup with straw",
      "cup_with_straw"
    ],
    u: "1f964"
  },
  {
    n: [
      "chopsticks"
    ],
    u: "1f962"
  },
  {
    n: [
      "knife_fork_plate"
    ],
    u: "1f37d-fe0f"
  },
  {
    n: [
      "fork and knife",
      "fork_and_knife"
    ],
    u: "1f374"
  },
  {
    n: [
      "spoon"
    ],
    u: "1f944"
  },
  {
    n: [
      "hocho",
      "knife"
    ],
    u: "1f52a"
  },
  {
    n: [
      "amphora"
    ],
    u: "1f3fa"
  }
], mR = [
  {
    n: [
      "jack-o-lantern",
      "jack_o_lantern"
    ],
    u: "1f383"
  },
  {
    n: [
      "christmas tree",
      "christmas_tree"
    ],
    u: "1f384"
  },
  {
    n: [
      "fireworks"
    ],
    u: "1f386"
  },
  {
    n: [
      "firework sparkler",
      "sparkler"
    ],
    u: "1f387"
  },
  {
    n: [
      "sparkles"
    ],
    u: "2728"
  },
  {
    n: [
      "balloon"
    ],
    u: "1f388"
  },
  {
    n: [
      "party popper",
      "tada"
    ],
    u: "1f389"
  },
  {
    n: [
      "confetti ball",
      "confetti_ball"
    ],
    u: "1f38a"
  },
  {
    n: [
      "tanabata tree",
      "tanabata_tree"
    ],
    u: "1f38b"
  },
  {
    n: [
      "pine decoration",
      "bamboo"
    ],
    u: "1f38d"
  },
  {
    n: [
      "japanese dolls",
      "dolls"
    ],
    u: "1f38e"
  },
  {
    n: [
      "carp streamer",
      "flags"
    ],
    u: "1f38f"
  },
  {
    n: [
      "wind chime",
      "wind_chime"
    ],
    u: "1f390"
  },
  {
    n: [
      "moon viewing ceremony",
      "rice_scene"
    ],
    u: "1f391"
  },
  {
    n: [
      "ribbon"
    ],
    u: "1f380"
  },
  {
    n: [
      "wrapped present",
      "gift"
    ],
    u: "1f381"
  },
  {
    n: [
      "reminder_ribbon"
    ],
    u: "1f397-fe0f"
  },
  {
    n: [
      "admission_tickets"
    ],
    u: "1f39f-fe0f"
  },
  {
    n: [
      "ticket"
    ],
    u: "1f3ab"
  },
  {
    n: [
      "medal"
    ],
    u: "1f396-fe0f"
  },
  {
    n: [
      "trophy"
    ],
    u: "1f3c6"
  },
  {
    n: [
      "sports medal",
      "sports_medal"
    ],
    u: "1f3c5"
  },
  {
    n: [
      "first place medal",
      "first_place_medal"
    ],
    u: "1f947"
  },
  {
    n: [
      "second place medal",
      "second_place_medal"
    ],
    u: "1f948"
  },
  {
    n: [
      "third place medal",
      "third_place_medal"
    ],
    u: "1f949"
  },
  {
    n: [
      "soccer ball",
      "soccer"
    ],
    u: "26bd"
  },
  {
    n: [
      "baseball"
    ],
    u: "26be"
  },
  {
    n: [
      "basketball and hoop",
      "basketball"
    ],
    u: "1f3c0"
  },
  {
    n: [
      "volleyball"
    ],
    u: "1f3d0"
  },
  {
    n: [
      "american football",
      "football"
    ],
    u: "1f3c8"
  },
  {
    n: [
      "rugby football",
      "rugby_football"
    ],
    u: "1f3c9"
  },
  {
    n: [
      "tennis racquet and ball",
      "tennis"
    ],
    u: "1f3be"
  },
  {
    n: [
      "billiards",
      "8ball"
    ],
    u: "1f3b1"
  },
  {
    n: [
      "bowling"
    ],
    u: "1f3b3"
  },
  {
    n: [
      "cricket bat and ball",
      "cricket_bat_and_ball"
    ],
    u: "1f3cf"
  },
  {
    n: [
      "field hockey stick and ball",
      "field_hockey_stick_and_ball"
    ],
    u: "1f3d1"
  },
  {
    n: [
      "ice hockey stick and puck",
      "ice_hockey_stick_and_puck"
    ],
    u: "1f3d2"
  },
  {
    n: [
      "table tennis paddle and ball",
      "table_tennis_paddle_and_ball"
    ],
    u: "1f3d3"
  },
  {
    n: [
      "badminton racquet and shuttlecock",
      "badminton_racquet_and_shuttlecock"
    ],
    u: "1f3f8"
  },
  {
    n: [
      "boxing glove",
      "boxing_glove"
    ],
    u: "1f94a"
  },
  {
    n: [
      "martial arts uniform",
      "martial_arts_uniform"
    ],
    u: "1f94b"
  },
  {
    n: [
      "goal net",
      "goal_net"
    ],
    u: "1f945"
  },
  {
    n: [
      "direct hit",
      "dart"
    ],
    u: "1f3af"
  },
  {
    n: [
      "flag in hole",
      "golf"
    ],
    u: "26f3"
  },
  {
    n: [
      "ice_skate"
    ],
    u: "26f8-fe0f"
  },
  {
    n: [
      "fishing pole and fish",
      "fishing_pole_and_fish"
    ],
    u: "1f3a3"
  },
  {
    n: [
      "running shirt with sash",
      "running_shirt_with_sash"
    ],
    u: "1f3bd"
  },
  {
    n: [
      "ski and ski boot",
      "ski"
    ],
    u: "1f3bf"
  },
  {
    n: [
      "sled"
    ],
    u: "1f6f7"
  },
  {
    n: [
      "curling stone",
      "curling_stone"
    ],
    u: "1f94c"
  },
  {
    n: [
      "video game",
      "video_game"
    ],
    u: "1f3ae"
  },
  {
    n: [
      "joystick"
    ],
    u: "1f579-fe0f"
  },
  {
    n: [
      "game die",
      "game_die"
    ],
    u: "1f3b2"
  },
  {
    n: [
      "black spade suit",
      "spades"
    ],
    u: "2660-fe0f"
  },
  {
    n: [
      "black heart suit",
      "hearts"
    ],
    u: "2665-fe0f"
  },
  {
    n: [
      "black diamond suit",
      "diamonds"
    ],
    u: "2666-fe0f"
  },
  {
    n: [
      "black club suit",
      "clubs"
    ],
    u: "2663-fe0f"
  },
  {
    n: [
      "playing card black joker",
      "black_joker"
    ],
    u: "1f0cf"
  },
  {
    n: [
      "mahjong tile red dragon",
      "mahjong"
    ],
    u: "1f004"
  },
  {
    n: [
      "flower playing cards",
      "flower_playing_cards"
    ],
    u: "1f3b4"
  }
], bR = [
  {
    n: [
      "earth globe europe-africa",
      "earth_africa"
    ],
    u: "1f30d"
  },
  {
    n: [
      "earth globe americas",
      "earth_americas"
    ],
    u: "1f30e"
  },
  {
    n: [
      "earth globe asia-australia",
      "earth_asia"
    ],
    u: "1f30f"
  },
  {
    n: [
      "globe with meridians",
      "globe_with_meridians"
    ],
    u: "1f310"
  },
  {
    n: [
      "world_map"
    ],
    u: "1f5fa-fe0f"
  },
  {
    n: [
      "silhouette of japan",
      "japan"
    ],
    u: "1f5fe"
  },
  {
    n: [
      "snow_capped_mountain"
    ],
    u: "1f3d4-fe0f"
  },
  {
    n: [
      "mountain"
    ],
    u: "26f0-fe0f"
  },
  {
    n: [
      "volcano"
    ],
    u: "1f30b"
  },
  {
    n: [
      "mount fuji",
      "mount_fuji"
    ],
    u: "1f5fb"
  },
  {
    n: [
      "camping"
    ],
    u: "1f3d5-fe0f"
  },
  {
    n: [
      "beach_with_umbrella"
    ],
    u: "1f3d6-fe0f"
  },
  {
    n: [
      "desert"
    ],
    u: "1f3dc-fe0f"
  },
  {
    n: [
      "desert_island"
    ],
    u: "1f3dd-fe0f"
  },
  {
    n: [
      "national_park"
    ],
    u: "1f3de-fe0f"
  },
  {
    n: [
      "stadium"
    ],
    u: "1f3df-fe0f"
  },
  {
    n: [
      "classical_building"
    ],
    u: "1f3db-fe0f"
  },
  {
    n: [
      "building_construction"
    ],
    u: "1f3d7-fe0f"
  },
  {
    n: [
      "house_buildings"
    ],
    u: "1f3d8-fe0f"
  },
  {
    n: [
      "cityscape"
    ],
    u: "1f3d9-fe0f"
  },
  {
    n: [
      "derelict_house_building"
    ],
    u: "1f3da-fe0f"
  },
  {
    n: [
      "house building",
      "house"
    ],
    u: "1f3e0"
  },
  {
    n: [
      "house with garden",
      "house_with_garden"
    ],
    u: "1f3e1"
  },
  {
    n: [
      "office building",
      "office"
    ],
    u: "1f3e2"
  },
  {
    n: [
      "japanese post office",
      "post_office"
    ],
    u: "1f3e3"
  },
  {
    n: [
      "european post office",
      "european_post_office"
    ],
    u: "1f3e4"
  },
  {
    n: [
      "hospital"
    ],
    u: "1f3e5"
  },
  {
    n: [
      "bank"
    ],
    u: "1f3e6"
  },
  {
    n: [
      "hotel"
    ],
    u: "1f3e8"
  },
  {
    n: [
      "love hotel",
      "love_hotel"
    ],
    u: "1f3e9"
  },
  {
    n: [
      "convenience store",
      "convenience_store"
    ],
    u: "1f3ea"
  },
  {
    n: [
      "school"
    ],
    u: "1f3eb"
  },
  {
    n: [
      "department store",
      "department_store"
    ],
    u: "1f3ec"
  },
  {
    n: [
      "factory"
    ],
    u: "1f3ed"
  },
  {
    n: [
      "japanese castle",
      "japanese_castle"
    ],
    u: "1f3ef"
  },
  {
    n: [
      "european castle",
      "european_castle"
    ],
    u: "1f3f0"
  },
  {
    n: [
      "wedding"
    ],
    u: "1f492"
  },
  {
    n: [
      "tokyo tower",
      "tokyo_tower"
    ],
    u: "1f5fc"
  },
  {
    n: [
      "statue of liberty",
      "statue_of_liberty"
    ],
    u: "1f5fd"
  },
  {
    n: [
      "church"
    ],
    u: "26ea"
  },
  {
    n: [
      "mosque"
    ],
    u: "1f54c"
  },
  {
    n: [
      "synagogue"
    ],
    u: "1f54d"
  },
  {
    n: [
      "shinto_shrine"
    ],
    u: "26e9-fe0f"
  },
  {
    n: [
      "kaaba"
    ],
    u: "1f54b"
  },
  {
    n: [
      "fountain"
    ],
    u: "26f2"
  },
  {
    n: [
      "tent"
    ],
    u: "26fa"
  },
  {
    n: [
      "foggy"
    ],
    u: "1f301"
  },
  {
    n: [
      "night with stars",
      "night_with_stars"
    ],
    u: "1f303"
  },
  {
    n: [
      "sunrise over mountains",
      "sunrise_over_mountains"
    ],
    u: "1f304"
  },
  {
    n: [
      "sunrise"
    ],
    u: "1f305"
  },
  {
    n: [
      "cityscape at dusk",
      "city_sunset"
    ],
    u: "1f306"
  },
  {
    n: [
      "sunset over buildings",
      "city_sunrise"
    ],
    u: "1f307"
  },
  {
    n: [
      "bridge at night",
      "bridge_at_night"
    ],
    u: "1f309"
  },
  {
    n: [
      "hot springs",
      "hotsprings"
    ],
    u: "2668-fe0f"
  },
  {
    n: [
      "milky way",
      "milky_way"
    ],
    u: "1f30c"
  },
  {
    n: [
      "carousel horse",
      "carousel_horse"
    ],
    u: "1f3a0"
  },
  {
    n: [
      "ferris wheel",
      "ferris_wheel"
    ],
    u: "1f3a1"
  },
  {
    n: [
      "roller coaster",
      "roller_coaster"
    ],
    u: "1f3a2"
  },
  {
    n: [
      "barber pole",
      "barber"
    ],
    u: "1f488"
  },
  {
    n: [
      "circus tent",
      "circus_tent"
    ],
    u: "1f3aa"
  },
  {
    n: [
      "performing arts",
      "performing_arts"
    ],
    u: "1f3ad"
  },
  {
    n: [
      "frame_with_picture"
    ],
    u: "1f5bc-fe0f"
  },
  {
    n: [
      "artist palette",
      "art"
    ],
    u: "1f3a8"
  },
  {
    n: [
      "slot machine",
      "slot_machine"
    ],
    u: "1f3b0"
  },
  {
    n: [
      "steam locomotive",
      "steam_locomotive"
    ],
    u: "1f682"
  },
  {
    n: [
      "railway car",
      "railway_car"
    ],
    u: "1f683"
  },
  {
    n: [
      "high-speed train",
      "bullettrain_side"
    ],
    u: "1f684"
  },
  {
    n: [
      "high-speed train with bullet nose",
      "bullettrain_front"
    ],
    u: "1f685"
  },
  {
    n: [
      "train",
      "train2"
    ],
    u: "1f686"
  },
  {
    n: [
      "metro"
    ],
    u: "1f687"
  },
  {
    n: [
      "light rail",
      "light_rail"
    ],
    u: "1f688"
  },
  {
    n: [
      "station"
    ],
    u: "1f689"
  },
  {
    n: [
      "tram"
    ],
    u: "1f68a"
  },
  {
    n: [
      "monorail"
    ],
    u: "1f69d"
  },
  {
    n: [
      "mountain railway",
      "mountain_railway"
    ],
    u: "1f69e"
  },
  {
    n: [
      "tram car",
      "train"
    ],
    u: "1f68b"
  },
  {
    n: [
      "bus"
    ],
    u: "1f68c"
  },
  {
    n: [
      "oncoming bus",
      "oncoming_bus"
    ],
    u: "1f68d"
  },
  {
    n: [
      "trolleybus"
    ],
    u: "1f68e"
  },
  {
    n: [
      "minibus"
    ],
    u: "1f690"
  },
  {
    n: [
      "ambulance"
    ],
    u: "1f691"
  },
  {
    n: [
      "fire engine",
      "fire_engine"
    ],
    u: "1f692"
  },
  {
    n: [
      "police car",
      "police_car"
    ],
    u: "1f693"
  },
  {
    n: [
      "oncoming police car",
      "oncoming_police_car"
    ],
    u: "1f694"
  },
  {
    n: [
      "taxi"
    ],
    u: "1f695"
  },
  {
    n: [
      "oncoming taxi",
      "oncoming_taxi"
    ],
    u: "1f696"
  },
  {
    n: [
      "automobile",
      "car",
      "red_car"
    ],
    u: "1f697"
  },
  {
    n: [
      "oncoming automobile",
      "oncoming_automobile"
    ],
    u: "1f698"
  },
  {
    n: [
      "recreational vehicle",
      "blue_car"
    ],
    u: "1f699"
  },
  {
    n: [
      "delivery truck",
      "truck"
    ],
    u: "1f69a"
  },
  {
    n: [
      "articulated lorry",
      "articulated_lorry"
    ],
    u: "1f69b"
  },
  {
    n: [
      "tractor"
    ],
    u: "1f69c"
  },
  {
    n: [
      "bicycle",
      "bike"
    ],
    u: "1f6b2"
  },
  {
    n: [
      "scooter"
    ],
    u: "1f6f4"
  },
  {
    n: [
      "motor scooter",
      "motor_scooter"
    ],
    u: "1f6f5"
  },
  {
    n: [
      "bus stop",
      "busstop"
    ],
    u: "1f68f"
  },
  {
    n: [
      "motorway"
    ],
    u: "1f6e3-fe0f"
  },
  {
    n: [
      "railway_track"
    ],
    u: "1f6e4-fe0f"
  },
  {
    n: [
      "fuel pump",
      "fuelpump"
    ],
    u: "26fd"
  },
  {
    n: [
      "police cars revolving light",
      "rotating_light"
    ],
    u: "1f6a8"
  },
  {
    n: [
      "horizontal traffic light",
      "traffic_light"
    ],
    u: "1f6a5"
  },
  {
    n: [
      "vertical traffic light",
      "vertical_traffic_light"
    ],
    u: "1f6a6"
  },
  {
    n: [
      "construction sign",
      "construction"
    ],
    u: "1f6a7"
  },
  {
    n: [
      "octagonal sign",
      "octagonal_sign"
    ],
    u: "1f6d1"
  },
  {
    n: [
      "anchor"
    ],
    u: "2693"
  },
  {
    n: [
      "sailboat",
      "boat"
    ],
    u: "26f5"
  },
  {
    n: [
      "canoe"
    ],
    u: "1f6f6"
  },
  {
    n: [
      "speedboat"
    ],
    u: "1f6a4"
  },
  {
    n: [
      "passenger_ship"
    ],
    u: "1f6f3-fe0f"
  },
  {
    n: [
      "ferry"
    ],
    u: "26f4-fe0f"
  },
  {
    n: [
      "motor_boat"
    ],
    u: "1f6e5-fe0f"
  },
  {
    n: [
      "ship"
    ],
    u: "1f6a2"
  },
  {
    n: [
      "airplane"
    ],
    u: "2708-fe0f"
  },
  {
    n: [
      "small_airplane"
    ],
    u: "1f6e9-fe0f"
  },
  {
    n: [
      "airplane departure",
      "airplane_departure"
    ],
    u: "1f6eb"
  },
  {
    n: [
      "airplane arriving",
      "airplane_arriving"
    ],
    u: "1f6ec"
  },
  {
    n: [
      "seat"
    ],
    u: "1f4ba"
  },
  {
    n: [
      "helicopter"
    ],
    u: "1f681"
  },
  {
    n: [
      "suspension railway",
      "suspension_railway"
    ],
    u: "1f69f"
  },
  {
    n: [
      "mountain cableway",
      "mountain_cableway"
    ],
    u: "1f6a0"
  },
  {
    n: [
      "aerial tramway",
      "aerial_tramway"
    ],
    u: "1f6a1"
  },
  {
    n: [
      "satellite"
    ],
    u: "1f6f0-fe0f"
  },
  {
    n: [
      "rocket"
    ],
    u: "1f680"
  },
  {
    n: [
      "flying saucer",
      "flying_saucer"
    ],
    u: "1f6f8"
  },
  {
    n: [
      "bellhop_bell"
    ],
    u: "1f6ce-fe0f"
  },
  {
    n: [
      "door"
    ],
    u: "1f6aa"
  },
  {
    n: [
      "bed"
    ],
    u: "1f6cf-fe0f"
  },
  {
    n: [
      "couch_and_lamp"
    ],
    u: "1f6cb-fe0f"
  },
  {
    n: [
      "toilet"
    ],
    u: "1f6bd"
  },
  {
    n: [
      "shower"
    ],
    u: "1f6bf"
  },
  {
    n: [
      "bathtub"
    ],
    u: "1f6c1"
  },
  {
    n: [
      "hourglass"
    ],
    u: "231b"
  },
  {
    n: [
      "hourglass with flowing sand",
      "hourglass_flowing_sand"
    ],
    u: "23f3"
  },
  {
    n: [
      "watch"
    ],
    u: "231a"
  },
  {
    n: [
      "alarm clock",
      "alarm_clock"
    ],
    u: "23f0"
  },
  {
    n: [
      "stopwatch"
    ],
    u: "23f1-fe0f"
  },
  {
    n: [
      "timer_clock"
    ],
    u: "23f2-fe0f"
  },
  {
    n: [
      "mantelpiece_clock"
    ],
    u: "1f570-fe0f"
  },
  {
    n: [
      "clock face twelve oclock",
      "clock12"
    ],
    u: "1f55b"
  },
  {
    n: [
      "clock face twelve-thirty",
      "clock1230"
    ],
    u: "1f567"
  },
  {
    n: [
      "clock face one oclock",
      "clock1"
    ],
    u: "1f550"
  },
  {
    n: [
      "clock face one-thirty",
      "clock130"
    ],
    u: "1f55c"
  },
  {
    n: [
      "clock face two oclock",
      "clock2"
    ],
    u: "1f551"
  },
  {
    n: [
      "clock face two-thirty",
      "clock230"
    ],
    u: "1f55d"
  },
  {
    n: [
      "clock face three oclock",
      "clock3"
    ],
    u: "1f552"
  },
  {
    n: [
      "clock face three-thirty",
      "clock330"
    ],
    u: "1f55e"
  },
  {
    n: [
      "clock face four oclock",
      "clock4"
    ],
    u: "1f553"
  },
  {
    n: [
      "clock face four-thirty",
      "clock430"
    ],
    u: "1f55f"
  },
  {
    n: [
      "clock face five oclock",
      "clock5"
    ],
    u: "1f554"
  },
  {
    n: [
      "clock face five-thirty",
      "clock530"
    ],
    u: "1f560"
  },
  {
    n: [
      "clock face six oclock",
      "clock6"
    ],
    u: "1f555"
  },
  {
    n: [
      "clock face six-thirty",
      "clock630"
    ],
    u: "1f561"
  },
  {
    n: [
      "clock face seven oclock",
      "clock7"
    ],
    u: "1f556"
  },
  {
    n: [
      "clock face seven-thirty",
      "clock730"
    ],
    u: "1f562"
  },
  {
    n: [
      "clock face eight oclock",
      "clock8"
    ],
    u: "1f557"
  },
  {
    n: [
      "clock face eight-thirty",
      "clock830"
    ],
    u: "1f563"
  },
  {
    n: [
      "clock face nine oclock",
      "clock9"
    ],
    u: "1f558"
  },
  {
    n: [
      "clock face nine-thirty",
      "clock930"
    ],
    u: "1f564"
  },
  {
    n: [
      "clock face ten oclock",
      "clock10"
    ],
    u: "1f559"
  },
  {
    n: [
      "clock face ten-thirty",
      "clock1030"
    ],
    u: "1f565"
  },
  {
    n: [
      "clock face eleven oclock",
      "clock11"
    ],
    u: "1f55a"
  },
  {
    n: [
      "clock face eleven-thirty",
      "clock1130"
    ],
    u: "1f566"
  },
  {
    n: [
      "new moon symbol",
      "new_moon"
    ],
    u: "1f311"
  },
  {
    n: [
      "waxing crescent moon symbol",
      "waxing_crescent_moon"
    ],
    u: "1f312"
  },
  {
    n: [
      "first quarter moon symbol",
      "first_quarter_moon"
    ],
    u: "1f313"
  },
  {
    n: [
      "waxing gibbous moon symbol",
      "moon",
      "waxing_gibbous_moon"
    ],
    u: "1f314"
  },
  {
    n: [
      "full moon symbol",
      "full_moon"
    ],
    u: "1f315"
  },
  {
    n: [
      "waning gibbous moon symbol",
      "waning_gibbous_moon"
    ],
    u: "1f316"
  },
  {
    n: [
      "last quarter moon symbol",
      "last_quarter_moon"
    ],
    u: "1f317"
  },
  {
    n: [
      "waning crescent moon symbol",
      "waning_crescent_moon"
    ],
    u: "1f318"
  },
  {
    n: [
      "crescent moon",
      "crescent_moon"
    ],
    u: "1f319"
  },
  {
    n: [
      "new moon with face",
      "new_moon_with_face"
    ],
    u: "1f31a"
  },
  {
    n: [
      "first quarter moon with face",
      "first_quarter_moon_with_face"
    ],
    u: "1f31b"
  },
  {
    n: [
      "last quarter moon with face",
      "last_quarter_moon_with_face"
    ],
    u: "1f31c"
  },
  {
    n: [
      "thermometer"
    ],
    u: "1f321-fe0f"
  },
  {
    n: [
      "black sun with rays",
      "sunny"
    ],
    u: "2600-fe0f"
  },
  {
    n: [
      "full moon with face",
      "full_moon_with_face"
    ],
    u: "1f31d"
  },
  {
    n: [
      "sun with face",
      "sun_with_face"
    ],
    u: "1f31e"
  },
  {
    n: [
      "white medium star",
      "star"
    ],
    u: "2b50"
  },
  {
    n: [
      "glowing star",
      "star2"
    ],
    u: "1f31f"
  },
  {
    n: [
      "shooting star",
      "stars"
    ],
    u: "1f320"
  },
  {
    n: [
      "cloud"
    ],
    u: "2601-fe0f"
  },
  {
    n: [
      "sun behind cloud",
      "partly_sunny"
    ],
    u: "26c5"
  },
  {
    n: [
      "thunder_cloud_and_rain"
    ],
    u: "26c8-fe0f"
  },
  {
    n: [
      "mostly_sunny",
      "sun_small_cloud"
    ],
    u: "1f324-fe0f"
  },
  {
    n: [
      "barely_sunny",
      "sun_behind_cloud"
    ],
    u: "1f325-fe0f"
  },
  {
    n: [
      "partly_sunny_rain",
      "sun_behind_rain_cloud"
    ],
    u: "1f326-fe0f"
  },
  {
    n: [
      "rain_cloud"
    ],
    u: "1f327-fe0f"
  },
  {
    n: [
      "snow_cloud"
    ],
    u: "1f328-fe0f"
  },
  {
    n: [
      "lightning",
      "lightning_cloud"
    ],
    u: "1f329-fe0f"
  },
  {
    n: [
      "tornado",
      "tornado_cloud"
    ],
    u: "1f32a-fe0f"
  },
  {
    n: [
      "fog"
    ],
    u: "1f32b-fe0f"
  },
  {
    n: [
      "wind_blowing_face"
    ],
    u: "1f32c-fe0f"
  },
  {
    n: [
      "cyclone"
    ],
    u: "1f300"
  },
  {
    n: [
      "rainbow"
    ],
    u: "1f308"
  },
  {
    n: [
      "closed umbrella",
      "closed_umbrella"
    ],
    u: "1f302"
  },
  {
    n: [
      "umbrella"
    ],
    u: "2602-fe0f"
  },
  {
    n: [
      "umbrella with rain drops",
      "umbrella_with_rain_drops"
    ],
    u: "2614"
  },
  {
    n: [
      "umbrella_on_ground"
    ],
    u: "26f1-fe0f"
  },
  {
    n: [
      "high voltage sign",
      "zap"
    ],
    u: "26a1"
  },
  {
    n: [
      "snowflake"
    ],
    u: "2744-fe0f"
  },
  {
    n: [
      "snowman"
    ],
    u: "2603-fe0f"
  },
  {
    n: [
      "snowman without snow",
      "snowman_without_snow"
    ],
    u: "26c4"
  },
  {
    n: [
      "comet"
    ],
    u: "2604-fe0f"
  },
  {
    n: [
      "fire"
    ],
    u: "1f525"
  },
  {
    n: [
      "droplet"
    ],
    u: "1f4a7"
  },
  {
    n: [
      "water wave",
      "ocean"
    ],
    u: "1f30a"
  }
], yR = [
  {
    n: [
      "speaker with cancellation stroke",
      "mute"
    ],
    u: "1f507"
  },
  {
    n: [
      "speaker"
    ],
    u: "1f508"
  },
  {
    n: [
      "speaker with one sound wave",
      "sound"
    ],
    u: "1f509"
  },
  {
    n: [
      "speaker with three sound waves",
      "loud_sound"
    ],
    u: "1f50a"
  },
  {
    n: [
      "public address loudspeaker",
      "loudspeaker"
    ],
    u: "1f4e2"
  },
  {
    n: [
      "cheering megaphone",
      "mega"
    ],
    u: "1f4e3"
  },
  {
    n: [
      "postal horn",
      "postal_horn"
    ],
    u: "1f4ef"
  },
  {
    n: [
      "bell"
    ],
    u: "1f514"
  },
  {
    n: [
      "bell with cancellation stroke",
      "no_bell"
    ],
    u: "1f515"
  },
  {
    n: [
      "musical score",
      "musical_score"
    ],
    u: "1f3bc"
  },
  {
    n: [
      "musical note",
      "musical_note"
    ],
    u: "1f3b5"
  },
  {
    n: [
      "multiple musical notes",
      "notes"
    ],
    u: "1f3b6"
  },
  {
    n: [
      "studio_microphone"
    ],
    u: "1f399-fe0f"
  },
  {
    n: [
      "level_slider"
    ],
    u: "1f39a-fe0f"
  },
  {
    n: [
      "control_knobs"
    ],
    u: "1f39b-fe0f"
  },
  {
    n: [
      "microphone"
    ],
    u: "1f3a4"
  },
  {
    n: [
      "headphone",
      "headphones"
    ],
    u: "1f3a7"
  },
  {
    n: [
      "radio"
    ],
    u: "1f4fb"
  },
  {
    n: [
      "saxophone"
    ],
    u: "1f3b7"
  },
  {
    n: [
      "guitar"
    ],
    u: "1f3b8"
  },
  {
    n: [
      "musical keyboard",
      "musical_keyboard"
    ],
    u: "1f3b9"
  },
  {
    n: [
      "trumpet"
    ],
    u: "1f3ba"
  },
  {
    n: [
      "violin"
    ],
    u: "1f3bb"
  },
  {
    n: [
      "drum with drumsticks",
      "drum_with_drumsticks"
    ],
    u: "1f941"
  },
  {
    n: [
      "mobile phone",
      "iphone"
    ],
    u: "1f4f1"
  },
  {
    n: [
      "mobile phone with rightwards arrow at left",
      "calling"
    ],
    u: "1f4f2"
  },
  {
    n: [
      "black telephone",
      "phone",
      "telephone"
    ],
    u: "260e-fe0f"
  },
  {
    n: [
      "telephone receiver",
      "telephone_receiver"
    ],
    u: "1f4de"
  },
  {
    n: [
      "pager"
    ],
    u: "1f4df"
  },
  {
    n: [
      "fax machine",
      "fax"
    ],
    u: "1f4e0"
  },
  {
    n: [
      "battery"
    ],
    u: "1f50b"
  },
  {
    n: [
      "electric plug",
      "electric_plug"
    ],
    u: "1f50c"
  },
  {
    n: [
      "personal computer",
      "computer"
    ],
    u: "1f4bb"
  },
  {
    n: [
      "desktop_computer"
    ],
    u: "1f5a5-fe0f"
  },
  {
    n: [
      "printer"
    ],
    u: "1f5a8-fe0f"
  },
  {
    n: [
      "keyboard"
    ],
    u: "2328-fe0f"
  },
  {
    n: [
      "three_button_mouse"
    ],
    u: "1f5b1-fe0f"
  },
  {
    n: [
      "trackball"
    ],
    u: "1f5b2-fe0f"
  },
  {
    n: [
      "minidisc"
    ],
    u: "1f4bd"
  },
  {
    n: [
      "floppy disk",
      "floppy_disk"
    ],
    u: "1f4be"
  },
  {
    n: [
      "optical disc",
      "cd"
    ],
    u: "1f4bf"
  },
  {
    n: [
      "dvd"
    ],
    u: "1f4c0"
  },
  {
    n: [
      "movie camera",
      "movie_camera"
    ],
    u: "1f3a5"
  },
  {
    n: [
      "film_frames"
    ],
    u: "1f39e-fe0f"
  },
  {
    n: [
      "film_projector"
    ],
    u: "1f4fd-fe0f"
  },
  {
    n: [
      "clapper board",
      "clapper"
    ],
    u: "1f3ac"
  },
  {
    n: [
      "television",
      "tv"
    ],
    u: "1f4fa"
  },
  {
    n: [
      "camera"
    ],
    u: "1f4f7"
  },
  {
    n: [
      "camera with flash",
      "camera_with_flash"
    ],
    u: "1f4f8"
  },
  {
    n: [
      "video camera",
      "video_camera"
    ],
    u: "1f4f9"
  },
  {
    n: [
      "videocassette",
      "vhs"
    ],
    u: "1f4fc"
  },
  {
    n: [
      "left-pointing magnifying glass",
      "mag"
    ],
    u: "1f50d"
  },
  {
    n: [
      "right-pointing magnifying glass",
      "mag_right"
    ],
    u: "1f50e"
  },
  {
    n: [
      "microscope"
    ],
    u: "1f52c"
  },
  {
    n: [
      "telescope"
    ],
    u: "1f52d"
  },
  {
    n: [
      "satellite antenna",
      "satellite_antenna"
    ],
    u: "1f4e1"
  },
  {
    n: [
      "candle"
    ],
    u: "1f56f-fe0f"
  },
  {
    n: [
      "electric light bulb",
      "bulb"
    ],
    u: "1f4a1"
  },
  {
    n: [
      "electric torch",
      "flashlight"
    ],
    u: "1f526"
  },
  {
    n: [
      "izakaya lantern",
      "izakaya_lantern",
      "lantern"
    ],
    u: "1f3ee"
  },
  {
    n: [
      "notebook with decorative cover",
      "notebook_with_decorative_cover"
    ],
    u: "1f4d4"
  },
  {
    n: [
      "closed book",
      "closed_book"
    ],
    u: "1f4d5"
  },
  {
    n: [
      "open book",
      "book",
      "open_book"
    ],
    u: "1f4d6"
  },
  {
    n: [
      "green book",
      "green_book"
    ],
    u: "1f4d7"
  },
  {
    n: [
      "blue book",
      "blue_book"
    ],
    u: "1f4d8"
  },
  {
    n: [
      "orange book",
      "orange_book"
    ],
    u: "1f4d9"
  },
  {
    n: [
      "books"
    ],
    u: "1f4da"
  },
  {
    n: [
      "notebook"
    ],
    u: "1f4d3"
  },
  {
    n: [
      "ledger"
    ],
    u: "1f4d2"
  },
  {
    n: [
      "page with curl",
      "page_with_curl"
    ],
    u: "1f4c3"
  },
  {
    n: [
      "scroll"
    ],
    u: "1f4dc"
  },
  {
    n: [
      "page facing up",
      "page_facing_up"
    ],
    u: "1f4c4"
  },
  {
    n: [
      "newspaper"
    ],
    u: "1f4f0"
  },
  {
    n: [
      "rolled_up_newspaper"
    ],
    u: "1f5de-fe0f"
  },
  {
    n: [
      "bookmark tabs",
      "bookmark_tabs"
    ],
    u: "1f4d1"
  },
  {
    n: [
      "bookmark"
    ],
    u: "1f516"
  },
  {
    n: [
      "label"
    ],
    u: "1f3f7-fe0f"
  },
  {
    n: [
      "money bag",
      "moneybag"
    ],
    u: "1f4b0"
  },
  {
    n: [
      "banknote with yen sign",
      "yen"
    ],
    u: "1f4b4"
  },
  {
    n: [
      "banknote with dollar sign",
      "dollar"
    ],
    u: "1f4b5"
  },
  {
    n: [
      "banknote with euro sign",
      "euro"
    ],
    u: "1f4b6"
  },
  {
    n: [
      "banknote with pound sign",
      "pound"
    ],
    u: "1f4b7"
  },
  {
    n: [
      "money with wings",
      "money_with_wings"
    ],
    u: "1f4b8"
  },
  {
    n: [
      "credit card",
      "credit_card"
    ],
    u: "1f4b3"
  },
  {
    n: [
      "chart with upwards trend and yen sign",
      "chart"
    ],
    u: "1f4b9"
  },
  {
    n: [
      "currency exchange",
      "currency_exchange"
    ],
    u: "1f4b1"
  },
  {
    n: [
      "heavy dollar sign",
      "heavy_dollar_sign"
    ],
    u: "1f4b2"
  },
  {
    n: [
      "envelope",
      "email"
    ],
    u: "2709-fe0f"
  },
  {
    n: [
      "e-mail symbol",
      "e-mail"
    ],
    u: "1f4e7"
  },
  {
    n: [
      "incoming envelope",
      "incoming_envelope"
    ],
    u: "1f4e8"
  },
  {
    n: [
      "envelope with downwards arrow above",
      "envelope_with_arrow"
    ],
    u: "1f4e9"
  },
  {
    n: [
      "outbox tray",
      "outbox_tray"
    ],
    u: "1f4e4"
  },
  {
    n: [
      "inbox tray",
      "inbox_tray"
    ],
    u: "1f4e5"
  },
  {
    n: [
      "package"
    ],
    u: "1f4e6"
  },
  {
    n: [
      "closed mailbox with raised flag",
      "mailbox"
    ],
    u: "1f4eb"
  },
  {
    n: [
      "closed mailbox with lowered flag",
      "mailbox_closed"
    ],
    u: "1f4ea"
  },
  {
    n: [
      "open mailbox with raised flag",
      "mailbox_with_mail"
    ],
    u: "1f4ec"
  },
  {
    n: [
      "open mailbox with lowered flag",
      "mailbox_with_no_mail"
    ],
    u: "1f4ed"
  },
  {
    n: [
      "postbox"
    ],
    u: "1f4ee"
  },
  {
    n: [
      "ballot_box_with_ballot"
    ],
    u: "1f5f3-fe0f"
  },
  {
    n: [
      "pencil",
      "pencil2"
    ],
    u: "270f-fe0f"
  },
  {
    n: [
      "black nib",
      "black_nib"
    ],
    u: "2712-fe0f"
  },
  {
    n: [
      "lower_left_fountain_pen"
    ],
    u: "1f58b-fe0f"
  },
  {
    n: [
      "lower_left_ballpoint_pen"
    ],
    u: "1f58a-fe0f"
  },
  {
    n: [
      "lower_left_paintbrush"
    ],
    u: "1f58c-fe0f"
  },
  {
    n: [
      "lower_left_crayon"
    ],
    u: "1f58d-fe0f"
  },
  {
    n: [
      "memo",
      "pencil"
    ],
    u: "1f4dd"
  },
  {
    n: [
      "briefcase"
    ],
    u: "1f4bc"
  },
  {
    n: [
      "file folder",
      "file_folder"
    ],
    u: "1f4c1"
  },
  {
    n: [
      "open file folder",
      "open_file_folder"
    ],
    u: "1f4c2"
  },
  {
    n: [
      "card_index_dividers"
    ],
    u: "1f5c2-fe0f"
  },
  {
    n: [
      "calendar",
      "date"
    ],
    u: "1f4c5"
  },
  {
    n: [
      "tear-off calendar",
      "calendar"
    ],
    u: "1f4c6"
  },
  {
    n: [
      "spiral_note_pad"
    ],
    u: "1f5d2-fe0f"
  },
  {
    n: [
      "spiral_calendar_pad"
    ],
    u: "1f5d3-fe0f"
  },
  {
    n: [
      "card index",
      "card_index"
    ],
    u: "1f4c7"
  },
  {
    n: [
      "chart with upwards trend",
      "chart_with_upwards_trend"
    ],
    u: "1f4c8"
  },
  {
    n: [
      "chart with downwards trend",
      "chart_with_downwards_trend"
    ],
    u: "1f4c9"
  },
  {
    n: [
      "bar chart",
      "bar_chart"
    ],
    u: "1f4ca"
  },
  {
    n: [
      "clipboard"
    ],
    u: "1f4cb"
  },
  {
    n: [
      "pushpin"
    ],
    u: "1f4cc"
  },
  {
    n: [
      "round pushpin",
      "round_pushpin"
    ],
    u: "1f4cd"
  },
  {
    n: [
      "paperclip"
    ],
    u: "1f4ce"
  },
  {
    n: [
      "linked_paperclips"
    ],
    u: "1f587-fe0f"
  },
  {
    n: [
      "straight ruler",
      "straight_ruler"
    ],
    u: "1f4cf"
  },
  {
    n: [
      "triangular ruler",
      "triangular_ruler"
    ],
    u: "1f4d0"
  },
  {
    n: [
      "black scissors",
      "scissors"
    ],
    u: "2702-fe0f"
  },
  {
    n: [
      "card_file_box"
    ],
    u: "1f5c3-fe0f"
  },
  {
    n: [
      "file_cabinet"
    ],
    u: "1f5c4-fe0f"
  },
  {
    n: [
      "wastebasket"
    ],
    u: "1f5d1-fe0f"
  },
  {
    n: [
      "lock"
    ],
    u: "1f512"
  },
  {
    n: [
      "open lock",
      "unlock"
    ],
    u: "1f513"
  },
  {
    n: [
      "lock with ink pen",
      "lock_with_ink_pen"
    ],
    u: "1f50f"
  },
  {
    n: [
      "closed lock with key",
      "closed_lock_with_key"
    ],
    u: "1f510"
  },
  {
    n: [
      "key"
    ],
    u: "1f511"
  },
  {
    n: [
      "old_key"
    ],
    u: "1f5dd-fe0f"
  },
  {
    n: [
      "hammer"
    ],
    u: "1f528"
  },
  {
    n: [
      "pick"
    ],
    u: "26cf-fe0f"
  },
  {
    n: [
      "hammer_and_pick"
    ],
    u: "2692-fe0f"
  },
  {
    n: [
      "hammer_and_wrench"
    ],
    u: "1f6e0-fe0f"
  },
  {
    n: [
      "dagger_knife"
    ],
    u: "1f5e1-fe0f"
  },
  {
    n: [
      "crossed_swords"
    ],
    u: "2694-fe0f"
  },
  {
    n: [
      "pistol",
      "gun"
    ],
    u: "1f52b"
  },
  {
    n: [
      "bow and arrow",
      "bow_and_arrow"
    ],
    u: "1f3f9"
  },
  {
    n: [
      "shield"
    ],
    u: "1f6e1-fe0f"
  },
  {
    n: [
      "wrench"
    ],
    u: "1f527"
  },
  {
    n: [
      "nut and bolt",
      "nut_and_bolt"
    ],
    u: "1f529"
  },
  {
    n: [
      "gear"
    ],
    u: "2699-fe0f"
  },
  {
    n: [
      "compression"
    ],
    u: "1f5dc-fe0f"
  },
  {
    n: [
      "alembic"
    ],
    u: "2697-fe0f"
  },
  {
    n: [
      "scales"
    ],
    u: "2696-fe0f"
  },
  {
    n: [
      "link symbol",
      "link"
    ],
    u: "1f517"
  },
  {
    n: [
      "chains"
    ],
    u: "26d3-fe0f"
  },
  {
    n: [
      "syringe"
    ],
    u: "1f489"
  },
  {
    n: [
      "pill"
    ],
    u: "1f48a"
  },
  {
    n: [
      "smoking symbol",
      "smoking"
    ],
    u: "1f6ac"
  },
  {
    n: [
      "coffin"
    ],
    u: "26b0-fe0f"
  },
  {
    n: [
      "funeral_urn"
    ],
    u: "26b1-fe0f"
  },
  {
    n: [
      "moyai"
    ],
    u: "1f5ff"
  },
  {
    n: [
      "oil_drum"
    ],
    u: "1f6e2-fe0f"
  },
  {
    n: [
      "crystal ball",
      "crystal_ball"
    ],
    u: "1f52e"
  },
  {
    n: [
      "shopping trolley",
      "shopping_trolley"
    ],
    u: "1f6d2"
  }
], vR = [
  {
    n: [
      "automated teller machine",
      "atm"
    ],
    u: "1f3e7"
  },
  {
    n: [
      "put litter in its place symbol",
      "put_litter_in_its_place"
    ],
    u: "1f6ae"
  },
  {
    n: [
      "potable water symbol",
      "potable_water"
    ],
    u: "1f6b0"
  },
  {
    n: [
      "wheelchair symbol",
      "wheelchair"
    ],
    u: "267f"
  },
  {
    n: [
      "mens symbol",
      "mens"
    ],
    u: "1f6b9"
  },
  {
    n: [
      "womens symbol",
      "womens"
    ],
    u: "1f6ba"
  },
  {
    n: [
      "restroom"
    ],
    u: "1f6bb"
  },
  {
    n: [
      "baby symbol",
      "baby_symbol"
    ],
    u: "1f6bc"
  },
  {
    n: [
      "water closet",
      "wc"
    ],
    u: "1f6be"
  },
  {
    n: [
      "passport control",
      "passport_control"
    ],
    u: "1f6c2"
  },
  {
    n: [
      "customs"
    ],
    u: "1f6c3"
  },
  {
    n: [
      "baggage claim",
      "baggage_claim"
    ],
    u: "1f6c4"
  },
  {
    n: [
      "left luggage",
      "left_luggage"
    ],
    u: "1f6c5"
  },
  {
    n: [
      "warning sign",
      "warning"
    ],
    u: "26a0-fe0f"
  },
  {
    n: [
      "children crossing",
      "children_crossing"
    ],
    u: "1f6b8"
  },
  {
    n: [
      "no entry",
      "no_entry"
    ],
    u: "26d4"
  },
  {
    n: [
      "no entry sign",
      "no_entry_sign"
    ],
    u: "1f6ab"
  },
  {
    n: [
      "no bicycles",
      "no_bicycles"
    ],
    u: "1f6b3"
  },
  {
    n: [
      "no smoking symbol",
      "no_smoking"
    ],
    u: "1f6ad"
  },
  {
    n: [
      "do not litter symbol",
      "do_not_litter"
    ],
    u: "1f6af"
  },
  {
    n: [
      "non-potable water symbol",
      "non-potable_water"
    ],
    u: "1f6b1"
  },
  {
    n: [
      "no pedestrians",
      "no_pedestrians"
    ],
    u: "1f6b7"
  },
  {
    n: [
      "no mobile phones",
      "no_mobile_phones"
    ],
    u: "1f4f5"
  },
  {
    n: [
      "no one under eighteen symbol",
      "underage"
    ],
    u: "1f51e"
  },
  {
    n: [
      "radioactive_sign"
    ],
    u: "2622-fe0f"
  },
  {
    n: [
      "biohazard_sign"
    ],
    u: "2623-fe0f"
  },
  {
    n: [
      "upwards black arrow",
      "arrow_up"
    ],
    u: "2b06-fe0f"
  },
  {
    n: [
      "north east arrow",
      "arrow_upper_right"
    ],
    u: "2197-fe0f"
  },
  {
    n: [
      "black rightwards arrow",
      "arrow_right"
    ],
    u: "27a1-fe0f"
  },
  {
    n: [
      "south east arrow",
      "arrow_lower_right"
    ],
    u: "2198-fe0f"
  },
  {
    n: [
      "downwards black arrow",
      "arrow_down"
    ],
    u: "2b07-fe0f"
  },
  {
    n: [
      "south west arrow",
      "arrow_lower_left"
    ],
    u: "2199-fe0f"
  },
  {
    n: [
      "leftwards black arrow",
      "arrow_left"
    ],
    u: "2b05-fe0f"
  },
  {
    n: [
      "north west arrow",
      "arrow_upper_left"
    ],
    u: "2196-fe0f"
  },
  {
    n: [
      "up down arrow",
      "arrow_up_down"
    ],
    u: "2195-fe0f"
  },
  {
    n: [
      "left right arrow",
      "left_right_arrow"
    ],
    u: "2194-fe0f"
  },
  {
    n: [
      "leftwards arrow with hook",
      "leftwards_arrow_with_hook"
    ],
    u: "21a9-fe0f"
  },
  {
    n: [
      "rightwards arrow with hook",
      "arrow_right_hook"
    ],
    u: "21aa-fe0f"
  },
  {
    n: [
      "arrow pointing rightwards then curving upwards",
      "arrow_heading_up"
    ],
    u: "2934-fe0f"
  },
  {
    n: [
      "arrow pointing rightwards then curving downwards",
      "arrow_heading_down"
    ],
    u: "2935-fe0f"
  },
  {
    n: [
      "clockwise downwards and upwards open circle arrows",
      "arrows_clockwise"
    ],
    u: "1f503"
  },
  {
    n: [
      "anticlockwise downwards and upwards open circle arrows",
      "arrows_counterclockwise"
    ],
    u: "1f504"
  },
  {
    n: [
      "back with leftwards arrow above",
      "back"
    ],
    u: "1f519"
  },
  {
    n: [
      "end with leftwards arrow above",
      "end"
    ],
    u: "1f51a"
  },
  {
    n: [
      "on with exclamation mark with left right arrow above",
      "on"
    ],
    u: "1f51b"
  },
  {
    n: [
      "soon with rightwards arrow above",
      "soon"
    ],
    u: "1f51c"
  },
  {
    n: [
      "top with upwards arrow above",
      "top"
    ],
    u: "1f51d"
  },
  {
    n: [
      "place of worship",
      "place_of_worship"
    ],
    u: "1f6d0"
  },
  {
    n: [
      "atom_symbol"
    ],
    u: "269b-fe0f"
  },
  {
    n: [
      "om_symbol"
    ],
    u: "1f549-fe0f"
  },
  {
    n: [
      "star_of_david"
    ],
    u: "2721-fe0f"
  },
  {
    n: [
      "wheel_of_dharma"
    ],
    u: "2638-fe0f"
  },
  {
    n: [
      "yin_yang"
    ],
    u: "262f-fe0f"
  },
  {
    n: [
      "latin_cross"
    ],
    u: "271d-fe0f"
  },
  {
    n: [
      "orthodox_cross"
    ],
    u: "2626-fe0f"
  },
  {
    n: [
      "star_and_crescent"
    ],
    u: "262a-fe0f"
  },
  {
    n: [
      "peace_symbol"
    ],
    u: "262e-fe0f"
  },
  {
    n: [
      "menorah with nine branches",
      "menorah_with_nine_branches"
    ],
    u: "1f54e"
  },
  {
    n: [
      "six pointed star with middle dot",
      "six_pointed_star"
    ],
    u: "1f52f"
  },
  {
    n: [
      "aries"
    ],
    u: "2648"
  },
  {
    n: [
      "taurus"
    ],
    u: "2649"
  },
  {
    n: [
      "gemini"
    ],
    u: "264a"
  },
  {
    n: [
      "cancer"
    ],
    u: "264b"
  },
  {
    n: [
      "leo"
    ],
    u: "264c"
  },
  {
    n: [
      "virgo"
    ],
    u: "264d"
  },
  {
    n: [
      "libra"
    ],
    u: "264e"
  },
  {
    n: [
      "scorpius"
    ],
    u: "264f"
  },
  {
    n: [
      "sagittarius"
    ],
    u: "2650"
  },
  {
    n: [
      "capricorn"
    ],
    u: "2651"
  },
  {
    n: [
      "aquarius"
    ],
    u: "2652"
  },
  {
    n: [
      "pisces"
    ],
    u: "2653"
  },
  {
    n: [
      "ophiuchus"
    ],
    u: "26ce"
  },
  {
    n: [
      "twisted rightwards arrows",
      "twisted_rightwards_arrows"
    ],
    u: "1f500"
  },
  {
    n: [
      "clockwise rightwards and leftwards open circle arrows",
      "repeat"
    ],
    u: "1f501"
  },
  {
    n: [
      "clockwise rightwards and leftwards open circle arrows with circled one overlay",
      "repeat_one"
    ],
    u: "1f502"
  },
  {
    n: [
      "black right-pointing triangle",
      "arrow_forward"
    ],
    u: "25b6-fe0f"
  },
  {
    n: [
      "black right-pointing double triangle",
      "fast_forward"
    ],
    u: "23e9"
  },
  {
    n: [
      "black_right_pointing_double_triangle_with_vertical_bar"
    ],
    u: "23ed-fe0f"
  },
  {
    n: [
      "black_right_pointing_triangle_with_double_vertical_bar"
    ],
    u: "23ef-fe0f"
  },
  {
    n: [
      "black left-pointing triangle",
      "arrow_backward"
    ],
    u: "25c0-fe0f"
  },
  {
    n: [
      "black left-pointing double triangle",
      "rewind"
    ],
    u: "23ea"
  },
  {
    n: [
      "black_left_pointing_double_triangle_with_vertical_bar"
    ],
    u: "23ee-fe0f"
  },
  {
    n: [
      "up-pointing small red triangle",
      "arrow_up_small"
    ],
    u: "1f53c"
  },
  {
    n: [
      "black up-pointing double triangle",
      "arrow_double_up"
    ],
    u: "23eb"
  },
  {
    n: [
      "down-pointing small red triangle",
      "arrow_down_small"
    ],
    u: "1f53d"
  },
  {
    n: [
      "black down-pointing double triangle",
      "arrow_double_down"
    ],
    u: "23ec"
  },
  {
    n: [
      "double_vertical_bar"
    ],
    u: "23f8-fe0f"
  },
  {
    n: [
      "black_square_for_stop"
    ],
    u: "23f9-fe0f"
  },
  {
    n: [
      "black_circle_for_record"
    ],
    u: "23fa-fe0f"
  },
  {
    n: [
      "eject"
    ],
    u: "23cf-fe0f"
  },
  {
    n: [
      "cinema"
    ],
    u: "1f3a6"
  },
  {
    n: [
      "low brightness symbol",
      "low_brightness"
    ],
    u: "1f505"
  },
  {
    n: [
      "high brightness symbol",
      "high_brightness"
    ],
    u: "1f506"
  },
  {
    n: [
      "antenna with bars",
      "signal_strength"
    ],
    u: "1f4f6"
  },
  {
    n: [
      "vibration mode",
      "vibration_mode"
    ],
    u: "1f4f3"
  },
  {
    n: [
      "mobile phone off",
      "mobile_phone_off"
    ],
    u: "1f4f4"
  },
  {
    n: [
      "female_sign"
    ],
    u: "2640-fe0f"
  },
  {
    n: [
      "male_sign"
    ],
    u: "2642-fe0f"
  },
  {
    n: [
      "medical_symbol",
      "staff_of_aesculapius"
    ],
    u: "2695-fe0f"
  },
  {
    n: [
      "black universal recycling symbol",
      "recycle"
    ],
    u: "267b-fe0f"
  },
  {
    n: [
      "fleur_de_lis"
    ],
    u: "269c-fe0f"
  },
  {
    n: [
      "trident emblem",
      "trident"
    ],
    u: "1f531"
  },
  {
    n: [
      "name badge",
      "name_badge"
    ],
    u: "1f4db"
  },
  {
    n: [
      "japanese symbol for beginner",
      "beginner"
    ],
    u: "1f530"
  },
  {
    n: [
      "heavy large circle",
      "o"
    ],
    u: "2b55"
  },
  {
    n: [
      "white heavy check mark",
      "white_check_mark"
    ],
    u: "2705"
  },
  {
    n: [
      "ballot box with check",
      "ballot_box_with_check"
    ],
    u: "2611-fe0f"
  },
  {
    n: [
      "heavy check mark",
      "heavy_check_mark"
    ],
    u: "2714-fe0f"
  },
  {
    n: [
      "heavy multiplication x",
      "heavy_multiplication_x"
    ],
    u: "2716-fe0f"
  },
  {
    n: [
      "cross mark",
      "x"
    ],
    u: "274c"
  },
  {
    n: [
      "negative squared cross mark",
      "negative_squared_cross_mark"
    ],
    u: "274e"
  },
  {
    n: [
      "heavy plus sign",
      "heavy_plus_sign"
    ],
    u: "2795"
  },
  {
    n: [
      "heavy minus sign",
      "heavy_minus_sign"
    ],
    u: "2796"
  },
  {
    n: [
      "heavy division sign",
      "heavy_division_sign"
    ],
    u: "2797"
  },
  {
    n: [
      "curly loop",
      "curly_loop"
    ],
    u: "27b0"
  },
  {
    n: [
      "double curly loop",
      "loop"
    ],
    u: "27bf"
  },
  {
    n: [
      "part alternation mark",
      "part_alternation_mark"
    ],
    u: "303d-fe0f"
  },
  {
    n: [
      "eight spoked asterisk",
      "eight_spoked_asterisk"
    ],
    u: "2733-fe0f"
  },
  {
    n: [
      "eight pointed black star",
      "eight_pointed_black_star"
    ],
    u: "2734-fe0f"
  },
  {
    n: [
      "sparkle"
    ],
    u: "2747-fe0f"
  },
  {
    n: [
      "double exclamation mark",
      "bangbang"
    ],
    u: "203c-fe0f"
  },
  {
    n: [
      "exclamation question mark",
      "interrobang"
    ],
    u: "2049-fe0f"
  },
  {
    n: [
      "black question mark ornament",
      "question"
    ],
    u: "2753"
  },
  {
    n: [
      "white question mark ornament",
      "grey_question"
    ],
    u: "2754"
  },
  {
    n: [
      "white exclamation mark ornament",
      "grey_exclamation"
    ],
    u: "2755"
  },
  {
    n: [
      "heavy exclamation mark symbol",
      "exclamation",
      "heavy_exclamation_mark"
    ],
    u: "2757"
  },
  {
    n: [
      "wavy dash",
      "wavy_dash"
    ],
    u: "3030-fe0f"
  },
  {
    n: [
      "copyright sign",
      "copyright"
    ],
    u: "00a9-fe0f"
  },
  {
    n: [
      "registered sign",
      "registered"
    ],
    u: "00ae-fe0f"
  },
  {
    n: [
      "trade mark sign",
      "tm"
    ],
    u: "2122-fe0f"
  },
  {
    n: [
      "hash key",
      "hash"
    ],
    u: "0023-fe0f-20e3"
  },
  {
    n: [
      "keycap_star"
    ],
    u: "002a-fe0f-20e3"
  },
  {
    n: [
      "keycap 0",
      "zero"
    ],
    u: "0030-fe0f-20e3"
  },
  {
    n: [
      "keycap 1",
      "one"
    ],
    u: "0031-fe0f-20e3"
  },
  {
    n: [
      "keycap 2",
      "two"
    ],
    u: "0032-fe0f-20e3"
  },
  {
    n: [
      "keycap 3",
      "three"
    ],
    u: "0033-fe0f-20e3"
  },
  {
    n: [
      "keycap 4",
      "four"
    ],
    u: "0034-fe0f-20e3"
  },
  {
    n: [
      "keycap 5",
      "five"
    ],
    u: "0035-fe0f-20e3"
  },
  {
    n: [
      "keycap 6",
      "six"
    ],
    u: "0036-fe0f-20e3"
  },
  {
    n: [
      "keycap 7",
      "seven"
    ],
    u: "0037-fe0f-20e3"
  },
  {
    n: [
      "keycap 8",
      "eight"
    ],
    u: "0038-fe0f-20e3"
  },
  {
    n: [
      "keycap 9",
      "nine"
    ],
    u: "0039-fe0f-20e3"
  },
  {
    n: [
      "keycap ten",
      "keycap_ten"
    ],
    u: "1f51f"
  },
  {
    n: [
      "hundred points symbol",
      "100"
    ],
    u: "1f4af"
  },
  {
    n: [
      "input symbol for latin capital letters",
      "capital_abcd"
    ],
    u: "1f520"
  },
  {
    n: [
      "input symbol for latin small letters",
      "abcd"
    ],
    u: "1f521"
  },
  {
    n: [
      "input symbol for numbers",
      "1234"
    ],
    u: "1f522"
  },
  {
    n: [
      "input symbol for symbols",
      "symbols"
    ],
    u: "1f523"
  },
  {
    n: [
      "input symbol for latin letters",
      "abc"
    ],
    u: "1f524"
  },
  {
    n: [
      "negative squared latin capital letter a",
      "a"
    ],
    u: "1f170-fe0f"
  },
  {
    n: [
      "negative squared ab",
      "ab"
    ],
    u: "1f18e"
  },
  {
    n: [
      "negative squared latin capital letter b",
      "b"
    ],
    u: "1f171-fe0f"
  },
  {
    n: [
      "squared cl",
      "cl"
    ],
    u: "1f191"
  },
  {
    n: [
      "squared cool",
      "cool"
    ],
    u: "1f192"
  },
  {
    n: [
      "squared free",
      "free"
    ],
    u: "1f193"
  },
  {
    n: [
      "information source",
      "information_source"
    ],
    u: "2139-fe0f"
  },
  {
    n: [
      "squared id",
      "id"
    ],
    u: "1f194"
  },
  {
    n: [
      "circled latin capital letter m",
      "m"
    ],
    u: "24c2-fe0f"
  },
  {
    n: [
      "squared new",
      "new"
    ],
    u: "1f195"
  },
  {
    n: [
      "squared ng",
      "ng"
    ],
    u: "1f196"
  },
  {
    n: [
      "negative squared latin capital letter o",
      "o2"
    ],
    u: "1f17e-fe0f"
  },
  {
    n: [
      "squared ok",
      "ok"
    ],
    u: "1f197"
  },
  {
    n: [
      "negative squared latin capital letter p",
      "parking"
    ],
    u: "1f17f-fe0f"
  },
  {
    n: [
      "squared sos",
      "sos"
    ],
    u: "1f198"
  },
  {
    n: [
      "squared up with exclamation mark",
      "up"
    ],
    u: "1f199"
  },
  {
    n: [
      "squared vs",
      "vs"
    ],
    u: "1f19a"
  },
  {
    n: [
      "squared katakana koko",
      "koko"
    ],
    u: "1f201"
  },
  {
    n: [
      "squared katakana sa",
      "sa"
    ],
    u: "1f202-fe0f"
  },
  {
    n: [
      "squared cjk unified ideograph-6708",
      "u6708"
    ],
    u: "1f237-fe0f"
  },
  {
    n: [
      "squared cjk unified ideograph-6709",
      "u6709"
    ],
    u: "1f236"
  },
  {
    n: [
      "squared cjk unified ideograph-6307",
      "u6307"
    ],
    u: "1f22f"
  },
  {
    n: [
      "circled ideograph advantage",
      "ideograph_advantage"
    ],
    u: "1f250"
  },
  {
    n: [
      "squared cjk unified ideograph-5272",
      "u5272"
    ],
    u: "1f239"
  },
  {
    n: [
      "squared cjk unified ideograph-7121",
      "u7121"
    ],
    u: "1f21a"
  },
  {
    n: [
      "squared cjk unified ideograph-7981",
      "u7981"
    ],
    u: "1f232"
  },
  {
    n: [
      "circled ideograph accept",
      "accept"
    ],
    u: "1f251"
  },
  {
    n: [
      "squared cjk unified ideograph-7533",
      "u7533"
    ],
    u: "1f238"
  },
  {
    n: [
      "squared cjk unified ideograph-5408",
      "u5408"
    ],
    u: "1f234"
  },
  {
    n: [
      "squared cjk unified ideograph-7a7a",
      "u7a7a"
    ],
    u: "1f233"
  },
  {
    n: [
      "circled ideograph congratulation",
      "congratulations"
    ],
    u: "3297-fe0f"
  },
  {
    n: [
      "circled ideograph secret",
      "secret"
    ],
    u: "3299-fe0f"
  },
  {
    n: [
      "squared cjk unified ideograph-55b6",
      "u55b6"
    ],
    u: "1f23a"
  },
  {
    n: [
      "squared cjk unified ideograph-6e80",
      "u6e80"
    ],
    u: "1f235"
  },
  {
    n: [
      "black small square",
      "black_small_square"
    ],
    u: "25aa-fe0f"
  },
  {
    n: [
      "white small square",
      "white_small_square"
    ],
    u: "25ab-fe0f"
  },
  {
    n: [
      "white medium square",
      "white_medium_square"
    ],
    u: "25fb-fe0f"
  },
  {
    n: [
      "black medium square",
      "black_medium_square"
    ],
    u: "25fc-fe0f"
  },
  {
    n: [
      "white medium small square",
      "white_medium_small_square"
    ],
    u: "25fd"
  },
  {
    n: [
      "black medium small square",
      "black_medium_small_square"
    ],
    u: "25fe"
  },
  {
    n: [
      "black large square",
      "black_large_square"
    ],
    u: "2b1b"
  },
  {
    n: [
      "white large square",
      "white_large_square"
    ],
    u: "2b1c"
  },
  {
    n: [
      "large orange diamond",
      "large_orange_diamond"
    ],
    u: "1f536"
  },
  {
    n: [
      "large blue diamond",
      "large_blue_diamond"
    ],
    u: "1f537"
  },
  {
    n: [
      "small orange diamond",
      "small_orange_diamond"
    ],
    u: "1f538"
  },
  {
    n: [
      "small blue diamond",
      "small_blue_diamond"
    ],
    u: "1f539"
  },
  {
    n: [
      "up-pointing red triangle",
      "small_red_triangle"
    ],
    u: "1f53a"
  },
  {
    n: [
      "down-pointing red triangle",
      "small_red_triangle_down"
    ],
    u: "1f53b"
  },
  {
    n: [
      "diamond shape with a dot inside",
      "diamond_shape_with_a_dot_inside"
    ],
    u: "1f4a0"
  },
  {
    n: [
      "radio button",
      "radio_button"
    ],
    u: "1f518"
  },
  {
    n: [
      "black square button",
      "black_square_button"
    ],
    u: "1f532"
  },
  {
    n: [
      "white square button",
      "white_square_button"
    ],
    u: "1f533"
  },
  {
    n: [
      "medium white circle",
      "white_circle"
    ],
    u: "26aa"
  },
  {
    n: [
      "medium black circle",
      "black_circle"
    ],
    u: "26ab"
  },
  {
    n: [
      "large red circle",
      "red_circle"
    ],
    u: "1f534"
  },
  {
    n: [
      "large blue circle",
      "large_blue_circle"
    ],
    u: "1f535"
  }
], _R = [
  {
    n: [
      "chequered flag",
      "checkered_flag"
    ],
    u: "1f3c1"
  },
  {
    n: [
      "triangular flag on post",
      "triangular_flag_on_post"
    ],
    u: "1f6a9"
  },
  {
    n: [
      "crossed flags",
      "crossed_flags"
    ],
    u: "1f38c"
  },
  {
    n: [
      "waving black flag",
      "waving_black_flag"
    ],
    u: "1f3f4"
  },
  {
    n: [
      "waving_white_flag"
    ],
    u: "1f3f3-fe0f"
  },
  {
    n: [
      "rainbow-flag"
    ],
    u: "1f3f3-fe0f-200d-1f308"
  },
  {
    n: [
      "ascension island flag",
      "flag-ac"
    ],
    u: "1f1e6-1f1e8"
  },
  {
    n: [
      "andorra flag",
      "flag-ad"
    ],
    u: "1f1e6-1f1e9"
  },
  {
    n: [
      "united arab emirates flag",
      "flag-ae"
    ],
    u: "1f1e6-1f1ea"
  },
  {
    n: [
      "afghanistan flag",
      "flag-af"
    ],
    u: "1f1e6-1f1eb"
  },
  {
    n: [
      "antigua & barbuda flag",
      "flag-ag"
    ],
    u: "1f1e6-1f1ec"
  },
  {
    n: [
      "anguilla flag",
      "flag-ai"
    ],
    u: "1f1e6-1f1ee"
  },
  {
    n: [
      "albania flag",
      "flag-al"
    ],
    u: "1f1e6-1f1f1"
  },
  {
    n: [
      "armenia flag",
      "flag-am"
    ],
    u: "1f1e6-1f1f2"
  },
  {
    n: [
      "angola flag",
      "flag-ao"
    ],
    u: "1f1e6-1f1f4"
  },
  {
    n: [
      "antarctica flag",
      "flag-aq"
    ],
    u: "1f1e6-1f1f6"
  },
  {
    n: [
      "argentina flag",
      "flag-ar"
    ],
    u: "1f1e6-1f1f7"
  },
  {
    n: [
      "american samoa flag",
      "flag-as"
    ],
    u: "1f1e6-1f1f8"
  },
  {
    n: [
      "austria flag",
      "flag-at"
    ],
    u: "1f1e6-1f1f9"
  },
  {
    n: [
      "australia flag",
      "flag-au"
    ],
    u: "1f1e6-1f1fa"
  },
  {
    n: [
      "aruba flag",
      "flag-aw"
    ],
    u: "1f1e6-1f1fc"
  },
  {
    n: [
      "land islands flag",
      "flag-ax"
    ],
    u: "1f1e6-1f1fd"
  },
  {
    n: [
      "azerbaijan flag",
      "flag-az"
    ],
    u: "1f1e6-1f1ff"
  },
  {
    n: [
      "bosnia & herzegovina flag",
      "flag-ba"
    ],
    u: "1f1e7-1f1e6"
  },
  {
    n: [
      "barbados flag",
      "flag-bb"
    ],
    u: "1f1e7-1f1e7"
  },
  {
    n: [
      "bangladesh flag",
      "flag-bd"
    ],
    u: "1f1e7-1f1e9"
  },
  {
    n: [
      "belgium flag",
      "flag-be"
    ],
    u: "1f1e7-1f1ea"
  },
  {
    n: [
      "burkina faso flag",
      "flag-bf"
    ],
    u: "1f1e7-1f1eb"
  },
  {
    n: [
      "bulgaria flag",
      "flag-bg"
    ],
    u: "1f1e7-1f1ec"
  },
  {
    n: [
      "bahrain flag",
      "flag-bh"
    ],
    u: "1f1e7-1f1ed"
  },
  {
    n: [
      "burundi flag",
      "flag-bi"
    ],
    u: "1f1e7-1f1ee"
  },
  {
    n: [
      "benin flag",
      "flag-bj"
    ],
    u: "1f1e7-1f1ef"
  },
  {
    n: [
      "st. barthlemy flag",
      "flag-bl"
    ],
    u: "1f1e7-1f1f1"
  },
  {
    n: [
      "bermuda flag",
      "flag-bm"
    ],
    u: "1f1e7-1f1f2"
  },
  {
    n: [
      "brunei flag",
      "flag-bn"
    ],
    u: "1f1e7-1f1f3"
  },
  {
    n: [
      "bolivia flag",
      "flag-bo"
    ],
    u: "1f1e7-1f1f4"
  },
  {
    n: [
      "caribbean netherlands flag",
      "flag-bq"
    ],
    u: "1f1e7-1f1f6"
  },
  {
    n: [
      "brazil flag",
      "flag-br"
    ],
    u: "1f1e7-1f1f7"
  },
  {
    n: [
      "bahamas flag",
      "flag-bs"
    ],
    u: "1f1e7-1f1f8"
  },
  {
    n: [
      "bhutan flag",
      "flag-bt"
    ],
    u: "1f1e7-1f1f9"
  },
  {
    n: [
      "bouvet island flag",
      "flag-bv"
    ],
    u: "1f1e7-1f1fb"
  },
  {
    n: [
      "botswana flag",
      "flag-bw"
    ],
    u: "1f1e7-1f1fc"
  },
  {
    n: [
      "belarus flag",
      "flag-by"
    ],
    u: "1f1e7-1f1fe"
  },
  {
    n: [
      "belize flag",
      "flag-bz"
    ],
    u: "1f1e7-1f1ff"
  },
  {
    n: [
      "canada flag",
      "flag-ca"
    ],
    u: "1f1e8-1f1e6"
  },
  {
    n: [
      "cocos (keeling) islands flag",
      "flag-cc"
    ],
    u: "1f1e8-1f1e8"
  },
  {
    n: [
      "congo - kinshasa flag",
      "flag-cd"
    ],
    u: "1f1e8-1f1e9"
  },
  {
    n: [
      "central african republic flag",
      "flag-cf"
    ],
    u: "1f1e8-1f1eb"
  },
  {
    n: [
      "congo - brazzaville flag",
      "flag-cg"
    ],
    u: "1f1e8-1f1ec"
  },
  {
    n: [
      "switzerland flag",
      "flag-ch"
    ],
    u: "1f1e8-1f1ed"
  },
  {
    n: [
      "cte divoire flag",
      "flag-ci"
    ],
    u: "1f1e8-1f1ee"
  },
  {
    n: [
      "cook islands flag",
      "flag-ck"
    ],
    u: "1f1e8-1f1f0"
  },
  {
    n: [
      "chile flag",
      "flag-cl"
    ],
    u: "1f1e8-1f1f1"
  },
  {
    n: [
      "cameroon flag",
      "flag-cm"
    ],
    u: "1f1e8-1f1f2"
  },
  {
    n: [
      "china flag",
      "cn",
      "flag-cn"
    ],
    u: "1f1e8-1f1f3"
  },
  {
    n: [
      "colombia flag",
      "flag-co"
    ],
    u: "1f1e8-1f1f4"
  },
  {
    n: [
      "clipperton island flag",
      "flag-cp"
    ],
    u: "1f1e8-1f1f5"
  },
  {
    n: [
      "costa rica flag",
      "flag-cr"
    ],
    u: "1f1e8-1f1f7"
  },
  {
    n: [
      "cuba flag",
      "flag-cu"
    ],
    u: "1f1e8-1f1fa"
  },
  {
    n: [
      "cape verde flag",
      "flag-cv"
    ],
    u: "1f1e8-1f1fb"
  },
  {
    n: [
      "curaao flag",
      "flag-cw"
    ],
    u: "1f1e8-1f1fc"
  },
  {
    n: [
      "christmas island flag",
      "flag-cx"
    ],
    u: "1f1e8-1f1fd"
  },
  {
    n: [
      "cyprus flag",
      "flag-cy"
    ],
    u: "1f1e8-1f1fe"
  },
  {
    n: [
      "czechia flag",
      "flag-cz"
    ],
    u: "1f1e8-1f1ff"
  },
  {
    n: [
      "germany flag",
      "de",
      "flag-de"
    ],
    u: "1f1e9-1f1ea"
  },
  {
    n: [
      "diego garcia flag",
      "flag-dg"
    ],
    u: "1f1e9-1f1ec"
  },
  {
    n: [
      "djibouti flag",
      "flag-dj"
    ],
    u: "1f1e9-1f1ef"
  },
  {
    n: [
      "denmark flag",
      "flag-dk"
    ],
    u: "1f1e9-1f1f0"
  },
  {
    n: [
      "dominica flag",
      "flag-dm"
    ],
    u: "1f1e9-1f1f2"
  },
  {
    n: [
      "dominican republic flag",
      "flag-do"
    ],
    u: "1f1e9-1f1f4"
  },
  {
    n: [
      "algeria flag",
      "flag-dz"
    ],
    u: "1f1e9-1f1ff"
  },
  {
    n: [
      "ceuta & melilla flag",
      "flag-ea"
    ],
    u: "1f1ea-1f1e6"
  },
  {
    n: [
      "ecuador flag",
      "flag-ec"
    ],
    u: "1f1ea-1f1e8"
  },
  {
    n: [
      "estonia flag",
      "flag-ee"
    ],
    u: "1f1ea-1f1ea"
  },
  {
    n: [
      "egypt flag",
      "flag-eg"
    ],
    u: "1f1ea-1f1ec"
  },
  {
    n: [
      "western sahara flag",
      "flag-eh"
    ],
    u: "1f1ea-1f1ed"
  },
  {
    n: [
      "eritrea flag",
      "flag-er"
    ],
    u: "1f1ea-1f1f7"
  },
  {
    n: [
      "spain flag",
      "es",
      "flag-es"
    ],
    u: "1f1ea-1f1f8"
  },
  {
    n: [
      "ethiopia flag",
      "flag-et"
    ],
    u: "1f1ea-1f1f9"
  },
  {
    n: [
      "european union flag",
      "flag-eu"
    ],
    u: "1f1ea-1f1fa"
  },
  {
    n: [
      "finland flag",
      "flag-fi"
    ],
    u: "1f1eb-1f1ee"
  },
  {
    n: [
      "fiji flag",
      "flag-fj"
    ],
    u: "1f1eb-1f1ef"
  },
  {
    n: [
      "falkland islands flag",
      "flag-fk"
    ],
    u: "1f1eb-1f1f0"
  },
  {
    n: [
      "micronesia flag",
      "flag-fm"
    ],
    u: "1f1eb-1f1f2"
  },
  {
    n: [
      "faroe islands flag",
      "flag-fo"
    ],
    u: "1f1eb-1f1f4"
  },
  {
    n: [
      "france flag",
      "fr",
      "flag-fr"
    ],
    u: "1f1eb-1f1f7"
  },
  {
    n: [
      "gabon flag",
      "flag-ga"
    ],
    u: "1f1ec-1f1e6"
  },
  {
    n: [
      "united kingdom flag",
      "gb",
      "uk",
      "flag-gb"
    ],
    u: "1f1ec-1f1e7"
  },
  {
    n: [
      "grenada flag",
      "flag-gd"
    ],
    u: "1f1ec-1f1e9"
  },
  {
    n: [
      "georgia flag",
      "flag-ge"
    ],
    u: "1f1ec-1f1ea"
  },
  {
    n: [
      "french guiana flag",
      "flag-gf"
    ],
    u: "1f1ec-1f1eb"
  },
  {
    n: [
      "guernsey flag",
      "flag-gg"
    ],
    u: "1f1ec-1f1ec"
  },
  {
    n: [
      "ghana flag",
      "flag-gh"
    ],
    u: "1f1ec-1f1ed"
  },
  {
    n: [
      "gibraltar flag",
      "flag-gi"
    ],
    u: "1f1ec-1f1ee"
  },
  {
    n: [
      "greenland flag",
      "flag-gl"
    ],
    u: "1f1ec-1f1f1"
  },
  {
    n: [
      "gambia flag",
      "flag-gm"
    ],
    u: "1f1ec-1f1f2"
  },
  {
    n: [
      "guinea flag",
      "flag-gn"
    ],
    u: "1f1ec-1f1f3"
  },
  {
    n: [
      "guadeloupe flag",
      "flag-gp"
    ],
    u: "1f1ec-1f1f5"
  },
  {
    n: [
      "equatorial guinea flag",
      "flag-gq"
    ],
    u: "1f1ec-1f1f6"
  },
  {
    n: [
      "greece flag",
      "flag-gr"
    ],
    u: "1f1ec-1f1f7"
  },
  {
    n: [
      "south georgia & south sandwich islands flag",
      "flag-gs"
    ],
    u: "1f1ec-1f1f8"
  },
  {
    n: [
      "guatemala flag",
      "flag-gt"
    ],
    u: "1f1ec-1f1f9"
  },
  {
    n: [
      "guam flag",
      "flag-gu"
    ],
    u: "1f1ec-1f1fa"
  },
  {
    n: [
      "guinea-bissau flag",
      "flag-gw"
    ],
    u: "1f1ec-1f1fc"
  },
  {
    n: [
      "guyana flag",
      "flag-gy"
    ],
    u: "1f1ec-1f1fe"
  },
  {
    n: [
      "hong kong sar china flag",
      "flag-hk"
    ],
    u: "1f1ed-1f1f0"
  },
  {
    n: [
      "heard & mcdonald islands flag",
      "flag-hm"
    ],
    u: "1f1ed-1f1f2"
  },
  {
    n: [
      "honduras flag",
      "flag-hn"
    ],
    u: "1f1ed-1f1f3"
  },
  {
    n: [
      "croatia flag",
      "flag-hr"
    ],
    u: "1f1ed-1f1f7"
  },
  {
    n: [
      "haiti flag",
      "flag-ht"
    ],
    u: "1f1ed-1f1f9"
  },
  {
    n: [
      "hungary flag",
      "flag-hu"
    ],
    u: "1f1ed-1f1fa"
  },
  {
    n: [
      "canary islands flag",
      "flag-ic"
    ],
    u: "1f1ee-1f1e8"
  },
  {
    n: [
      "indonesia flag",
      "flag-id"
    ],
    u: "1f1ee-1f1e9"
  },
  {
    n: [
      "ireland flag",
      "flag-ie"
    ],
    u: "1f1ee-1f1ea"
  },
  {
    n: [
      "israel flag",
      "flag-il"
    ],
    u: "1f1ee-1f1f1"
  },
  {
    n: [
      "isle of man flag",
      "flag-im"
    ],
    u: "1f1ee-1f1f2"
  },
  {
    n: [
      "india flag",
      "flag-in"
    ],
    u: "1f1ee-1f1f3"
  },
  {
    n: [
      "british indian ocean territory flag",
      "flag-io"
    ],
    u: "1f1ee-1f1f4"
  },
  {
    n: [
      "iraq flag",
      "flag-iq"
    ],
    u: "1f1ee-1f1f6"
  },
  {
    n: [
      "iran flag",
      "flag-ir"
    ],
    u: "1f1ee-1f1f7"
  },
  {
    n: [
      "iceland flag",
      "flag-is"
    ],
    u: "1f1ee-1f1f8"
  },
  {
    n: [
      "italy flag",
      "it",
      "flag-it"
    ],
    u: "1f1ee-1f1f9"
  },
  {
    n: [
      "jersey flag",
      "flag-je"
    ],
    u: "1f1ef-1f1ea"
  },
  {
    n: [
      "jamaica flag",
      "flag-jm"
    ],
    u: "1f1ef-1f1f2"
  },
  {
    n: [
      "jordan flag",
      "flag-jo"
    ],
    u: "1f1ef-1f1f4"
  },
  {
    n: [
      "japan flag",
      "jp",
      "flag-jp"
    ],
    u: "1f1ef-1f1f5"
  },
  {
    n: [
      "kenya flag",
      "flag-ke"
    ],
    u: "1f1f0-1f1ea"
  },
  {
    n: [
      "kyrgyzstan flag",
      "flag-kg"
    ],
    u: "1f1f0-1f1ec"
  },
  {
    n: [
      "cambodia flag",
      "flag-kh"
    ],
    u: "1f1f0-1f1ed"
  },
  {
    n: [
      "kiribati flag",
      "flag-ki"
    ],
    u: "1f1f0-1f1ee"
  },
  {
    n: [
      "comoros flag",
      "flag-km"
    ],
    u: "1f1f0-1f1f2"
  },
  {
    n: [
      "st. kitts & nevis flag",
      "flag-kn"
    ],
    u: "1f1f0-1f1f3"
  },
  {
    n: [
      "north korea flag",
      "flag-kp"
    ],
    u: "1f1f0-1f1f5"
  },
  {
    n: [
      "south korea flag",
      "kr",
      "flag-kr"
    ],
    u: "1f1f0-1f1f7"
  },
  {
    n: [
      "kuwait flag",
      "flag-kw"
    ],
    u: "1f1f0-1f1fc"
  },
  {
    n: [
      "cayman islands flag",
      "flag-ky"
    ],
    u: "1f1f0-1f1fe"
  },
  {
    n: [
      "kazakhstan flag",
      "flag-kz"
    ],
    u: "1f1f0-1f1ff"
  },
  {
    n: [
      "laos flag",
      "flag-la"
    ],
    u: "1f1f1-1f1e6"
  },
  {
    n: [
      "lebanon flag",
      "flag-lb"
    ],
    u: "1f1f1-1f1e7"
  },
  {
    n: [
      "st. lucia flag",
      "flag-lc"
    ],
    u: "1f1f1-1f1e8"
  },
  {
    n: [
      "liechtenstein flag",
      "flag-li"
    ],
    u: "1f1f1-1f1ee"
  },
  {
    n: [
      "sri lanka flag",
      "flag-lk"
    ],
    u: "1f1f1-1f1f0"
  },
  {
    n: [
      "liberia flag",
      "flag-lr"
    ],
    u: "1f1f1-1f1f7"
  },
  {
    n: [
      "lesotho flag",
      "flag-ls"
    ],
    u: "1f1f1-1f1f8"
  },
  {
    n: [
      "lithuania flag",
      "flag-lt"
    ],
    u: "1f1f1-1f1f9"
  },
  {
    n: [
      "luxembourg flag",
      "flag-lu"
    ],
    u: "1f1f1-1f1fa"
  },
  {
    n: [
      "latvia flag",
      "flag-lv"
    ],
    u: "1f1f1-1f1fb"
  },
  {
    n: [
      "libya flag",
      "flag-ly"
    ],
    u: "1f1f1-1f1fe"
  },
  {
    n: [
      "morocco flag",
      "flag-ma"
    ],
    u: "1f1f2-1f1e6"
  },
  {
    n: [
      "monaco flag",
      "flag-mc"
    ],
    u: "1f1f2-1f1e8"
  },
  {
    n: [
      "moldova flag",
      "flag-md"
    ],
    u: "1f1f2-1f1e9"
  },
  {
    n: [
      "montenegro flag",
      "flag-me"
    ],
    u: "1f1f2-1f1ea"
  },
  {
    n: [
      "st. martin flag",
      "flag-mf"
    ],
    u: "1f1f2-1f1eb"
  },
  {
    n: [
      "madagascar flag",
      "flag-mg"
    ],
    u: "1f1f2-1f1ec"
  },
  {
    n: [
      "marshall islands flag",
      "flag-mh"
    ],
    u: "1f1f2-1f1ed"
  },
  {
    n: [
      "macedonia flag",
      "flag-mk"
    ],
    u: "1f1f2-1f1f0"
  },
  {
    n: [
      "mali flag",
      "flag-ml"
    ],
    u: "1f1f2-1f1f1"
  },
  {
    n: [
      "myanmar (burma) flag",
      "flag-mm"
    ],
    u: "1f1f2-1f1f2"
  },
  {
    n: [
      "mongolia flag",
      "flag-mn"
    ],
    u: "1f1f2-1f1f3"
  },
  {
    n: [
      "macau sar china flag",
      "flag-mo"
    ],
    u: "1f1f2-1f1f4"
  },
  {
    n: [
      "northern mariana islands flag",
      "flag-mp"
    ],
    u: "1f1f2-1f1f5"
  },
  {
    n: [
      "martinique flag",
      "flag-mq"
    ],
    u: "1f1f2-1f1f6"
  },
  {
    n: [
      "mauritania flag",
      "flag-mr"
    ],
    u: "1f1f2-1f1f7"
  },
  {
    n: [
      "montserrat flag",
      "flag-ms"
    ],
    u: "1f1f2-1f1f8"
  },
  {
    n: [
      "malta flag",
      "flag-mt"
    ],
    u: "1f1f2-1f1f9"
  },
  {
    n: [
      "mauritius flag",
      "flag-mu"
    ],
    u: "1f1f2-1f1fa"
  },
  {
    n: [
      "maldives flag",
      "flag-mv"
    ],
    u: "1f1f2-1f1fb"
  },
  {
    n: [
      "malawi flag",
      "flag-mw"
    ],
    u: "1f1f2-1f1fc"
  },
  {
    n: [
      "mexico flag",
      "flag-mx"
    ],
    u: "1f1f2-1f1fd"
  },
  {
    n: [
      "malaysia flag",
      "flag-my"
    ],
    u: "1f1f2-1f1fe"
  },
  {
    n: [
      "mozambique flag",
      "flag-mz"
    ],
    u: "1f1f2-1f1ff"
  },
  {
    n: [
      "namibia flag",
      "flag-na"
    ],
    u: "1f1f3-1f1e6"
  },
  {
    n: [
      "new caledonia flag",
      "flag-nc"
    ],
    u: "1f1f3-1f1e8"
  },
  {
    n: [
      "niger flag",
      "flag-ne"
    ],
    u: "1f1f3-1f1ea"
  },
  {
    n: [
      "norfolk island flag",
      "flag-nf"
    ],
    u: "1f1f3-1f1eb"
  },
  {
    n: [
      "nigeria flag",
      "flag-ng"
    ],
    u: "1f1f3-1f1ec"
  },
  {
    n: [
      "nicaragua flag",
      "flag-ni"
    ],
    u: "1f1f3-1f1ee"
  },
  {
    n: [
      "netherlands flag",
      "flag-nl"
    ],
    u: "1f1f3-1f1f1"
  },
  {
    n: [
      "norway flag",
      "flag-no"
    ],
    u: "1f1f3-1f1f4"
  },
  {
    n: [
      "nepal flag",
      "flag-np"
    ],
    u: "1f1f3-1f1f5"
  },
  {
    n: [
      "nauru flag",
      "flag-nr"
    ],
    u: "1f1f3-1f1f7"
  },
  {
    n: [
      "niue flag",
      "flag-nu"
    ],
    u: "1f1f3-1f1fa"
  },
  {
    n: [
      "new zealand flag",
      "flag-nz"
    ],
    u: "1f1f3-1f1ff"
  },
  {
    n: [
      "oman flag",
      "flag-om"
    ],
    u: "1f1f4-1f1f2"
  },
  {
    n: [
      "panama flag",
      "flag-pa"
    ],
    u: "1f1f5-1f1e6"
  },
  {
    n: [
      "peru flag",
      "flag-pe"
    ],
    u: "1f1f5-1f1ea"
  },
  {
    n: [
      "french polynesia flag",
      "flag-pf"
    ],
    u: "1f1f5-1f1eb"
  },
  {
    n: [
      "papua new guinea flag",
      "flag-pg"
    ],
    u: "1f1f5-1f1ec"
  },
  {
    n: [
      "philippines flag",
      "flag-ph"
    ],
    u: "1f1f5-1f1ed"
  },
  {
    n: [
      "pakistan flag",
      "flag-pk"
    ],
    u: "1f1f5-1f1f0"
  },
  {
    n: [
      "poland flag",
      "flag-pl"
    ],
    u: "1f1f5-1f1f1"
  },
  {
    n: [
      "st. pierre & miquelon flag",
      "flag-pm"
    ],
    u: "1f1f5-1f1f2"
  },
  {
    n: [
      "pitcairn islands flag",
      "flag-pn"
    ],
    u: "1f1f5-1f1f3"
  },
  {
    n: [
      "puerto rico flag",
      "flag-pr"
    ],
    u: "1f1f5-1f1f7"
  },
  {
    n: [
      "palestinian territories flag",
      "flag-ps"
    ],
    u: "1f1f5-1f1f8"
  },
  {
    n: [
      "portugal flag",
      "flag-pt"
    ],
    u: "1f1f5-1f1f9"
  },
  {
    n: [
      "palau flag",
      "flag-pw"
    ],
    u: "1f1f5-1f1fc"
  },
  {
    n: [
      "paraguay flag",
      "flag-py"
    ],
    u: "1f1f5-1f1fe"
  },
  {
    n: [
      "qatar flag",
      "flag-qa"
    ],
    u: "1f1f6-1f1e6"
  },
  {
    n: [
      "runion flag",
      "flag-re"
    ],
    u: "1f1f7-1f1ea"
  },
  {
    n: [
      "romania flag",
      "flag-ro"
    ],
    u: "1f1f7-1f1f4"
  },
  {
    n: [
      "serbia flag",
      "flag-rs"
    ],
    u: "1f1f7-1f1f8"
  },
  {
    n: [
      "russia flag",
      "ru",
      "flag-ru"
    ],
    u: "1f1f7-1f1fa"
  },
  {
    n: [
      "rwanda flag",
      "flag-rw"
    ],
    u: "1f1f7-1f1fc"
  },
  {
    n: [
      "saudi arabia flag",
      "flag-sa"
    ],
    u: "1f1f8-1f1e6"
  },
  {
    n: [
      "solomon islands flag",
      "flag-sb"
    ],
    u: "1f1f8-1f1e7"
  },
  {
    n: [
      "seychelles flag",
      "flag-sc"
    ],
    u: "1f1f8-1f1e8"
  },
  {
    n: [
      "sudan flag",
      "flag-sd"
    ],
    u: "1f1f8-1f1e9"
  },
  {
    n: [
      "sweden flag",
      "flag-se"
    ],
    u: "1f1f8-1f1ea"
  },
  {
    n: [
      "singapore flag",
      "flag-sg"
    ],
    u: "1f1f8-1f1ec"
  },
  {
    n: [
      "st. helena flag",
      "flag-sh"
    ],
    u: "1f1f8-1f1ed"
  },
  {
    n: [
      "slovenia flag",
      "flag-si"
    ],
    u: "1f1f8-1f1ee"
  },
  {
    n: [
      "svalbard & jan mayen flag",
      "flag-sj"
    ],
    u: "1f1f8-1f1ef"
  },
  {
    n: [
      "slovakia flag",
      "flag-sk"
    ],
    u: "1f1f8-1f1f0"
  },
  {
    n: [
      "sierra leone flag",
      "flag-sl"
    ],
    u: "1f1f8-1f1f1"
  },
  {
    n: [
      "san marino flag",
      "flag-sm"
    ],
    u: "1f1f8-1f1f2"
  },
  {
    n: [
      "senegal flag",
      "flag-sn"
    ],
    u: "1f1f8-1f1f3"
  },
  {
    n: [
      "somalia flag",
      "flag-so"
    ],
    u: "1f1f8-1f1f4"
  },
  {
    n: [
      "suriname flag",
      "flag-sr"
    ],
    u: "1f1f8-1f1f7"
  },
  {
    n: [
      "south sudan flag",
      "flag-ss"
    ],
    u: "1f1f8-1f1f8"
  },
  {
    n: [
      "so tom & prncipe flag",
      "flag-st"
    ],
    u: "1f1f8-1f1f9"
  },
  {
    n: [
      "el salvador flag",
      "flag-sv"
    ],
    u: "1f1f8-1f1fb"
  },
  {
    n: [
      "sint maarten flag",
      "flag-sx"
    ],
    u: "1f1f8-1f1fd"
  },
  {
    n: [
      "syria flag",
      "flag-sy"
    ],
    u: "1f1f8-1f1fe"
  },
  {
    n: [
      "swaziland flag",
      "flag-sz"
    ],
    u: "1f1f8-1f1ff"
  },
  {
    n: [
      "tristan da cunha flag",
      "flag-ta"
    ],
    u: "1f1f9-1f1e6"
  },
  {
    n: [
      "turks & caicos islands flag",
      "flag-tc"
    ],
    u: "1f1f9-1f1e8"
  },
  {
    n: [
      "chad flag",
      "flag-td"
    ],
    u: "1f1f9-1f1e9"
  },
  {
    n: [
      "french southern territories flag",
      "flag-tf"
    ],
    u: "1f1f9-1f1eb"
  },
  {
    n: [
      "togo flag",
      "flag-tg"
    ],
    u: "1f1f9-1f1ec"
  },
  {
    n: [
      "thailand flag",
      "flag-th"
    ],
    u: "1f1f9-1f1ed"
  },
  {
    n: [
      "tajikistan flag",
      "flag-tj"
    ],
    u: "1f1f9-1f1ef"
  },
  {
    n: [
      "tokelau flag",
      "flag-tk"
    ],
    u: "1f1f9-1f1f0"
  },
  {
    n: [
      "timor-leste flag",
      "flag-tl"
    ],
    u: "1f1f9-1f1f1"
  },
  {
    n: [
      "turkmenistan flag",
      "flag-tm"
    ],
    u: "1f1f9-1f1f2"
  },
  {
    n: [
      "tunisia flag",
      "flag-tn"
    ],
    u: "1f1f9-1f1f3"
  },
  {
    n: [
      "tonga flag",
      "flag-to"
    ],
    u: "1f1f9-1f1f4"
  },
  {
    n: [
      "turkey flag",
      "flag-tr"
    ],
    u: "1f1f9-1f1f7"
  },
  {
    n: [
      "trinidad & tobago flag",
      "flag-tt"
    ],
    u: "1f1f9-1f1f9"
  },
  {
    n: [
      "tuvalu flag",
      "flag-tv"
    ],
    u: "1f1f9-1f1fb"
  },
  {
    n: [
      "taiwan flag",
      "flag-tw"
    ],
    u: "1f1f9-1f1fc"
  },
  {
    n: [
      "tanzania flag",
      "flag-tz"
    ],
    u: "1f1f9-1f1ff"
  },
  {
    n: [
      "ukraine flag",
      "flag-ua"
    ],
    u: "1f1fa-1f1e6"
  },
  {
    n: [
      "uganda flag",
      "flag-ug"
    ],
    u: "1f1fa-1f1ec"
  },
  {
    n: [
      "u.s. outlying islands flag",
      "flag-um"
    ],
    u: "1f1fa-1f1f2"
  },
  {
    n: [
      "united nations flag",
      "flag-un"
    ],
    u: "1f1fa-1f1f3"
  },
  {
    n: [
      "united states flag",
      "us",
      "flag-us"
    ],
    u: "1f1fa-1f1f8"
  },
  {
    n: [
      "uruguay flag",
      "flag-uy"
    ],
    u: "1f1fa-1f1fe"
  },
  {
    n: [
      "uzbekistan flag",
      "flag-uz"
    ],
    u: "1f1fa-1f1ff"
  },
  {
    n: [
      "vatican city flag",
      "flag-va"
    ],
    u: "1f1fb-1f1e6"
  },
  {
    n: [
      "st. vincent & grenadines flag",
      "flag-vc"
    ],
    u: "1f1fb-1f1e8"
  },
  {
    n: [
      "venezuela flag",
      "flag-ve"
    ],
    u: "1f1fb-1f1ea"
  },
  {
    n: [
      "british virgin islands flag",
      "flag-vg"
    ],
    u: "1f1fb-1f1ec"
  },
  {
    n: [
      "u.s. virgin islands flag",
      "flag-vi"
    ],
    u: "1f1fb-1f1ee"
  },
  {
    n: [
      "vietnam flag",
      "flag-vn"
    ],
    u: "1f1fb-1f1f3"
  },
  {
    n: [
      "vanuatu flag",
      "flag-vu"
    ],
    u: "1f1fb-1f1fa"
  },
  {
    n: [
      "wallis & futuna flag",
      "flag-wf"
    ],
    u: "1f1fc-1f1eb"
  },
  {
    n: [
      "samoa flag",
      "flag-ws"
    ],
    u: "1f1fc-1f1f8"
  },
  {
    n: [
      "kosovo flag",
      "flag-xk"
    ],
    u: "1f1fd-1f1f0"
  },
  {
    n: [
      "yemen flag",
      "flag-ye"
    ],
    u: "1f1fe-1f1ea"
  },
  {
    n: [
      "mayotte flag",
      "flag-yt"
    ],
    u: "1f1fe-1f1f9"
  },
  {
    n: [
      "south africa flag",
      "flag-za"
    ],
    u: "1f1ff-1f1e6"
  },
  {
    n: [
      "zambia flag",
      "flag-zm"
    ],
    u: "1f1ff-1f1f2"
  },
  {
    n: [
      "zimbabwe flag",
      "flag-zw"
    ],
    u: "1f1ff-1f1fc"
  },
  {
    n: [
      "england flag",
      "flag-england"
    ],
    u: "1f3f4-e0067-e0062-e0065-e006e-e0067-e007f"
  },
  {
    n: [
      "scotland flag",
      "flag-scotland"
    ],
    u: "1f3f4-e0067-e0062-e0073-e0063-e0074-e007f"
  },
  {
    n: [
      "wales flag",
      "flag-wales"
    ],
    u: "1f3f4-e0067-e0062-e0077-e006c-e0073-e007f"
  }
];
var ER = {
  smileys_people: pR,
  animals_nature: hR,
  food_drink: gR,
  activities: mR,
  travel_places: bR,
  objects: yR,
  symbols: vR,
  flags: _R
}, kb = [
  {
    key: "recent",
    title: "Recently Used",
    u: "1f551"
  },
  {
    key: "smileys_people",
    title: "Smiles & People",
    u: "1f600"
  },
  {
    key: "animals_nature",
    title: "Animals & Nature",
    u: "1F431"
  },
  {
    key: "food_drink",
    title: "Food & Drink",
    u: "2615"
  },
  {
    key: "activities",
    title: "Activities",
    u: "26BD"
  },
  {
    key: "travel_places",
    title: "Travel & Places",
    u: "1F697"
  },
  {
    key: "objects",
    title: "Objects",
    u: "1F4A1"
  },
  {
    key: "symbols",
    title: "Symbols",
    u: "1f4af"
  },
  {
    key: "flags",
    title: "Flags",
    u: "1f3f3-fe0f"
  }
];
const wR = (e, t) => t.some((n) => e instanceof n);
let Mb, Ab;
function xR() {
  return Mb || (Mb = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function kR() {
  return Ab || (Ab = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const lw = /* @__PURE__ */ new WeakMap(), Fh = /* @__PURE__ */ new WeakMap(), uw = /* @__PURE__ */ new WeakMap(), Ep = /* @__PURE__ */ new WeakMap(), yg = /* @__PURE__ */ new WeakMap();
function MR(e) {
  const t = new Promise((n, r) => {
    const i = () => {
      e.removeEventListener("success", o), e.removeEventListener("error", s);
    }, o = () => {
      n(Hi(e.result)), i();
    }, s = () => {
      r(e.error), i();
    };
    e.addEventListener("success", o), e.addEventListener("error", s);
  });
  return t.then((n) => {
    n instanceof IDBCursor && lw.set(n, e);
  }).catch(() => {
  }), yg.set(t, e), t;
}
function AR(e) {
  if (Fh.has(e))
    return;
  const t = new Promise((n, r) => {
    const i = () => {
      e.removeEventListener("complete", o), e.removeEventListener("error", s), e.removeEventListener("abort", s);
    }, o = () => {
      n(), i();
    }, s = () => {
      r(e.error || new DOMException("AbortError", "AbortError")), i();
    };
    e.addEventListener("complete", o), e.addEventListener("error", s), e.addEventListener("abort", s);
  });
  Fh.set(e, t);
}
let jh = {
  get(e, t, n) {
    if (e instanceof IDBTransaction) {
      if (t === "done")
        return Fh.get(e);
      if (t === "objectStoreNames")
        return e.objectStoreNames || uw.get(e);
      if (t === "store")
        return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0]);
    }
    return Hi(e[t]);
  },
  set(e, t, n) {
    return e[t] = n, !0;
  },
  has(e, t) {
    return e instanceof IDBTransaction && (t === "done" || t === "store") ? !0 : t in e;
  }
};
function TR(e) {
  jh = e(jh);
}
function SR(e) {
  return e === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(t, ...n) {
    const r = e.call(wp(this), t, ...n);
    return uw.set(r, t.sort ? t.sort() : [t]), Hi(r);
  } : kR().includes(e) ? function(...t) {
    return e.apply(wp(this), t), Hi(lw.get(this));
  } : function(...t) {
    return Hi(e.apply(wp(this), t));
  };
}
function CR(e) {
  return typeof e == "function" ? SR(e) : (e instanceof IDBTransaction && AR(e), wR(e, xR()) ? new Proxy(e, jh) : e);
}
function Hi(e) {
  if (e instanceof IDBRequest)
    return MR(e);
  if (Ep.has(e))
    return Ep.get(e);
  const t = CR(e);
  return t !== e && (Ep.set(e, t), yg.set(t, e)), t;
}
const wp = (e) => yg.get(e);
function vg(e, t, { blocked: n, upgrade: r, blocking: i, terminated: o } = {}) {
  const s = indexedDB.open(e, t), a = Hi(s);
  return r && s.addEventListener("upgradeneeded", (l) => {
    r(Hi(s.result), l.oldVersion, l.newVersion, Hi(s.transaction), l);
  }), n && s.addEventListener("blocked", (l) => n(
    l.oldVersion,
    l.newVersion,
    l
  )), a.then((l) => {
    o && l.addEventListener("close", () => o()), i && l.addEventListener("versionchange", (u) => i(u.oldVersion, u.newVersion, u));
  }).catch(() => {
  }), a;
}
const NR = ["get", "getKey", "getAll", "getAllKeys", "count"], DR = ["put", "add", "delete", "clear"], xp = /* @__PURE__ */ new Map();
function Tb(e, t) {
  if (!(e instanceof IDBDatabase && !(t in e) && typeof t == "string"))
    return;
  if (xp.get(t))
    return xp.get(t);
  const n = t.replace(/FromIndex$/, ""), r = t !== n, i = DR.includes(n);
  if (!(n in (r ? IDBIndex : IDBObjectStore).prototype) || !(i || NR.includes(n)))
    return;
  const o = async function(s, ...a) {
    const l = this.transaction(s, i ? "readwrite" : "readonly");
    let u = l.store;
    return r && (u = u.index(a.shift())), (await Promise.all([
      u[n](...a),
      i && l.done
    ]))[0];
  };
  return xp.set(t, o), o;
}
TR((e) => ({
  ...e,
  get: (t, n, r) => Tb(t, n) || e.get(t, n, r),
  has: (t, n) => !!Tb(t, n) || e.has(t, n)
}));
const _g = "EMJ", Os = "emojis", Eg = 3;
async function OR() {
  (await vg(_g, Eg, {
    upgrade(t, n) {
      t.objectStoreNames.contains(Os) || t.createObjectStore(Os, {
        keyPath: "id",
        autoIncrement: !0
      }).createIndex("id", "id", {
        unique: !0
      });
    }
  })).close();
}
OR();
const IR = {
  native: !1,
  hideSearch: !0,
  hideGroupIcons: !1,
  hideGroupNames: !1,
  staticTexts: {},
  disabledGroups: [],
  groupNames: {},
  displayRecent: !1,
  additionalGroups: {},
  groupOrder: [],
  groupIcons: {}
};
async function RR() {
  return await (await vg(_g, Eg)).transaction(Os, "readonly").objectStore(Os).getAll();
}
function LR() {
  const e = vs({
    search: "",
    emoji: iR,
    activeGroup: "",
    skinTone: Hc,
    options: IR,
    additionalGroups: {},
    recent: [],
    get emojis() {
      return {
        recent: this.recent,
        ...this.options.additionalGroups,
        ...ER
      };
    },
    get disabled() {
      let f = Array.isArray(this.options.disabledGroups) ? this.options.disabledGroups : [];
      return this.options.displayRecent || (f = ["recent", ...f]), f;
    },
    get groups() {
      return kb.filter(
        (f) => !this.disabled.includes(f.key)
      );
    },
    get orderedGroupKeys() {
      const f = [
        ...this.options.groupOrder,
        ...Object.keys(this.options.additionalGroups),
        ...kb.map((d) => d.key)
      ];
      return [...new Set(f)].filter((d) => !this.disabled.includes(d));
    }
  });
  function t() {
    e.options.displayRecent && r();
  }
  async function n() {
    var f;
    let d = await RR();
    return Array.isArray(d) && d.length ? d = JSON.parse(((f = d[0]) == null ? void 0 : f.value) || "") : d = [], d;
  }
  function r() {
    n().then((f) => {
      e.recent = f, u();
    });
  }
  const i = (f) => {
    e.search = f;
  }, o = (f) => {
    e.emoji = f;
  }, s = (f) => {
    e.activeGroup = f;
  }, a = (f = Hc) => {
    e.skinTone = f;
  }, l = (f) => {
    e.options = Object.assign({}, e.options, f), t();
  };
  async function u() {
    (await vg(_g, Eg)).transaction(Os, "readwrite").objectStore(Os).put({
      id: 0,
      value: JSON.stringify(e.recent)
    });
  }
  const c = (f) => {
    if (e.options.displayRecent !== !0)
      return;
    const d = e.recent.findIndex((h) => h.u === f.u);
    if (d > 0 && e.recent.splice(d, 1), d === 0)
      return;
    const p = { u: f.u, n: Sa(f.n) };
    e.recent = [p, ...e.recent], e.recent.length > 24 && (e.recent.length = 24), u();
  };
  return {
    state: Zf(e),
    updateSearch: i,
    updateEmoji: o,
    updateActiveGroup: s,
    updateSkinTone: a,
    updateOptions: l,
    updateSelect: c
  };
}
var Sn = "top", nr = "bottom", rr = "right", Cn = "left", wg = "auto", Kl = [Sn, nr, rr, Cn], Is = "start", dl = "end", BR = "clippingParents", cw = "viewport", ca = "popper", PR = "reference", Sb = /* @__PURE__ */ Kl.reduce(function(e, t) {
  return e.concat([t + "-" + Is, t + "-" + dl]);
}, []), fw = /* @__PURE__ */ [].concat(Kl, [wg]).reduce(function(e, t) {
  return e.concat([t, t + "-" + Is, t + "-" + dl]);
}, []), $R = "beforeRead", zR = "read", FR = "afterRead", jR = "beforeMain", UR = "main", VR = "afterMain", HR = "beforeWrite", qR = "write", GR = "afterWrite", WR = [$R, zR, FR, jR, UR, VR, HR, qR, GR];
function qr(e) {
  return e ? (e.nodeName || "").toLowerCase() : null;
}
function dr(e) {
  if (e == null)
    return window;
  if (e.toString() !== "[object Window]") {
    var t = e.ownerDocument;
    return t && t.defaultView || window;
  }
  return e;
}
function Rs(e) {
  var t = dr(e).Element;
  return e instanceof t || e instanceof Element;
}
function Xn(e) {
  var t = dr(e).HTMLElement;
  return e instanceof t || e instanceof HTMLElement;
}
function dw(e) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = dr(e).ShadowRoot;
  return e instanceof t || e instanceof ShadowRoot;
}
function KR(e) {
  var t = e.state;
  Object.keys(t.elements).forEach(function(n) {
    var r = t.styles[n] || {}, i = t.attributes[n] || {}, o = t.elements[n];
    !Xn(o) || !qr(o) || (Object.assign(o.style, r), Object.keys(i).forEach(function(s) {
      var a = i[s];
      a === !1 ? o.removeAttribute(s) : o.setAttribute(s, a === !0 ? "" : a);
    }));
  });
}
function YR(e) {
  var t = e.state, n = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function() {
    Object.keys(t.elements).forEach(function(r) {
      var i = t.elements[r], o = t.attributes[r] || {}, s = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : n[r]), a = s.reduce(function(l, u) {
        return l[u] = "", l;
      }, {});
      !Xn(i) || !qr(i) || (Object.assign(i.style, a), Object.keys(o).forEach(function(l) {
        i.removeAttribute(l);
      }));
    });
  };
}
var QR = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: KR,
  effect: YR,
  requires: ["computeStyles"]
};
function Pr(e) {
  return e.split("-")[0];
}
var wo = Math.max, qc = Math.min, Ls = Math.round;
function Bs(e, t) {
  t === void 0 && (t = !1);
  var n = e.getBoundingClientRect(), r = 1, i = 1;
  if (Xn(e) && t) {
    var o = e.offsetHeight, s = e.offsetWidth;
    s > 0 && (r = Ls(n.width) / s || 1), o > 0 && (i = Ls(n.height) / o || 1);
  }
  return {
    width: n.width / r,
    height: n.height / i,
    top: n.top / i,
    right: n.right / r,
    bottom: n.bottom / i,
    left: n.left / r,
    x: n.left / r,
    y: n.top / i
  };
}
function xg(e) {
  var t = Bs(e), n = e.offsetWidth, r = e.offsetHeight;
  return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), {
    x: e.offsetLeft,
    y: e.offsetTop,
    width: n,
    height: r
  };
}
function pw(e, t) {
  var n = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && dw(n)) {
    var r = t;
    do {
      if (r && e.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function Gr(e) {
  return dr(e).getComputedStyle(e);
}
function ZR(e) {
  return ["table", "td", "th"].indexOf(qr(e)) >= 0;
}
function eo(e) {
  return ((Rs(e) ? e.ownerDocument : e.document) || window.document).documentElement;
}
function bd(e) {
  return qr(e) === "html" ? e : e.assignedSlot || e.parentNode || (dw(e) ? e.host : null) || eo(e);
}
function Cb(e) {
  return !Xn(e) || Gr(e).position === "fixed" ? null : e.offsetParent;
}
function XR(e) {
  var t = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
  if (n && Xn(e)) {
    var r = Gr(e);
    if (r.position === "fixed")
      return null;
  }
  for (var i = bd(e); Xn(i) && ["html", "body"].indexOf(qr(i)) < 0; ) {
    var o = Gr(i);
    if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || t && o.willChange === "filter" || t && o.filter && o.filter !== "none")
      return i;
    i = i.parentNode;
  }
  return null;
}
function Yl(e) {
  for (var t = dr(e), n = Cb(e); n && ZR(n) && Gr(n).position === "static"; )
    n = Cb(n);
  return n && (qr(n) === "html" || qr(n) === "body" && Gr(n).position === "static") ? t : n || XR(e) || t;
}
function kg(e) {
  return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
}
function Ua(e, t, n) {
  return wo(e, qc(t, n));
}
function JR(e, t, n) {
  var r = Ua(e, t, n);
  return r > n ? n : r;
}
function hw() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function gw(e) {
  return Object.assign({}, hw(), e);
}
function mw(e, t) {
  return t.reduce(function(n, r) {
    return n[r] = e, n;
  }, {});
}
var e8 = function(t, n) {
  return t = typeof t == "function" ? t(Object.assign({}, n.rects, {
    placement: n.placement
  })) : t, gw(typeof t != "number" ? t : mw(t, Kl));
};
function t8(e) {
  var t, n = e.state, r = e.name, i = e.options, o = n.elements.arrow, s = n.modifiersData.popperOffsets, a = Pr(n.placement), l = kg(a), u = [Cn, rr].indexOf(a) >= 0, c = u ? "height" : "width";
  if (!(!o || !s)) {
    var f = e8(i.padding, n), d = xg(o), p = l === "y" ? Sn : Cn, h = l === "y" ? nr : rr, m = n.rects.reference[c] + n.rects.reference[l] - s[l] - n.rects.popper[c], g = s[l] - n.rects.reference[l], y = Yl(o), _ = y ? l === "y" ? y.clientHeight || 0 : y.clientWidth || 0 : 0, E = m / 2 - g / 2, v = f[p], M = _ - d[c] - f[h], k = _ / 2 - d[c] / 2 + E, T = Ua(v, k, M), U = l;
    n.modifiersData[r] = (t = {}, t[U] = T, t.centerOffset = T - k, t);
  }
}
function n8(e) {
  var t = e.state, n = e.options, r = n.element, i = r === void 0 ? "[data-popper-arrow]" : r;
  i != null && (typeof i == "string" && (i = t.elements.popper.querySelector(i), !i) || pw(t.elements.popper, i) && (t.elements.arrow = i));
}
var r8 = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: t8,
  effect: n8,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Ps(e) {
  return e.split("-")[1];
}
var i8 = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function o8(e) {
  var t = e.x, n = e.y, r = window, i = r.devicePixelRatio || 1;
  return {
    x: Ls(t * i) / i || 0,
    y: Ls(n * i) / i || 0
  };
}
function Nb(e) {
  var t, n = e.popper, r = e.popperRect, i = e.placement, o = e.variation, s = e.offsets, a = e.position, l = e.gpuAcceleration, u = e.adaptive, c = e.roundOffsets, f = e.isFixed, d = c === !0 ? o8(s) : typeof c == "function" ? c(s) : s, p = d.x, h = p === void 0 ? 0 : p, m = d.y, g = m === void 0 ? 0 : m, y = s.hasOwnProperty("x"), _ = s.hasOwnProperty("y"), E = Cn, v = Sn, M = window;
  if (u) {
    var k = Yl(n), T = "clientHeight", U = "clientWidth";
    if (k === dr(n) && (k = eo(n), Gr(k).position !== "static" && a === "absolute" && (T = "scrollHeight", U = "scrollWidth")), k = k, i === Sn || (i === Cn || i === rr) && o === dl) {
      v = nr;
      var C = f && M.visualViewport ? M.visualViewport.height : k[T];
      g -= C - r.height, g *= l ? 1 : -1;
    }
    if (i === Cn || (i === Sn || i === nr) && o === dl) {
      E = rr;
      var z = f && M.visualViewport ? M.visualViewport.width : k[U];
      h -= z - r.width, h *= l ? 1 : -1;
    }
  }
  var H = Object.assign({
    position: a
  }, u && i8);
  if (l) {
    var j;
    return Object.assign({}, H, (j = {}, j[v] = _ ? "0" : "", j[E] = y ? "0" : "", j.transform = (M.devicePixelRatio || 1) <= 1 ? "translate(" + h + "px, " + g + "px)" : "translate3d(" + h + "px, " + g + "px, 0)", j));
  }
  return Object.assign({}, H, (t = {}, t[v] = _ ? g + "px" : "", t[E] = y ? h + "px" : "", t.transform = "", t));
}
function s8(e) {
  var t = e.state, n = e.options, r = n.gpuAcceleration, i = r === void 0 ? !0 : r, o = n.adaptive, s = o === void 0 ? !0 : o, a = n.roundOffsets, l = a === void 0 ? !0 : a, u = {
    placement: Pr(t.placement),
    variation: Ps(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: i,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, Nb(Object.assign({}, u, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: s,
    roundOffsets: l
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, Nb(Object.assign({}, u, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
var a8 = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: s8,
  data: {}
}, Eu = {
  passive: !0
};
function l8(e) {
  var t = e.state, n = e.instance, r = e.options, i = r.scroll, o = i === void 0 ? !0 : i, s = r.resize, a = s === void 0 ? !0 : s, l = dr(t.elements.popper), u = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return o && u.forEach(function(c) {
    c.addEventListener("scroll", n.update, Eu);
  }), a && l.addEventListener("resize", n.update, Eu), function() {
    o && u.forEach(function(c) {
      c.removeEventListener("scroll", n.update, Eu);
    }), a && l.removeEventListener("resize", n.update, Eu);
  };
}
var u8 = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: l8,
  data: {}
}, c8 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function rc(e) {
  return e.replace(/left|right|bottom|top/g, function(t) {
    return c8[t];
  });
}
var f8 = {
  start: "end",
  end: "start"
};
function Db(e) {
  return e.replace(/start|end/g, function(t) {
    return f8[t];
  });
}
function Mg(e) {
  var t = dr(e), n = t.pageXOffset, r = t.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: r
  };
}
function Ag(e) {
  return Bs(eo(e)).left + Mg(e).scrollLeft;
}
function d8(e) {
  var t = dr(e), n = eo(e), r = t.visualViewport, i = n.clientWidth, o = n.clientHeight, s = 0, a = 0;
  return r && (i = r.width, o = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (s = r.offsetLeft, a = r.offsetTop)), {
    width: i,
    height: o,
    x: s + Ag(e),
    y: a
  };
}
function p8(e) {
  var t, n = eo(e), r = Mg(e), i = (t = e.ownerDocument) == null ? void 0 : t.body, o = wo(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), s = wo(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), a = -r.scrollLeft + Ag(e), l = -r.scrollTop;
  return Gr(i || n).direction === "rtl" && (a += wo(n.clientWidth, i ? i.clientWidth : 0) - o), {
    width: o,
    height: s,
    x: a,
    y: l
  };
}
function Tg(e) {
  var t = Gr(e), n = t.overflow, r = t.overflowX, i = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + i + r);
}
function bw(e) {
  return ["html", "body", "#document"].indexOf(qr(e)) >= 0 ? e.ownerDocument.body : Xn(e) && Tg(e) ? e : bw(bd(e));
}
function Va(e, t) {
  var n;
  t === void 0 && (t = []);
  var r = bw(e), i = r === ((n = e.ownerDocument) == null ? void 0 : n.body), o = dr(r), s = i ? [o].concat(o.visualViewport || [], Tg(r) ? r : []) : r, a = t.concat(s);
  return i ? a : a.concat(Va(bd(s)));
}
function Uh(e) {
  return Object.assign({}, e, {
    left: e.x,
    top: e.y,
    right: e.x + e.width,
    bottom: e.y + e.height
  });
}
function h8(e) {
  var t = Bs(e);
  return t.top = t.top + e.clientTop, t.left = t.left + e.clientLeft, t.bottom = t.top + e.clientHeight, t.right = t.left + e.clientWidth, t.width = e.clientWidth, t.height = e.clientHeight, t.x = t.left, t.y = t.top, t;
}
function Ob(e, t) {
  return t === cw ? Uh(d8(e)) : Rs(t) ? h8(t) : Uh(p8(eo(e)));
}
function g8(e) {
  var t = Va(bd(e)), n = ["absolute", "fixed"].indexOf(Gr(e).position) >= 0, r = n && Xn(e) ? Yl(e) : e;
  return Rs(r) ? t.filter(function(i) {
    return Rs(i) && pw(i, r) && qr(i) !== "body" && (n ? Gr(i).position !== "static" : !0);
  }) : [];
}
function m8(e, t, n) {
  var r = t === "clippingParents" ? g8(e) : [].concat(t), i = [].concat(r, [n]), o = i[0], s = i.reduce(function(a, l) {
    var u = Ob(e, l);
    return a.top = wo(u.top, a.top), a.right = qc(u.right, a.right), a.bottom = qc(u.bottom, a.bottom), a.left = wo(u.left, a.left), a;
  }, Ob(e, o));
  return s.width = s.right - s.left, s.height = s.bottom - s.top, s.x = s.left, s.y = s.top, s;
}
function yw(e) {
  var t = e.reference, n = e.element, r = e.placement, i = r ? Pr(r) : null, o = r ? Ps(r) : null, s = t.x + t.width / 2 - n.width / 2, a = t.y + t.height / 2 - n.height / 2, l;
  switch (i) {
    case Sn:
      l = {
        x: s,
        y: t.y - n.height
      };
      break;
    case nr:
      l = {
        x: s,
        y: t.y + t.height
      };
      break;
    case rr:
      l = {
        x: t.x + t.width,
        y: a
      };
      break;
    case Cn:
      l = {
        x: t.x - n.width,
        y: a
      };
      break;
    default:
      l = {
        x: t.x,
        y: t.y
      };
  }
  var u = i ? kg(i) : null;
  if (u != null) {
    var c = u === "y" ? "height" : "width";
    switch (o) {
      case Is:
        l[u] = l[u] - (t[c] / 2 - n[c] / 2);
        break;
      case dl:
        l[u] = l[u] + (t[c] / 2 - n[c] / 2);
        break;
    }
  }
  return l;
}
function pl(e, t) {
  t === void 0 && (t = {});
  var n = t, r = n.placement, i = r === void 0 ? e.placement : r, o = n.boundary, s = o === void 0 ? BR : o, a = n.rootBoundary, l = a === void 0 ? cw : a, u = n.elementContext, c = u === void 0 ? ca : u, f = n.altBoundary, d = f === void 0 ? !1 : f, p = n.padding, h = p === void 0 ? 0 : p, m = gw(typeof h != "number" ? h : mw(h, Kl)), g = c === ca ? PR : ca, y = e.rects.popper, _ = e.elements[d ? g : c], E = m8(Rs(_) ? _ : _.contextElement || eo(e.elements.popper), s, l), v = Bs(e.elements.reference), M = yw({
    reference: v,
    element: y,
    strategy: "absolute",
    placement: i
  }), k = Uh(Object.assign({}, y, M)), T = c === ca ? k : v, U = {
    top: E.top - T.top + m.top,
    bottom: T.bottom - E.bottom + m.bottom,
    left: E.left - T.left + m.left,
    right: T.right - E.right + m.right
  }, C = e.modifiersData.offset;
  if (c === ca && C) {
    var z = C[i];
    Object.keys(U).forEach(function(H) {
      var j = [rr, nr].indexOf(H) >= 0 ? 1 : -1, V = [Sn, nr].indexOf(H) >= 0 ? "y" : "x";
      U[H] += z[V] * j;
    });
  }
  return U;
}
function b8(e, t) {
  t === void 0 && (t = {});
  var n = t, r = n.placement, i = n.boundary, o = n.rootBoundary, s = n.padding, a = n.flipVariations, l = n.allowedAutoPlacements, u = l === void 0 ? fw : l, c = Ps(r), f = c ? a ? Sb : Sb.filter(function(h) {
    return Ps(h) === c;
  }) : Kl, d = f.filter(function(h) {
    return u.indexOf(h) >= 0;
  });
  d.length === 0 && (d = f);
  var p = d.reduce(function(h, m) {
    return h[m] = pl(e, {
      placement: m,
      boundary: i,
      rootBoundary: o,
      padding: s
    })[Pr(m)], h;
  }, {});
  return Object.keys(p).sort(function(h, m) {
    return p[h] - p[m];
  });
}
function y8(e) {
  if (Pr(e) === wg)
    return [];
  var t = rc(e);
  return [Db(e), t, Db(t)];
}
function v8(e) {
  var t = e.state, n = e.options, r = e.name;
  if (!t.modifiersData[r]._skip) {
    for (var i = n.mainAxis, o = i === void 0 ? !0 : i, s = n.altAxis, a = s === void 0 ? !0 : s, l = n.fallbackPlacements, u = n.padding, c = n.boundary, f = n.rootBoundary, d = n.altBoundary, p = n.flipVariations, h = p === void 0 ? !0 : p, m = n.allowedAutoPlacements, g = t.options.placement, y = Pr(g), _ = y === g, E = l || (_ || !h ? [rc(g)] : y8(g)), v = [g].concat(E).reduce(function(P, ie) {
      return P.concat(Pr(ie) === wg ? b8(t, {
        placement: ie,
        boundary: c,
        rootBoundary: f,
        padding: u,
        flipVariations: h,
        allowedAutoPlacements: m
      }) : ie);
    }, []), M = t.rects.reference, k = t.rects.popper, T = /* @__PURE__ */ new Map(), U = !0, C = v[0], z = 0; z < v.length; z++) {
      var H = v[z], j = Pr(H), V = Ps(H) === Is, Q = [Sn, nr].indexOf(j) >= 0, le = Q ? "width" : "height", ne = pl(t, {
        placement: H,
        boundary: c,
        rootBoundary: f,
        altBoundary: d,
        padding: u
      }), w = Q ? V ? rr : Cn : V ? nr : Sn;
      M[le] > k[le] && (w = rc(w));
      var O = rc(w), q = [];
      if (o && q.push(ne[j] <= 0), a && q.push(ne[w] <= 0, ne[O] <= 0), q.every(function(P) {
        return P;
      })) {
        C = H, U = !1;
        break;
      }
      T.set(H, q);
    }
    if (U)
      for (var X = h ? 3 : 1, se = function(ie) {
        var Y = v.find(function(ge) {
          var me = T.get(ge);
          if (me)
            return me.slice(0, ie).every(function(xe) {
              return xe;
            });
        });
        if (Y)
          return C = Y, "break";
      }, fe = X; fe > 0; fe--) {
        var Se = se(fe);
        if (Se === "break")
          break;
      }
    t.placement !== C && (t.modifiersData[r]._skip = !0, t.placement = C, t.reset = !0);
  }
}
var _8 = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: v8,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function Ib(e, t, n) {
  return n === void 0 && (n = {
    x: 0,
    y: 0
  }), {
    top: e.top - t.height - n.y,
    right: e.right - t.width + n.x,
    bottom: e.bottom - t.height + n.y,
    left: e.left - t.width - n.x
  };
}
function Rb(e) {
  return [Sn, rr, nr, Cn].some(function(t) {
    return e[t] >= 0;
  });
}
function E8(e) {
  var t = e.state, n = e.name, r = t.rects.reference, i = t.rects.popper, o = t.modifiersData.preventOverflow, s = pl(t, {
    elementContext: "reference"
  }), a = pl(t, {
    altBoundary: !0
  }), l = Ib(s, r), u = Ib(a, i, o), c = Rb(l), f = Rb(u);
  t.modifiersData[n] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: u,
    isReferenceHidden: c,
    hasPopperEscaped: f
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": c,
    "data-popper-escaped": f
  });
}
var w8 = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: E8
};
function x8(e, t, n) {
  var r = Pr(e), i = [Cn, Sn].indexOf(r) >= 0 ? -1 : 1, o = typeof n == "function" ? n(Object.assign({}, t, {
    placement: e
  })) : n, s = o[0], a = o[1];
  return s = s || 0, a = (a || 0) * i, [Cn, rr].indexOf(r) >= 0 ? {
    x: a,
    y: s
  } : {
    x: s,
    y: a
  };
}
function k8(e) {
  var t = e.state, n = e.options, r = e.name, i = n.offset, o = i === void 0 ? [0, 0] : i, s = fw.reduce(function(c, f) {
    return c[f] = x8(f, t.rects, o), c;
  }, {}), a = s[t.placement], l = a.x, u = a.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += u), t.modifiersData[r] = s;
}
var M8 = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: k8
};
function A8(e) {
  var t = e.state, n = e.name;
  t.modifiersData[n] = yw({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement
  });
}
var T8 = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: A8,
  data: {}
};
function S8(e) {
  return e === "x" ? "y" : "x";
}
function C8(e) {
  var t = e.state, n = e.options, r = e.name, i = n.mainAxis, o = i === void 0 ? !0 : i, s = n.altAxis, a = s === void 0 ? !1 : s, l = n.boundary, u = n.rootBoundary, c = n.altBoundary, f = n.padding, d = n.tether, p = d === void 0 ? !0 : d, h = n.tetherOffset, m = h === void 0 ? 0 : h, g = pl(t, {
    boundary: l,
    rootBoundary: u,
    padding: f,
    altBoundary: c
  }), y = Pr(t.placement), _ = Ps(t.placement), E = !_, v = kg(y), M = S8(v), k = t.modifiersData.popperOffsets, T = t.rects.reference, U = t.rects.popper, C = typeof m == "function" ? m(Object.assign({}, t.rects, {
    placement: t.placement
  })) : m, z = typeof C == "number" ? {
    mainAxis: C,
    altAxis: C
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, C), H = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, j = {
    x: 0,
    y: 0
  };
  if (k) {
    if (o) {
      var V, Q = v === "y" ? Sn : Cn, le = v === "y" ? nr : rr, ne = v === "y" ? "height" : "width", w = k[v], O = w + g[Q], q = w - g[le], X = p ? -U[ne] / 2 : 0, se = _ === Is ? T[ne] : U[ne], fe = _ === Is ? -U[ne] : -T[ne], Se = t.elements.arrow, P = p && Se ? xg(Se) : {
        width: 0,
        height: 0
      }, ie = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : hw(), Y = ie[Q], ge = ie[le], me = Ua(0, T[ne], P[ne]), xe = E ? T[ne] / 2 - X - me - Y - z.mainAxis : se - me - Y - z.mainAxis, Ve = E ? -T[ne] / 2 + X + me + ge + z.mainAxis : fe + me + ge + z.mainAxis, qe = t.elements.arrow && Yl(t.elements.arrow), ot = qe ? v === "y" ? qe.clientTop || 0 : qe.clientLeft || 0 : 0, Ie = (V = H == null ? void 0 : H[v]) != null ? V : 0, ct = w + xe - Ie - ot, yt = w + Ve - Ie, Fe = Ua(p ? qc(O, ct) : O, w, p ? wo(q, yt) : q);
      k[v] = Fe, j[v] = Fe - w;
    }
    if (a) {
      var $t, St = v === "x" ? Sn : Cn, ee = v === "x" ? nr : rr, Ke = k[M], Te = M === "y" ? "height" : "width", we = Ke + g[St], ut = Ke - g[ee], Xe = [Sn, Cn].indexOf(y) !== -1, Ct = ($t = H == null ? void 0 : H[M]) != null ? $t : 0, vt = Xe ? we : Ke - T[Te] - U[Te] - Ct + z.altAxis, F = Xe ? Ke + T[Te] + U[Te] - Ct - z.altAxis : ut, K = p && Xe ? JR(vt, Ke, F) : Ua(p ? vt : we, Ke, p ? F : ut);
      k[M] = K, j[M] = K - Ke;
    }
    t.modifiersData[r] = j;
  }
}
var N8 = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: C8,
  requiresIfExists: ["offset"]
};
function D8(e) {
  return {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  };
}
function O8(e) {
  return e === dr(e) || !Xn(e) ? Mg(e) : D8(e);
}
function I8(e) {
  var t = e.getBoundingClientRect(), n = Ls(t.width) / e.offsetWidth || 1, r = Ls(t.height) / e.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function R8(e, t, n) {
  n === void 0 && (n = !1);
  var r = Xn(t), i = Xn(t) && I8(t), o = eo(t), s = Bs(e, i), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (r || !r && !n) && ((qr(t) !== "body" || Tg(o)) && (a = O8(t)), Xn(t) ? (l = Bs(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : o && (l.x = Ag(o))), {
    x: s.left + a.scrollLeft - l.x,
    y: s.top + a.scrollTop - l.y,
    width: s.width,
    height: s.height
  };
}
function L8(e) {
  var t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
  e.forEach(function(o) {
    t.set(o.name, o);
  });
  function i(o) {
    n.add(o.name);
    var s = [].concat(o.requires || [], o.requiresIfExists || []);
    s.forEach(function(a) {
      if (!n.has(a)) {
        var l = t.get(a);
        l && i(l);
      }
    }), r.push(o);
  }
  return e.forEach(function(o) {
    n.has(o.name) || i(o);
  }), r;
}
function B8(e) {
  var t = L8(e);
  return WR.reduce(function(n, r) {
    return n.concat(t.filter(function(i) {
      return i.phase === r;
    }));
  }, []);
}
function P8(e) {
  var t;
  return function() {
    return t || (t = new Promise(function(n) {
      Promise.resolve().then(function() {
        t = void 0, n(e());
      });
    })), t;
  };
}
function $8(e) {
  var t = e.reduce(function(n, r) {
    var i = n[r.name];
    return n[r.name] = i ? Object.assign({}, i, r, {
      options: Object.assign({}, i.options, r.options),
      data: Object.assign({}, i.data, r.data)
    }) : r, n;
  }, {});
  return Object.keys(t).map(function(n) {
    return t[n];
  });
}
var Lb = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function Bb() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return !t.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function z8(e) {
  e === void 0 && (e = {});
  var t = e, n = t.defaultModifiers, r = n === void 0 ? [] : n, i = t.defaultOptions, o = i === void 0 ? Lb : i;
  return function(a, l, u) {
    u === void 0 && (u = o);
    var c = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, Lb, o),
      modifiersData: {},
      elements: {
        reference: a,
        popper: l
      },
      attributes: {},
      styles: {}
    }, f = [], d = !1, p = {
      state: c,
      setOptions: function(y) {
        var _ = typeof y == "function" ? y(c.options) : y;
        m(), c.options = Object.assign({}, o, c.options, _), c.scrollParents = {
          reference: Rs(a) ? Va(a) : a.contextElement ? Va(a.contextElement) : [],
          popper: Va(l)
        };
        var E = B8($8([].concat(r, c.options.modifiers)));
        return c.orderedModifiers = E.filter(function(v) {
          return v.enabled;
        }), h(), p.update();
      },
      forceUpdate: function() {
        if (!d) {
          var y = c.elements, _ = y.reference, E = y.popper;
          if (Bb(_, E)) {
            c.rects = {
              reference: R8(_, Yl(E), c.options.strategy === "fixed"),
              popper: xg(E)
            }, c.reset = !1, c.placement = c.options.placement, c.orderedModifiers.forEach(function(z) {
              return c.modifiersData[z.name] = Object.assign({}, z.data);
            });
            for (var v = 0; v < c.orderedModifiers.length; v++) {
              if (c.reset === !0) {
                c.reset = !1, v = -1;
                continue;
              }
              var M = c.orderedModifiers[v], k = M.fn, T = M.options, U = T === void 0 ? {} : T, C = M.name;
              typeof k == "function" && (c = k({
                state: c,
                options: U,
                name: C,
                instance: p
              }) || c);
            }
          }
        }
      },
      update: P8(function() {
        return new Promise(function(g) {
          p.forceUpdate(), g(c);
        });
      }),
      destroy: function() {
        m(), d = !0;
      }
    };
    if (!Bb(a, l))
      return p;
    p.setOptions(u).then(function(g) {
      !d && u.onFirstUpdate && u.onFirstUpdate(g);
    });
    function h() {
      c.orderedModifiers.forEach(function(g) {
        var y = g.name, _ = g.options, E = _ === void 0 ? {} : _, v = g.effect;
        if (typeof v == "function") {
          var M = v({
            state: c,
            name: y,
            instance: p,
            options: E
          }), k = function() {
          };
          f.push(M || k);
        }
      });
    }
    function m() {
      f.forEach(function(g) {
        return g();
      }), f = [];
    }
    return p;
  };
}
var F8 = [u8, T8, a8, QR, M8, _8, N8, r8, w8], j8 = /* @__PURE__ */ z8({
  defaultModifiers: F8
}), vw = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSAxNiA0IEMgOS4zODI4MTMgNCA0IDkuMzgyODEzIDQgMTYgQyA0IDIyLjYxNzE4OCA5LjM4MjgxMyAyOCAxNiAyOCBDIDIyLjYxNzE4OCAyOCAyOCAyMi42MTcxODggMjggMTYgQyAyOCA5LjM4MjgxMyAyMi42MTcxODggNCAxNiA0IFogTSAxNiA2IEMgMjEuNTM1MTU2IDYgMjYgMTAuNDY0ODQ0IDI2IDE2IEMgMjYgMjEuNTM1MTU2IDIxLjUzNTE1NiAyNiAxNiAyNiBDIDEwLjQ2NDg0NCAyNiA2IDIxLjUzNTE1NiA2IDE2IEMgNiAxMC40NjQ4NDQgMTAuNDY0ODQ0IDYgMTYgNiBaIE0gMTEuNSAxMiBDIDEwLjY3MTg3NSAxMiAxMCAxMi42NzE4NzUgMTAgMTMuNSBDIDEwIDE0LjMyODEyNSAxMC42NzE4NzUgMTUgMTEuNSAxNSBDIDEyLjMyODEyNSAxNSAxMyAxNC4zMjgxMjUgMTMgMTMuNSBDIDEzIDEyLjY3MTg3NSAxMi4zMjgxMjUgMTIgMTEuNSAxMiBaIE0gMjAuNSAxMiBDIDE5LjY3MTg3NSAxMiAxOSAxMi42NzE4NzUgMTkgMTMuNSBDIDE5IDE0LjMyODEyNSAxOS42NzE4NzUgMTUgMjAuNSAxNSBDIDIxLjMyODEyNSAxNSAyMiAxNC4zMjgxMjUgMjIgMTMuNSBDIDIyIDEyLjY3MTg3NSAyMS4zMjgxMjUgMTIgMjAuNSAxMiBaIE0gMTAuODEyNSAxOSBMIDkuMDkzNzUgMjAgQyAxMC40NzY1NjMgMjIuMzg2NzE5IDEzLjA0Njg3NSAyNCAxNiAyNCBDIDE4Ljk1MzEyNSAyNCAyMS41MjM0MzggMjIuMzg2NzE5IDIyLjkwNjI1IDIwIEwgMjEuMTg3NSAxOSBDIDIwLjE0ODQzOCAyMC43OTI5NjkgMTguMjI2NTYzIDIyIDE2IDIyIEMgMTMuNzczNDM4IDIyIDExLjg1MTU2MyAyMC43OTI5NjkgMTAuODEyNSAxOSBaIi8+PC9zdmc+";
function ic(e) {
  return e.split("-").map((t) => parseInt(t, 16)).map((t) => String.fromCodePoint(t)).join("");
}
function U8(e, t, n, r = []) {
  const i = {};
  return Object.keys(e).forEach((o) => {
    if (r.includes(o))
      return;
    const s = [];
    e[o].forEach((a) => {
      var l;
      if (a[md][0].includes(t.toLocaleLowerCase())) {
        let u = a[aw];
        if (n !== Hc && Array.isArray(a[_u])) {
          const c = ((l = a[_u]) == null ? void 0 : l.findIndex(
            (f) => f.includes(n)
          )) || -1;
          c !== -1 && a[_u] && (u = a[_u][c]);
        }
        return s.push({
          ...a,
          [fl]: u
        });
      }
    }), s.length && (i[o] = s);
  }), i;
}
function _w() {
  var e;
  return (((e = navigator == null ? void 0 : navigator.userAgentData) == null ? void 0 : e.platform) || (navigator == null ? void 0 : navigator.platform) || "unknown").toUpperCase().indexOf("MAC") !== -1;
}
function Ew(e) {
  return e.replace(
    /^_*(.)|_+(.)/g,
    (t, n, r) => n ? n.toUpperCase() : " " + r.toUpperCase()
  );
}
var Ql = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [r, i] of t)
    n[r] = i;
  return n;
};
const V8 = S({
  name: "Body",
  emits: {
    select: (e) => !0
  },
  setup() {
    const { state: e, updateEmoji: t, updateSelect: n } = Wr("store"), r = _e(null), i = R(() => U8(
      e.emojis,
      e.search,
      e.skinTone,
      e.options.disabledGroups
    )), o = jn(), s = R(() => !e.options.hideGroupNames), a = R(() => !e.options.disableStickyGroupNames), l = Sa(e.options.groupNames), u = e.orderedGroupKeys;
    e.options.additionalGroups && Object.keys(e.options.additionalGroups).map((h) => {
      e.options.groupNames[h] ? l[h] = e.options.groupNames[h] : l[h] = Ew(h);
    });
    const c = _w() ? "is-mac" : "";
    function f(h) {
      t(h);
    }
    function d(h) {
      n(h), o == null || o.emit("select", {
        ...h,
        t: e.skinTone,
        i: ic(h.r)
      });
    }
    function p(h, m) {
      var g;
      const y = (g = h == null ? void 0 : h.target) == null ? void 0 : g.closest("button");
      y && (y.innerHTML = `<span>${ic(m)}</span>`);
    }
    return Mt(
      () => e.activeGroup,
      () => {
        var h;
        const m = (h = r.value) == null ? void 0 : h.querySelector("#" + e.activeGroup);
        m && (m.parentNode.scrollTop = m.offsetTop - m.parentNode.offsetTop);
      }
    ), {
      emojis: i,
      bodyInner: r,
      EMOJI_REMOTE_SRC: ow,
      GROUP_NAMES: sw,
      handleClick: d,
      handleError: p,
      handleMouseEnter: f,
      native: e.options.native,
      unicodeToEmoji: ic,
      EMOJI_RESULT_KEY: fl,
      EMOJI_NAME_KEY: md,
      hasGroupNames: s,
      isSticky: a,
      platform: c,
      groupNames: l,
      orderedKeys: u
    };
  }
}), H8 = { class: "v3-body" }, q8 = ["id"], G8 = { class: "v3-emojis" }, W8 = ["onMouseenter", "onClick"], K8 = { key: 0 }, Y8 = ["src", "alt", "onError"], Q8 = {
  key: 1,
  class: "v3-no-result"
};
function Z8(e, t, n, r, i, o) {
  return x(), W("div", H8, [
    be("div", {
      ref: "bodyInner",
      class: ce([e.platform, "v3-body-inner"])
    }, [
      e.orderedKeys.length ? (x(!0), W(Ge, { key: 0 }, ft(e.orderedKeys, (s) => (x(), W("div", {
        id: s,
        key: s,
        class: "v3-group"
      }, [
        e.hasGroupNames ? Ja((x(), W("h5", {
          key: 0,
          class: ce(e.isSticky ? "v3-sticky" : "")
        }, ze(e.groupNames[s]), 3)), [
          [O1, e.emojis[s]]
        ]) : Qe("", !0),
        Ja(be("div", G8, [
          (x(!0), W(Ge, null, ft(e.emojis[s], (a) => (x(), W("button", {
            key: a.r,
            type: "button",
            onMouseenter: (l) => e.handleMouseEnter(a),
            onClick: (l) => e.handleClick(a)
          }, [
            e.native ? (x(), W("span", K8, ze(e.unicodeToEmoji(a.r)), 1)) : (x(), W("img", {
              key: 1,
              src: e.EMOJI_REMOTE_SRC + `/${a.r}.png`,
              alt: a.n[0],
              onError: (l) => e.handleError(l, a.r)
            }, null, 40, Y8))
          ], 40, W8))), 128))
        ], 512), [
          [O1, e.emojis[s]]
        ])
      ], 8, q8))), 128)) : (x(), W("span", Q8, " No emoji has been found! "))
    ], 2)
  ]);
}
var X8 = /* @__PURE__ */ Ql(V8, [["render", Z8]]), J8 = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSAxMi41IDUgQyAxMS40Mjk2ODggNSAxMC41IDUuNjA5Mzc1IDkuOTA2MjUgNi40Mzc1IEMgOS4zMTI1IDcuMjY1NjI1IDkgOC4zMzk4NDQgOSA5LjUgQyA5IDEwLjY2MDE1NiA5LjMxMjUgMTEuNzM0Mzc1IDkuOTA2MjUgMTIuNTYyNSBDIDEwLjUgMTMuMzkwNjI1IDExLjQyOTY4OCAxNCAxMi41IDE0IEMgMTMuNTcwMzEzIDE0IDE0LjUgMTMuMzkwNjI1IDE1LjA5Mzc1IDEyLjU2MjUgQyAxNS42ODc1IDExLjczNDM3NSAxNiAxMC42NjAxNTYgMTYgOS41IEMgMTYgOC4zMzk4NDQgMTUuNjg3NSA3LjI2NTYyNSAxNS4wOTM3NSA2LjQzNzUgQyAxNC41IDUuNjA5Mzc1IDEzLjU3MDMxMyA1IDEyLjUgNSBaIE0gMTYgOS41IEMgMTYgMTAuNjYwMTU2IDE2LjMxMjUgMTEuNzM0Mzc1IDE2LjkwNjI1IDEyLjU2MjUgQyAxNy41IDEzLjM5MDYyNSAxOC40Mjk2ODggMTQgMTkuNSAxNCBDIDIwLjU3MDMxMyAxNCAyMS41IDEzLjM5MDYyNSAyMi4wOTM3NSAxMi41NjI1IEMgMjIuNjg3NSAxMS43MzQzNzUgMjMgMTAuNjYwMTU2IDIzIDkuNSBDIDIzIDguMzM5ODQ0IDIyLjY4NzUgNy4yNjU2MjUgMjIuMDkzNzUgNi40Mzc1IEMgMjEuNSA1LjYwOTM3NSAyMC41NzAzMTMgNSAxOS41IDUgQyAxOC40Mjk2ODggNSAxNy41IDUuNjA5Mzc1IDE2LjkwNjI1IDYuNDM3NSBDIDE2LjMxMjUgNy4yNjU2MjUgMTYgOC4zMzk4NDQgMTYgOS41IFogTSAxMi41IDcgQyAxMi44MTI1IDcgMTMuMTU2MjUgNy4xNTYyNSAxMy40Njg3NSA3LjU5Mzc1IEMgMTMuNzgxMjUgOC4wMzEyNSAxNCA4LjcyNjU2MyAxNCA5LjUgQyAxNCAxMC4yNzM0MzggMTMuNzgxMjUgMTAuOTY4NzUgMTMuNDY4NzUgMTEuNDA2MjUgQyAxMy4xNTYyNSAxMS44NDM3NSAxMi44MTI1IDEyIDEyLjUgMTIgQyAxMi4xODc1IDEyIDExLjg0Mzc1IDExLjg0Mzc1IDExLjUzMTI1IDExLjQwNjI1IEMgMTEuMjE4NzUgMTAuOTY4NzUgMTEgMTAuMjczNDM4IDExIDkuNSBDIDExIDguNzI2NTYzIDExLjIxODc1IDguMDMxMjUgMTEuNTMxMjUgNy41OTM3NSBDIDExLjg0Mzc1IDcuMTU2MjUgMTIuMTg3NSA3IDEyLjUgNyBaIE0gMTkuNSA3IEMgMTkuODEyNSA3IDIwLjE1NjI1IDcuMTU2MjUgMjAuNDY4NzUgNy41OTM3NSBDIDIwLjc4MTI1IDguMDMxMjUgMjEgOC43MjY1NjMgMjEgOS41IEMgMjEgMTAuMjczNDM4IDIwLjc4MTI1IDEwLjk2ODc1IDIwLjQ2ODc1IDExLjQwNjI1IEMgMjAuMTU2MjUgMTEuODQzNzUgMTkuODEyNSAxMiAxOS41IDEyIEMgMTkuMTg3NSAxMiAxOC44NDM3NSAxMS44NDM3NSAxOC41MzEyNSAxMS40MDYyNSBDIDE4LjIxODc1IDEwLjk2ODc1IDE4IDEwLjI3MzQzOCAxOCA5LjUgQyAxOCA4LjcyNjU2MyAxOC4yMTg3NSA4LjAzMTI1IDE4LjUzMTI1IDcuNTkzNzUgQyAxOC44NDM3NSA3LjE1NjI1IDE5LjE4NzUgNyAxOS41IDcgWiBNIDcuNSAxMiBDIDYuNDI5Njg4IDEyIDUuNSAxMi42MDkzNzUgNC45MDYyNSAxMy40Mzc1IEMgNC4zMTI1IDE0LjI2NTYyNSA0IDE1LjMzOTg0NCA0IDE2LjUgQyA0IDE3LjY2MDE1NiA0LjMxMjUgMTguNzM0Mzc1IDQuOTA2MjUgMTkuNTYyNSBDIDUuNSAyMC4zOTA2MjUgNi40Mjk2ODggMjEgNy41IDIxIEMgOC41NzAzMTMgMjEgOS41IDIwLjM5MDYyNSAxMC4wOTM3NSAxOS41NjI1IEMgMTAuNjg3NSAxOC43MzQzNzUgMTEgMTcuNjYwMTU2IDExIDE2LjUgQyAxMSAxNS4zMzk4NDQgMTAuNjg3NSAxNC4yNjU2MjUgMTAuMDkzNzUgMTMuNDM3NSBDIDkuNSAxMi42MDkzNzUgOC41NzAzMTMgMTIgNy41IDEyIFogTSAyNC41IDEyIEMgMjMuNDI5Njg4IDEyIDIyLjUgMTIuNjA5Mzc1IDIxLjkwNjI1IDEzLjQzNzUgQyAyMS4zMTI1IDE0LjI2NTYyNSAyMSAxNS4zMzk4NDQgMjEgMTYuNSBDIDIxIDE3LjY2MDE1NiAyMS4zMTI1IDE4LjczNDM3NSAyMS45MDYyNSAxOS41NjI1IEMgMjIuNSAyMC4zOTA2MjUgMjMuNDI5Njg4IDIxIDI0LjUgMjEgQyAyNS41NzAzMTMgMjEgMjYuNSAyMC4zOTA2MjUgMjcuMDkzNzUgMTkuNTYyNSBDIDI3LjY4NzUgMTguNzM0Mzc1IDI4IDE3LjY2MDE1NiAyOCAxNi41IEMgMjggMTUuMzM5ODQ0IDI3LjY4NzUgMTQuMjY1NjI1IDI3LjA5Mzc1IDEzLjQzNzUgQyAyNi41IDEyLjYwOTM3NSAyNS41NzAzMTMgMTIgMjQuNSAxMiBaIE0gNy41IDE0IEMgNy44MTI1IDE0IDguMTU2MjUgMTQuMTU2MjUgOC40Njg3NSAxNC41OTM3NSBDIDguNzgxMjUgMTUuMDMxMjUgOSAxNS43MjY1NjMgOSAxNi41IEMgOSAxNy4yNzM0MzggOC43ODEyNSAxNy45Njg3NSA4LjQ2ODc1IDE4LjQwNjI1IEMgOC4xNTYyNSAxOC44NDM3NSA3LjgxMjUgMTkgNy41IDE5IEMgNy4xODc1IDE5IDYuODQzNzUgMTguODQzNzUgNi41MzEyNSAxOC40MDYyNSBDIDYuMjE4NzUgMTcuOTY4NzUgNiAxNy4yNzM0MzggNiAxNi41IEMgNiAxNS43MjY1NjMgNi4yMTg3NSAxNS4wMzEyNSA2LjUzMTI1IDE0LjU5Mzc1IEMgNi44NDM3NSAxNC4xNTYyNSA3LjE4NzUgMTQgNy41IDE0IFogTSAyNC41IDE0IEMgMjQuODEyNSAxNCAyNS4xNTYyNSAxNC4xNTYyNSAyNS40Njg3NSAxNC41OTM3NSBDIDI1Ljc4MTI1IDE1LjAzMTI1IDI2IDE1LjcyNjU2MyAyNiAxNi41IEMgMjYgMTcuMjczNDM4IDI1Ljc4MTI1IDE3Ljk2ODc1IDI1LjQ2ODc1IDE4LjQwNjI1IEMgMjUuMTU2MjUgMTguODQzNzUgMjQuODEyNSAxOSAyNC41IDE5IEMgMjQuMTg3NSAxOSAyMy44NDM3NSAxOC44NDM3NSAyMy41MzEyNSAxOC40MDYyNSBDIDIzLjIxODc1IDE3Ljk2ODc1IDIzIDE3LjI3MzQzOCAyMyAxNi41IEMgMjMgMTUuNzI2NTYzIDIzLjIxODc1IDE1LjAzMTI1IDIzLjUzMTI1IDE0LjU5Mzc1IEMgMjMuODQzNzUgMTQuMTU2MjUgMjQuMTg3NSAxNCAyNC41IDE0IFogTSAxNiAxNiBDIDE0LjY2Nzk2OSAxNiAxMy43MzgyODEgMTYuODY3MTg4IDEzLjI4MTI1IDE3LjYyNSBDIDEyLjgyNDIxOSAxOC4zODI4MTMgMTIuNTQ2ODc1IDE5LjAxNTYyNSAxMi4yODEyNSAxOS4yODEyNSBDIDEyLjEyNSAxOS40Mzc1IDExLjE2MDE1NiAxOS44MDA3ODEgMTAuMTU2MjUgMjAuMzEyNSBDIDkuNjUyMzQ0IDIwLjU3MDMxMyA5LjE0NDUzMSAyMC45MTQwNjMgOC43MTg3NSAyMS40Mzc1IEMgOC4yOTI5NjkgMjEuOTYwOTM4IDggMjIuNjg3NSA4IDIzLjUgQyA4IDI1LjQyMTg3NSA5LjU3ODEyNSAyNyAxMS41IDI3IEMgMTIuMzY3MTg4IDI3IDEzLjI2OTUzMSAyNi43MjI2NTYgMTQuMTU2MjUgMjYuNDY4NzUgQyAxNS4wNDI5NjkgMjYuMjE0ODQ0IDE2IDI2IDE2IDI2IEMgMTYgMjYgMTYuOTU3MDMxIDI2LjIxNDg0NCAxNy44NDM3NSAyNi40Njg3NSBDIDE4LjczMDQ2OSAyNi43MjI2NTYgMTkuNjMyODEzIDI3IDIwLjUgMjcgQyAyMi40MjE4NzUgMjcgMjQgMjUuNDIxODc1IDI0IDIzLjUgQyAyNCAyMi43MDcwMzEgMjMuNzA3MDMxIDIxLjk4MDQ2OSAyMy4yODEyNSAyMS40Njg3NSBDIDIyLjg1NTQ2OSAyMC45NTcwMzEgMjIuMzQzNzUgMjAuNjQwNjI1IDIxLjg0Mzc1IDIwLjM3NSBDIDIwLjg0Mzc1IDE5Ljg0Mzc1IDE5Ljg1OTM3NSAxOS40MjE4NzUgMTkuNzE4NzUgMTkuMjgxMjUgQyAxOS40ODA0NjkgMTkuMDQyOTY5IDE5LjIxMDkzOCAxOC4zOTA2MjUgMTguNzUgMTcuNjI1IEMgMTguMjg5MDYzIDE2Ljg1OTM3NSAxNy4zMzk4NDQgMTYgMTYgMTYgWiBNIDE2IDE4IEMgMTYuNjYwMTU2IDE4IDE2LjczNDM3NSAxOC4xNjAxNTYgMTcuMDMxMjUgMTguNjU2MjUgQyAxNy4zMjgxMjUgMTkuMTUyMzQ0IDE3LjU1NDY4OCAxOS45OTIxODggMTguMjgxMjUgMjAuNzE4NzUgQyAxOS4xMDU0NjkgMjEuNTQyOTY5IDIwLjE0ODQzOCAyMS43MjI2NTYgMjAuOTA2MjUgMjIuMTI1IEMgMjEuMjg1MTU2IDIyLjMyODEyNSAyMS41NzgxMjUgMjIuNTQyOTY5IDIxLjc1IDIyLjc1IEMgMjEuOTIxODc1IDIyLjk1NzAzMSAyMiAyMy4xNDg0MzggMjIgMjMuNSBDIDIyIDI0LjMzOTg0NCAyMS4zMzk4NDQgMjUgMjAuNSAyNSBDIDIwLjIxMDkzOCAyNSAxOS4yNzczNDQgMjQuNzc3MzQ0IDE4LjQwNjI1IDI0LjUzMTI1IEMgMTcuNTM1MTU2IDI0LjI4NTE1NiAxNi44MTY0MDYgMjQgMTYgMjQgQyAxNS4xODM1OTQgMjQgMTQuNDY0ODQ0IDI0LjI4NTE1NiAxMy41OTM3NSAyNC41MzEyNSBDIDEyLjcyMjY1NiAyNC43NzczNDQgMTEuNzg5MDYzIDI1IDExLjUgMjUgQyAxMC42NjAxNTYgMjUgMTAgMjQuMzM5ODQ0IDEwIDIzLjUgQyAxMCAyMy4wOTc2NTYgMTAuMDgyMDMxIDIyLjg5MDYyNSAxMC4yNSAyMi42ODc1IEMgMTAuNDE3OTY5IDIyLjQ4NDM3NSAxMC43MjI2NTYgMjIuMjg1MTU2IDExLjA5Mzc1IDIyLjA5Mzc1IEMgMTEuODM5ODQ0IDIxLjcxNDg0NCAxMi44NzUgMjEuNTYyNSAxMy43MTg3NSAyMC43MTg3NSBDIDE0LjQ1MzEyNSAxOS45ODQzNzUgMTQuNjc1NzgxIDE5LjExNzE4OCAxNC45Njg3NSAxOC42MjUgQyAxNS4yNjE3MTkgMTguMTMyODEzIDE1LjMzMjAzMSAxOCAxNiAxOCBaIi8+PC9zdmc+", eL = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSAxMSAzIEwgMTEgNyBMIDEzIDcgTCAxMyAzIFogTSAxNSA0IEwgMTUgNyBMIDE3IDcgTCAxNyA0IFogTSA0Ljg3NSA4IEwgNSA5LjA5Mzc1IEwgNi44MTI1IDI2LjMxMjUgQyA2Ljk3MjY1NiAyNy44MzIwMzEgOC4yODUxNTYgMjkgOS44MTI1IDI5IEwgMTkuMTg3NSAyOSBDIDIwLjcxNDg0NCAyOSAyMi4wMjczNDQgMjcuODMyMDMxIDIyLjE4NzUgMjYuMzEyNSBMIDIyLjY1NjI1IDIyIEwgMjUgMjIgQyAyNi42NDQ1MzEgMjIgMjggMjAuNjQ0NTMxIDI4IDE5IEwgMjggMTYgQyAyOCAxNC4zNTU0NjkgMjYuNjQ0NTMxIDEzIDI1IDEzIEwgMjMuNTkzNzUgMTMgTCAyNCA5LjA5Mzc1IEwgMjQuMTI1IDggWiBNIDcuMTI1IDEwIEwgMjEuODc1IDEwIEwgMjAuMTg3NSAyNi4wOTM3NSBDIDIwLjEzMjgxMyAyNi42MTMyODEgMTkuNzA3MDMxIDI3IDE5LjE4NzUgMjcgTCA5LjgxMjUgMjcgQyA5LjI5Mjk2OSAyNyA4Ljg2NzE4OCAyNi42MTMyODEgOC44MTI1IDI2LjA5Mzc1IFogTSAyMy4zNzUgMTUgTCAyNSAxNSBDIDI1LjU2NjQwNiAxNSAyNiAxNS40MzM1OTQgMjYgMTYgTCAyNiAxOSBDIDI2IDE5LjU2NjQwNiAyNS41NjY0MDYgMjAgMjUgMjAgTCAyMi44NDM3NSAyMCBaIi8+PC9zdmc+", tL = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSAxNiAzIEMgOC44MzIwMzEgMyAzIDguODMyMDMxIDMgMTYgQyAzIDIzLjE2Nzk2OSA4LjgzMjAzMSAyOSAxNiAyOSBDIDIzLjE2Nzk2OSAyOSAyOSAyMy4xNjc5NjkgMjkgMTYgQyAyOSA4LjgzMjAzMSAyMy4xNjc5NjkgMyAxNiAzIFogTSAxNiA1IEMgMTYuNjAxNTYzIDUgMTcuMTc1NzgxIDUuMDYyNSAxNy43NSA1LjE1NjI1IEwgMTYgNi40MDYyNSBMIDE0LjI1IDUuMTU2MjUgQyAxNC44MjAzMTMgNS4wNjY0MDYgMTUuNDAyMzQ0IDUgMTYgNSBaIE0gMTEuODEyNSA1Ljg0Mzc1IEwgMTUuNDA2MjUgOC40Njg3NSBMIDE2IDguOTA2MjUgTCAxNi41OTM3NSA4LjQ2ODc1IEwgMjAuMTg3NSA1Ljg0Mzc1IEMgMjEuNzg1MTU2IDYuNTA3ODEzIDIzLjE5NTMxMyA3LjUyMzQzOCAyNC4zMTI1IDguODEyNSBMIDIyLjkzNzUgMTMuMDkzNzUgTCAyMi43MTg3NSAxMy43ODEyNSBMIDIzLjMxMjUgMTQuMTg3NSBMIDI2LjkzNzUgMTYuODQzNzUgQyAyNi44MDQ2ODggMTguNjA1NDY5IDI2LjI2NTYyNSAyMC4yNTc4MTMgMjUuNDA2MjUgMjEuNjg3NSBMIDIwLjEyNSAyMS42ODc1IEwgMTkuOTA2MjUgMjIuMzc1IEwgMTguNSAyNi43MTg3NSBDIDE3LjY5OTIxOSAyNi45MDYyNSAxNi44NTkzNzUgMjcgMTYgMjcgQyAxNS4xMDU0NjkgMjcgMTQuMjM4MjgxIDI2Ljg4NjcxOSAxMy40MDYyNSAyNi42ODc1IEwgMTIuMDMxMjUgMjIuNDA2MjUgTCAxMS44MTI1IDIxLjcxODc1IEwgNi41OTM3NSAyMS43MTg3NSBDIDUuNzE4NzUgMjAuMjgxMjUgNS4xOTkyMTkgMTguNjIxMDk0IDUuMDYyNSAxNi44NDM3NSBMIDguNjU2MjUgMTQuMjE4NzUgTCA5LjI1IDEzLjgxMjUgTCA5LjAzMTI1IDEzLjEyNSBMIDcuNjI1IDguODc1IEMgOC43NSA3LjU1NDY4OCAxMC4xODM1OTQgNi41MTU2MjUgMTEuODEyNSA1Ljg0Mzc1IFogTSAxNiAxMC4wOTM3NSBMIDE1LjQwNjI1IDEwLjUzMTI1IEwgMTAuODQzNzUgMTMuODQzNzUgTCAxMC4yODEyNSAxNC4yODEyNSBMIDEwLjUgMTQuOTY4NzUgTCAxMi4yNSAyMC4zMTI1IEwgMTIuNDY4NzUgMjEgTCAxOS41MzEyNSAyMSBMIDE5Ljc1IDIwLjMxMjUgTCAyMS41IDE0Ljk2ODc1IEwgMjEuNzE4NzUgMTQuMjgxMjUgTCAyMS4xNTYyNSAxMy44NDM3NSBMIDE2LjU5Mzc1IDEwLjUzMTI1IFogTSAyNS43NSAxMC45MDYyNSBDIDI2LjI5Njg3NSAxMS45NTMxMjUgMjYuNjU2MjUgMTMuMTAxNTYzIDI2Ljg0Mzc1IDE0LjMxMjUgTCAyNS4wNjI1IDEzLjAzMTI1IFogTSA2LjIxODc1IDEwLjk2ODc1IEwgNi45MDYyNSAxMy4wMzEyNSBMIDUuMTU2MjUgMTQuMzEyNSBDIDUuMzM5ODQ0IDEzLjEyNSA1LjY4NzUgMTIgNi4yMTg3NSAxMC45Njg3NSBaIE0gMTYgMTIuNTkzNzUgTCAxOS4zNzUgMTUuMDMxMjUgTCAxOC4wOTM3NSAxOSBMIDEzLjkwNjI1IDE5IEwgMTIuNjI1IDE1LjAzMTI1IFogTSAyMS41OTM3NSAyMy42ODc1IEwgMjMuODQzNzUgMjMuNjg3NSBDIDIyLjk5MjE4OCAyNC41NjY0MDYgMjIuMDExNzE5IDI1LjI5Mjk2OSAyMC45MDYyNSAyNS44NDM3NSBaIE0gOC4xNTYyNSAyMy43MTg3NSBMIDEwLjM0Mzc1IDIzLjcxODc1IEwgMTEuMDMxMjUgMjUuODEyNSBDIDkuOTYwOTM4IDI1LjI2OTUzMSA4Ljk4ODI4MSAyNC41NjI1IDguMTU2MjUgMjMuNzE4NzUgWiIvPjwvc3ZnPg==", nL = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSA5LjUgNiBDIDguMTc5Njg4IDYgNy4wMDM5MDYgNi44NTkzNzUgNi42MjUgOC4xMjUgTCA1LjI1IDEyLjcxODc1IEwgMy4zMTI1IDEyLjA2MjUgTCAyLjY4NzUgMTMuOTM3NSBMIDQuNjU2MjUgMTQuNTkzNzUgTCA0LjAzMTI1IDE2LjcxODc1IEMgNC4wMDc4MTMgMTYuODA4NTk0IDMuOTk2MDk0IDE2LjkwNjI1IDQgMTcgTCA0IDI0IEMgNCAyNC4wMzEyNSA0IDI0LjA2MjUgNCAyNC4wOTM3NSBMIDQgMjUgQyA0IDI1LjU1MDc4MSA0LjQ0OTIxOSAyNiA1IDI2IEwgOCAyNiBMIDguMzQzNzUgMjUgTCAyMy42NTYyNSAyNSBMIDI0IDI2IEwgMjcgMjYgQyAyNy41NTA3ODEgMjYgMjggMjUuNTUwNzgxIDI4IDI1IEwgMjggMjQuMTU2MjUgQyAyOC4wMDM5MDYgMjQuMTA1NDY5IDI4LjAwMzkwNiAyNC4wNTA3ODEgMjggMjQgTCAyOCAxNyBDIDI4LjAwMzkwNiAxNi45MDYyNSAyNy45OTIxODggMTYuODA4NTk0IDI3Ljk2ODc1IDE2LjcxODc1IEwgMjcuMzQzNzUgMTQuNTkzNzUgTCAyOS4zMTI1IDEzLjkzNzUgTCAyOC42ODc1IDEyLjA2MjUgTCAyNi43NSAxMi43MTg3NSBMIDI1LjM3NSA4LjEyNSBDIDI0Ljk5NjA5NCA2Ljg1OTM3NSAyMy44MjAzMTMgNiAyMi41IDYgWiBNIDkuNSA4IEwgMjIuNSA4IEMgMjIuOTQ1MzEzIDggMjMuMzM5ODQ0IDguMjkyOTY5IDIzLjQ2ODc1IDguNzE4NzUgTCAyNC43NSAxMyBMIDcuMjUgMTMgTCA4LjUzMTI1IDguNzE4NzUgQyA4LjY2MDE1NiA4LjI4OTA2MyA5LjA1NDY4OCA4IDkuNSA4IFogTSA2LjY1NjI1IDE1IEwgMjUuMzQzNzUgMTUgTCAyNiAxNy4xODc1IEwgMjYgMjMgTCA2IDIzIEwgNiAxNy4xODc1IFogTSA4LjUgMTYgQyA3LjY3MTg3NSAxNiA3IDE2LjY3MTg3NSA3IDE3LjUgQyA3IDE4LjMyODEyNSA3LjY3MTg3NSAxOSA4LjUgMTkgQyA5LjMyODEyNSAxOSAxMCAxOC4zMjgxMjUgMTAgMTcuNSBDIDEwIDE2LjY3MTg3NSA5LjMyODEyNSAxNiA4LjUgMTYgWiBNIDIzLjUgMTYgQyAyMi42NzE4NzUgMTYgMjIgMTYuNjcxODc1IDIyIDE3LjUgQyAyMiAxOC4zMjgxMjUgMjIuNjcxODc1IDE5IDIzLjUgMTkgQyAyNC4zMjgxMjUgMTkgMjUgMTguMzI4MTI1IDI1IDE3LjUgQyAyNSAxNi42NzE4NzUgMjQuMzI4MTI1IDE2IDIzLjUgMTYgWiBNIDEyIDE5IEwgMTAuNzUgMjIgTCAxMi45MDYyNSAyMiBMIDEzLjM0Mzc1IDIxIEwgMTguNjU2MjUgMjEgTCAxOS4wOTM3NSAyMiBMIDIxLjI1IDIyIEwgMjAgMTkgWiIvPjwvc3ZnPg==", rL = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSAxNiA0IEMgMTEuMDQyOTY5IDQgNyA4LjA0Mjk2OSA3IDEzIEMgNyAxNC45MTc5NjkgNy44NDM3NSAxNi45MDYyNSA5IDE4LjY4NzUgQyA5Ljg1OTM3NSAyMC4wMTE3MTkgMTAuODg2NzE5IDIxLjIzMDQ2OSAxMiAyMi4xNTYyNSBMIDEyIDI1IEMgMTIgMjYuMDkzNzUgMTIuOTA2MjUgMjcgMTQgMjcgTCAxNSAyOCBMIDE3IDI4IEwgMTggMjcgQyAxOS4wOTM3NSAyNyAyMCAyNi4wOTM3NSAyMCAyNSBMIDIwIDIyLjE1NjI1IEMgMjEuMTEzMjgxIDIxLjIzMDQ2OSAyMi4xNDA2MjUgMjAuMDExNzE5IDIzIDE4LjY4NzUgQyAyNC4xNTYyNSAxNi45MDYyNSAyNSAxNC45MTc5NjkgMjUgMTMgQyAyNSA4LjA0Mjk2OSAyMC45NTcwMzEgNCAxNiA0IFogTSAxNiA2IEMgMTkuODc4OTA2IDYgMjMgOS4xMjEwOTQgMjMgMTMgQyAyMyAxNC4zMDg1OTQgMjIuMzU1NDY5IDE2LjAzNTE1NiAyMS4zNDM3NSAxNy41OTM3NSBDIDIwLjQ0MTQwNiAxOC45ODQzNzUgMTkuMjUzOTA2IDIwLjIyMjY1NiAxOC4xNTYyNSAyMSBMIDEzLjg0Mzc1IDIxIEMgMTIuNzQ2MDk0IDIwLjIyMjY1NiAxMS41NTg1OTQgMTguOTg0Mzc1IDEwLjY1NjI1IDE3LjU5Mzc1IEMgOS42NDQ1MzEgMTYuMDM1MTU2IDkgMTQuMzA4NTk0IDkgMTMgQyA5IDkuMTIxMDk0IDEyLjEyMTA5NCA2IDE2IDYgWiBNIDE0LjI1IDIzIEwgMTcuNzUgMjMgQyAxNy44MjgxMjUgMjMuMDU0Njg4IDE3LjkxMDE1NiAyMy4wOTM3NSAxOCAyMy4xMjUgTCAxOCAyNSBMIDE0IDI1IEwgMTQgMjMuMTI1IEMgMTQuMDg5ODQ0IDIzLjA5Mzc1IDE0LjE3MTg3NSAyMy4wNTQ2ODggMTQuMjUgMjMgWiIvPjwvc3ZnPg==", iL = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSAxMSA1IEwgMTEgMTEgTCA1IDExIEwgNSAxMyBMIDExIDEzIEwgMTEgMTkgTCA1IDE5IEwgNSAyMSBMIDExIDIxIEwgMTEgMjcgTCAxMyAyNyBMIDEzIDIxIEwgMTkgMjEgTCAxOSAyNyBMIDIxIDI3IEwgMjEgMjEgTCAyNyAyMSBMIDI3IDE5IEwgMjEgMTkgTCAyMSAxMyBMIDI3IDEzIEwgMjcgMTEgTCAyMSAxMSBMIDIxIDUgTCAxOSA1IEwgMTkgMTEgTCAxMyAxMSBMIDEzIDUgWiBNIDEzIDEzIEwgMTkgMTMgTCAxOSAxOSBMIDEzIDE5IFoiLz48L3N2Zz4=", oL = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSA5IDQgQyA3LjM0NiA0IDYgNS4zNDYgNiA3IEMgNiA4LjMwMTYwOTQgNi44Mzg3NDg2IDkuNDAyMTM5MSA4IDkuODE2NDA2MiBMIDggMTEuMzA0Njg4IEwgOCAyMy4yMDcwMzEgTCA4IDI3LjAyMzQzOCBDIDggMjcuNTYzNDM4IDguNDM2NTYyNSAyOCA4Ljk3NjU2MjUgMjggTCA5LjAyMzQzNzUgMjggQyA5LjU2MzQzNzUgMjggMTAgMjcuNTYzNDM3IDEwIDI3LjAyMzQzOCBMIDEwIDIyLjIyODUxNiBDIDEwLjMzNDcwNyAyMS44Mzk3NTYgMTEuMTM4NDIzIDIxLjA0Njg3NSAxMy40NDUzMTIgMjEuMDQ2ODc1IEMgMTQuNjY5MzEzIDIxLjA0Njg3NSAxNS42NzA0MjIgMjEuNDczNzgxIDE2LjczMjQyMiAyMS45MjU3ODEgQyAxNy43Njk0MjIgMjIuMzY3NzgxIDE4Ljg0MTg5MSAyMi44MjQyMTkgMjAuMDg3ODkxIDIyLjgyNDIxOSBDIDIyLjQ0Njg5MSAyMi44MjQyMTkgMjQuMDQ5Mzc1IDIxLjU4NDY4OCAyNC43MzQzNzUgMjEuMDU0Njg4IEwgMjQuODg2NzE5IDIwLjkzOTQ1MyBDIDI1LjQzNzcxOSAyMC41NDA0NTMgMjYgMTkuOTk2IDI2IDE5IEwgMjYgMTAuNjc1NzgxIEMgMjYgOS43Njc3ODEyIDI1LjIyMTgyOCA5IDI0LjI5ODgyOCA5IEMgMjMuODAzODI4IDkgMjMuNDQwNDA2IDkuMjg2NTkzNyAyMi45NDE0MDYgOS42ODM1OTM4IEMgMjIuMjc5NDA2IDEwLjIwNzU5NCAyMS4yODA4OTEgMTEgMjAuMDg3ODkxIDExIEMgMTkuMjcyODkxIDExIDE4LjQ3NzY4OCAxMC42MTk3MzQgMTcuNTU0Njg4IDEwLjE3NzczNCBDIDE2LjQwMzY4NyA5LjYyNTczNDQgMTUuMDk4MzU5IDkgMTMuNDQzMzU5IDkgQyAxMi4zMDgyNTcgOSAxMS40MjE2ODcgOS4xODgzMzkzIDEwLjcxMjg5MSA5LjQ1NzAzMTIgQyAxMS40ODkwNzEgOC45MTQxODI0IDEyIDguMDE2NzgwMiAxMiA3IEMgMTIgNS4zNDYgMTAuNjU0IDQgOSA0IHogTSA5IDYgQyA5LjU1MiA2IDEwIDYuNDQ5IDEwIDcgQyAxMCA3LjU1MSA5LjU1MiA4IDkgOCBDIDguNDQ4IDggOCA3LjU1MSA4IDcgQyA4IDYuNDQ5IDguNDQ4IDYgOSA2IHogTSAxMy40NDMzNTkgMTEgQyAxNC42NDUzNTkgMTEgMTUuNjM4NDA2IDExLjQ3NjQ2OSAxNi42OTE0MDYgMTEuOTgwNDY5IEMgMTcuNzM2NDA2IDEyLjQ4MjQ2OSAxOC44MTc4OTEgMTMgMjAuMDg3ODkxIDEzIEMgMjEuODQyODkxIDEzIDIzLjE1ODA0NyAxMi4wNTQ0ODQgMjMuOTk4MDQ3IDExLjM5NjQ4NCBMIDIzLjk5ODA0NyAxOS4wNjY0MDYgQyAyMy45OTcwNDcgMTkuMDcwNDA2IDIzLjk1Mjk4NCAxOS4xNDUyNjYgMjMuNzA4OTg0IDE5LjMyMjI2NiBMIDIzLjUwOTc2NiAxOS40NzQ2MDkgQyAyMi45NDI3NjYgMTkuOTEyNjA5IDIxLjc2Mjg5MSAyMC44MjQyMTkgMjAuMDg3ODkxIDIwLjgyNDIxOSBDIDE5LjI0OTg5MSAyMC44MjQyMTkgMTguNDQ2NjI1IDIwLjQ4MjkzNyAxNy41MTU2MjUgMjAuMDg1OTM4IEMgMTYuMzcyNjI1IDE5LjU5NzkzOCAxNS4wNzYzNTkgMTkuMDQ0OTIyIDEzLjQ0MzM1OSAxOS4wNDQ5MjIgQyAxMS44OTEzNTkgMTkuMDQ0OTIyIDEwLjc4NiAxOS4zNTggMTAgMTkuNzUgTCAxMCAxMi4zNjEzMjggQyAxMC4zNDUgMTEuOTA1MzI4IDExLjEzMjM1OSAxMSAxMy40NDMzNTkgMTEgeiIvPjwvc3ZnPg==", sL = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSAxNiA0IEMgMTEuODMyMDMxIDQgOC4xNTIzNDQgNi4xMTMyODEgNiA5LjM0Mzc1IEwgNiA2IEwgNCA2IEwgNCAxMyBMIDExIDEzIEwgMTEgMTEgTCA3LjM3NSAxMSBDIDkuMTAxNTYzIDguMDE5NTMxIDEyLjI5Njg3NSA2IDE2IDYgQyAyMS41MzUxNTYgNiAyNiAxMC40NjQ4NDQgMjYgMTYgQyAyNiAyMS41MzUxNTYgMjEuNTM1MTU2IDI2IDE2IDI2IEMgMTAuNDY0ODQ0IDI2IDYgMjEuNTM1MTU2IDYgMTYgTCA0IDE2IEMgNCAyMi42MTcxODggOS4zODI4MTMgMjggMTYgMjggQyAyMi42MTcxODggMjggMjggMjIuNjE3MTg4IDI4IDE2IEMgMjggOS4zODI4MTMgMjIuNjE3MTg4IDQgMTYgNCBaIE0gMTUgOCBMIDE1IDE3IEwgMjIgMTcgTCAyMiAxNSBMIDE3IDE1IEwgMTcgOCBaIi8+PC9zdmc+Cg==";
const aL = S({
  name: "Header",
  setup(e) {
    const { state: t, updateSearch: n, updateActiveGroup: r } = Wr("store"), i = R(() => !t.options.hideSearch), o = R(() => !t.options.hideGroupIcons), s = JSON.parse(JSON.stringify(t.orderedGroupKeys)), a = R(
      () => t.options.staticTexts.placeholder || ""
    ), l = R({
      get: () => t.search,
      set: (f) => n(f)
    }), u = [
      ...t.groups,
      ...Object.keys(t.options.additionalGroups).map((f) => ({
        key: f,
        title: t.options.groupNames[f] ? t.options.groupNames[f] : Ew(f)
      }))
    ], c = [];
    return s.forEach((f) => {
      const d = u.findIndex((p) => p.key === f);
      d !== -1 && (c.push(u[d]), u.splice(d, 1));
    }), {
      orderedGroups: c,
      orderedKeys: s,
      searchValue: l,
      updateActiveGroup: r,
      hasSearch: i,
      hasGroupIcons: o,
      placeholder: a,
      icons: {
        smileys_people: vw,
        animals_nature: J8,
        food_drink: eL,
        activities: tL,
        travel_places: nL,
        objects: rL,
        symbols: iL,
        flags: oL,
        ...t.options.groupIcons,
        recent: sL
      }
    };
  }
}), lL = {
  key: 0,
  class: "v3-header"
}, uL = {
  key: 0,
  class: "v3-groups"
}, cL = ["onClick"], fL = ["title"], dL = ["src"], pL = {
  key: 1,
  class: "v3-spacing"
}, hL = {
  key: 2,
  class: "v3-search"
}, gL = ["placeholder"];
function mL(e, t, n, r, i, o) {
  return e.hasGroupIcons || e.hasSearch ? (x(), W("div", lL, [
    e.hasGroupIcons ? (x(), W("div", uL, [
      (x(!0), W(Ge, null, ft(e.orderedGroups, (s) => (x(), W("button", {
        key: s.key,
        type: "button",
        class: ce(["v3-group", {
          "v3-is-hidden": !e.icons[s.key]
        }]),
        onClick: (a) => e.updateActiveGroup(s.key)
      }, [
        be("span", {
          title: s.title,
          class: "v3-icon"
        }, [
          be("img", {
            src: e.icons[s.key],
            alt: ""
          }, null, 8, dL)
        ], 8, fL)
      ], 10, cL))), 128))
    ])) : Qe("", !0),
    e.hasGroupIcons && e.hasSearch ? (x(), W("div", pL)) : Qe("", !0),
    e.hasSearch ? (x(), W("div", hL, [
      Ja(be("input", {
        "onUpdate:modelValue": t[0] || (t[0] = (s) => e.searchValue = s),
        type: "text",
        placeholder: e.placeholder
      }, null, 8, gL), [
        [Q_, e.searchValue]
      ])
    ])) : Qe("", !0)
  ])) : Qe("", !0);
}
var bL = /* @__PURE__ */ Ql(aL, [["render", mL]]);
const yL = S({
  name: "Header",
  setup() {
    const { state: e, updateSkinTone: t } = Wr("store"), n = _e(!1), r = _e(!1), i = R(() => e.skinTone), o = R(
      () => e.options.staticTexts.skinTone || "Skin tone"
    ), s = R(() => !e.options.disableSkinTones), a = _w() ? "is-mac" : "", l = R(() => ({
      ...e.emoji,
      src: ow + "/" + e.emoji[fl] + ".png"
    }));
    function u(d = !0) {
      n.value = d;
    }
    function c() {
      n.value = !n.value;
    }
    function f(d) {
      t(d), u(!1);
    }
    return Mt(
      () => e.emoji,
      () => {
        r.value = !1;
      }
    ), {
      emoji: l,
      SKIN_TONES: cR,
      updateSkinToneState: u,
      skinTone: n,
      stateSkinTone: i,
      selectSkinTone: f,
      toggleSkinToneState: c,
      EMOJI_RESULT_KEY: fl,
      EMOJI_NAME_KEY: md,
      skinToneText: o,
      hasSkinTones: s,
      native: e.options.native,
      unicodeToEmoji: ic,
      platform: a,
      hasError: r
    };
  }
}), vL = { class: "v3-foot-left" }, _L = { key: 0 }, EL = ["alt", "src"], wL = { class: "v3-text" }, xL = { class: "v3-text" }, kL = ["onClick"];
function ML(e, t, n, r, i, o) {
  return x(), W("div", {
    class: "v3-footer",
    onMouseleave: t[2] || (t[2] = (s) => e.updateSkinToneState(!1))
  }, [
    be("div", vL, [
      be("span", {
        class: ce([e.platform, "v3-icon"])
      }, [
        e.native || e.hasError ? (x(), W("span", _L, ze(e.unicodeToEmoji(e.emoji.r)), 1)) : (x(), W("img", {
          key: 1,
          alt: e.unicodeToEmoji(e.emoji.r),
          src: e.emoji.src,
          onError: t[0] || (t[0] = (s) => e.hasError = !0)
        }, null, 40, EL))
      ], 2),
      be("span", wL, " :" + ze(e.emoji[e.EMOJI_NAME_KEY][1] || e.emoji[e.EMOJI_NAME_KEY][0]) + ": ", 1)
    ]),
    e.hasSkinTones ? (x(), W(Ge, { key: 0 }, [
      be("button", {
        type: "button",
        class: "v3-tone",
        onClick: t[1] || (t[1] = (...s) => e.toggleSkinToneState && e.toggleSkinToneState(...s))
      }, [
        be("span", xL, ze(e.skinToneText), 1),
        be("span", {
          class: ce(`v3-icon v3-tone-${e.stateSkinTone}`)
        }, null, 2)
      ]),
      be("div", {
        class: ce([e.skinTone ? "v3-is-open" : "", "v3-skin-tones"])
      }, [
        (x(!0), W(Ge, null, ft(e.SKIN_TONES, (s) => (x(), W("button", {
          key: s,
          type: "button",
          class: ce(["v3-skin-tone-" + s, "v3-skin-tone"]),
          onClick: (a) => e.selectSkinTone(s)
        }, null, 10, kL))), 128))
      ], 2)
    ], 64)) : Qe("", !0)
  ], 32);
}
var AL = /* @__PURE__ */ Ql(yL, [["render", ML]]);
const TL = S({
  name: "PickerRoot",
  components: {
    Header: bL,
    Body: X8,
    Footer: AL
  },
  props: {
    type: {
      type: String,
      default: ""
    },
    text: {
      type: String,
      default: ""
    },
    additionalGroups: {
      type: Object,
      default: () => ({})
    },
    groupOrder: {
      type: Array,
      default: () => []
    },
    groupIcons: {
      type: Object,
      default: () => ({})
    },
    groupNames: {
      type: Object,
      default: () => ({})
    }
  },
  emits: {
    select: (e) => !0,
    "update:text": (e) => !0
  },
  setup(e, { emit: t }) {
    const n = _e(), r = _e(), i = _e(), o = _e(!1), s = _e(e.text), a = e.type === "input" || e.type === "textarea";
    let l = -1;
    const { state: u } = Wr("store"), c = R(() => u.options.colorTheme);
    function f(g) {
      if (a) {
        const y = u.options.mode;
        y === "prepend" ? s.value = g.i + s.value : y === "insert" && l !== -1 ? (s.value = `${s.value.slice(0, l)}${g.i}${s.value.slice(l)}`, l += g.i.length) : s.value += g.i, t("update:text", s.value);
      }
      t("select", g);
    }
    function d() {
      var g;
      n.value && (l = ((g = n.value) == null ? void 0 : g.selectionEnd) || -1);
    }
    function p(g) {
      var y;
      !((y = g.target) != null && y.closest(
        ".v3-input-picker-wrap"
      )) && o.value && (o.value = !1);
    }
    function h() {
      if (r.value && i.value && a) {
        let g = u.options.offset;
        typeof g != "number" && (g = 6), j8(r.value, i.value, {
          placement: "bottom-end",
          modifiers: [
            {
              name: "offset",
              options: {
                offset: [0, g]
              }
            }
          ]
        }), document.body.addEventListener("click", p);
      }
    }
    function m(g) {
      s.value = g.target.value || "", t("update:text", s.value);
    }
    return Jn(() => {
      h();
    }), Qs(() => {
      document.body.removeEventListener("click", p);
    }), {
      face: vw,
      open: o,
      onSelect: f,
      input: s,
      elem: n,
      updateCursor: d,
      button: r,
      picker: i,
      isInputType: a,
      onChangeText: m,
      colorTheme: c
    };
  }
}), SL = {
  key: 0,
  class: "v3-input-emoji-picker"
}, CL = { class: "v3-input-picker-root" }, NL = ["value"], DL = ["value"], OL = ["src"];
function IL(e, t, n, r, i, o) {
  const s = Ta("Header"), a = Ta("Body"), l = Ta("Footer");
  return e.isInputType ? (x(), W("div", SL, [
    be("div", CL, [
      e.type === "input" ? (x(), W("input", {
        key: 0,
        ref: "elem",
        value: e.input,
        type: "text",
        class: "v3-emoji-picker-input",
        onInput: t[0] || (t[0] = (...u) => e.onChangeText && e.onChangeText(...u)),
        onBlur: t[1] || (t[1] = (...u) => e.updateCursor && e.updateCursor(...u))
      }, null, 40, NL)) : (x(), W("textarea", {
        key: 1,
        ref: "elem",
        value: e.input,
        class: "v3-emoji-picker-textarea",
        onInput: t[2] || (t[2] = (...u) => e.onChangeText && e.onChangeText(...u)),
        onBlur: t[3] || (t[3] = (...u) => e.updateCursor && e.updateCursor(...u))
      }, null, 40, DL)),
      be("div", {
        class: ce(["v3-input-picker-wrap", e.open ? "v3-picker-is-open" : ""])
      }, [
        be("button", {
          ref: "button",
          type: "button",
          class: "v3-input-picker-icon",
          onClick: t[4] || (t[4] = (u) => e.open = !e.open)
        }, [
          be("img", {
            src: e.face,
            alt: ""
          }, null, 8, OL)
        ], 512),
        be("div", {
          ref: "picker",
          class: ce(["v3-emoji-picker", "v3-color-theme-" + e.colorTheme])
        }, [
          $(s),
          $(a, { onSelect: e.onSelect }, null, 8, ["onSelect"]),
          $(l)
        ], 2)
      ], 2)
    ])
  ])) : (x(), W("div", {
    key: 1,
    class: ce(["v3-emoji-picker", "v3-color-theme-" + e.colorTheme])
  }, [
    $(s),
    $(a, { onSelect: e.onSelect }, null, 8, ["onSelect"]),
    $(l)
  ], 2));
}
var RL = /* @__PURE__ */ Ql(TL, [["render", IL]]);
const LL = S({
  name: "Picker",
  components: {
    PickerRoot: RL
  },
  props: {
    native: {
      type: Boolean,
      default: !1
    },
    hideSearch: {
      type: Boolean,
      default: !1
    },
    hideGroupIcons: {
      type: Boolean,
      default: !1
    },
    hideGroupNames: {
      type: Boolean,
      default: !1
    },
    staticTexts: {
      type: Object,
      default: () => ({})
    },
    disableStickyGroupNames: {
      type: Boolean,
      default: !1
    },
    disabledGroups: {
      type: Array,
      default: () => []
    },
    groupNames: {
      type: Object,
      default: () => ({})
    },
    disableSkinTones: {
      type: Boolean,
      default: !1
    },
    text: {
      type: String,
      default: ""
    },
    mode: {
      type: String,
      default: "insert"
    },
    offset: {
      type: Number,
      default: 6
    },
    additionalGroups: {
      type: Object,
      default: () => ({})
    },
    groupOrder: {
      type: Array,
      default: () => []
    },
    groupIcons: {
      type: Object,
      default: () => ({})
    },
    pickerType: {
      type: String,
      default: ""
    },
    displayRecent: {
      type: Boolean,
      default: !1
    },
    theme: {
      type: String,
      default: "light"
    }
  },
  emits: {
    "update:text": (e) => !0,
    select: (e) => !0
  },
  setup(e, { emit: t }) {
    const n = _e(e.text);
    function r(o) {
      n.value = o || "", t("update:text", n.value);
    }
    const i = LR();
    return i.updateOptions({
      native: e.native,
      hideSearch: e.hideSearch,
      hideGroupIcons: e.hideGroupIcons,
      hideGroupNames: e.hideGroupNames,
      staticTexts: { ...fR, ...e.staticTexts },
      disableStickyGroupNames: e.disableStickyGroupNames,
      disabledGroups: e.disabledGroups,
      groupNames: { ...sw, ...e.groupNames },
      disableSkinTones: e.disableSkinTones,
      displayRecent: e.displayRecent,
      additionalGroups: e.additionalGroups,
      mode: e.mode,
      offset: e.offset,
      groupOrder: e.groupOrder,
      groupIcons: e.groupIcons,
      colorTheme: dR.includes(e.theme) ? e.theme : "light"
    }), zi("store", i), {
      type: e.pickerType,
      input: n,
      onChangeText: r
    };
  }
});
function BL(e, t, n, r, i, o) {
  const s = Ta("picker-root");
  return x(), L(s, {
    type: e.type,
    text: e.input,
    onSelect: t[0] || (t[0] = (a) => e.$emit("select", a)),
    "onUpdate:text": e.onChangeText
  }, null, 8, ["type", "text", "onUpdate:text"]);
}
var PL = /* @__PURE__ */ Ql(LL, [["render", BL]]);
const $L = /* @__PURE__ */ S({
  __name: "EmojiSelector",
  props: {
    open: { type: Boolean, default: !1 },
    theme: { default: "auto" }
  },
  emits: ["select", "update:open"],
  setup(e, { emit: t }) {
    const n = t, r = (i) => {
      n("select", i), n("update:open", !1);
    };
    return (i, o) => (x(), L(b(z0), {
      open: i.open,
      "onUpdate:open": o[1] || (o[1] = (s) => n("update:open", s))
    }, {
      default: A(() => [
        $(b(F0), { "as-child": "" }, {
          default: A(() => [
            $(b(Kr), oe({ variant: "ghost" }, i.$attrs, {
              onClick: o[0] || (o[0] = () => n("update:open", !i.open))
            }), {
              default: A(() => [
                $(b(dS), { class: "inline-block h-5 w-5 cursor-pointer" })
              ]),
              _: 1
            }, 16)
          ]),
          _: 1
        }),
        $(b(j0), { class: "w-auto p-0" }, {
          default: A(() => [
            $(b(PL), {
              native: !0,
              onSelect: r,
              theme: i.theme
            }, null, 8, ["theme"])
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["open"]));
  }
}), zL = /* @__PURE__ */ S({
  __name: "Emoji",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 },
    isActive: { type: Boolean, default: !1 }
  },
  setup(e) {
    const t = e, n = _e(!1), r = (i) => {
      t.editor.chain().focus().insertContent(i.i).run();
    };
    return (i, o) => (x(), L(Vc, {
      disabled: i.disabled,
      isActive: i.isActive,
      tooltip: "Add Emojis",
      "aria-label": "Add Emojis",
      "handle-action": () => n.value = !0
    }, {
      icon: A(() => [
        $($L, {
          open: n.value,
          "onUpdate:open": o[0] || (o[0] = (s) => n.value = s),
          onSelect: r
        }, null, 8, ["open"])
      ]),
      _: 1
    }, 8, ["disabled", "isActive", "handle-action"]));
  }
}), FL = { class: "shrink-0 overflow-x-auto border-b border-border p-2" }, jL = { class: "flex w-max items-center gap-px" }, UL = /* @__PURE__ */ S({
  __name: "Toolbar",
  props: {
    editor: {}
  },
  setup(e) {
    return (t, n) => (x(), W("div", FL, [
      be("div", jL, [
        $(eR, {
          editor: t.editor,
          activeLevels: [1, 2, 3]
        }, null, 8, ["editor"]),
        $(b(_p), {
          orientation: "vertical",
          class: "mx-2 h-7"
        }),
        $(nR, {
          editor: t.editor,
          actions: ["bold", "italic", "underline", "strikethrough", "code", "clearFormatting"],
          mainActionCount: 3
        }, null, 8, ["editor"]),
        $(b(_p), {
          orientation: "vertical",
          class: "mx-2 h-7"
        }),
        $(rR, {
          editor: t.editor,
          actions: ["orderedList", "bulletList", "checkList"],
          mainActionCount: 3
        }, null, 8, ["editor"]),
        $(b(_p), {
          orientation: "vertical",
          class: "mx-2 h-7"
        }),
        $(zL, { editor: t.editor }, null, 8, ["editor"])
      ])
    ]));
  }
}), VL = /^\s*>\s$/, HL = lt.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: !0,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["blockquote", At(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: e }) => e.wrapIn(this.name),
      toggleBlockquote: () => ({ commands: e }) => e.toggleWrap(this.name),
      unsetBlockquote: () => ({ commands: e }) => e.lift(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      Ts({
        find: VL,
        type: this.type
      })
    ];
  }
}), qL = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, GL = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, WL = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, KL = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, YL = Jt.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (e) => e.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (e) => e.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (e) => /^(bold(er)?|[5-9]\d{2,})$/.test(e) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["strong", At(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: e }) => e.setMark(this.name),
      toggleBold: () => ({ commands: e }) => e.toggleMark(this.name),
      unsetBold: () => ({ commands: e }) => e.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      As({
        find: qL,
        type: this.type
      }),
      As({
        find: WL,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Io({
        find: GL,
        type: this.type
      }),
      Io({
        find: KL,
        type: this.type
      })
    ];
  }
}), QL = "listItem", Pb = "textStyle", $b = /^\s*([-+*])\s$/, ZL = lt.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["ul", At(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: e, chain: t }) => this.options.keepAttributes ? t().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(QL, this.editor.getAttributes(Pb)).run() : e.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let e = Ts({
      find: $b,
      type: this.type
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (e = Ts({
      find: $b,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: () => this.editor.getAttributes(Pb),
      editor: this.editor
    })), [
      e
    ];
  }
}), XL = new RegExp("(?<!`)`([^`]+)`(?!`)"), JL = new RegExp("(?<!`)`([^`]+)`(?!`)", "g"), eB = Jt.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: !0,
  exitable: !0,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["code", At(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: e }) => e.setMark(this.name),
      toggleCode: () => ({ commands: e }) => e.toggleMark(this.name),
      unsetCode: () => ({ commands: e }) => e.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      As({
        find: XL,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Io({
        find: JL,
        type: this.type
      })
    ];
  }
}), tB = /^```([a-z]+)?[\s\n]$/, nB = /^~~~([a-z]+)?[\s\n]$/, ww = lt.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      defaultLanguage: null,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: !0,
  defining: !0,
  addAttributes() {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (e) => {
          var t;
          const { languageClassPrefix: n } = this.options, o = [...((t = e.firstElementChild) === null || t === void 0 ? void 0 : t.classList) || []].filter((s) => s.startsWith(n)).map((s) => s.replace(n, ""))[0];
          return o || null;
        },
        rendered: !1
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node: e, HTMLAttributes: t }) {
    return [
      "pre",
      At(this.options.HTMLAttributes, t),
      [
        "code",
        {
          class: e.attrs.language ? this.options.languageClassPrefix + e.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (e) => ({ commands: t }) => t.setNode(this.name, e),
      toggleCodeBlock: (e) => ({ commands: t }) => t.toggleNode(this.name, "paragraph", e)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: e, $anchor: t } = this.editor.state.selection, n = t.pos === 1;
        return !e || t.parent.type.name !== this.name ? !1 : n || !t.parent.textContent.length ? this.editor.commands.clearNodes() : !1;
      },
      // exit node on triple enter
      Enter: ({ editor: e }) => {
        if (!this.options.exitOnTripleEnter)
          return !1;
        const { state: t } = e, { selection: n } = t, { $from: r, empty: i } = n;
        if (!i || r.parent.type !== this.type)
          return !1;
        const o = r.parentOffset === r.parent.nodeSize - 2, s = r.parent.textContent.endsWith(`

`);
        return !o || !s ? !1 : e.chain().command(({ tr: a }) => (a.delete(r.pos - 2, r.pos), !0)).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor: e }) => {
        if (!this.options.exitOnArrowDown)
          return !1;
        const { state: t } = e, { selection: n, doc: r } = t, { $from: i, empty: o } = n;
        if (!o || i.parent.type !== this.type || !(i.parentOffset === i.parent.nodeSize - 2))
          return !1;
        const a = i.after();
        return a === void 0 ? !1 : r.nodeAt(a) ? e.commands.command(({ tr: u }) => (u.setSelection(Be.near(r.resolve(a))), !0)) : e.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      Ih({
        find: tB,
        type: this.type,
        getAttributes: (e) => ({
          language: e[1]
        })
      }),
      Ih({
        find: nB,
        type: this.type,
        getAttributes: (e) => ({
          language: e[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new mt({
        key: new Pt("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (e, t) => {
            if (!t.clipboardData || this.editor.isActive(this.type.name))
              return !1;
            const n = t.clipboardData.getData("text/plain"), r = t.clipboardData.getData("vscode-editor-data"), i = r ? JSON.parse(r) : void 0, o = i == null ? void 0 : i.mode;
            if (!n || !o)
              return !1;
            const { tr: s, schema: a } = e.state, l = a.text(n.replace(/\r\n?/g, `
`));
            return s.replaceSelectionWith(this.type.create({ language: o }, l)), s.selection.$from.parent.type !== this.type && s.setSelection(Oe.near(s.doc.resolve(Math.max(0, s.selection.from - 2)))), s.setMeta("paste", !0), e.dispatch(s), !0;
          }
        }
      })
    ];
  }
}), rB = lt.create({
  name: "doc",
  topNode: !0,
  content: "block+"
});
function iB(e = {}) {
  return new mt({
    view(t) {
      return new oB(t, e);
    }
  });
}
class oB {
  constructor(t, n) {
    var r;
    this.editorView = t, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (r = n.width) !== null && r !== void 0 ? r : 1, this.color = n.color === !1 ? void 0 : n.color || "black", this.class = n.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((i) => {
      let o = (s) => {
        this[i](s);
      };
      return t.dom.addEventListener(i, o), { name: i, handler: o };
    });
  }
  destroy() {
    this.handlers.forEach(({ name: t, handler: n }) => this.editorView.dom.removeEventListener(t, n));
  }
  update(t, n) {
    this.cursorPos != null && n.doc != t.state.doc && (this.cursorPos > t.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
  }
  setCursor(t) {
    t != this.cursorPos && (this.cursorPos = t, t == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
  }
  updateOverlay() {
    let t = this.editorView.state.doc.resolve(this.cursorPos), n = !t.parent.inlineContent, r;
    if (n) {
      let a = t.nodeBefore, l = t.nodeAfter;
      if (a || l) {
        let u = this.editorView.nodeDOM(this.cursorPos - (a ? a.nodeSize : 0));
        if (u) {
          let c = u.getBoundingClientRect(), f = a ? c.bottom : c.top;
          a && l && (f = (f + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2), r = { left: c.left, right: c.right, top: f - this.width / 2, bottom: f + this.width / 2 };
        }
      }
    }
    if (!r) {
      let a = this.editorView.coordsAtPos(this.cursorPos);
      r = { left: a.left - this.width / 2, right: a.left + this.width / 2, top: a.top, bottom: a.bottom };
    }
    let i = this.editorView.dom.offsetParent;
    this.element || (this.element = i.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", n), this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
    let o, s;
    if (!i || i == document.body && getComputedStyle(i).position == "static")
      o = -pageXOffset, s = -pageYOffset;
    else {
      let a = i.getBoundingClientRect();
      o = a.left - i.scrollLeft, s = a.top - i.scrollTop;
    }
    this.element.style.left = r.left - o + "px", this.element.style.top = r.top - s + "px", this.element.style.width = r.right - r.left + "px", this.element.style.height = r.bottom - r.top + "px";
  }
  scheduleRemoval(t) {
    clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), t);
  }
  dragover(t) {
    if (!this.editorView.editable)
      return;
    let n = this.editorView.posAtCoords({ left: t.clientX, top: t.clientY }), r = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside), i = r && r.type.spec.disableDropCursor, o = typeof i == "function" ? i(this.editorView, n, t) : i;
    if (n && !o) {
      let s = n.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let a = vE(this.editorView.state.doc, s, this.editorView.dragging.slice);
        a != null && (s = a);
      }
      this.setCursor(s), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(t) {
    (t.target == this.editorView.dom || !this.editorView.dom.contains(t.relatedTarget)) && this.setCursor(null);
  }
}
const sB = ht.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      iB(this.options)
    ];
  }
});
class kt extends Be {
  /**
  Create a gap cursor.
  */
  constructor(t) {
    super(t, t);
  }
  map(t, n) {
    let r = t.resolve(n.map(this.head));
    return kt.valid(r) ? new kt(r) : Be.near(r);
  }
  content() {
    return ye.empty;
  }
  eq(t) {
    return t instanceof kt && t.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new kt(t.resolve(n.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new Sg(this.anchor);
  }
  /**
  @internal
  */
  static valid(t) {
    let n = t.parent;
    if (n.isTextblock || !aB(t) || !lB(t))
      return !1;
    let r = n.type.spec.allowGapCursor;
    if (r != null)
      return r;
    let i = n.contentMatchAt(t.index()).defaultType;
    return i && i.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(t, n, r = !1) {
    e: for (; ; ) {
      if (!r && kt.valid(t))
        return t;
      let i = t.pos, o = null;
      for (let s = t.depth; ; s--) {
        let a = t.node(s);
        if (n > 0 ? t.indexAfter(s) < a.childCount : t.index(s) > 0) {
          o = a.child(n > 0 ? t.indexAfter(s) : t.index(s) - 1);
          break;
        } else if (s == 0)
          return null;
        i += n;
        let l = t.doc.resolve(i);
        if (kt.valid(l))
          return l;
      }
      for (; ; ) {
        let s = n > 0 ? o.firstChild : o.lastChild;
        if (!s) {
          if (o.isAtom && !o.isText && !Ce.isSelectable(o)) {
            t = t.doc.resolve(i + o.nodeSize * n), r = !1;
            continue e;
          }
          break;
        }
        o = s, i += n;
        let a = t.doc.resolve(i);
        if (kt.valid(a))
          return a;
      }
      return null;
    }
  }
}
kt.prototype.visible = !1;
kt.findFrom = kt.findGapCursorFrom;
Be.jsonID("gapcursor", kt);
class Sg {
  constructor(t) {
    this.pos = t;
  }
  map(t) {
    return new Sg(t.map(this.pos));
  }
  resolve(t) {
    let n = t.resolve(this.pos);
    return kt.valid(n) ? new kt(n) : Be.near(n);
  }
}
function aB(e) {
  for (let t = e.depth; t >= 0; t--) {
    let n = e.index(t), r = e.node(t);
    if (n == 0) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(n - 1); ; i = i.lastChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function lB(e) {
  for (let t = e.depth; t >= 0; t--) {
    let n = e.indexAfter(t), r = e.node(t);
    if (n == r.childCount) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(n); ; i = i.firstChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function uB() {
  return new mt({
    props: {
      decorations: pB,
      createSelectionBetween(e, t, n) {
        return t.pos == n.pos && kt.valid(n) ? new kt(n) : null;
      },
      handleClick: fB,
      handleKeyDown: cB,
      handleDOMEvents: { beforeinput: dB }
    }
  });
}
const cB = a3({
  ArrowLeft: wu("horiz", -1),
  ArrowRight: wu("horiz", 1),
  ArrowUp: wu("vert", -1),
  ArrowDown: wu("vert", 1)
});
function wu(e, t) {
  const n = e == "vert" ? t > 0 ? "down" : "up" : t > 0 ? "right" : "left";
  return function(r, i, o) {
    let s = r.selection, a = t > 0 ? s.$to : s.$from, l = s.empty;
    if (s instanceof Oe) {
      if (!o.endOfTextblock(n) || a.depth == 0)
        return !1;
      l = !1, a = r.doc.resolve(t > 0 ? a.after() : a.before());
    }
    let u = kt.findGapCursorFrom(a, t, l);
    return u ? (i && i(r.tr.setSelection(new kt(u))), !0) : !1;
  };
}
function fB(e, t, n) {
  if (!e || !e.editable)
    return !1;
  let r = e.state.doc.resolve(t);
  if (!kt.valid(r))
    return !1;
  let i = e.posAtCoords({ left: n.clientX, top: n.clientY });
  return i && i.inside > -1 && Ce.isSelectable(e.state.doc.nodeAt(i.inside)) ? !1 : (e.dispatch(e.state.tr.setSelection(new kt(r))), !0);
}
function dB(e, t) {
  if (t.inputType != "insertCompositionText" || !(e.state.selection instanceof kt))
    return !1;
  let { $from: n } = e.state.selection, r = n.parent.contentMatchAt(n.index()).findWrapping(e.state.schema.nodes.text);
  if (!r)
    return !1;
  let i = te.empty;
  for (let s = r.length - 1; s >= 0; s--)
    i = te.from(r[s].createAndFill(null, i));
  let o = e.state.tr.replace(n.pos, n.pos, new ye(i, 0, 0));
  return o.setSelection(Oe.near(o.doc.resolve(n.pos + 1))), e.dispatch(o), !1;
}
function pB(e) {
  if (!(e.selection instanceof kt))
    return null;
  let t = document.createElement("div");
  return t.className = "ProseMirror-gapcursor", xt.create(e.doc, [dn.widget(e.selection.head, t, { key: "gapcursor" })]);
}
const hB = ht.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      uB()
    ];
  },
  extendNodeSchema(e) {
    var t;
    const n = {
      name: e.name,
      options: e.options,
      storage: e.storage
    };
    return {
      allowGapCursor: (t = je(ke(e, "allowGapCursor", n))) !== null && t !== void 0 ? t : null
    };
  }
}), gB = lt.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: !0,
      HTMLAttributes: {}
    };
  },
  inline: !0,
  group: "inline",
  selectable: !1,
  linebreakReplacement: !0,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["br", At(this.options.HTMLAttributes, e)];
  },
  renderText() {
    return `
`;
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: e, chain: t, state: n, editor: r }) => e.first([
        () => e.exitCode(),
        () => e.command(() => {
          const { selection: i, storedMarks: o } = n;
          if (i.$from.parent.type.spec.isolating)
            return !1;
          const { keepMarks: s } = this.options, { splittableMarks: a } = r.extensionManager, l = o || i.$to.parentOffset && i.$from.marks();
          return t().insertContent({ type: this.name }).command(({ tr: u, dispatch: c }) => {
            if (c && l && s) {
              const f = l.filter((d) => a.includes(d.type.name));
              u.ensureMarks(f);
            }
            return !0;
          }).run();
        })
      ])
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
}), mB = lt.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: !0,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: !1
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((e) => ({
      tag: `h${e}`,
      attrs: { level: e }
    }));
  },
  renderHTML({ node: e, HTMLAttributes: t }) {
    return [`h${this.options.levels.includes(e.attrs.level) ? e.attrs.level : this.options.levels[0]}`, At(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setHeading: (e) => ({ commands: t }) => this.options.levels.includes(e.level) ? t.setNode(this.name, e) : !1,
      toggleHeading: (e) => ({ commands: t }) => this.options.levels.includes(e.level) ? t.toggleNode(this.name, "paragraph", e) : !1
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((e, t) => ({
      ...e,
      [`Mod-Alt-${t}`]: () => this.editor.commands.toggleHeading({ level: t })
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((e) => Ih({
      find: new RegExp(`^(#{1,${e}})\\s$`),
      type: this.type,
      getAttributes: {
        level: e
      }
    }));
  }
});
var Gc = 200, Ht = function() {
};
Ht.prototype.append = function(t) {
  return t.length ? (t = Ht.from(t), !this.length && t || t.length < Gc && this.leafAppend(t) || this.length < Gc && t.leafPrepend(this) || this.appendInner(t)) : this;
};
Ht.prototype.prepend = function(t) {
  return t.length ? Ht.from(t).append(this) : this;
};
Ht.prototype.appendInner = function(t) {
  return new bB(this, t);
};
Ht.prototype.slice = function(t, n) {
  return t === void 0 && (t = 0), n === void 0 && (n = this.length), t >= n ? Ht.empty : this.sliceInner(Math.max(0, t), Math.min(this.length, n));
};
Ht.prototype.get = function(t) {
  if (!(t < 0 || t >= this.length))
    return this.getInner(t);
};
Ht.prototype.forEach = function(t, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length), n <= r ? this.forEachInner(t, n, r, 0) : this.forEachInvertedInner(t, n, r, 0);
};
Ht.prototype.map = function(t, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length);
  var i = [];
  return this.forEach(function(o, s) {
    return i.push(t(o, s));
  }, n, r), i;
};
Ht.from = function(t) {
  return t instanceof Ht ? t : t && t.length ? new xw(t) : Ht.empty;
};
var xw = /* @__PURE__ */ function(e) {
  function t(r) {
    e.call(this), this.values = r;
  }
  e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
  var n = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return t.prototype.flatten = function() {
    return this.values;
  }, t.prototype.sliceInner = function(i, o) {
    return i == 0 && o == this.length ? this : new t(this.values.slice(i, o));
  }, t.prototype.getInner = function(i) {
    return this.values[i];
  }, t.prototype.forEachInner = function(i, o, s, a) {
    for (var l = o; l < s; l++)
      if (i(this.values[l], a + l) === !1)
        return !1;
  }, t.prototype.forEachInvertedInner = function(i, o, s, a) {
    for (var l = o - 1; l >= s; l--)
      if (i(this.values[l], a + l) === !1)
        return !1;
  }, t.prototype.leafAppend = function(i) {
    if (this.length + i.length <= Gc)
      return new t(this.values.concat(i.flatten()));
  }, t.prototype.leafPrepend = function(i) {
    if (this.length + i.length <= Gc)
      return new t(i.flatten().concat(this.values));
  }, n.length.get = function() {
    return this.values.length;
  }, n.depth.get = function() {
    return 0;
  }, Object.defineProperties(t.prototype, n), t;
}(Ht);
Ht.empty = new xw([]);
var bB = /* @__PURE__ */ function(e) {
  function t(n, r) {
    e.call(this), this.left = n, this.right = r, this.length = n.length + r.length, this.depth = Math.max(n.depth, r.depth) + 1;
  }
  return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, t.prototype.getInner = function(r) {
    return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
  }, t.prototype.forEachInner = function(r, i, o, s) {
    var a = this.left.length;
    if (i < a && this.left.forEachInner(r, i, Math.min(o, a), s) === !1 || o > a && this.right.forEachInner(r, Math.max(i - a, 0), Math.min(this.length, o) - a, s + a) === !1)
      return !1;
  }, t.prototype.forEachInvertedInner = function(r, i, o, s) {
    var a = this.left.length;
    if (i > a && this.right.forEachInvertedInner(r, i - a, Math.max(o, a) - a, s + a) === !1 || o < a && this.left.forEachInvertedInner(r, Math.min(i, a), o, s) === !1)
      return !1;
  }, t.prototype.sliceInner = function(r, i) {
    if (r == 0 && i == this.length)
      return this;
    var o = this.left.length;
    return i <= o ? this.left.slice(r, i) : r >= o ? this.right.slice(r - o, i - o) : this.left.slice(r, o).append(this.right.slice(0, i - o));
  }, t.prototype.leafAppend = function(r) {
    var i = this.right.leafAppend(r);
    if (i)
      return new t(this.left, i);
  }, t.prototype.leafPrepend = function(r) {
    var i = this.left.leafPrepend(r);
    if (i)
      return new t(i, this.right);
  }, t.prototype.appendInner = function(r) {
    return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new t(this.left, new t(this.right, r)) : new t(this, r);
  }, t;
}(Ht);
const yB = 500;
class sr {
  constructor(t, n) {
    this.items = t, this.eventCount = n;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(t, n) {
    if (this.eventCount == 0)
      return null;
    let r = this.items.length;
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r;
        break;
      }
    let i, o;
    n && (i = this.remapping(r, this.items.length), o = i.maps.length);
    let s = t.tr, a, l, u = [], c = [];
    return this.items.forEach((f, d) => {
      if (!f.step) {
        i || (i = this.remapping(r, d + 1), o = i.maps.length), o--, c.push(f);
        return;
      }
      if (i) {
        c.push(new Er(f.map));
        let p = f.step.map(i.slice(o)), h;
        p && s.maybeStep(p).doc && (h = s.mapping.maps[s.mapping.maps.length - 1], u.push(new Er(h, void 0, void 0, u.length + c.length))), o--, h && i.appendMap(h, o);
      } else
        s.maybeStep(f.step);
      if (f.selection)
        return a = i ? f.selection.map(i.slice(o)) : f.selection, l = new sr(this.items.slice(0, r).append(c.reverse().concat(u)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: l, transform: s, selection: a };
  }
  // Create a new branch with the given transform added.
  addTransform(t, n, r, i) {
    let o = [], s = this.eventCount, a = this.items, l = !i && a.length ? a.get(a.length - 1) : null;
    for (let c = 0; c < t.steps.length; c++) {
      let f = t.steps[c].invert(t.docs[c]), d = new Er(t.mapping.maps[c], f, n), p;
      (p = l && l.merge(d)) && (d = p, c ? o.pop() : a = a.slice(0, a.length - 1)), o.push(d), n && (s++, n = void 0), i || (l = d);
    }
    let u = s - r.depth;
    return u > _B && (a = vB(a, u), s -= u), new sr(a.append(o), s);
  }
  remapping(t, n) {
    let r = new cs();
    return this.items.forEach((i, o) => {
      let s = i.mirrorOffset != null && o - i.mirrorOffset >= t ? r.maps.length - i.mirrorOffset : void 0;
      r.appendMap(i.map, s);
    }, t, n), r;
  }
  addMaps(t) {
    return this.eventCount == 0 ? this : new sr(this.items.append(t.map((n) => new Er(n))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(t, n) {
    if (!this.eventCount)
      return this;
    let r = [], i = Math.max(0, this.items.length - n), o = t.mapping, s = t.steps.length, a = this.eventCount;
    this.items.forEach((d) => {
      d.selection && a--;
    }, i);
    let l = n;
    this.items.forEach((d) => {
      let p = o.getMirror(--l);
      if (p == null)
        return;
      s = Math.min(s, p);
      let h = o.maps[p];
      if (d.step) {
        let m = t.steps[p].invert(t.docs[p]), g = d.selection && d.selection.map(o.slice(l + 1, p));
        g && a++, r.push(new Er(h, m, g));
      } else
        r.push(new Er(h));
    }, i);
    let u = [];
    for (let d = n; d < s; d++)
      u.push(new Er(o.maps[d]));
    let c = this.items.slice(0, i).append(u).append(r), f = new sr(c, a);
    return f.emptyItemCount() > yB && (f = f.compress(this.items.length - r.length)), f;
  }
  emptyItemCount() {
    let t = 0;
    return this.items.forEach((n) => {
      n.step || t++;
    }), t;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(t = this.items.length) {
    let n = this.remapping(0, t), r = n.maps.length, i = [], o = 0;
    return this.items.forEach((s, a) => {
      if (a >= t)
        i.push(s), s.selection && o++;
      else if (s.step) {
        let l = s.step.map(n.slice(r)), u = l && l.getMap();
        if (r--, u && n.appendMap(u, r), l) {
          let c = s.selection && s.selection.map(n.slice(r));
          c && o++;
          let f = new Er(u.invert(), l, c), d, p = i.length - 1;
          (d = i.length && i[p].merge(f)) ? i[p] = d : i.push(f);
        }
      } else s.map && r--;
    }, this.items.length, 0), new sr(Ht.from(i.reverse()), o);
  }
}
sr.empty = new sr(Ht.empty, 0);
function vB(e, t) {
  let n;
  return e.forEach((r, i) => {
    if (r.selection && t-- == 0)
      return n = i, !1;
  }), e.slice(n);
}
class Er {
  constructor(t, n, r, i) {
    this.map = t, this.step = n, this.selection = r, this.mirrorOffset = i;
  }
  merge(t) {
    if (this.step && t.step && !t.selection) {
      let n = t.step.merge(this.step);
      if (n)
        return new Er(n.getMap().invert(), n, this.selection);
    }
  }
}
class _i {
  constructor(t, n, r, i, o) {
    this.done = t, this.undone = n, this.prevRanges = r, this.prevTime = i, this.prevComposition = o;
  }
}
const _B = 20;
function EB(e, t, n, r) {
  let i = n.getMeta(xo), o;
  if (i)
    return i.historyState;
  n.getMeta(kB) && (e = new _i(e.done, e.undone, null, 0, -1));
  let s = n.getMeta("appendedTransaction");
  if (n.steps.length == 0)
    return e;
  if (s && s.getMeta(xo))
    return s.getMeta(xo).redo ? new _i(e.done.addTransform(n, void 0, r, oc(t)), e.undone, zb(n.mapping.maps), e.prevTime, e.prevComposition) : new _i(e.done, e.undone.addTransform(n, void 0, r, oc(t)), null, e.prevTime, e.prevComposition);
  if (n.getMeta("addToHistory") !== !1 && !(s && s.getMeta("addToHistory") === !1)) {
    let a = n.getMeta("composition"), l = e.prevTime == 0 || !s && e.prevComposition != a && (e.prevTime < (n.time || 0) - r.newGroupDelay || !wB(n, e.prevRanges)), u = s ? kp(e.prevRanges, n.mapping) : zb(n.mapping.maps);
    return new _i(e.done.addTransform(n, l ? t.selection.getBookmark() : void 0, r, oc(t)), sr.empty, u, n.time, a ?? e.prevComposition);
  } else return (o = n.getMeta("rebased")) ? new _i(e.done.rebased(n, o), e.undone.rebased(n, o), kp(e.prevRanges, n.mapping), e.prevTime, e.prevComposition) : new _i(e.done.addMaps(n.mapping.maps), e.undone.addMaps(n.mapping.maps), kp(e.prevRanges, n.mapping), e.prevTime, e.prevComposition);
}
function wB(e, t) {
  if (!t)
    return !1;
  if (!e.docChanged)
    return !0;
  let n = !1;
  return e.mapping.maps[0].forEach((r, i) => {
    for (let o = 0; o < t.length; o += 2)
      r <= t[o + 1] && i >= t[o] && (n = !0);
  }), n;
}
function zb(e) {
  let t = [];
  for (let n = e.length - 1; n >= 0 && t.length == 0; n--)
    e[n].forEach((r, i, o, s) => t.push(o, s));
  return t;
}
function kp(e, t) {
  if (!e)
    return null;
  let n = [];
  for (let r = 0; r < e.length; r += 2) {
    let i = t.map(e[r], 1), o = t.map(e[r + 1], -1);
    i <= o && n.push(i, o);
  }
  return n;
}
function xB(e, t, n) {
  let r = oc(t), i = xo.get(t).spec.config, o = (n ? e.undone : e.done).popEvent(t, r);
  if (!o)
    return null;
  let s = o.selection.resolve(o.transform.doc), a = (n ? e.done : e.undone).addTransform(o.transform, t.selection.getBookmark(), i, r), l = new _i(n ? a : o.remaining, n ? o.remaining : a, null, 0, -1);
  return o.transform.setSelection(s).setMeta(xo, { redo: n, historyState: l });
}
let Mp = !1, Fb = null;
function oc(e) {
  let t = e.plugins;
  if (Fb != t) {
    Mp = !1, Fb = t;
    for (let n = 0; n < t.length; n++)
      if (t[n].spec.historyPreserveItems) {
        Mp = !0;
        break;
      }
  }
  return Mp;
}
const xo = new Pt("history"), kB = new Pt("closeHistory");
function MB(e = {}) {
  return e = {
    depth: e.depth || 100,
    newGroupDelay: e.newGroupDelay || 500
  }, new mt({
    key: xo,
    state: {
      init() {
        return new _i(sr.empty, sr.empty, null, 0, -1);
      },
      apply(t, n, r) {
        return EB(n, r, t, e);
      }
    },
    config: e,
    props: {
      handleDOMEvents: {
        beforeinput(t, n) {
          let r = n.inputType, i = r == "historyUndo" ? Mw : r == "historyRedo" ? Aw : null;
          return i ? (n.preventDefault(), i(t.state, t.dispatch)) : !1;
        }
      }
    }
  });
}
function kw(e, t) {
  return (n, r) => {
    let i = xo.getState(n);
    if (!i || (e ? i.undone : i.done).eventCount == 0)
      return !1;
    if (r) {
      let o = xB(i, n, e);
      o && r(t ? o.scrollIntoView() : o);
    }
    return !0;
  };
}
const Mw = kw(!1, !0), Aw = kw(!0, !0), AB = ht.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state: e, dispatch: t }) => Mw(e, t),
      redo: () => ({ state: e, dispatch: t }) => Aw(e, t)
    };
  },
  addProseMirrorPlugins() {
    return [
      MB(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-": () => this.editor.commands.undo(),
      "Shift-Mod-": () => this.editor.commands.redo()
    };
  }
}), Tw = lt.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["hr", At(this.options.HTMLAttributes, e)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: e, state: t }) => {
        const { selection: n } = t, { $from: r, $to: i } = n, o = e();
        return r.parentOffset === 0 ? o.insertContentAt({
          from: Math.max(r.pos - 1, 0),
          to: i.pos
        }, {
          type: this.name
        }) : k3(n) ? o.insertContentAt(i.pos, {
          type: this.name
        }) : o.insertContent({ type: this.name }), o.command(({ tr: s, dispatch: a }) => {
          var l;
          if (a) {
            const { $to: u } = s.selection, c = u.end();
            if (u.nodeAfter)
              u.nodeAfter.isTextblock ? s.setSelection(Oe.create(s.doc, u.pos + 1)) : u.nodeAfter.isBlock ? s.setSelection(Ce.create(s.doc, u.pos)) : s.setSelection(Oe.create(s.doc, u.pos));
            else {
              const f = (l = u.parent.type.contentMatch.defaultType) === null || l === void 0 ? void 0 : l.create();
              f && (s.insert(c, f), s.setSelection(Oe.create(s.doc, c + 1)));
            }
            s.scrollIntoView();
          }
          return !0;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      l5({
        find: /^(?:---|-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
}), TB = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, SB = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, CB = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, NB = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, DB = Jt.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (e) => e.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (e) => e.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["em", At(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: e }) => e.setMark(this.name),
      toggleItalic: () => ({ commands: e }) => e.toggleMark(this.name),
      unsetItalic: () => ({ commands: e }) => e.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      As({
        find: TB,
        type: this.type
      }),
      As({
        find: CB,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Io({
        find: SB,
        type: this.type
      }),
      Io({
        find: NB,
        type: this.type
      })
    ];
  }
}), OB = lt.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["li", At(this.options.HTMLAttributes, e), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), IB = "listItem", jb = "textStyle", Ub = /^(\d+)\.\s$/, RB = lt.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (e) => e.hasAttribute("start") ? parseInt(e.getAttribute("start") || "", 10) : 1
      },
      type: {
        default: void 0,
        parseHTML: (e) => e.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    const { start: t, ...n } = e;
    return t === 1 ? ["ol", At(this.options.HTMLAttributes, n), 0] : ["ol", At(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: e, chain: t }) => this.options.keepAttributes ? t().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(IB, this.editor.getAttributes(jb)).run() : e.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let e = Ts({
      find: Ub,
      type: this.type,
      getAttributes: (t) => ({ start: +t[1] }),
      joinPredicate: (t, n) => n.childCount + n.attrs.start === +t[1]
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (e = Ts({
      find: Ub,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: (t) => ({ start: +t[1], ...this.editor.getAttributes(jb) }),
      joinPredicate: (t, n) => n.childCount + n.attrs.start === +t[1],
      editor: this.editor
    })), [
      e
    ];
  }
}), LB = lt.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["p", At(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: e }) => e.setNode(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
}), BB = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, PB = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, $B = Jt.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (e) => e.includes("line-through") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["s", At(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: e }) => e.setMark(this.name),
      toggleStrike: () => ({ commands: e }) => e.toggleMark(this.name),
      unsetStrike: () => ({ commands: e }) => e.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      As({
        find: BB,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Io({
        find: PB,
        type: this.type
      })
    ];
  }
}), zB = lt.create({
  name: "text",
  group: "inline"
}), FB = ht.create({
  name: "starterKit",
  addExtensions() {
    var e, t, n, r, i, o, s, a, l, u, c, f, d, p, h, m, g, y;
    const _ = [];
    return this.options.bold !== !1 && _.push(YL.configure((e = this.options) === null || e === void 0 ? void 0 : e.bold)), this.options.blockquote !== !1 && _.push(HL.configure((t = this.options) === null || t === void 0 ? void 0 : t.blockquote)), this.options.bulletList !== !1 && _.push(ZL.configure((n = this.options) === null || n === void 0 ? void 0 : n.bulletList)), this.options.code !== !1 && _.push(eB.configure((r = this.options) === null || r === void 0 ? void 0 : r.code)), this.options.codeBlock !== !1 && _.push(ww.configure((i = this.options) === null || i === void 0 ? void 0 : i.codeBlock)), this.options.document !== !1 && _.push(rB.configure((o = this.options) === null || o === void 0 ? void 0 : o.document)), this.options.dropcursor !== !1 && _.push(sB.configure((s = this.options) === null || s === void 0 ? void 0 : s.dropcursor)), this.options.gapcursor !== !1 && _.push(hB.configure((a = this.options) === null || a === void 0 ? void 0 : a.gapcursor)), this.options.hardBreak !== !1 && _.push(gB.configure((l = this.options) === null || l === void 0 ? void 0 : l.hardBreak)), this.options.heading !== !1 && _.push(mB.configure((u = this.options) === null || u === void 0 ? void 0 : u.heading)), this.options.history !== !1 && _.push(AB.configure((c = this.options) === null || c === void 0 ? void 0 : c.history)), this.options.horizontalRule !== !1 && _.push(Tw.configure((f = this.options) === null || f === void 0 ? void 0 : f.horizontalRule)), this.options.italic !== !1 && _.push(DB.configure((d = this.options) === null || d === void 0 ? void 0 : d.italic)), this.options.listItem !== !1 && _.push(OB.configure((p = this.options) === null || p === void 0 ? void 0 : p.listItem)), this.options.orderedList !== !1 && _.push(RB.configure((h = this.options) === null || h === void 0 ? void 0 : h.orderedList)), this.options.paragraph !== !1 && _.push(LB.configure((m = this.options) === null || m === void 0 ? void 0 : m.paragraph)), this.options.strike !== !1 && _.push($B.configure((g = this.options) === null || g === void 0 ? void 0 : g.strike)), this.options.text !== !1 && _.push(zB.configure((y = this.options) === null || y === void 0 ? void 0 : y.text)), _;
  }
}), jB = (e) => Tt({
  find: /--$/,
  replace: e ?? ""
}), UB = (e) => Tt({
  find: /\.\.\.$/,
  replace: e ?? ""
}), VB = (e) => Tt({
  find: /(?:^|[\s{[(<'"\u2018\u201C])(")$/,
  replace: e ?? ""
}), HB = (e) => Tt({
  find: /"$/,
  replace: e ?? ""
}), qB = (e) => Tt({
  find: /(?:^|[\s{[(<'"\u2018\u201C])(')$/,
  replace: e ?? ""
}), GB = (e) => Tt({
  find: /'$/,
  replace: e ?? ""
}), WB = (e) => Tt({
  find: /<-$/,
  replace: e ?? ""
}), KB = (e) => Tt({
  find: /->$/,
  replace: e ?? ""
}), YB = (e) => Tt({
  find: /\(c\)$/,
  replace: e ?? ""
}), QB = (e) => Tt({
  find: /\(tm\)$/,
  replace: e ?? ""
}), ZB = (e) => Tt({
  find: /\(sm\)$/,
  replace: e ?? ""
}), XB = (e) => Tt({
  find: /\(r\)$/,
  replace: e ?? ""
}), JB = (e) => Tt({
  find: /(?:^|\s)(1\/2)\s$/,
  replace: e ?? ""
}), eP = (e) => Tt({
  find: /\+\/-$/,
  replace: e ?? ""
}), tP = (e) => Tt({
  find: /!=$/,
  replace: e ?? ""
}), nP = (e) => Tt({
  find: /<<$/,
  replace: e ?? ""
}), rP = (e) => Tt({
  find: />>$/,
  replace: e ?? ""
}), iP = (e) => Tt({
  find: /\d+\s?([*x])\s?\d+$/,
  replace: e ?? ""
}), oP = (e) => Tt({
  find: /\^2$/,
  replace: e ?? ""
}), sP = (e) => Tt({
  find: /\^3$/,
  replace: e ?? ""
}), aP = (e) => Tt({
  find: /(?:^|\s)(1\/4)\s$/,
  replace: e ?? ""
}), lP = (e) => Tt({
  find: /(?:^|\s)(3\/4)\s$/,
  replace: e ?? ""
}), uP = ht.create({
  name: "typography",
  addOptions() {
    return {
      closeDoubleQuote: "",
      closeSingleQuote: "",
      copyright: "",
      ellipsis: "",
      emDash: "",
      laquo: "",
      leftArrow: "",
      multiplication: "",
      notEqual: "",
      oneHalf: "",
      oneQuarter: "",
      openDoubleQuote: "",
      openSingleQuote: "",
      plusMinus: "",
      raquo: "",
      registeredTrademark: "",
      rightArrow: "",
      servicemark: "",
      superscriptThree: "",
      superscriptTwo: "",
      threeQuarters: "",
      trademark: ""
    };
  },
  addInputRules() {
    const e = [];
    return this.options.emDash !== !1 && e.push(jB(this.options.emDash)), this.options.ellipsis !== !1 && e.push(UB(this.options.ellipsis)), this.options.openDoubleQuote !== !1 && e.push(VB(this.options.openDoubleQuote)), this.options.closeDoubleQuote !== !1 && e.push(HB(this.options.closeDoubleQuote)), this.options.openSingleQuote !== !1 && e.push(qB(this.options.openSingleQuote)), this.options.closeSingleQuote !== !1 && e.push(GB(this.options.closeSingleQuote)), this.options.leftArrow !== !1 && e.push(WB(this.options.leftArrow)), this.options.rightArrow !== !1 && e.push(KB(this.options.rightArrow)), this.options.copyright !== !1 && e.push(YB(this.options.copyright)), this.options.trademark !== !1 && e.push(QB(this.options.trademark)), this.options.servicemark !== !1 && e.push(ZB(this.options.servicemark)), this.options.registeredTrademark !== !1 && e.push(XB(this.options.registeredTrademark)), this.options.oneHalf !== !1 && e.push(JB(this.options.oneHalf)), this.options.plusMinus !== !1 && e.push(eP(this.options.plusMinus)), this.options.notEqual !== !1 && e.push(tP(this.options.notEqual)), this.options.laquo !== !1 && e.push(nP(this.options.laquo)), this.options.raquo !== !1 && e.push(rP(this.options.raquo)), this.options.multiplication !== !1 && e.push(iP(this.options.multiplication)), this.options.superscriptTwo !== !1 && e.push(oP(this.options.superscriptTwo)), this.options.superscriptThree !== !1 && e.push(sP(this.options.superscriptThree)), this.options.oneQuarter !== !1 && e.push(aP(this.options.oneQuarter)), this.options.threeQuarters !== !1 && e.push(lP(this.options.threeQuarters)), e;
  }
}), cP = ht.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something ",
      showOnlyWhenEditable: !0,
      showOnlyCurrent: !0,
      includeChildren: !1
    };
  },
  addProseMirrorPlugins() {
    return [
      new mt({
        key: new Pt("placeholder"),
        props: {
          decorations: ({ doc: e, selection: t }) => {
            const n = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: r } = t, i = [];
            if (!n)
              return null;
            const o = this.editor.isEmpty;
            return e.descendants((s, a) => {
              const l = r >= a && r <= a + s.nodeSize, u = !s.isLeaf && hd(s);
              if ((l || !this.options.showOnlyCurrent) && u) {
                const c = [this.options.emptyNodeClass];
                o && c.push(this.options.emptyEditorClass);
                const f = dn.node(a, a + s.nodeSize, {
                  class: c.join(" "),
                  "data-placeholder": typeof this.options.placeholder == "function" ? this.options.placeholder({
                    editor: this.editor,
                    node: s,
                    pos: a,
                    hasAnchor: l
                  }) : this.options.placeholder
                });
                i.push(f);
              }
              return this.options.includeChildren;
            }), xt.create(e, i);
          }
        }
      })
    ];
  }
}), fP = Jt.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (e) => e.includes("underline") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["u", At(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: e }) => e.setMark(this.name),
      toggleUnderline: () => ({ commands: e }) => e.toggleMark(this.name),
      unsetUnderline: () => ({ commands: e }) => e.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
}), dP = Jt.create({
  name: "textStyle",
  priority: 101,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (e) => e.hasAttribute("style") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["span", At(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state: e, commands: t }) => {
        const n = ag(e, this.type);
        return Object.entries(n).some(([, i]) => !!i) ? !0 : t.unsetMark(this.name);
      }
    };
  }
}), Vb = {};
function pP(e) {
  let t = Vb[e];
  if (t)
    return t;
  t = Vb[e] = [];
  for (let n = 0; n < 128; n++) {
    const r = String.fromCharCode(n);
    t.push(r);
  }
  for (let n = 0; n < e.length; n++) {
    const r = e.charCodeAt(n);
    t[r] = "%" + ("0" + r.toString(16).toUpperCase()).slice(-2);
  }
  return t;
}
function $s(e, t) {
  typeof t != "string" && (t = $s.defaultChars);
  const n = pP(t);
  return e.replace(/(%[a-f0-9]{2})+/gi, function(r) {
    let i = "";
    for (let o = 0, s = r.length; o < s; o += 3) {
      const a = parseInt(r.slice(o + 1, o + 3), 16);
      if (a < 128) {
        i += n[a];
        continue;
      }
      if ((a & 224) === 192 && o + 3 < s) {
        const l = parseInt(r.slice(o + 4, o + 6), 16);
        if ((l & 192) === 128) {
          const u = a << 6 & 1984 | l & 63;
          u < 128 ? i += "" : i += String.fromCharCode(u), o += 3;
          continue;
        }
      }
      if ((a & 240) === 224 && o + 6 < s) {
        const l = parseInt(r.slice(o + 4, o + 6), 16), u = parseInt(r.slice(o + 7, o + 9), 16);
        if ((l & 192) === 128 && (u & 192) === 128) {
          const c = a << 12 & 61440 | l << 6 & 4032 | u & 63;
          c < 2048 || c >= 55296 && c <= 57343 ? i += "" : i += String.fromCharCode(c), o += 6;
          continue;
        }
      }
      if ((a & 248) === 240 && o + 9 < s) {
        const l = parseInt(r.slice(o + 4, o + 6), 16), u = parseInt(r.slice(o + 7, o + 9), 16), c = parseInt(r.slice(o + 10, o + 12), 16);
        if ((l & 192) === 128 && (u & 192) === 128 && (c & 192) === 128) {
          let f = a << 18 & 1835008 | l << 12 & 258048 | u << 6 & 4032 | c & 63;
          f < 65536 || f > 1114111 ? i += "" : (f -= 65536, i += String.fromCharCode(55296 + (f >> 10), 56320 + (f & 1023))), o += 9;
          continue;
        }
      }
      i += "";
    }
    return i;
  });
}
$s.defaultChars = ";/?:@&=+$,#";
$s.componentChars = "";
const Hb = {};
function hP(e) {
  let t = Hb[e];
  if (t)
    return t;
  t = Hb[e] = [];
  for (let n = 0; n < 128; n++) {
    const r = String.fromCharCode(n);
    /^[0-9a-z]$/i.test(r) ? t.push(r) : t.push("%" + ("0" + n.toString(16).toUpperCase()).slice(-2));
  }
  for (let n = 0; n < e.length; n++)
    t[e.charCodeAt(n)] = e[n];
  return t;
}
function Zl(e, t, n) {
  typeof t != "string" && (n = t, t = Zl.defaultChars), typeof n > "u" && (n = !0);
  const r = hP(t);
  let i = "";
  for (let o = 0, s = e.length; o < s; o++) {
    const a = e.charCodeAt(o);
    if (n && a === 37 && o + 2 < s && /^[0-9a-f]{2}$/i.test(e.slice(o + 1, o + 3))) {
      i += e.slice(o, o + 3), o += 2;
      continue;
    }
    if (a < 128) {
      i += r[a];
      continue;
    }
    if (a >= 55296 && a <= 57343) {
      if (a >= 55296 && a <= 56319 && o + 1 < s) {
        const l = e.charCodeAt(o + 1);
        if (l >= 56320 && l <= 57343) {
          i += encodeURIComponent(e[o] + e[o + 1]), o++;
          continue;
        }
      }
      i += "%EF%BF%BD";
      continue;
    }
    i += encodeURIComponent(e[o]);
  }
  return i;
}
Zl.defaultChars = ";/?:@&=+$,-_.!~*'()#";
Zl.componentChars = "-_.!~*'()";
function Cg(e) {
  let t = "";
  return t += e.protocol || "", t += e.slashes ? "//" : "", t += e.auth ? e.auth + "@" : "", e.hostname && e.hostname.indexOf(":") !== -1 ? t += "[" + e.hostname + "]" : t += e.hostname || "", t += e.port ? ":" + e.port : "", t += e.pathname || "", t += e.search || "", t += e.hash || "", t;
}
function Wc() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
const gP = /^([a-z0-9.+-]+:)/i, mP = /:[0-9]*$/, bP = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, yP = ["<", ">", '"', "`", " ", "\r", `
`, "	"], vP = ["{", "}", "|", "\\", "^", "`"].concat(yP), _P = ["'"].concat(vP), qb = ["%", "/", "?", ";", "#"].concat(_P), Gb = ["/", "?", "#"], EP = 255, Wb = /^[+a-z0-9A-Z_-]{0,63}$/, wP = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, Kb = {
  javascript: !0,
  "javascript:": !0
}, Yb = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
};
function Ng(e, t) {
  if (e && e instanceof Wc) return e;
  const n = new Wc();
  return n.parse(e, t), n;
}
Wc.prototype.parse = function(e, t) {
  let n, r, i, o = e;
  if (o = o.trim(), !t && e.split("#").length === 1) {
    const u = bP.exec(o);
    if (u)
      return this.pathname = u[1], u[2] && (this.search = u[2]), this;
  }
  let s = gP.exec(o);
  if (s && (s = s[0], n = s.toLowerCase(), this.protocol = s, o = o.substr(s.length)), (t || s || o.match(/^\/\/[^@\/]+@[^@\/]+/)) && (i = o.substr(0, 2) === "//", i && !(s && Kb[s]) && (o = o.substr(2), this.slashes = !0)), !Kb[s] && (i || s && !Yb[s])) {
    let u = -1;
    for (let h = 0; h < Gb.length; h++)
      r = o.indexOf(Gb[h]), r !== -1 && (u === -1 || r < u) && (u = r);
    let c, f;
    u === -1 ? f = o.lastIndexOf("@") : f = o.lastIndexOf("@", u), f !== -1 && (c = o.slice(0, f), o = o.slice(f + 1), this.auth = c), u = -1;
    for (let h = 0; h < qb.length; h++)
      r = o.indexOf(qb[h]), r !== -1 && (u === -1 || r < u) && (u = r);
    u === -1 && (u = o.length), o[u - 1] === ":" && u--;
    const d = o.slice(0, u);
    o = o.slice(u), this.parseHost(d), this.hostname = this.hostname || "";
    const p = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!p) {
      const h = this.hostname.split(/\./);
      for (let m = 0, g = h.length; m < g; m++) {
        const y = h[m];
        if (y && !y.match(Wb)) {
          let _ = "";
          for (let E = 0, v = y.length; E < v; E++)
            y.charCodeAt(E) > 127 ? _ += "x" : _ += y[E];
          if (!_.match(Wb)) {
            const E = h.slice(0, m), v = h.slice(m + 1), M = y.match(wP);
            M && (E.push(M[1]), v.unshift(M[2])), v.length && (o = v.join(".") + o), this.hostname = E.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > EP && (this.hostname = ""), p && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  const a = o.indexOf("#");
  a !== -1 && (this.hash = o.substr(a), o = o.slice(0, a));
  const l = o.indexOf("?");
  return l !== -1 && (this.search = o.substr(l), o = o.slice(0, l)), o && (this.pathname = o), Yb[n] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
Wc.prototype.parseHost = function(e) {
  let t = mP.exec(e);
  t && (t = t[0], t !== ":" && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e);
};
const xP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: $s,
  encode: Zl,
  format: Cg,
  parse: Ng
}, Symbol.toStringTag, { value: "Module" })), Sw = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, Cw = /[\0-\x1F\x7F-\x9F]/, kP = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/, Dg = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/, Nw = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/, Dw = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/, MP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Any: Sw,
  Cc: Cw,
  Cf: kP,
  P: Dg,
  S: Nw,
  Z: Dw
}, Symbol.toStringTag, { value: "Module" })), AP = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map((e) => e.charCodeAt(0))
), TP = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map((e) => e.charCodeAt(0))
);
var Ap;
const SP = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]), CP = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (Ap = String.fromCodePoint) !== null && Ap !== void 0 ? Ap : function(e) {
    let t = "";
    return e > 65535 && (e -= 65536, t += String.fromCharCode(e >>> 10 & 1023 | 55296), e = 56320 | e & 1023), t += String.fromCharCode(e), t;
  }
);
function NP(e) {
  var t;
  return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : (t = SP.get(e)) !== null && t !== void 0 ? t : e;
}
var Ut;
(function(e) {
  e[e.NUM = 35] = "NUM", e[e.SEMI = 59] = "SEMI", e[e.EQUALS = 61] = "EQUALS", e[e.ZERO = 48] = "ZERO", e[e.NINE = 57] = "NINE", e[e.LOWER_A = 97] = "LOWER_A", e[e.LOWER_F = 102] = "LOWER_F", e[e.LOWER_X = 120] = "LOWER_X", e[e.LOWER_Z = 122] = "LOWER_Z", e[e.UPPER_A = 65] = "UPPER_A", e[e.UPPER_F = 70] = "UPPER_F", e[e.UPPER_Z = 90] = "UPPER_Z";
})(Ut || (Ut = {}));
const DP = 32;
var Li;
(function(e) {
  e[e.VALUE_LENGTH = 49152] = "VALUE_LENGTH", e[e.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", e[e.JUMP_TABLE = 127] = "JUMP_TABLE";
})(Li || (Li = {}));
function Vh(e) {
  return e >= Ut.ZERO && e <= Ut.NINE;
}
function OP(e) {
  return e >= Ut.UPPER_A && e <= Ut.UPPER_F || e >= Ut.LOWER_A && e <= Ut.LOWER_F;
}
function IP(e) {
  return e >= Ut.UPPER_A && e <= Ut.UPPER_Z || e >= Ut.LOWER_A && e <= Ut.LOWER_Z || Vh(e);
}
function RP(e) {
  return e === Ut.EQUALS || IP(e);
}
var zt;
(function(e) {
  e[e.EntityStart = 0] = "EntityStart", e[e.NumericStart = 1] = "NumericStart", e[e.NumericDecimal = 2] = "NumericDecimal", e[e.NumericHex = 3] = "NumericHex", e[e.NamedEntity = 4] = "NamedEntity";
})(zt || (zt = {}));
var Si;
(function(e) {
  e[e.Legacy = 0] = "Legacy", e[e.Strict = 1] = "Strict", e[e.Attribute = 2] = "Attribute";
})(Si || (Si = {}));
class LP {
  constructor(t, n, r) {
    this.decodeTree = t, this.emitCodePoint = n, this.errors = r, this.state = zt.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = Si.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(t) {
    this.decodeMode = t, this.state = zt.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(t, n) {
    switch (this.state) {
      case zt.EntityStart:
        return t.charCodeAt(n) === Ut.NUM ? (this.state = zt.NumericStart, this.consumed += 1, this.stateNumericStart(t, n + 1)) : (this.state = zt.NamedEntity, this.stateNamedEntity(t, n));
      case zt.NumericStart:
        return this.stateNumericStart(t, n);
      case zt.NumericDecimal:
        return this.stateNumericDecimal(t, n);
      case zt.NumericHex:
        return this.stateNumericHex(t, n);
      case zt.NamedEntity:
        return this.stateNamedEntity(t, n);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(t, n) {
    return n >= t.length ? -1 : (t.charCodeAt(n) | DP) === Ut.LOWER_X ? (this.state = zt.NumericHex, this.consumed += 1, this.stateNumericHex(t, n + 1)) : (this.state = zt.NumericDecimal, this.stateNumericDecimal(t, n));
  }
  addToNumericResult(t, n, r, i) {
    if (n !== r) {
      const o = r - n;
      this.result = this.result * Math.pow(i, o) + parseInt(t.substr(n, o), i), this.consumed += o;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(t, n) {
    const r = n;
    for (; n < t.length; ) {
      const i = t.charCodeAt(n);
      if (Vh(i) || OP(i))
        n += 1;
      else
        return this.addToNumericResult(t, r, n, 16), this.emitNumericEntity(i, 3);
    }
    return this.addToNumericResult(t, r, n, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(t, n) {
    const r = n;
    for (; n < t.length; ) {
      const i = t.charCodeAt(n);
      if (Vh(i))
        n += 1;
      else
        return this.addToNumericResult(t, r, n, 10), this.emitNumericEntity(i, 2);
    }
    return this.addToNumericResult(t, r, n, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(t, n) {
    var r;
    if (this.consumed <= n)
      return (r = this.errors) === null || r === void 0 || r.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (t === Ut.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === Si.Strict)
      return 0;
    return this.emitCodePoint(NP(this.result), this.consumed), this.errors && (t !== Ut.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(t, n) {
    const { decodeTree: r } = this;
    let i = r[this.treeIndex], o = (i & Li.VALUE_LENGTH) >> 14;
    for (; n < t.length; n++, this.excess++) {
      const s = t.charCodeAt(n);
      if (this.treeIndex = BP(r, i, this.treeIndex + Math.max(1, o), s), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === Si.Attribute && // We shouldn't have consumed any characters after the entity,
        (o === 0 || // And there should be no invalid characters.
        RP(s)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (i = r[this.treeIndex], o = (i & Li.VALUE_LENGTH) >> 14, o !== 0) {
        if (s === Ut.SEMI)
          return this.emitNamedEntityData(this.treeIndex, o, this.consumed + this.excess);
        this.decodeMode !== Si.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var t;
    const { result: n, decodeTree: r } = this, i = (r[n] & Li.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(n, i, this.consumed), (t = this.errors) === null || t === void 0 || t.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(t, n, r) {
    const { decodeTree: i } = this;
    return this.emitCodePoint(n === 1 ? i[t] & ~Li.VALUE_LENGTH : i[t + 1], r), n === 3 && this.emitCodePoint(i[t + 2], r), r;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var t;
    switch (this.state) {
      case zt.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== Si.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case zt.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case zt.NumericHex:
        return this.emitNumericEntity(0, 3);
      case zt.NumericStart:
        return (t = this.errors) === null || t === void 0 || t.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case zt.EntityStart:
        return 0;
    }
  }
}
function Ow(e) {
  let t = "";
  const n = new LP(e, (r) => t += CP(r));
  return function(i, o) {
    let s = 0, a = 0;
    for (; (a = i.indexOf("&", a)) >= 0; ) {
      t += i.slice(s, a), n.startEntity(o);
      const u = n.write(
        i,
        // Skip the "&"
        a + 1
      );
      if (u < 0) {
        s = a + n.end();
        break;
      }
      s = a + u, a = u === 0 ? s + 1 : s;
    }
    const l = t + i.slice(s);
    return t = "", l;
  };
}
function BP(e, t, n, r) {
  const i = (t & Li.BRANCH_LENGTH) >> 7, o = t & Li.JUMP_TABLE;
  if (i === 0)
    return o !== 0 && r === o ? n : -1;
  if (o) {
    const l = r - o;
    return l < 0 || l >= i ? -1 : e[n + l] - 1;
  }
  let s = n, a = s + i - 1;
  for (; s <= a; ) {
    const l = s + a >>> 1, u = e[l];
    if (u < r)
      s = l + 1;
    else if (u > r)
      a = l - 1;
    else
      return e[l + i];
  }
  return -1;
}
const PP = Ow(AP);
Ow(TP);
function Iw(e, t = Si.Legacy) {
  return PP(e, t);
}
function $P(e) {
  return Object.prototype.toString.call(e);
}
function Og(e) {
  return $P(e) === "[object String]";
}
const zP = Object.prototype.hasOwnProperty;
function FP(e, t) {
  return zP.call(e, t);
}
function yd(e) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(n) {
    if (n) {
      if (typeof n != "object")
        throw new TypeError(n + "must be object");
      Object.keys(n).forEach(function(r) {
        e[r] = n[r];
      });
    }
  }), e;
}
function Rw(e, t, n) {
  return [].concat(e.slice(0, t), n, e.slice(t + 1));
}
function Ig(e) {
  return !(e >= 55296 && e <= 57343 || e >= 64976 && e <= 65007 || (e & 65535) === 65535 || (e & 65535) === 65534 || e >= 0 && e <= 8 || e === 11 || e >= 14 && e <= 31 || e >= 127 && e <= 159 || e > 1114111);
}
function Kc(e) {
  if (e > 65535) {
    e -= 65536;
    const t = 55296 + (e >> 10), n = 56320 + (e & 1023);
    return String.fromCharCode(t, n);
  }
  return String.fromCharCode(e);
}
const Lw = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g, jP = /&([a-z#][a-z0-9]{1,31});/gi, UP = new RegExp(Lw.source + "|" + jP.source, "gi"), VP = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
function HP(e, t) {
  if (t.charCodeAt(0) === 35 && VP.test(t)) {
    const r = t[1].toLowerCase() === "x" ? parseInt(t.slice(2), 16) : parseInt(t.slice(1), 10);
    return Ig(r) ? Kc(r) : e;
  }
  const n = Iw(e);
  return n !== e ? n : e;
}
function qP(e) {
  return e.indexOf("\\") < 0 ? e : e.replace(Lw, "$1");
}
function zs(e) {
  return e.indexOf("\\") < 0 && e.indexOf("&") < 0 ? e : e.replace(UP, function(t, n, r) {
    return n || HP(t, r);
  });
}
const GP = /[&<>"]/, WP = /[&<>"]/g, KP = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;"
};
function YP(e) {
  return KP[e];
}
function Wi(e) {
  return GP.test(e) ? e.replace(WP, YP) : e;
}
const QP = /[.?*+^$[\]\\(){}|-]/g;
function ZP(e) {
  return e.replace(QP, "\\$&");
}
function dt(e) {
  switch (e) {
    case 9:
    case 32:
      return !0;
  }
  return !1;
}
function hl(e) {
  if (e >= 8192 && e <= 8202)
    return !0;
  switch (e) {
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return !0;
  }
  return !1;
}
function gl(e) {
  return Dg.test(e) || Nw.test(e);
}
function ml(e) {
  switch (e) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return !0;
    default:
      return !1;
  }
}
function vd(e) {
  return e = e.trim().replace(/\s+/g, " "), "".toLowerCase() === "" && (e = e.replace(//g, "")), e.toLowerCase().toUpperCase();
}
const XP = { mdurl: xP, ucmicro: MP }, JP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayReplaceAt: Rw,
  assign: yd,
  escapeHtml: Wi,
  escapeRE: ZP,
  fromCodePoint: Kc,
  has: FP,
  isMdAsciiPunct: ml,
  isPunctChar: gl,
  isSpace: dt,
  isString: Og,
  isValidEntityCode: Ig,
  isWhiteSpace: hl,
  lib: XP,
  normalizeReference: vd,
  unescapeAll: zs,
  unescapeMd: qP
}, Symbol.toStringTag, { value: "Module" }));
function e$(e, t, n) {
  let r, i, o, s;
  const a = e.posMax, l = e.pos;
  for (e.pos = t + 1, r = 1; e.pos < a; ) {
    if (o = e.src.charCodeAt(e.pos), o === 93 && (r--, r === 0)) {
      i = !0;
      break;
    }
    if (s = e.pos, e.md.inline.skipToken(e), o === 91) {
      if (s === e.pos - 1)
        r++;
      else if (n)
        return e.pos = l, -1;
    }
  }
  let u = -1;
  return i && (u = e.pos), e.pos = l, u;
}
function t$(e, t, n) {
  let r, i = t;
  const o = {
    ok: !1,
    pos: 0,
    str: ""
  };
  if (e.charCodeAt(i) === 60) {
    for (i++; i < n; ) {
      if (r = e.charCodeAt(i), r === 10 || r === 60)
        return o;
      if (r === 62)
        return o.pos = i + 1, o.str = zs(e.slice(t + 1, i)), o.ok = !0, o;
      if (r === 92 && i + 1 < n) {
        i += 2;
        continue;
      }
      i++;
    }
    return o;
  }
  let s = 0;
  for (; i < n && (r = e.charCodeAt(i), !(r === 32 || r < 32 || r === 127)); ) {
    if (r === 92 && i + 1 < n) {
      if (e.charCodeAt(i + 1) === 32)
        break;
      i += 2;
      continue;
    }
    if (r === 40 && (s++, s > 32))
      return o;
    if (r === 41) {
      if (s === 0)
        break;
      s--;
    }
    i++;
  }
  return t === i || s !== 0 || (o.str = zs(e.slice(t, i)), o.pos = i, o.ok = !0), o;
}
function n$(e, t, n, r) {
  let i, o = t;
  const s = {
    // if `true`, this is a valid link title
    ok: !1,
    // if `true`, this link can be continued on the next line
    can_continue: !1,
    // if `ok`, it's the position of the first character after the closing marker
    pos: 0,
    // if `ok`, it's the unescaped title
    str: "",
    // expected closing marker character code
    marker: 0
  };
  if (r)
    s.str = r.str, s.marker = r.marker;
  else {
    if (o >= n)
      return s;
    let a = e.charCodeAt(o);
    if (a !== 34 && a !== 39 && a !== 40)
      return s;
    t++, o++, a === 40 && (a = 41), s.marker = a;
  }
  for (; o < n; ) {
    if (i = e.charCodeAt(o), i === s.marker)
      return s.pos = o + 1, s.str += zs(e.slice(t, o)), s.ok = !0, s;
    if (i === 40 && s.marker === 41)
      return s;
    i === 92 && o + 1 < n && o++, o++;
  }
  return s.can_continue = !0, s.str += zs(e.slice(t, o)), s;
}
const r$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  parseLinkDestination: t$,
  parseLinkLabel: e$,
  parseLinkTitle: n$
}, Symbol.toStringTag, { value: "Module" })), Yr = {};
Yr.code_inline = function(e, t, n, r, i) {
  const o = e[t];
  return "<code" + i.renderAttrs(o) + ">" + Wi(o.content) + "</code>";
};
Yr.code_block = function(e, t, n, r, i) {
  const o = e[t];
  return "<pre" + i.renderAttrs(o) + "><code>" + Wi(e[t].content) + `</code></pre>
`;
};
Yr.fence = function(e, t, n, r, i) {
  const o = e[t], s = o.info ? zs(o.info).trim() : "";
  let a = "", l = "";
  if (s) {
    const c = s.split(/(\s+)/g);
    a = c[0], l = c.slice(2).join("");
  }
  let u;
  if (n.highlight ? u = n.highlight(o.content, a, l) || Wi(o.content) : u = Wi(o.content), u.indexOf("<pre") === 0)
    return u + `
`;
  if (s) {
    const c = o.attrIndex("class"), f = o.attrs ? o.attrs.slice() : [];
    c < 0 ? f.push(["class", n.langPrefix + a]) : (f[c] = f[c].slice(), f[c][1] += " " + n.langPrefix + a);
    const d = {
      attrs: f
    };
    return `<pre><code${i.renderAttrs(d)}>${u}</code></pre>
`;
  }
  return `<pre><code${i.renderAttrs(o)}>${u}</code></pre>
`;
};
Yr.image = function(e, t, n, r, i) {
  const o = e[t];
  return o.attrs[o.attrIndex("alt")][1] = i.renderInlineAsText(o.children, n, r), i.renderToken(e, t, n);
};
Yr.hardbreak = function(e, t, n) {
  return n.xhtmlOut ? `<br />
` : `<br>
`;
};
Yr.softbreak = function(e, t, n) {
  return n.breaks ? n.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
Yr.text = function(e, t) {
  return Wi(e[t].content);
};
Yr.html_block = function(e, t) {
  return e[t].content;
};
Yr.html_inline = function(e, t) {
  return e[t].content;
};
function ra() {
  this.rules = yd({}, Yr);
}
ra.prototype.renderAttrs = function(t) {
  let n, r, i;
  if (!t.attrs)
    return "";
  for (i = "", n = 0, r = t.attrs.length; n < r; n++)
    i += " " + Wi(t.attrs[n][0]) + '="' + Wi(t.attrs[n][1]) + '"';
  return i;
};
ra.prototype.renderToken = function(t, n, r) {
  const i = t[n];
  let o = "";
  if (i.hidden)
    return "";
  i.block && i.nesting !== -1 && n && t[n - 1].hidden && (o += `
`), o += (i.nesting === -1 ? "</" : "<") + i.tag, o += this.renderAttrs(i), i.nesting === 0 && r.xhtmlOut && (o += " /");
  let s = !1;
  if (i.block && (s = !0, i.nesting === 1 && n + 1 < t.length)) {
    const a = t[n + 1];
    (a.type === "inline" || a.hidden || a.nesting === -1 && a.tag === i.tag) && (s = !1);
  }
  return o += s ? `>
` : ">", o;
};
ra.prototype.renderInline = function(e, t, n) {
  let r = "";
  const i = this.rules;
  for (let o = 0, s = e.length; o < s; o++) {
    const a = e[o].type;
    typeof i[a] < "u" ? r += i[a](e, o, t, n, this) : r += this.renderToken(e, o, t);
  }
  return r;
};
ra.prototype.renderInlineAsText = function(e, t, n) {
  let r = "";
  for (let i = 0, o = e.length; i < o; i++)
    switch (e[i].type) {
      case "text":
        r += e[i].content;
        break;
      case "image":
        r += this.renderInlineAsText(e[i].children, t, n);
        break;
      case "html_inline":
      case "html_block":
        r += e[i].content;
        break;
      case "softbreak":
      case "hardbreak":
        r += `
`;
        break;
    }
  return r;
};
ra.prototype.render = function(e, t, n) {
  let r = "";
  const i = this.rules;
  for (let o = 0, s = e.length; o < s; o++) {
    const a = e[o].type;
    a === "inline" ? r += this.renderInline(e[o].children, t, n) : typeof i[a] < "u" ? r += i[a](e, o, t, n, this) : r += this.renderToken(e, o, t, n);
  }
  return r;
};
function Nn() {
  this.__rules__ = [], this.__cache__ = null;
}
Nn.prototype.__find__ = function(e) {
  for (let t = 0; t < this.__rules__.length; t++)
    if (this.__rules__[t].name === e)
      return t;
  return -1;
};
Nn.prototype.__compile__ = function() {
  const e = this, t = [""];
  e.__rules__.forEach(function(n) {
    n.enabled && n.alt.forEach(function(r) {
      t.indexOf(r) < 0 && t.push(r);
    });
  }), e.__cache__ = {}, t.forEach(function(n) {
    e.__cache__[n] = [], e.__rules__.forEach(function(r) {
      r.enabled && (n && r.alt.indexOf(n) < 0 || e.__cache__[n].push(r.fn));
    });
  });
};
Nn.prototype.at = function(e, t, n) {
  const r = this.__find__(e), i = n || {};
  if (r === -1)
    throw new Error("Parser rule not found: " + e);
  this.__rules__[r].fn = t, this.__rules__[r].alt = i.alt || [], this.__cache__ = null;
};
Nn.prototype.before = function(e, t, n, r) {
  const i = this.__find__(e), o = r || {};
  if (i === -1)
    throw new Error("Parser rule not found: " + e);
  this.__rules__.splice(i, 0, {
    name: t,
    enabled: !0,
    fn: n,
    alt: o.alt || []
  }), this.__cache__ = null;
};
Nn.prototype.after = function(e, t, n, r) {
  const i = this.__find__(e), o = r || {};
  if (i === -1)
    throw new Error("Parser rule not found: " + e);
  this.__rules__.splice(i + 1, 0, {
    name: t,
    enabled: !0,
    fn: n,
    alt: o.alt || []
  }), this.__cache__ = null;
};
Nn.prototype.push = function(e, t, n) {
  const r = n || {};
  this.__rules__.push({
    name: e,
    enabled: !0,
    fn: t,
    alt: r.alt || []
  }), this.__cache__ = null;
};
Nn.prototype.enable = function(e, t) {
  Array.isArray(e) || (e = [e]);
  const n = [];
  return e.forEach(function(r) {
    const i = this.__find__(r);
    if (i < 0) {
      if (t)
        return;
      throw new Error("Rules manager: invalid rule name " + r);
    }
    this.__rules__[i].enabled = !0, n.push(r);
  }, this), this.__cache__ = null, n;
};
Nn.prototype.enableOnly = function(e, t) {
  Array.isArray(e) || (e = [e]), this.__rules__.forEach(function(n) {
    n.enabled = !1;
  }), this.enable(e, t);
};
Nn.prototype.disable = function(e, t) {
  Array.isArray(e) || (e = [e]);
  const n = [];
  return e.forEach(function(r) {
    const i = this.__find__(r);
    if (i < 0) {
      if (t)
        return;
      throw new Error("Rules manager: invalid rule name " + r);
    }
    this.__rules__[i].enabled = !1, n.push(r);
  }, this), this.__cache__ = null, n;
};
Nn.prototype.getRules = function(e) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[e] || [];
};
function pr(e, t, n) {
  this.type = e, this.tag = t, this.attrs = null, this.map = null, this.nesting = n, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = !1, this.hidden = !1;
}
pr.prototype.attrIndex = function(t) {
  if (!this.attrs)
    return -1;
  const n = this.attrs;
  for (let r = 0, i = n.length; r < i; r++)
    if (n[r][0] === t)
      return r;
  return -1;
};
pr.prototype.attrPush = function(t) {
  this.attrs ? this.attrs.push(t) : this.attrs = [t];
};
pr.prototype.attrSet = function(t, n) {
  const r = this.attrIndex(t), i = [t, n];
  r < 0 ? this.attrPush(i) : this.attrs[r] = i;
};
pr.prototype.attrGet = function(t) {
  const n = this.attrIndex(t);
  let r = null;
  return n >= 0 && (r = this.attrs[n][1]), r;
};
pr.prototype.attrJoin = function(t, n) {
  const r = this.attrIndex(t);
  r < 0 ? this.attrPush([t, n]) : this.attrs[r][1] = this.attrs[r][1] + " " + n;
};
function Bw(e, t, n) {
  this.src = e, this.env = n, this.tokens = [], this.inlineMode = !1, this.md = t;
}
Bw.prototype.Token = pr;
const i$ = /\r\n?|\n/g, o$ = /\0/g;
function s$(e) {
  let t;
  t = e.src.replace(i$, `
`), t = t.replace(o$, ""), e.src = t;
}
function a$(e) {
  let t;
  e.inlineMode ? (t = new e.Token("inline", "", 0), t.content = e.src, t.map = [0, 1], t.children = [], e.tokens.push(t)) : e.md.block.parse(e.src, e.md, e.env, e.tokens);
}
function l$(e) {
  const t = e.tokens;
  for (let n = 0, r = t.length; n < r; n++) {
    const i = t[n];
    i.type === "inline" && e.md.inline.parse(i.content, e.md, e.env, i.children);
  }
}
function u$(e) {
  return /^<a[>\s]/i.test(e);
}
function c$(e) {
  return /^<\/a\s*>/i.test(e);
}
function f$(e) {
  const t = e.tokens;
  if (e.md.options.linkify)
    for (let n = 0, r = t.length; n < r; n++) {
      if (t[n].type !== "inline" || !e.md.linkify.pretest(t[n].content))
        continue;
      let i = t[n].children, o = 0;
      for (let s = i.length - 1; s >= 0; s--) {
        const a = i[s];
        if (a.type === "link_close") {
          for (s--; i[s].level !== a.level && i[s].type !== "link_open"; )
            s--;
          continue;
        }
        if (a.type === "html_inline" && (u$(a.content) && o > 0 && o--, c$(a.content) && o++), !(o > 0) && a.type === "text" && e.md.linkify.test(a.content)) {
          const l = a.content;
          let u = e.md.linkify.match(l);
          const c = [];
          let f = a.level, d = 0;
          u.length > 0 && u[0].index === 0 && s > 0 && i[s - 1].type === "text_special" && (u = u.slice(1));
          for (let p = 0; p < u.length; p++) {
            const h = u[p].url, m = e.md.normalizeLink(h);
            if (!e.md.validateLink(m))
              continue;
            let g = u[p].text;
            u[p].schema ? u[p].schema === "mailto:" && !/^mailto:/i.test(g) ? g = e.md.normalizeLinkText("mailto:" + g).replace(/^mailto:/, "") : g = e.md.normalizeLinkText(g) : g = e.md.normalizeLinkText("http://" + g).replace(/^http:\/\//, "");
            const y = u[p].index;
            if (y > d) {
              const M = new e.Token("text", "", 0);
              M.content = l.slice(d, y), M.level = f, c.push(M);
            }
            const _ = new e.Token("link_open", "a", 1);
            _.attrs = [["href", m]], _.level = f++, _.markup = "linkify", _.info = "auto", c.push(_);
            const E = new e.Token("text", "", 0);
            E.content = g, E.level = f, c.push(E);
            const v = new e.Token("link_close", "a", -1);
            v.level = --f, v.markup = "linkify", v.info = "auto", c.push(v), d = u[p].lastIndex;
          }
          if (d < l.length) {
            const p = new e.Token("text", "", 0);
            p.content = l.slice(d), p.level = f, c.push(p);
          }
          t[n].children = i = Rw(i, s, c);
        }
      }
    }
}
const Pw = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/, d$ = /\((c|tm|r)\)/i, p$ = /\((c|tm|r)\)/ig, h$ = {
  c: "",
  r: "",
  tm: ""
};
function g$(e, t) {
  return h$[t.toLowerCase()];
}
function m$(e) {
  let t = 0;
  for (let n = e.length - 1; n >= 0; n--) {
    const r = e[n];
    r.type === "text" && !t && (r.content = r.content.replace(p$, g$)), r.type === "link_open" && r.info === "auto" && t--, r.type === "link_close" && r.info === "auto" && t++;
  }
}
function b$(e) {
  let t = 0;
  for (let n = e.length - 1; n >= 0; n--) {
    const r = e[n];
    r.type === "text" && !t && Pw.test(r.content) && (r.content = r.content.replace(/\+-/g, "").replace(/\.{2,}/g, "").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1").replace(/(^|\s)--(?=\s|$)/mg, "$1").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1")), r.type === "link_open" && r.info === "auto" && t--, r.type === "link_close" && r.info === "auto" && t++;
  }
}
function y$(e) {
  let t;
  if (e.md.options.typographer)
    for (t = e.tokens.length - 1; t >= 0; t--)
      e.tokens[t].type === "inline" && (d$.test(e.tokens[t].content) && m$(e.tokens[t].children), Pw.test(e.tokens[t].content) && b$(e.tokens[t].children));
}
const v$ = /['"]/, Qb = /['"]/g, Zb = "";
function xu(e, t, n) {
  return e.slice(0, t) + n + e.slice(t + 1);
}
function _$(e, t) {
  let n;
  const r = [];
  for (let i = 0; i < e.length; i++) {
    const o = e[i], s = e[i].level;
    for (n = r.length - 1; n >= 0 && !(r[n].level <= s); n--)
      ;
    if (r.length = n + 1, o.type !== "text")
      continue;
    let a = o.content, l = 0, u = a.length;
    e:
      for (; l < u; ) {
        Qb.lastIndex = l;
        const c = Qb.exec(a);
        if (!c)
          break;
        let f = !0, d = !0;
        l = c.index + 1;
        const p = c[0] === "'";
        let h = 32;
        if (c.index - 1 >= 0)
          h = a.charCodeAt(c.index - 1);
        else
          for (n = i - 1; n >= 0 && !(e[n].type === "softbreak" || e[n].type === "hardbreak"); n--)
            if (e[n].content) {
              h = e[n].content.charCodeAt(e[n].content.length - 1);
              break;
            }
        let m = 32;
        if (l < u)
          m = a.charCodeAt(l);
        else
          for (n = i + 1; n < e.length && !(e[n].type === "softbreak" || e[n].type === "hardbreak"); n++)
            if (e[n].content) {
              m = e[n].content.charCodeAt(0);
              break;
            }
        const g = ml(h) || gl(String.fromCharCode(h)), y = ml(m) || gl(String.fromCharCode(m)), _ = hl(h), E = hl(m);
        if (E ? f = !1 : y && (_ || g || (f = !1)), _ ? d = !1 : g && (E || y || (d = !1)), m === 34 && c[0] === '"' && h >= 48 && h <= 57 && (d = f = !1), f && d && (f = g, d = y), !f && !d) {
          p && (o.content = xu(o.content, c.index, Zb));
          continue;
        }
        if (d)
          for (n = r.length - 1; n >= 0; n--) {
            let v = r[n];
            if (r[n].level < s)
              break;
            if (v.single === p && r[n].level === s) {
              v = r[n];
              let M, k;
              p ? (M = t.md.options.quotes[2], k = t.md.options.quotes[3]) : (M = t.md.options.quotes[0], k = t.md.options.quotes[1]), o.content = xu(o.content, c.index, k), e[v.token].content = xu(
                e[v.token].content,
                v.pos,
                M
              ), l += k.length - 1, v.token === i && (l += M.length - 1), a = o.content, u = a.length, r.length = n;
              continue e;
            }
          }
        f ? r.push({
          token: i,
          pos: c.index,
          single: p,
          level: s
        }) : d && p && (o.content = xu(o.content, c.index, Zb));
      }
  }
}
function E$(e) {
  if (e.md.options.typographer)
    for (let t = e.tokens.length - 1; t >= 0; t--)
      e.tokens[t].type !== "inline" || !v$.test(e.tokens[t].content) || _$(e.tokens[t].children, e);
}
function w$(e) {
  let t, n;
  const r = e.tokens, i = r.length;
  for (let o = 0; o < i; o++) {
    if (r[o].type !== "inline") continue;
    const s = r[o].children, a = s.length;
    for (t = 0; t < a; t++)
      s[t].type === "text_special" && (s[t].type = "text");
    for (t = n = 0; t < a; t++)
      s[t].type === "text" && t + 1 < a && s[t + 1].type === "text" ? s[t + 1].content = s[t].content + s[t + 1].content : (t !== n && (s[n] = s[t]), n++);
    t !== n && (s.length = n);
  }
}
const Tp = [
  ["normalize", s$],
  ["block", a$],
  ["inline", l$],
  ["linkify", f$],
  ["replacements", y$],
  ["smartquotes", E$],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", w$]
];
function Rg() {
  this.ruler = new Nn();
  for (let e = 0; e < Tp.length; e++)
    this.ruler.push(Tp[e][0], Tp[e][1]);
}
Rg.prototype.process = function(e) {
  const t = this.ruler.getRules("");
  for (let n = 0, r = t.length; n < r; n++)
    t[n](e);
};
Rg.prototype.State = Bw;
function Qr(e, t, n, r) {
  this.src = e, this.md = t, this.env = n, this.tokens = r, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = !1, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0;
  const i = this.src;
  for (let o = 0, s = 0, a = 0, l = 0, u = i.length, c = !1; s < u; s++) {
    const f = i.charCodeAt(s);
    if (!c)
      if (dt(f)) {
        a++, f === 9 ? l += 4 - l % 4 : l++;
        continue;
      } else
        c = !0;
    (f === 10 || s === u - 1) && (f !== 10 && s++, this.bMarks.push(o), this.eMarks.push(s), this.tShift.push(a), this.sCount.push(l), this.bsCount.push(0), c = !1, a = 0, l = 0, o = s + 1);
  }
  this.bMarks.push(i.length), this.eMarks.push(i.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
Qr.prototype.push = function(e, t, n) {
  const r = new pr(e, t, n);
  return r.block = !0, n < 0 && this.level--, r.level = this.level, n > 0 && this.level++, this.tokens.push(r), r;
};
Qr.prototype.isEmpty = function(t) {
  return this.bMarks[t] + this.tShift[t] >= this.eMarks[t];
};
Qr.prototype.skipEmptyLines = function(t) {
  for (let n = this.lineMax; t < n && !(this.bMarks[t] + this.tShift[t] < this.eMarks[t]); t++)
    ;
  return t;
};
Qr.prototype.skipSpaces = function(t) {
  for (let n = this.src.length; t < n; t++) {
    const r = this.src.charCodeAt(t);
    if (!dt(r))
      break;
  }
  return t;
};
Qr.prototype.skipSpacesBack = function(t, n) {
  if (t <= n)
    return t;
  for (; t > n; )
    if (!dt(this.src.charCodeAt(--t)))
      return t + 1;
  return t;
};
Qr.prototype.skipChars = function(t, n) {
  for (let r = this.src.length; t < r && this.src.charCodeAt(t) === n; t++)
    ;
  return t;
};
Qr.prototype.skipCharsBack = function(t, n, r) {
  if (t <= r)
    return t;
  for (; t > r; )
    if (n !== this.src.charCodeAt(--t))
      return t + 1;
  return t;
};
Qr.prototype.getLines = function(t, n, r, i) {
  if (t >= n)
    return "";
  const o = new Array(n - t);
  for (let s = 0, a = t; a < n; a++, s++) {
    let l = 0;
    const u = this.bMarks[a];
    let c = u, f;
    for (a + 1 < n || i ? f = this.eMarks[a] + 1 : f = this.eMarks[a]; c < f && l < r; ) {
      const d = this.src.charCodeAt(c);
      if (dt(d))
        d === 9 ? l += 4 - (l + this.bsCount[a]) % 4 : l++;
      else if (c - u < this.tShift[a])
        l++;
      else
        break;
      c++;
    }
    l > r ? o[s] = new Array(l - r + 1).join(" ") + this.src.slice(c, f) : o[s] = this.src.slice(c, f);
  }
  return o.join("");
};
Qr.prototype.Token = pr;
const x$ = 65536;
function Sp(e, t) {
  const n = e.bMarks[t] + e.tShift[t], r = e.eMarks[t];
  return e.src.slice(n, r);
}
function Xb(e) {
  const t = [], n = e.length;
  let r = 0, i = e.charCodeAt(r), o = !1, s = 0, a = "";
  for (; r < n; )
    i === 124 && (o ? (a += e.substring(s, r - 1), s = r) : (t.push(a + e.substring(s, r)), a = "", s = r + 1)), o = i === 92, r++, i = e.charCodeAt(r);
  return t.push(a + e.substring(s)), t;
}
function k$(e, t, n, r) {
  if (t + 2 > n)
    return !1;
  let i = t + 1;
  if (e.sCount[i] < e.blkIndent || e.sCount[i] - e.blkIndent >= 4)
    return !1;
  let o = e.bMarks[i] + e.tShift[i];
  if (o >= e.eMarks[i])
    return !1;
  const s = e.src.charCodeAt(o++);
  if (s !== 124 && s !== 45 && s !== 58 || o >= e.eMarks[i])
    return !1;
  const a = e.src.charCodeAt(o++);
  if (a !== 124 && a !== 45 && a !== 58 && !dt(a) || s === 45 && dt(a))
    return !1;
  for (; o < e.eMarks[i]; ) {
    const v = e.src.charCodeAt(o);
    if (v !== 124 && v !== 45 && v !== 58 && !dt(v))
      return !1;
    o++;
  }
  let l = Sp(e, t + 1), u = l.split("|");
  const c = [];
  for (let v = 0; v < u.length; v++) {
    const M = u[v].trim();
    if (!M) {
      if (v === 0 || v === u.length - 1)
        continue;
      return !1;
    }
    if (!/^:?-+:?$/.test(M))
      return !1;
    M.charCodeAt(M.length - 1) === 58 ? c.push(M.charCodeAt(0) === 58 ? "center" : "right") : M.charCodeAt(0) === 58 ? c.push("left") : c.push("");
  }
  if (l = Sp(e, t).trim(), l.indexOf("|") === -1 || e.sCount[t] - e.blkIndent >= 4)
    return !1;
  u = Xb(l), u.length && u[0] === "" && u.shift(), u.length && u[u.length - 1] === "" && u.pop();
  const f = u.length;
  if (f === 0 || f !== c.length)
    return !1;
  if (r)
    return !0;
  const d = e.parentType;
  e.parentType = "table";
  const p = e.md.block.ruler.getRules("blockquote"), h = e.push("table_open", "table", 1), m = [t, 0];
  h.map = m;
  const g = e.push("thead_open", "thead", 1);
  g.map = [t, t + 1];
  const y = e.push("tr_open", "tr", 1);
  y.map = [t, t + 1];
  for (let v = 0; v < u.length; v++) {
    const M = e.push("th_open", "th", 1);
    c[v] && (M.attrs = [["style", "text-align:" + c[v]]]);
    const k = e.push("inline", "", 0);
    k.content = u[v].trim(), k.children = [], e.push("th_close", "th", -1);
  }
  e.push("tr_close", "tr", -1), e.push("thead_close", "thead", -1);
  let _, E = 0;
  for (i = t + 2; i < n && !(e.sCount[i] < e.blkIndent); i++) {
    let v = !1;
    for (let k = 0, T = p.length; k < T; k++)
      if (p[k](e, i, n, !0)) {
        v = !0;
        break;
      }
    if (v || (l = Sp(e, i).trim(), !l) || e.sCount[i] - e.blkIndent >= 4 || (u = Xb(l), u.length && u[0] === "" && u.shift(), u.length && u[u.length - 1] === "" && u.pop(), E += f - u.length, E > x$))
      break;
    if (i === t + 2) {
      const k = e.push("tbody_open", "tbody", 1);
      k.map = _ = [t + 2, 0];
    }
    const M = e.push("tr_open", "tr", 1);
    M.map = [i, i + 1];
    for (let k = 0; k < f; k++) {
      const T = e.push("td_open", "td", 1);
      c[k] && (T.attrs = [["style", "text-align:" + c[k]]]);
      const U = e.push("inline", "", 0);
      U.content = u[k] ? u[k].trim() : "", U.children = [], e.push("td_close", "td", -1);
    }
    e.push("tr_close", "tr", -1);
  }
  return _ && (e.push("tbody_close", "tbody", -1), _[1] = i), e.push("table_close", "table", -1), m[1] = i, e.parentType = d, e.line = i, !0;
}
function M$(e, t, n) {
  if (e.sCount[t] - e.blkIndent < 4)
    return !1;
  let r = t + 1, i = r;
  for (; r < n; ) {
    if (e.isEmpty(r)) {
      r++;
      continue;
    }
    if (e.sCount[r] - e.blkIndent >= 4) {
      r++, i = r;
      continue;
    }
    break;
  }
  e.line = i;
  const o = e.push("code_block", "code", 0);
  return o.content = e.getLines(t, i, 4 + e.blkIndent, !1) + `
`, o.map = [t, e.line], !0;
}
function A$(e, t, n, r) {
  let i = e.bMarks[t] + e.tShift[t], o = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || i + 3 > o)
    return !1;
  const s = e.src.charCodeAt(i);
  if (s !== 126 && s !== 96)
    return !1;
  let a = i;
  i = e.skipChars(i, s);
  let l = i - a;
  if (l < 3)
    return !1;
  const u = e.src.slice(a, i), c = e.src.slice(i, o);
  if (s === 96 && c.indexOf(String.fromCharCode(s)) >= 0)
    return !1;
  if (r)
    return !0;
  let f = t, d = !1;
  for (; f++, !(f >= n || (i = a = e.bMarks[f] + e.tShift[f], o = e.eMarks[f], i < o && e.sCount[f] < e.blkIndent)); )
    if (e.src.charCodeAt(i) === s && !(e.sCount[f] - e.blkIndent >= 4) && (i = e.skipChars(i, s), !(i - a < l) && (i = e.skipSpaces(i), !(i < o)))) {
      d = !0;
      break;
    }
  l = e.sCount[t], e.line = f + (d ? 1 : 0);
  const p = e.push("fence", "code", 0);
  return p.info = c, p.content = e.getLines(t + 1, f, l, !0), p.markup = u, p.map = [t, e.line], !0;
}
function T$(e, t, n, r) {
  let i = e.bMarks[t] + e.tShift[t], o = e.eMarks[t];
  const s = e.lineMax;
  if (e.sCount[t] - e.blkIndent >= 4 || e.src.charCodeAt(i) !== 62)
    return !1;
  if (r)
    return !0;
  const a = [], l = [], u = [], c = [], f = e.md.block.ruler.getRules("blockquote"), d = e.parentType;
  e.parentType = "blockquote";
  let p = !1, h;
  for (h = t; h < n; h++) {
    const E = e.sCount[h] < e.blkIndent;
    if (i = e.bMarks[h] + e.tShift[h], o = e.eMarks[h], i >= o)
      break;
    if (e.src.charCodeAt(i++) === 62 && !E) {
      let M = e.sCount[h] + 1, k, T;
      e.src.charCodeAt(i) === 32 ? (i++, M++, T = !1, k = !0) : e.src.charCodeAt(i) === 9 ? (k = !0, (e.bsCount[h] + M) % 4 === 3 ? (i++, M++, T = !1) : T = !0) : k = !1;
      let U = M;
      for (a.push(e.bMarks[h]), e.bMarks[h] = i; i < o; ) {
        const C = e.src.charCodeAt(i);
        if (dt(C))
          C === 9 ? U += 4 - (U + e.bsCount[h] + (T ? 1 : 0)) % 4 : U++;
        else
          break;
        i++;
      }
      p = i >= o, l.push(e.bsCount[h]), e.bsCount[h] = e.sCount[h] + 1 + (k ? 1 : 0), u.push(e.sCount[h]), e.sCount[h] = U - M, c.push(e.tShift[h]), e.tShift[h] = i - e.bMarks[h];
      continue;
    }
    if (p)
      break;
    let v = !1;
    for (let M = 0, k = f.length; M < k; M++)
      if (f[M](e, h, n, !0)) {
        v = !0;
        break;
      }
    if (v) {
      e.lineMax = h, e.blkIndent !== 0 && (a.push(e.bMarks[h]), l.push(e.bsCount[h]), c.push(e.tShift[h]), u.push(e.sCount[h]), e.sCount[h] -= e.blkIndent);
      break;
    }
    a.push(e.bMarks[h]), l.push(e.bsCount[h]), c.push(e.tShift[h]), u.push(e.sCount[h]), e.sCount[h] = -1;
  }
  const m = e.blkIndent;
  e.blkIndent = 0;
  const g = e.push("blockquote_open", "blockquote", 1);
  g.markup = ">";
  const y = [t, 0];
  g.map = y, e.md.block.tokenize(e, t, h);
  const _ = e.push("blockquote_close", "blockquote", -1);
  _.markup = ">", e.lineMax = s, e.parentType = d, y[1] = e.line;
  for (let E = 0; E < c.length; E++)
    e.bMarks[E + t] = a[E], e.tShift[E + t] = c[E], e.sCount[E + t] = u[E], e.bsCount[E + t] = l[E];
  return e.blkIndent = m, !0;
}
function S$(e, t, n, r) {
  const i = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4)
    return !1;
  let o = e.bMarks[t] + e.tShift[t];
  const s = e.src.charCodeAt(o++);
  if (s !== 42 && s !== 45 && s !== 95)
    return !1;
  let a = 1;
  for (; o < i; ) {
    const u = e.src.charCodeAt(o++);
    if (u !== s && !dt(u))
      return !1;
    u === s && a++;
  }
  if (a < 3)
    return !1;
  if (r)
    return !0;
  e.line = t + 1;
  const l = e.push("hr", "hr", 0);
  return l.map = [t, e.line], l.markup = Array(a + 1).join(String.fromCharCode(s)), !0;
}
function Jb(e, t) {
  const n = e.eMarks[t];
  let r = e.bMarks[t] + e.tShift[t];
  const i = e.src.charCodeAt(r++);
  if (i !== 42 && i !== 45 && i !== 43)
    return -1;
  if (r < n) {
    const o = e.src.charCodeAt(r);
    if (!dt(o))
      return -1;
  }
  return r;
}
function ey(e, t) {
  const n = e.bMarks[t] + e.tShift[t], r = e.eMarks[t];
  let i = n;
  if (i + 1 >= r)
    return -1;
  let o = e.src.charCodeAt(i++);
  if (o < 48 || o > 57)
    return -1;
  for (; ; ) {
    if (i >= r)
      return -1;
    if (o = e.src.charCodeAt(i++), o >= 48 && o <= 57) {
      if (i - n >= 10)
        return -1;
      continue;
    }
    if (o === 41 || o === 46)
      break;
    return -1;
  }
  return i < r && (o = e.src.charCodeAt(i), !dt(o)) ? -1 : i;
}
function C$(e, t) {
  const n = e.level + 2;
  for (let r = t + 2, i = e.tokens.length - 2; r < i; r++)
    e.tokens[r].level === n && e.tokens[r].type === "paragraph_open" && (e.tokens[r + 2].hidden = !0, e.tokens[r].hidden = !0, r += 2);
}
function N$(e, t, n, r) {
  let i, o, s, a, l = t, u = !0;
  if (e.sCount[l] - e.blkIndent >= 4 || e.listIndent >= 0 && e.sCount[l] - e.listIndent >= 4 && e.sCount[l] < e.blkIndent)
    return !1;
  let c = !1;
  r && e.parentType === "paragraph" && e.sCount[l] >= e.blkIndent && (c = !0);
  let f, d, p;
  if ((p = ey(e, l)) >= 0) {
    if (f = !0, s = e.bMarks[l] + e.tShift[l], d = Number(e.src.slice(s, p - 1)), c && d !== 1) return !1;
  } else if ((p = Jb(e, l)) >= 0)
    f = !1;
  else
    return !1;
  if (c && e.skipSpaces(p) >= e.eMarks[l])
    return !1;
  if (r)
    return !0;
  const h = e.src.charCodeAt(p - 1), m = e.tokens.length;
  f ? (a = e.push("ordered_list_open", "ol", 1), d !== 1 && (a.attrs = [["start", d]])) : a = e.push("bullet_list_open", "ul", 1);
  const g = [l, 0];
  a.map = g, a.markup = String.fromCharCode(h);
  let y = !1;
  const _ = e.md.block.ruler.getRules("list"), E = e.parentType;
  for (e.parentType = "list"; l < n; ) {
    o = p, i = e.eMarks[l];
    const v = e.sCount[l] + p - (e.bMarks[l] + e.tShift[l]);
    let M = v;
    for (; o < i; ) {
      const le = e.src.charCodeAt(o);
      if (le === 9)
        M += 4 - (M + e.bsCount[l]) % 4;
      else if (le === 32)
        M++;
      else
        break;
      o++;
    }
    const k = o;
    let T;
    k >= i ? T = 1 : T = M - v, T > 4 && (T = 1);
    const U = v + T;
    a = e.push("list_item_open", "li", 1), a.markup = String.fromCharCode(h);
    const C = [l, 0];
    a.map = C, f && (a.info = e.src.slice(s, p - 1));
    const z = e.tight, H = e.tShift[l], j = e.sCount[l], V = e.listIndent;
    if (e.listIndent = e.blkIndent, e.blkIndent = U, e.tight = !0, e.tShift[l] = k - e.bMarks[l], e.sCount[l] = M, k >= i && e.isEmpty(l + 1) ? e.line = Math.min(e.line + 2, n) : e.md.block.tokenize(e, l, n, !0), (!e.tight || y) && (u = !1), y = e.line - l > 1 && e.isEmpty(e.line - 1), e.blkIndent = e.listIndent, e.listIndent = V, e.tShift[l] = H, e.sCount[l] = j, e.tight = z, a = e.push("list_item_close", "li", -1), a.markup = String.fromCharCode(h), l = e.line, C[1] = l, l >= n || e.sCount[l] < e.blkIndent || e.sCount[l] - e.blkIndent >= 4)
      break;
    let Q = !1;
    for (let le = 0, ne = _.length; le < ne; le++)
      if (_[le](e, l, n, !0)) {
        Q = !0;
        break;
      }
    if (Q)
      break;
    if (f) {
      if (p = ey(e, l), p < 0)
        break;
      s = e.bMarks[l] + e.tShift[l];
    } else if (p = Jb(e, l), p < 0)
      break;
    if (h !== e.src.charCodeAt(p - 1))
      break;
  }
  return f ? a = e.push("ordered_list_close", "ol", -1) : a = e.push("bullet_list_close", "ul", -1), a.markup = String.fromCharCode(h), g[1] = l, e.line = l, e.parentType = E, u && C$(e, m), !0;
}
function D$(e, t, n, r) {
  let i = e.bMarks[t] + e.tShift[t], o = e.eMarks[t], s = t + 1;
  if (e.sCount[t] - e.blkIndent >= 4 || e.src.charCodeAt(i) !== 91)
    return !1;
  function a(_) {
    const E = e.lineMax;
    if (_ >= E || e.isEmpty(_))
      return null;
    let v = !1;
    if (e.sCount[_] - e.blkIndent > 3 && (v = !0), e.sCount[_] < 0 && (v = !0), !v) {
      const T = e.md.block.ruler.getRules("reference"), U = e.parentType;
      e.parentType = "reference";
      let C = !1;
      for (let z = 0, H = T.length; z < H; z++)
        if (T[z](e, _, E, !0)) {
          C = !0;
          break;
        }
      if (e.parentType = U, C)
        return null;
    }
    const M = e.bMarks[_] + e.tShift[_], k = e.eMarks[_];
    return e.src.slice(M, k + 1);
  }
  let l = e.src.slice(i, o + 1);
  o = l.length;
  let u = -1;
  for (i = 1; i < o; i++) {
    const _ = l.charCodeAt(i);
    if (_ === 91)
      return !1;
    if (_ === 93) {
      u = i;
      break;
    } else if (_ === 10) {
      const E = a(s);
      E !== null && (l += E, o = l.length, s++);
    } else if (_ === 92 && (i++, i < o && l.charCodeAt(i) === 10)) {
      const E = a(s);
      E !== null && (l += E, o = l.length, s++);
    }
  }
  if (u < 0 || l.charCodeAt(u + 1) !== 58)
    return !1;
  for (i = u + 2; i < o; i++) {
    const _ = l.charCodeAt(i);
    if (_ === 10) {
      const E = a(s);
      E !== null && (l += E, o = l.length, s++);
    } else if (!dt(_)) break;
  }
  const c = e.md.helpers.parseLinkDestination(l, i, o);
  if (!c.ok)
    return !1;
  const f = e.md.normalizeLink(c.str);
  if (!e.md.validateLink(f))
    return !1;
  i = c.pos;
  const d = i, p = s, h = i;
  for (; i < o; i++) {
    const _ = l.charCodeAt(i);
    if (_ === 10) {
      const E = a(s);
      E !== null && (l += E, o = l.length, s++);
    } else if (!dt(_)) break;
  }
  let m = e.md.helpers.parseLinkTitle(l, i, o);
  for (; m.can_continue; ) {
    const _ = a(s);
    if (_ === null) break;
    l += _, i = o, o = l.length, s++, m = e.md.helpers.parseLinkTitle(l, i, o, m);
  }
  let g;
  for (i < o && h !== i && m.ok ? (g = m.str, i = m.pos) : (g = "", i = d, s = p); i < o; ) {
    const _ = l.charCodeAt(i);
    if (!dt(_))
      break;
    i++;
  }
  if (i < o && l.charCodeAt(i) !== 10 && g)
    for (g = "", i = d, s = p; i < o; ) {
      const _ = l.charCodeAt(i);
      if (!dt(_))
        break;
      i++;
    }
  if (i < o && l.charCodeAt(i) !== 10)
    return !1;
  const y = vd(l.slice(1, u));
  return y ? (r || (typeof e.env.references > "u" && (e.env.references = {}), typeof e.env.references[y] > "u" && (e.env.references[y] = { title: g, href: f }), e.line = s), !0) : !1;
}
const O$ = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], I$ = "[a-zA-Z_:][a-zA-Z0-9:._-]*", R$ = "[^\"'=<>`\\x00-\\x20]+", L$ = "'[^']*'", B$ = '"[^"]*"', P$ = "(?:" + R$ + "|" + L$ + "|" + B$ + ")", $$ = "(?:\\s+" + I$ + "(?:\\s*=\\s*" + P$ + ")?)", $w = "<[A-Za-z][A-Za-z0-9\\-]*" + $$ + "*\\s*\\/?>", zw = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", z$ = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->", F$ = "<[?][\\s\\S]*?[?]>", j$ = "<![A-Za-z][^>]*>", U$ = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", V$ = new RegExp("^(?:" + $w + "|" + zw + "|" + z$ + "|" + F$ + "|" + j$ + "|" + U$ + ")"), H$ = new RegExp("^(?:" + $w + "|" + zw + ")"), Go = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, !0],
  [/^<!--/, /-->/, !0],
  [/^<\?/, /\?>/, !0],
  [/^<![A-Z]/, />/, !0],
  [/^<!\[CDATA\[/, /\]\]>/, !0],
  [new RegExp("^</?(" + O$.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, !0],
  [new RegExp(H$.source + "\\s*$"), /^$/, !1]
];
function q$(e, t, n, r) {
  let i = e.bMarks[t] + e.tShift[t], o = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || !e.md.options.html || e.src.charCodeAt(i) !== 60)
    return !1;
  let s = e.src.slice(i, o), a = 0;
  for (; a < Go.length && !Go[a][0].test(s); a++)
    ;
  if (a === Go.length)
    return !1;
  if (r)
    return Go[a][2];
  let l = t + 1;
  if (!Go[a][1].test(s)) {
    for (; l < n && !(e.sCount[l] < e.blkIndent); l++)
      if (i = e.bMarks[l] + e.tShift[l], o = e.eMarks[l], s = e.src.slice(i, o), Go[a][1].test(s)) {
        s.length !== 0 && l++;
        break;
      }
  }
  e.line = l;
  const u = e.push("html_block", "", 0);
  return u.map = [t, l], u.content = e.getLines(t, l, e.blkIndent, !0), !0;
}
function G$(e, t, n, r) {
  let i = e.bMarks[t] + e.tShift[t], o = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4)
    return !1;
  let s = e.src.charCodeAt(i);
  if (s !== 35 || i >= o)
    return !1;
  let a = 1;
  for (s = e.src.charCodeAt(++i); s === 35 && i < o && a <= 6; )
    a++, s = e.src.charCodeAt(++i);
  if (a > 6 || i < o && !dt(s))
    return !1;
  if (r)
    return !0;
  o = e.skipSpacesBack(o, i);
  const l = e.skipCharsBack(o, 35, i);
  l > i && dt(e.src.charCodeAt(l - 1)) && (o = l), e.line = t + 1;
  const u = e.push("heading_open", "h" + String(a), 1);
  u.markup = "########".slice(0, a), u.map = [t, e.line];
  const c = e.push("inline", "", 0);
  c.content = e.src.slice(i, o).trim(), c.map = [t, e.line], c.children = [];
  const f = e.push("heading_close", "h" + String(a), -1);
  return f.markup = "########".slice(0, a), !0;
}
function W$(e, t, n) {
  const r = e.md.block.ruler.getRules("paragraph");
  if (e.sCount[t] - e.blkIndent >= 4)
    return !1;
  const i = e.parentType;
  e.parentType = "paragraph";
  let o = 0, s, a = t + 1;
  for (; a < n && !e.isEmpty(a); a++) {
    if (e.sCount[a] - e.blkIndent > 3)
      continue;
    if (e.sCount[a] >= e.blkIndent) {
      let p = e.bMarks[a] + e.tShift[a];
      const h = e.eMarks[a];
      if (p < h && (s = e.src.charCodeAt(p), (s === 45 || s === 61) && (p = e.skipChars(p, s), p = e.skipSpaces(p), p >= h))) {
        o = s === 61 ? 1 : 2;
        break;
      }
    }
    if (e.sCount[a] < 0)
      continue;
    let d = !1;
    for (let p = 0, h = r.length; p < h; p++)
      if (r[p](e, a, n, !0)) {
        d = !0;
        break;
      }
    if (d)
      break;
  }
  if (!o)
    return !1;
  const l = e.getLines(t, a, e.blkIndent, !1).trim();
  e.line = a + 1;
  const u = e.push("heading_open", "h" + String(o), 1);
  u.markup = String.fromCharCode(s), u.map = [t, e.line];
  const c = e.push("inline", "", 0);
  c.content = l, c.map = [t, e.line - 1], c.children = [];
  const f = e.push("heading_close", "h" + String(o), -1);
  return f.markup = String.fromCharCode(s), e.parentType = i, !0;
}
function K$(e, t, n) {
  const r = e.md.block.ruler.getRules("paragraph"), i = e.parentType;
  let o = t + 1;
  for (e.parentType = "paragraph"; o < n && !e.isEmpty(o); o++) {
    if (e.sCount[o] - e.blkIndent > 3 || e.sCount[o] < 0)
      continue;
    let u = !1;
    for (let c = 0, f = r.length; c < f; c++)
      if (r[c](e, o, n, !0)) {
        u = !0;
        break;
      }
    if (u)
      break;
  }
  const s = e.getLines(t, o, e.blkIndent, !1).trim();
  e.line = o;
  const a = e.push("paragraph_open", "p", 1);
  a.map = [t, e.line];
  const l = e.push("inline", "", 0);
  return l.content = s, l.map = [t, e.line], l.children = [], e.push("paragraph_close", "p", -1), e.parentType = i, !0;
}
const ku = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", k$, ["paragraph", "reference"]],
  ["code", M$],
  ["fence", A$, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", T$, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", S$, ["paragraph", "reference", "blockquote", "list"]],
  ["list", N$, ["paragraph", "reference", "blockquote"]],
  ["reference", D$],
  ["html_block", q$, ["paragraph", "reference", "blockquote"]],
  ["heading", G$, ["paragraph", "reference", "blockquote"]],
  ["lheading", W$],
  ["paragraph", K$]
];
function _d() {
  this.ruler = new Nn();
  for (let e = 0; e < ku.length; e++)
    this.ruler.push(ku[e][0], ku[e][1], { alt: (ku[e][2] || []).slice() });
}
_d.prototype.tokenize = function(e, t, n) {
  const r = this.ruler.getRules(""), i = r.length, o = e.md.options.maxNesting;
  let s = t, a = !1;
  for (; s < n && (e.line = s = e.skipEmptyLines(s), !(s >= n || e.sCount[s] < e.blkIndent)); ) {
    if (e.level >= o) {
      e.line = n;
      break;
    }
    const l = e.line;
    let u = !1;
    for (let c = 0; c < i; c++)
      if (u = r[c](e, s, n, !1), u) {
        if (l >= e.line)
          throw new Error("block rule didn't increment state.line");
        break;
      }
    if (!u) throw new Error("none of the block rules matched");
    e.tight = !a, e.isEmpty(e.line - 1) && (a = !0), s = e.line, s < n && e.isEmpty(s) && (a = !0, s++, e.line = s);
  }
};
_d.prototype.parse = function(e, t, n, r) {
  if (!e)
    return;
  const i = new this.State(e, t, n, r);
  this.tokenize(i, i.line, i.lineMax);
};
_d.prototype.State = Qr;
function Xl(e, t, n, r) {
  this.src = e, this.env = n, this.md = t, this.tokens = r, this.tokens_meta = Array(r.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = !1, this.linkLevel = 0;
}
Xl.prototype.pushPending = function() {
  const e = new pr("text", "", 0);
  return e.content = this.pending, e.level = this.pendingLevel, this.tokens.push(e), this.pending = "", e;
};
Xl.prototype.push = function(e, t, n) {
  this.pending && this.pushPending();
  const r = new pr(e, t, n);
  let i = null;
  return n < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), r.level = this.level, n > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], i = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(r), this.tokens_meta.push(i), r;
};
Xl.prototype.scanDelims = function(e, t) {
  const n = this.posMax, r = this.src.charCodeAt(e), i = e > 0 ? this.src.charCodeAt(e - 1) : 32;
  let o = e;
  for (; o < n && this.src.charCodeAt(o) === r; )
    o++;
  const s = o - e, a = o < n ? this.src.charCodeAt(o) : 32, l = ml(i) || gl(String.fromCharCode(i)), u = ml(a) || gl(String.fromCharCode(a)), c = hl(i), f = hl(a), d = !f && (!u || c || l), p = !c && (!l || f || u);
  return { can_open: d && (t || !p || l), can_close: p && (t || !d || u), length: s };
};
Xl.prototype.Token = pr;
function Y$(e) {
  switch (e) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return !0;
    default:
      return !1;
  }
}
function Q$(e, t) {
  let n = e.pos;
  for (; n < e.posMax && !Y$(e.src.charCodeAt(n)); )
    n++;
  return n === e.pos ? !1 : (t || (e.pending += e.src.slice(e.pos, n)), e.pos = n, !0);
}
const Z$ = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
function X$(e, t) {
  if (!e.md.options.linkify || e.linkLevel > 0) return !1;
  const n = e.pos, r = e.posMax;
  if (n + 3 > r || e.src.charCodeAt(n) !== 58 || e.src.charCodeAt(n + 1) !== 47 || e.src.charCodeAt(n + 2) !== 47) return !1;
  const i = e.pending.match(Z$);
  if (!i) return !1;
  const o = i[1], s = e.md.linkify.matchAtStart(e.src.slice(n - o.length));
  if (!s) return !1;
  let a = s.url;
  if (a.length <= o.length) return !1;
  a = a.replace(/\*+$/, "");
  const l = e.md.normalizeLink(a);
  if (!e.md.validateLink(l)) return !1;
  if (!t) {
    e.pending = e.pending.slice(0, -o.length);
    const u = e.push("link_open", "a", 1);
    u.attrs = [["href", l]], u.markup = "linkify", u.info = "auto";
    const c = e.push("text", "", 0);
    c.content = e.md.normalizeLinkText(a);
    const f = e.push("link_close", "a", -1);
    f.markup = "linkify", f.info = "auto";
  }
  return e.pos += a.length - o.length, !0;
}
function J$(e, t) {
  let n = e.pos;
  if (e.src.charCodeAt(n) !== 10)
    return !1;
  const r = e.pending.length - 1, i = e.posMax;
  if (!t)
    if (r >= 0 && e.pending.charCodeAt(r) === 32)
      if (r >= 1 && e.pending.charCodeAt(r - 1) === 32) {
        let o = r - 1;
        for (; o >= 1 && e.pending.charCodeAt(o - 1) === 32; ) o--;
        e.pending = e.pending.slice(0, o), e.push("hardbreak", "br", 0);
      } else
        e.pending = e.pending.slice(0, -1), e.push("softbreak", "br", 0);
    else
      e.push("softbreak", "br", 0);
  for (n++; n < i && dt(e.src.charCodeAt(n)); )
    n++;
  return e.pos = n, !0;
}
const Lg = [];
for (let e = 0; e < 256; e++)
  Lg.push(0);
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(e) {
  Lg[e.charCodeAt(0)] = 1;
});
function e7(e, t) {
  let n = e.pos;
  const r = e.posMax;
  if (e.src.charCodeAt(n) !== 92 || (n++, n >= r)) return !1;
  let i = e.src.charCodeAt(n);
  if (i === 10) {
    for (t || e.push("hardbreak", "br", 0), n++; n < r && (i = e.src.charCodeAt(n), !!dt(i)); )
      n++;
    return e.pos = n, !0;
  }
  let o = e.src[n];
  if (i >= 55296 && i <= 56319 && n + 1 < r) {
    const a = e.src.charCodeAt(n + 1);
    a >= 56320 && a <= 57343 && (o += e.src[n + 1], n++);
  }
  const s = "\\" + o;
  if (!t) {
    const a = e.push("text_special", "", 0);
    i < 256 && Lg[i] !== 0 ? a.content = o : a.content = s, a.markup = s, a.info = "escape";
  }
  return e.pos = n + 1, !0;
}
function t7(e, t) {
  let n = e.pos;
  if (e.src.charCodeAt(n) !== 96)
    return !1;
  const i = n;
  n++;
  const o = e.posMax;
  for (; n < o && e.src.charCodeAt(n) === 96; )
    n++;
  const s = e.src.slice(i, n), a = s.length;
  if (e.backticksScanned && (e.backticks[a] || 0) <= i)
    return t || (e.pending += s), e.pos += a, !0;
  let l = n, u;
  for (; (u = e.src.indexOf("`", l)) !== -1; ) {
    for (l = u + 1; l < o && e.src.charCodeAt(l) === 96; )
      l++;
    const c = l - u;
    if (c === a) {
      if (!t) {
        const f = e.push("code_inline", "code", 0);
        f.markup = s, f.content = e.src.slice(n, u).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      return e.pos = l, !0;
    }
    e.backticks[c] = u;
  }
  return e.backticksScanned = !0, t || (e.pending += s), e.pos += a, !0;
}
function n7(e, t) {
  const n = e.pos, r = e.src.charCodeAt(n);
  if (t || r !== 126)
    return !1;
  const i = e.scanDelims(e.pos, !0);
  let o = i.length;
  const s = String.fromCharCode(r);
  if (o < 2)
    return !1;
  let a;
  o % 2 && (a = e.push("text", "", 0), a.content = s, o--);
  for (let l = 0; l < o; l += 2)
    a = e.push("text", "", 0), a.content = s + s, e.delimiters.push({
      marker: r,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: e.tokens.length - 1,
      end: -1,
      open: i.can_open,
      close: i.can_close
    });
  return e.pos += i.length, !0;
}
function ty(e, t) {
  let n;
  const r = [], i = t.length;
  for (let o = 0; o < i; o++) {
    const s = t[o];
    if (s.marker !== 126 || s.end === -1)
      continue;
    const a = t[s.end];
    n = e.tokens[s.token], n.type = "s_open", n.tag = "s", n.nesting = 1, n.markup = "~~", n.content = "", n = e.tokens[a.token], n.type = "s_close", n.tag = "s", n.nesting = -1, n.markup = "~~", n.content = "", e.tokens[a.token - 1].type === "text" && e.tokens[a.token - 1].content === "~" && r.push(a.token - 1);
  }
  for (; r.length; ) {
    const o = r.pop();
    let s = o + 1;
    for (; s < e.tokens.length && e.tokens[s].type === "s_close"; )
      s++;
    s--, o !== s && (n = e.tokens[s], e.tokens[s] = e.tokens[o], e.tokens[o] = n);
  }
}
function r7(e) {
  const t = e.tokens_meta, n = e.tokens_meta.length;
  ty(e, e.delimiters);
  for (let r = 0; r < n; r++)
    t[r] && t[r].delimiters && ty(e, t[r].delimiters);
}
const Fw = {
  tokenize: n7,
  postProcess: r7
};
function i7(e, t) {
  const n = e.pos, r = e.src.charCodeAt(n);
  if (t || r !== 95 && r !== 42)
    return !1;
  const i = e.scanDelims(e.pos, r === 42);
  for (let o = 0; o < i.length; o++) {
    const s = e.push("text", "", 0);
    s.content = String.fromCharCode(r), e.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: r,
      // Total length of these series of delimiters.
      //
      length: i.length,
      // A position of the token this delimiter corresponds to.
      //
      token: e.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: i.can_open,
      close: i.can_close
    });
  }
  return e.pos += i.length, !0;
}
function ny(e, t) {
  const n = t.length;
  for (let r = n - 1; r >= 0; r--) {
    const i = t[r];
    if (i.marker !== 95 && i.marker !== 42 || i.end === -1)
      continue;
    const o = t[i.end], s = r > 0 && t[r - 1].end === i.end + 1 && // check that first two markers match and adjacent
    t[r - 1].marker === i.marker && t[r - 1].token === i.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    t[i.end + 1].token === o.token + 1, a = String.fromCharCode(i.marker), l = e.tokens[i.token];
    l.type = s ? "strong_open" : "em_open", l.tag = s ? "strong" : "em", l.nesting = 1, l.markup = s ? a + a : a, l.content = "";
    const u = e.tokens[o.token];
    u.type = s ? "strong_close" : "em_close", u.tag = s ? "strong" : "em", u.nesting = -1, u.markup = s ? a + a : a, u.content = "", s && (e.tokens[t[r - 1].token].content = "", e.tokens[t[i.end + 1].token].content = "", r--);
  }
}
function o7(e) {
  const t = e.tokens_meta, n = e.tokens_meta.length;
  ny(e, e.delimiters);
  for (let r = 0; r < n; r++)
    t[r] && t[r].delimiters && ny(e, t[r].delimiters);
}
const jw = {
  tokenize: i7,
  postProcess: o7
};
function s7(e, t) {
  let n, r, i, o, s = "", a = "", l = e.pos, u = !0;
  if (e.src.charCodeAt(e.pos) !== 91)
    return !1;
  const c = e.pos, f = e.posMax, d = e.pos + 1, p = e.md.helpers.parseLinkLabel(e, e.pos, !0);
  if (p < 0)
    return !1;
  let h = p + 1;
  if (h < f && e.src.charCodeAt(h) === 40) {
    for (u = !1, h++; h < f && (n = e.src.charCodeAt(h), !(!dt(n) && n !== 10)); h++)
      ;
    if (h >= f)
      return !1;
    if (l = h, i = e.md.helpers.parseLinkDestination(e.src, h, e.posMax), i.ok) {
      for (s = e.md.normalizeLink(i.str), e.md.validateLink(s) ? h = i.pos : s = "", l = h; h < f && (n = e.src.charCodeAt(h), !(!dt(n) && n !== 10)); h++)
        ;
      if (i = e.md.helpers.parseLinkTitle(e.src, h, e.posMax), h < f && l !== h && i.ok)
        for (a = i.str, h = i.pos; h < f && (n = e.src.charCodeAt(h), !(!dt(n) && n !== 10)); h++)
          ;
    }
    (h >= f || e.src.charCodeAt(h) !== 41) && (u = !0), h++;
  }
  if (u) {
    if (typeof e.env.references > "u")
      return !1;
    if (h < f && e.src.charCodeAt(h) === 91 ? (l = h + 1, h = e.md.helpers.parseLinkLabel(e, h), h >= 0 ? r = e.src.slice(l, h++) : h = p + 1) : h = p + 1, r || (r = e.src.slice(d, p)), o = e.env.references[vd(r)], !o)
      return e.pos = c, !1;
    s = o.href, a = o.title;
  }
  if (!t) {
    e.pos = d, e.posMax = p;
    const m = e.push("link_open", "a", 1), g = [["href", s]];
    m.attrs = g, a && g.push(["title", a]), e.linkLevel++, e.md.inline.tokenize(e), e.linkLevel--, e.push("link_close", "a", -1);
  }
  return e.pos = h, e.posMax = f, !0;
}
function a7(e, t) {
  let n, r, i, o, s, a, l, u, c = "";
  const f = e.pos, d = e.posMax;
  if (e.src.charCodeAt(e.pos) !== 33 || e.src.charCodeAt(e.pos + 1) !== 91)
    return !1;
  const p = e.pos + 2, h = e.md.helpers.parseLinkLabel(e, e.pos + 1, !1);
  if (h < 0)
    return !1;
  if (o = h + 1, o < d && e.src.charCodeAt(o) === 40) {
    for (o++; o < d && (n = e.src.charCodeAt(o), !(!dt(n) && n !== 10)); o++)
      ;
    if (o >= d)
      return !1;
    for (u = o, a = e.md.helpers.parseLinkDestination(e.src, o, e.posMax), a.ok && (c = e.md.normalizeLink(a.str), e.md.validateLink(c) ? o = a.pos : c = ""), u = o; o < d && (n = e.src.charCodeAt(o), !(!dt(n) && n !== 10)); o++)
      ;
    if (a = e.md.helpers.parseLinkTitle(e.src, o, e.posMax), o < d && u !== o && a.ok)
      for (l = a.str, o = a.pos; o < d && (n = e.src.charCodeAt(o), !(!dt(n) && n !== 10)); o++)
        ;
    else
      l = "";
    if (o >= d || e.src.charCodeAt(o) !== 41)
      return e.pos = f, !1;
    o++;
  } else {
    if (typeof e.env.references > "u")
      return !1;
    if (o < d && e.src.charCodeAt(o) === 91 ? (u = o + 1, o = e.md.helpers.parseLinkLabel(e, o), o >= 0 ? i = e.src.slice(u, o++) : o = h + 1) : o = h + 1, i || (i = e.src.slice(p, h)), s = e.env.references[vd(i)], !s)
      return e.pos = f, !1;
    c = s.href, l = s.title;
  }
  if (!t) {
    r = e.src.slice(p, h);
    const m = [];
    e.md.inline.parse(
      r,
      e.md,
      e.env,
      m
    );
    const g = e.push("image", "img", 0), y = [["src", c], ["alt", ""]];
    g.attrs = y, g.children = m, g.content = r, l && y.push(["title", l]);
  }
  return e.pos = o, e.posMax = d, !0;
}
const l7 = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/, u7 = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function c7(e, t) {
  let n = e.pos;
  if (e.src.charCodeAt(n) !== 60)
    return !1;
  const r = e.pos, i = e.posMax;
  for (; ; ) {
    if (++n >= i) return !1;
    const s = e.src.charCodeAt(n);
    if (s === 60) return !1;
    if (s === 62) break;
  }
  const o = e.src.slice(r + 1, n);
  if (u7.test(o)) {
    const s = e.md.normalizeLink(o);
    if (!e.md.validateLink(s))
      return !1;
    if (!t) {
      const a = e.push("link_open", "a", 1);
      a.attrs = [["href", s]], a.markup = "autolink", a.info = "auto";
      const l = e.push("text", "", 0);
      l.content = e.md.normalizeLinkText(o);
      const u = e.push("link_close", "a", -1);
      u.markup = "autolink", u.info = "auto";
    }
    return e.pos += o.length + 2, !0;
  }
  if (l7.test(o)) {
    const s = e.md.normalizeLink("mailto:" + o);
    if (!e.md.validateLink(s))
      return !1;
    if (!t) {
      const a = e.push("link_open", "a", 1);
      a.attrs = [["href", s]], a.markup = "autolink", a.info = "auto";
      const l = e.push("text", "", 0);
      l.content = e.md.normalizeLinkText(o);
      const u = e.push("link_close", "a", -1);
      u.markup = "autolink", u.info = "auto";
    }
    return e.pos += o.length + 2, !0;
  }
  return !1;
}
function f7(e) {
  return /^<a[>\s]/i.test(e);
}
function d7(e) {
  return /^<\/a\s*>/i.test(e);
}
function p7(e) {
  const t = e | 32;
  return t >= 97 && t <= 122;
}
function h7(e, t) {
  if (!e.md.options.html)
    return !1;
  const n = e.posMax, r = e.pos;
  if (e.src.charCodeAt(r) !== 60 || r + 2 >= n)
    return !1;
  const i = e.src.charCodeAt(r + 1);
  if (i !== 33 && i !== 63 && i !== 47 && !p7(i))
    return !1;
  const o = e.src.slice(r).match(V$);
  if (!o)
    return !1;
  if (!t) {
    const s = e.push("html_inline", "", 0);
    s.content = o[0], f7(s.content) && e.linkLevel++, d7(s.content) && e.linkLevel--;
  }
  return e.pos += o[0].length, !0;
}
const g7 = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i, m7 = /^&([a-z][a-z0-9]{1,31});/i;
function b7(e, t) {
  const n = e.pos, r = e.posMax;
  if (e.src.charCodeAt(n) !== 38 || n + 1 >= r) return !1;
  if (e.src.charCodeAt(n + 1) === 35) {
    const o = e.src.slice(n).match(g7);
    if (o) {
      if (!t) {
        const s = o[1][0].toLowerCase() === "x" ? parseInt(o[1].slice(1), 16) : parseInt(o[1], 10), a = e.push("text_special", "", 0);
        a.content = Ig(s) ? Kc(s) : Kc(65533), a.markup = o[0], a.info = "entity";
      }
      return e.pos += o[0].length, !0;
    }
  } else {
    const o = e.src.slice(n).match(m7);
    if (o) {
      const s = Iw(o[0]);
      if (s !== o[0]) {
        if (!t) {
          const a = e.push("text_special", "", 0);
          a.content = s, a.markup = o[0], a.info = "entity";
        }
        return e.pos += o[0].length, !0;
      }
    }
  }
  return !1;
}
function ry(e) {
  const t = {}, n = e.length;
  if (!n) return;
  let r = 0, i = -2;
  const o = [];
  for (let s = 0; s < n; s++) {
    const a = e[s];
    if (o.push(0), (e[r].marker !== a.marker || i !== a.token - 1) && (r = s), i = a.token, a.length = a.length || 0, !a.close) continue;
    t.hasOwnProperty(a.marker) || (t[a.marker] = [-1, -1, -1, -1, -1, -1]);
    const l = t[a.marker][(a.open ? 3 : 0) + a.length % 3];
    let u = r - o[r] - 1, c = u;
    for (; u > l; u -= o[u] + 1) {
      const f = e[u];
      if (f.marker === a.marker && f.open && f.end < 0) {
        let d = !1;
        if ((f.close || a.open) && (f.length + a.length) % 3 === 0 && (f.length % 3 !== 0 || a.length % 3 !== 0) && (d = !0), !d) {
          const p = u > 0 && !e[u - 1].open ? o[u - 1] + 1 : 0;
          o[s] = s - u + p, o[u] = p, a.open = !1, f.end = s, f.close = !1, c = -1, i = -2;
          break;
        }
      }
    }
    c !== -1 && (t[a.marker][(a.open ? 3 : 0) + (a.length || 0) % 3] = c);
  }
}
function y7(e) {
  const t = e.tokens_meta, n = e.tokens_meta.length;
  ry(e.delimiters);
  for (let r = 0; r < n; r++)
    t[r] && t[r].delimiters && ry(t[r].delimiters);
}
function v7(e) {
  let t, n, r = 0;
  const i = e.tokens, o = e.tokens.length;
  for (t = n = 0; t < o; t++)
    i[t].nesting < 0 && r--, i[t].level = r, i[t].nesting > 0 && r++, i[t].type === "text" && t + 1 < o && i[t + 1].type === "text" ? i[t + 1].content = i[t].content + i[t + 1].content : (t !== n && (i[n] = i[t]), n++);
  t !== n && (i.length = n);
}
const Cp = [
  ["text", Q$],
  ["linkify", X$],
  ["newline", J$],
  ["escape", e7],
  ["backticks", t7],
  ["strikethrough", Fw.tokenize],
  ["emphasis", jw.tokenize],
  ["link", s7],
  ["image", a7],
  ["autolink", c7],
  ["html_inline", h7],
  ["entity", b7]
], Np = [
  ["balance_pairs", y7],
  ["strikethrough", Fw.postProcess],
  ["emphasis", jw.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", v7]
];
function Jl() {
  this.ruler = new Nn();
  for (let e = 0; e < Cp.length; e++)
    this.ruler.push(Cp[e][0], Cp[e][1]);
  this.ruler2 = new Nn();
  for (let e = 0; e < Np.length; e++)
    this.ruler2.push(Np[e][0], Np[e][1]);
}
Jl.prototype.skipToken = function(e) {
  const t = e.pos, n = this.ruler.getRules(""), r = n.length, i = e.md.options.maxNesting, o = e.cache;
  if (typeof o[t] < "u") {
    e.pos = o[t];
    return;
  }
  let s = !1;
  if (e.level < i) {
    for (let a = 0; a < r; a++)
      if (e.level++, s = n[a](e, !0), e.level--, s) {
        if (t >= e.pos)
          throw new Error("inline rule didn't increment state.pos");
        break;
      }
  } else
    e.pos = e.posMax;
  s || e.pos++, o[t] = e.pos;
};
Jl.prototype.tokenize = function(e) {
  const t = this.ruler.getRules(""), n = t.length, r = e.posMax, i = e.md.options.maxNesting;
  for (; e.pos < r; ) {
    const o = e.pos;
    let s = !1;
    if (e.level < i) {
      for (let a = 0; a < n; a++)
        if (s = t[a](e, !1), s) {
          if (o >= e.pos)
            throw new Error("inline rule didn't increment state.pos");
          break;
        }
    }
    if (s) {
      if (e.pos >= r)
        break;
      continue;
    }
    e.pending += e.src[e.pos++];
  }
  e.pending && e.pushPending();
};
Jl.prototype.parse = function(e, t, n, r) {
  const i = new this.State(e, t, n, r);
  this.tokenize(i);
  const o = this.ruler2.getRules(""), s = o.length;
  for (let a = 0; a < s; a++)
    o[a](i);
};
Jl.prototype.State = Xl;
function _7(e) {
  const t = {};
  e = e || {}, t.src_Any = Sw.source, t.src_Cc = Cw.source, t.src_Z = Dw.source, t.src_P = Dg.source, t.src_ZPCc = [t.src_Z, t.src_P, t.src_Cc].join("|"), t.src_ZCc = [t.src_Z, t.src_Cc].join("|");
  const n = "[><]";
  return t.src_pseudo_letter = "(?:(?!" + n + "|" + t.src_ZPCc + ")" + t.src_Any + ")", t.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", t.src_auth = "(?:(?:(?!" + t.src_ZCc + "|[@/\\[\\]()]).)+@)?", t.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", t.src_host_terminator = "(?=$|" + n + "|" + t.src_ZPCc + ")(?!" + (e["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + t.src_ZPCc + "))", t.src_path = "(?:[/?#](?:(?!" + t.src_ZCc + "|" + n + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + t.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + t.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + t.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + t.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + t.src_ZCc + "|[']).)+\\'|\\'(?=" + t.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + t.src_ZCc + "|[.]|$)|" + (e["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + // allow `,,,` in paths
  ",(?!" + t.src_ZCc + "|$)|;(?!" + t.src_ZCc + "|$)|\\!+(?!" + t.src_ZCc + "|[!]|$)|\\?(?!" + t.src_ZCc + "|[?]|$))+|\\/)?", t.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', t.src_xn = "xn--[a-z0-9\\-]{1,59}", t.src_domain_root = // Allow letters & digits (http://test1)
  "(?:" + t.src_xn + "|" + t.src_pseudo_letter + "{1,63})", t.src_domain = "(?:" + t.src_xn + "|(?:" + t.src_pseudo_letter + ")|(?:" + t.src_pseudo_letter + "(?:-|" + t.src_pseudo_letter + "){0,61}" + t.src_pseudo_letter + "))", t.src_host = "(?:(?:(?:(?:" + t.src_domain + ")\\.)*" + t.src_domain + "))", t.tpl_host_fuzzy = "(?:" + t.src_ip4 + "|(?:(?:(?:" + t.src_domain + ")\\.)+(?:%TLDS%)))", t.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + t.src_domain + ")\\.)+(?:%TLDS%))", t.src_host_strict = t.src_host + t.src_host_terminator, t.tpl_host_fuzzy_strict = t.tpl_host_fuzzy + t.src_host_terminator, t.src_host_port_strict = t.src_host + t.src_port + t.src_host_terminator, t.tpl_host_port_fuzzy_strict = t.tpl_host_fuzzy + t.src_port + t.src_host_terminator, t.tpl_host_port_no_ip_fuzzy_strict = t.tpl_host_no_ip_fuzzy + t.src_port + t.src_host_terminator, t.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + t.src_ZPCc + "|>|$))", t.tpl_email_fuzzy = "(^|" + n + '|"|\\(|' + t.src_ZCc + ")(" + t.src_email_name + "@" + t.tpl_host_fuzzy_strict + ")", t.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + t.src_ZPCc + "))((?![$+<=>^`|])" + t.tpl_host_port_fuzzy_strict + t.src_path + ")", t.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + t.src_ZPCc + "))((?![$+<=>^`|])" + t.tpl_host_port_no_ip_fuzzy_strict + t.src_path + ")", t;
}
function Hh(e) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(n) {
    n && Object.keys(n).forEach(function(r) {
      e[r] = n[r];
    });
  }), e;
}
function Ed(e) {
  return Object.prototype.toString.call(e);
}
function E7(e) {
  return Ed(e) === "[object String]";
}
function w7(e) {
  return Ed(e) === "[object Object]";
}
function x7(e) {
  return Ed(e) === "[object RegExp]";
}
function iy(e) {
  return Ed(e) === "[object Function]";
}
function k7(e) {
  return e.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
const Uw = {
  fuzzyLink: !0,
  fuzzyEmail: !0,
  fuzzyIP: !1
};
function M7(e) {
  return Object.keys(e || {}).reduce(function(t, n) {
    return t || Uw.hasOwnProperty(n);
  }, !1);
}
const A7 = {
  "http:": {
    validate: function(e, t, n) {
      const r = e.slice(t);
      return n.re.http || (n.re.http = new RegExp(
        "^\\/\\/" + n.re.src_auth + n.re.src_host_port_strict + n.re.src_path,
        "i"
      )), n.re.http.test(r) ? r.match(n.re.http)[0].length : 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(e, t, n) {
      const r = e.slice(t);
      return n.re.no_http || (n.re.no_http = new RegExp(
        "^" + n.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        "(?:localhost|(?:(?:" + n.re.src_domain + ")\\.)+" + n.re.src_domain_root + ")" + n.re.src_port + n.re.src_host_terminator + n.re.src_path,
        "i"
      )), n.re.no_http.test(r) ? t >= 3 && e[t - 3] === ":" || t >= 3 && e[t - 3] === "/" ? 0 : r.match(n.re.no_http)[0].length : 0;
    }
  },
  "mailto:": {
    validate: function(e, t, n) {
      const r = e.slice(t);
      return n.re.mailto || (n.re.mailto = new RegExp(
        "^" + n.re.src_email_name + "@" + n.re.src_host_strict,
        "i"
      )), n.re.mailto.test(r) ? r.match(n.re.mailto)[0].length : 0;
    }
  }
}, T7 = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]", S7 = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|".split("|");
function C7(e) {
  e.__index__ = -1, e.__text_cache__ = "";
}
function N7(e) {
  return function(t, n) {
    const r = t.slice(n);
    return e.test(r) ? r.match(e)[0].length : 0;
  };
}
function oy() {
  return function(e, t) {
    t.normalize(e);
  };
}
function Yc(e) {
  const t = e.re = _7(e.__opts__), n = e.__tlds__.slice();
  e.onCompile(), e.__tlds_replaced__ || n.push(T7), n.push(t.src_xn), t.src_tlds = n.join("|");
  function r(a) {
    return a.replace("%TLDS%", t.src_tlds);
  }
  t.email_fuzzy = RegExp(r(t.tpl_email_fuzzy), "i"), t.link_fuzzy = RegExp(r(t.tpl_link_fuzzy), "i"), t.link_no_ip_fuzzy = RegExp(r(t.tpl_link_no_ip_fuzzy), "i"), t.host_fuzzy_test = RegExp(r(t.tpl_host_fuzzy_test), "i");
  const i = [];
  e.__compiled__ = {};
  function o(a, l) {
    throw new Error('(LinkifyIt) Invalid schema "' + a + '": ' + l);
  }
  Object.keys(e.__schemas__).forEach(function(a) {
    const l = e.__schemas__[a];
    if (l === null)
      return;
    const u = { validate: null, link: null };
    if (e.__compiled__[a] = u, w7(l)) {
      x7(l.validate) ? u.validate = N7(l.validate) : iy(l.validate) ? u.validate = l.validate : o(a, l), iy(l.normalize) ? u.normalize = l.normalize : l.normalize ? o(a, l) : u.normalize = oy();
      return;
    }
    if (E7(l)) {
      i.push(a);
      return;
    }
    o(a, l);
  }), i.forEach(function(a) {
    e.__compiled__[e.__schemas__[a]] && (e.__compiled__[a].validate = e.__compiled__[e.__schemas__[a]].validate, e.__compiled__[a].normalize = e.__compiled__[e.__schemas__[a]].normalize);
  }), e.__compiled__[""] = { validate: null, normalize: oy() };
  const s = Object.keys(e.__compiled__).filter(function(a) {
    return a.length > 0 && e.__compiled__[a];
  }).map(k7).join("|");
  e.re.schema_test = RegExp("(^|(?!_)(?:[><]|" + t.src_ZPCc + "))(" + s + ")", "i"), e.re.schema_search = RegExp("(^|(?!_)(?:[><]|" + t.src_ZPCc + "))(" + s + ")", "ig"), e.re.schema_at_start = RegExp("^" + e.re.schema_search.source, "i"), e.re.pretest = RegExp(
    "(" + e.re.schema_test.source + ")|(" + e.re.host_fuzzy_test.source + ")|@",
    "i"
  ), C7(e);
}
function D7(e, t) {
  const n = e.__index__, r = e.__last_index__, i = e.__text_cache__.slice(n, r);
  this.schema = e.__schema__.toLowerCase(), this.index = n + t, this.lastIndex = r + t, this.raw = i, this.text = i, this.url = i;
}
function qh(e, t) {
  const n = new D7(e, t);
  return e.__compiled__[n.schema].normalize(n, e), n;
}
function Vn(e, t) {
  if (!(this instanceof Vn))
    return new Vn(e, t);
  t || M7(e) && (t = e, e = {}), this.__opts__ = Hh({}, Uw, t), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = Hh({}, A7, e), this.__compiled__ = {}, this.__tlds__ = S7, this.__tlds_replaced__ = !1, this.re = {}, Yc(this);
}
Vn.prototype.add = function(t, n) {
  return this.__schemas__[t] = n, Yc(this), this;
};
Vn.prototype.set = function(t) {
  return this.__opts__ = Hh(this.__opts__, t), this;
};
Vn.prototype.test = function(t) {
  if (this.__text_cache__ = t, this.__index__ = -1, !t.length)
    return !1;
  let n, r, i, o, s, a, l, u, c;
  if (this.re.schema_test.test(t)) {
    for (l = this.re.schema_search, l.lastIndex = 0; (n = l.exec(t)) !== null; )
      if (o = this.testSchemaAt(t, n[2], l.lastIndex), o) {
        this.__schema__ = n[2], this.__index__ = n.index + n[1].length, this.__last_index__ = n.index + n[0].length + o;
        break;
      }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (u = t.search(this.re.host_fuzzy_test), u >= 0 && (this.__index__ < 0 || u < this.__index__) && (r = t.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (s = r.index + r[1].length, (this.__index__ < 0 || s < this.__index__) && (this.__schema__ = "", this.__index__ = s, this.__last_index__ = r.index + r[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (c = t.indexOf("@"), c >= 0 && (i = t.match(this.re.email_fuzzy)) !== null && (s = i.index + i[1].length, a = i.index + i[0].length, (this.__index__ < 0 || s < this.__index__ || s === this.__index__ && a > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = s, this.__last_index__ = a))), this.__index__ >= 0;
};
Vn.prototype.pretest = function(t) {
  return this.re.pretest.test(t);
};
Vn.prototype.testSchemaAt = function(t, n, r) {
  return this.__compiled__[n.toLowerCase()] ? this.__compiled__[n.toLowerCase()].validate(t, r, this) : 0;
};
Vn.prototype.match = function(t) {
  const n = [];
  let r = 0;
  this.__index__ >= 0 && this.__text_cache__ === t && (n.push(qh(this, r)), r = this.__last_index__);
  let i = r ? t.slice(r) : t;
  for (; this.test(i); )
    n.push(qh(this, r)), i = i.slice(this.__last_index__), r += this.__last_index__;
  return n.length ? n : null;
};
Vn.prototype.matchAtStart = function(t) {
  if (this.__text_cache__ = t, this.__index__ = -1, !t.length) return null;
  const n = this.re.schema_at_start.exec(t);
  if (!n) return null;
  const r = this.testSchemaAt(t, n[2], n[0].length);
  return r ? (this.__schema__ = n[2], this.__index__ = n.index + n[1].length, this.__last_index__ = n.index + n[0].length + r, qh(this, 0)) : null;
};
Vn.prototype.tlds = function(t, n) {
  return t = Array.isArray(t) ? t : [t], n ? (this.__tlds__ = this.__tlds__.concat(t).sort().filter(function(r, i, o) {
    return r !== o[i - 1];
  }).reverse(), Yc(this), this) : (this.__tlds__ = t.slice(), this.__tlds_replaced__ = !0, Yc(this), this);
};
Vn.prototype.normalize = function(t) {
  t.schema || (t.url = "http://" + t.url), t.schema === "mailto:" && !/^mailto:/i.test(t.url) && (t.url = "mailto:" + t.url);
};
Vn.prototype.onCompile = function() {
};
const hs = 2147483647, Or = 36, Bg = 1, bl = 26, O7 = 38, I7 = 700, Vw = 72, Hw = 128, qw = "-", R7 = /^xn--/, L7 = /[^\0-\x7F]/, B7 = /[\x2E\u3002\uFF0E\uFF61]/g, P7 = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
}, Dp = Or - Bg, Ir = Math.floor, Op = String.fromCharCode;
function Ei(e) {
  throw new RangeError(P7[e]);
}
function $7(e, t) {
  const n = [];
  let r = e.length;
  for (; r--; )
    n[r] = t(e[r]);
  return n;
}
function Gw(e, t) {
  const n = e.split("@");
  let r = "";
  n.length > 1 && (r = n[0] + "@", e = n[1]), e = e.replace(B7, ".");
  const i = e.split("."), o = $7(i, t).join(".");
  return r + o;
}
function Ww(e) {
  const t = [];
  let n = 0;
  const r = e.length;
  for (; n < r; ) {
    const i = e.charCodeAt(n++);
    if (i >= 55296 && i <= 56319 && n < r) {
      const o = e.charCodeAt(n++);
      (o & 64512) == 56320 ? t.push(((i & 1023) << 10) + (o & 1023) + 65536) : (t.push(i), n--);
    } else
      t.push(i);
  }
  return t;
}
const z7 = (e) => String.fromCodePoint(...e), F7 = function(e) {
  return e >= 48 && e < 58 ? 26 + (e - 48) : e >= 65 && e < 91 ? e - 65 : e >= 97 && e < 123 ? e - 97 : Or;
}, sy = function(e, t) {
  return e + 22 + 75 * (e < 26) - ((t != 0) << 5);
}, Kw = function(e, t, n) {
  let r = 0;
  for (e = n ? Ir(e / I7) : e >> 1, e += Ir(e / t); e > Dp * bl >> 1; r += Or)
    e = Ir(e / Dp);
  return Ir(r + (Dp + 1) * e / (e + O7));
}, Yw = function(e) {
  const t = [], n = e.length;
  let r = 0, i = Hw, o = Vw, s = e.lastIndexOf(qw);
  s < 0 && (s = 0);
  for (let a = 0; a < s; ++a)
    e.charCodeAt(a) >= 128 && Ei("not-basic"), t.push(e.charCodeAt(a));
  for (let a = s > 0 ? s + 1 : 0; a < n; ) {
    const l = r;
    for (let c = 1, f = Or; ; f += Or) {
      a >= n && Ei("invalid-input");
      const d = F7(e.charCodeAt(a++));
      d >= Or && Ei("invalid-input"), d > Ir((hs - r) / c) && Ei("overflow"), r += d * c;
      const p = f <= o ? Bg : f >= o + bl ? bl : f - o;
      if (d < p)
        break;
      const h = Or - p;
      c > Ir(hs / h) && Ei("overflow"), c *= h;
    }
    const u = t.length + 1;
    o = Kw(r - l, u, l == 0), Ir(r / u) > hs - i && Ei("overflow"), i += Ir(r / u), r %= u, t.splice(r++, 0, i);
  }
  return String.fromCodePoint(...t);
}, Qw = function(e) {
  const t = [];
  e = Ww(e);
  const n = e.length;
  let r = Hw, i = 0, o = Vw;
  for (const l of e)
    l < 128 && t.push(Op(l));
  const s = t.length;
  let a = s;
  for (s && t.push(qw); a < n; ) {
    let l = hs;
    for (const c of e)
      c >= r && c < l && (l = c);
    const u = a + 1;
    l - r > Ir((hs - i) / u) && Ei("overflow"), i += (l - r) * u, r = l;
    for (const c of e)
      if (c < r && ++i > hs && Ei("overflow"), c === r) {
        let f = i;
        for (let d = Or; ; d += Or) {
          const p = d <= o ? Bg : d >= o + bl ? bl : d - o;
          if (f < p)
            break;
          const h = f - p, m = Or - p;
          t.push(
            Op(sy(p + h % m, 0))
          ), f = Ir(h / m);
        }
        t.push(Op(sy(f, 0))), o = Kw(i, u, a === s), i = 0, ++a;
      }
    ++i, ++r;
  }
  return t.join("");
}, j7 = function(e) {
  return Gw(e, function(t) {
    return R7.test(t) ? Yw(t.slice(4).toLowerCase()) : t;
  });
}, U7 = function(e) {
  return Gw(e, function(t) {
    return L7.test(t) ? "xn--" + Qw(t) : t;
  });
}, Zw = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  version: "2.3.1",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  ucs2: {
    decode: Ww,
    encode: z7
  },
  decode: Yw,
  encode: Qw,
  toASCII: U7,
  toUnicode: j7
}, V7 = {
  options: {
    // Enable HTML tags in source
    html: !1,
    // Use '/' to close single tags (<br />)
    xhtmlOut: !1,
    // Convert '\n' in paragraphs into <br>
    breaks: !1,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: !1,
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: "",
    /*  */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
}, H7 = {
  options: {
    // Enable HTML tags in source
    html: !1,
    // Use '/' to close single tags (<br />)
    xhtmlOut: !1,
    // Convert '\n' in paragraphs into <br>
    breaks: !1,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: !1,
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: "",
    /*  */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
}, q7 = {
  options: {
    // Enable HTML tags in source
    html: !0,
    // Use '/' to close single tags (<br />)
    xhtmlOut: !0,
    // Convert '\n' in paragraphs into <br>
    breaks: !1,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: !1,
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: "",
    /*  */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
}, G7 = {
  default: V7,
  zero: H7,
  commonmark: q7
}, W7 = /^(vbscript|javascript|file|data):/, K7 = /^data:image\/(gif|png|jpeg|webp);/;
function Y7(e) {
  const t = e.trim().toLowerCase();
  return W7.test(t) ? K7.test(t) : !0;
}
const Xw = ["http:", "https:", "mailto:"];
function Q7(e) {
  const t = Ng(e, !0);
  if (t.hostname && (!t.protocol || Xw.indexOf(t.protocol) >= 0))
    try {
      t.hostname = Zw.toASCII(t.hostname);
    } catch {
    }
  return Zl(Cg(t));
}
function Z7(e) {
  const t = Ng(e, !0);
  if (t.hostname && (!t.protocol || Xw.indexOf(t.protocol) >= 0))
    try {
      t.hostname = Zw.toUnicode(t.hostname);
    } catch {
    }
  return $s(Cg(t), $s.defaultChars + "%");
}
function Dn(e, t) {
  if (!(this instanceof Dn))
    return new Dn(e, t);
  t || Og(e) || (t = e || {}, e = "default"), this.inline = new Jl(), this.block = new _d(), this.core = new Rg(), this.renderer = new ra(), this.linkify = new Vn(), this.validateLink = Y7, this.normalizeLink = Q7, this.normalizeLinkText = Z7, this.utils = JP, this.helpers = yd({}, r$), this.options = {}, this.configure(e), t && this.set(t);
}
Dn.prototype.set = function(e) {
  return yd(this.options, e), this;
};
Dn.prototype.configure = function(e) {
  const t = this;
  if (Og(e)) {
    const n = e;
    if (e = G7[n], !e)
      throw new Error('Wrong `markdown-it` preset "' + n + '", check name');
  }
  if (!e)
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  return e.options && t.set(e.options), e.components && Object.keys(e.components).forEach(function(n) {
    e.components[n].rules && t[n].ruler.enableOnly(e.components[n].rules), e.components[n].rules2 && t[n].ruler2.enableOnly(e.components[n].rules2);
  }), this;
};
Dn.prototype.enable = function(e, t) {
  let n = [];
  Array.isArray(e) || (e = [e]), ["core", "block", "inline"].forEach(function(i) {
    n = n.concat(this[i].ruler.enable(e, !0));
  }, this), n = n.concat(this.inline.ruler2.enable(e, !0));
  const r = e.filter(function(i) {
    return n.indexOf(i) < 0;
  });
  if (r.length && !t)
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + r);
  return this;
};
Dn.prototype.disable = function(e, t) {
  let n = [];
  Array.isArray(e) || (e = [e]), ["core", "block", "inline"].forEach(function(i) {
    n = n.concat(this[i].ruler.disable(e, !0));
  }, this), n = n.concat(this.inline.ruler2.disable(e, !0));
  const r = e.filter(function(i) {
    return n.indexOf(i) < 0;
  });
  if (r.length && !t)
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + r);
  return this;
};
Dn.prototype.use = function(e) {
  const t = [this].concat(Array.prototype.slice.call(arguments, 1));
  return e.apply(e, t), this;
};
Dn.prototype.parse = function(e, t) {
  if (typeof e != "string")
    throw new Error("Input data should be a String");
  const n = new this.core.State(e, this, t);
  return this.core.process(n), n.tokens;
};
Dn.prototype.render = function(e, t) {
  return t = t || {}, this.renderer.render(this.parse(e, t), this.options, t);
};
Dn.prototype.parseInline = function(e, t) {
  const n = new this.core.State(e, this, t);
  return n.inlineMode = !0, this.core.process(n), n.tokens;
};
Dn.prototype.renderInline = function(e, t) {
  return t = t || {}, this.renderer.render(this.parseInline(e, t), this.options, t);
};
const X7 = new V0({
  nodes: {
    doc: {
      content: "block+"
    },
    paragraph: {
      content: "inline*",
      group: "block",
      parseDOM: [{ tag: "p" }],
      toDOM() {
        return ["p", 0];
      }
    },
    blockquote: {
      content: "block+",
      group: "block",
      parseDOM: [{ tag: "blockquote" }],
      toDOM() {
        return ["blockquote", 0];
      }
    },
    horizontal_rule: {
      group: "block",
      parseDOM: [{ tag: "hr" }],
      toDOM() {
        return ["div", ["hr"]];
      }
    },
    heading: {
      attrs: { level: { default: 1 } },
      content: "(text | image)*",
      group: "block",
      defining: !0,
      parseDOM: [
        { tag: "h1", attrs: { level: 1 } },
        { tag: "h2", attrs: { level: 2 } },
        { tag: "h3", attrs: { level: 3 } },
        { tag: "h4", attrs: { level: 4 } },
        { tag: "h5", attrs: { level: 5 } },
        { tag: "h6", attrs: { level: 6 } }
      ],
      toDOM(e) {
        return ["h" + e.attrs.level, 0];
      }
    },
    code_block: {
      content: "text*",
      group: "block",
      code: !0,
      defining: !0,
      marks: "",
      attrs: { params: { default: "" } },
      parseDOM: [{ tag: "pre", preserveWhitespace: "full", getAttrs: (e) => ({ params: e.getAttribute("data-params") || "" }) }],
      toDOM(e) {
        return ["pre", e.attrs.params ? { "data-params": e.attrs.params } : {}, ["code", 0]];
      }
    },
    ordered_list: {
      content: "list_item+",
      group: "block",
      attrs: { order: { default: 1 }, tight: { default: !1 } },
      parseDOM: [{ tag: "ol", getAttrs(e) {
        return {
          order: e.hasAttribute("start") ? +e.getAttribute("start") : 1,
          tight: e.hasAttribute("data-tight")
        };
      } }],
      toDOM(e) {
        return ["ol", {
          start: e.attrs.order == 1 ? null : e.attrs.order,
          "data-tight": e.attrs.tight ? "true" : null
        }, 0];
      }
    },
    bullet_list: {
      content: "list_item+",
      group: "block",
      attrs: { tight: { default: !1 } },
      parseDOM: [{ tag: "ul", getAttrs: (e) => ({ tight: e.hasAttribute("data-tight") }) }],
      toDOM(e) {
        return ["ul", { "data-tight": e.attrs.tight ? "true" : null }, 0];
      }
    },
    list_item: {
      content: "block+",
      defining: !0,
      parseDOM: [{ tag: "li" }],
      toDOM() {
        return ["li", 0];
      }
    },
    text: {
      group: "inline"
    },
    image: {
      inline: !0,
      attrs: {
        src: {},
        alt: { default: null },
        title: { default: null }
      },
      group: "inline",
      draggable: !0,
      parseDOM: [{ tag: "img[src]", getAttrs(e) {
        return {
          src: e.getAttribute("src"),
          title: e.getAttribute("title"),
          alt: e.getAttribute("alt")
        };
      } }],
      toDOM(e) {
        return ["img", e.attrs];
      }
    },
    hard_break: {
      inline: !0,
      group: "inline",
      selectable: !1,
      parseDOM: [{ tag: "br" }],
      toDOM() {
        return ["br"];
      }
    }
  },
  marks: {
    em: {
      parseDOM: [
        { tag: "i" },
        { tag: "em" },
        { style: "font-style=italic" },
        { style: "font-style=normal", clearMark: (e) => e.type.name == "em" }
      ],
      toDOM() {
        return ["em"];
      }
    },
    strong: {
      parseDOM: [
        { tag: "strong" },
        { tag: "b", getAttrs: (e) => e.style.fontWeight != "normal" && null },
        { style: "font-weight=400", clearMark: (e) => e.type.name == "strong" },
        { style: "font-weight", getAttrs: (e) => /^(bold(er)?|[5-9]\d{2,})$/.test(e) && null }
      ],
      toDOM() {
        return ["strong"];
      }
    },
    link: {
      attrs: {
        href: {},
        title: { default: null }
      },
      inclusive: !1,
      parseDOM: [{ tag: "a[href]", getAttrs(e) {
        return { href: e.getAttribute("href"), title: e.getAttribute("title") };
      } }],
      toDOM(e) {
        return ["a", e.attrs];
      }
    },
    code: {
      parseDOM: [{ tag: "code" }],
      toDOM() {
        return ["code"];
      }
    }
  }
});
function J7(e, t) {
  if (e.isText && t.isText && rt.sameSet(e.marks, t.marks))
    return e.withText(e.text + t.text);
}
class ez {
  constructor(t, n) {
    this.schema = t, this.tokenHandlers = n, this.stack = [{ type: t.topNodeType, attrs: null, content: [], marks: rt.none }];
  }
  top() {
    return this.stack[this.stack.length - 1];
  }
  push(t) {
    this.stack.length && this.top().content.push(t);
  }
  // Adds the given text to the current position in the document,
  // using the current marks as styling.
  addText(t) {
    if (!t)
      return;
    let n = this.top(), r = n.content, i = r[r.length - 1], o = this.schema.text(t, n.marks), s;
    i && (s = J7(i, o)) ? r[r.length - 1] = s : r.push(o);
  }
  // Adds the given mark to the set of active marks.
  openMark(t) {
    let n = this.top();
    n.marks = t.addToSet(n.marks);
  }
  // Removes the given mark from the set of active marks.
  closeMark(t) {
    let n = this.top();
    n.marks = t.removeFromSet(n.marks);
  }
  parseTokens(t) {
    for (let n = 0; n < t.length; n++) {
      let r = t[n], i = this.tokenHandlers[r.type];
      if (!i)
        throw new Error("Token type `" + r.type + "` not supported by Markdown parser");
      i(this, r, t, n);
    }
  }
  // Add a node at the current position.
  addNode(t, n, r) {
    let i = this.top(), o = t.createAndFill(n, r, i ? i.marks : []);
    return o ? (this.push(o), o) : null;
  }
  // Wrap subsequent content in a node of the given type.
  openNode(t, n) {
    this.stack.push({ type: t, attrs: n, content: [], marks: rt.none });
  }
  // Close and return the node that is currently on top of the stack.
  closeNode() {
    let t = this.stack.pop();
    return this.addNode(t.type, t.attrs, t.content);
  }
}
function fa(e, t, n, r) {
  return e.getAttrs ? e.getAttrs(t, n, r) : e.attrs instanceof Function ? e.attrs(t) : e.attrs;
}
function Ip(e, t) {
  return e.noCloseToken || t == "code_inline" || t == "code_block" || t == "fence";
}
function ay(e) {
  return e[e.length - 1] == `
` ? e.slice(0, e.length - 1) : e;
}
function Rp() {
}
function tz(e, t) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let r in t) {
    let i = t[r];
    if (i.block) {
      let o = e.nodeType(i.block);
      Ip(i, r) ? n[r] = (s, a, l, u) => {
        s.openNode(o, fa(i, a, l, u)), s.addText(ay(a.content)), s.closeNode();
      } : (n[r + "_open"] = (s, a, l, u) => s.openNode(o, fa(i, a, l, u)), n[r + "_close"] = (s) => s.closeNode());
    } else if (i.node) {
      let o = e.nodeType(i.node);
      n[r] = (s, a, l, u) => s.addNode(o, fa(i, a, l, u));
    } else if (i.mark) {
      let o = e.marks[i.mark];
      Ip(i, r) ? n[r] = (s, a, l, u) => {
        s.openMark(o.create(fa(i, a, l, u))), s.addText(ay(a.content)), s.closeMark(o);
      } : (n[r + "_open"] = (s, a, l, u) => s.openMark(o.create(fa(i, a, l, u))), n[r + "_close"] = (s) => s.closeMark(o));
    } else if (i.ignore)
      Ip(i, r) ? n[r] = Rp : (n[r + "_open"] = Rp, n[r + "_close"] = Rp);
    else
      throw new RangeError("Unrecognized parsing spec " + JSON.stringify(i));
  }
  return n.text = (r, i) => r.addText(i.content), n.inline = (r, i) => r.parseTokens(i.children), n.softbreak = n.softbreak || ((r) => r.addText(" ")), n;
}
let nz = class {
  /**
  Create a parser with the given configuration. You can configure
  the markdown-it parser to parse the dialect you want, and provide
  a description of the ProseMirror entities those tokens map to in
  the `tokens` object, which maps token names to descriptions of
  what to do with them. Such a description is an object, and may
  have the following properties:
  */
  constructor(t, n, r) {
    this.schema = t, this.tokenizer = n, this.tokens = r, this.tokenHandlers = tz(t, r);
  }
  /**
  Parse a string as [CommonMark](http://commonmark.org/) markup,
  and create a ProseMirror document as prescribed by this parser's
  rules.
  
  The second argument, when given, is passed through to the
  [Markdown
  parser](https://markdown-it.github.io/markdown-it/#MarkdownIt.parse).
  */
  parse(t, n = {}) {
    let r = new ez(this.schema, this.tokenHandlers), i;
    r.parseTokens(this.tokenizer.parse(t, n));
    do
      i = r.closeNode();
    while (r.stack.length);
    return i || this.schema.topNodeType.createAndFill();
  }
};
function ly(e, t) {
  for (; ++t < e.length; )
    if (e[t].type != "list_item_open")
      return e[t].hidden;
  return !1;
}
new nz(X7, Dn("commonmark", { html: !1 }), {
  blockquote: { block: "blockquote" },
  paragraph: { block: "paragraph" },
  list_item: { block: "list_item" },
  bullet_list: { block: "bullet_list", getAttrs: (e, t, n) => ({ tight: ly(t, n) }) },
  ordered_list: { block: "ordered_list", getAttrs: (e, t, n) => ({
    order: +e.attrGet("start") || 1,
    tight: ly(t, n)
  }) },
  heading: { block: "heading", getAttrs: (e) => ({ level: +e.tag.slice(1) }) },
  code_block: { block: "code_block", noCloseToken: !0 },
  fence: { block: "code_block", getAttrs: (e) => ({ params: e.info || "" }), noCloseToken: !0 },
  hr: { node: "horizontal_rule" },
  image: { node: "image", getAttrs: (e) => ({
    src: e.attrGet("src"),
    title: e.attrGet("title") || null,
    alt: e.children[0] && e.children[0].content || null
  }) },
  hardbreak: { node: "hard_break" },
  em: { mark: "em" },
  strong: { mark: "strong" },
  link: { mark: "link", getAttrs: (e) => ({
    href: e.attrGet("href"),
    title: e.attrGet("title") || null
  }) },
  code_inline: { mark: "code", noCloseToken: !0 }
});
const rz = { open: "", close: "", mixable: !0 };
let iz = class {
  /**
  Construct a serializer with the given configuration. The `nodes`
  object should map node names in a given schema to function that
  take a serializer state and such a node, and serialize the node.
  */
  constructor(t, n, r = {}) {
    this.nodes = t, this.marks = n, this.options = r;
  }
  /**
  Serialize the content of the given node to
  [CommonMark](http://commonmark.org/).
  */
  serialize(t, n = {}) {
    n = Object.assign({}, this.options, n);
    let r = new Jw(this.nodes, this.marks, n);
    return r.renderContent(t), r.out;
  }
};
const Zr = new iz({
  blockquote(e, t) {
    e.wrapBlock("> ", null, t, () => e.renderContent(t));
  },
  code_block(e, t) {
    const n = t.textContent.match(/`{3,}/gm), r = n ? n.sort().slice(-1)[0] + "`" : "```";
    e.write(r + (t.attrs.params || "") + `
`), e.text(t.textContent, !1), e.write(`
`), e.write(r), e.closeBlock(t);
  },
  heading(e, t) {
    e.write(e.repeat("#", t.attrs.level) + " "), e.renderInline(t, !1), e.closeBlock(t);
  },
  horizontal_rule(e, t) {
    e.write(t.attrs.markup || "---"), e.closeBlock(t);
  },
  bullet_list(e, t) {
    e.renderList(t, "  ", () => (t.attrs.bullet || "*") + " ");
  },
  ordered_list(e, t) {
    let n = t.attrs.order || 1, r = String(n + t.childCount - 1).length, i = e.repeat(" ", r + 2);
    e.renderList(t, i, (o) => {
      let s = String(n + o);
      return e.repeat(" ", r - s.length) + s + ". ";
    });
  },
  list_item(e, t) {
    e.renderContent(t);
  },
  paragraph(e, t) {
    e.renderInline(t), e.closeBlock(t);
  },
  image(e, t) {
    e.write("![" + e.esc(t.attrs.alt || "") + "](" + t.attrs.src.replace(/[\(\)]/g, "\\$&") + (t.attrs.title ? ' "' + t.attrs.title.replace(/"/g, '\\"') + '"' : "") + ")");
  },
  hard_break(e, t, n, r) {
    for (let i = r + 1; i < n.childCount; i++)
      if (n.child(i).type != t.type) {
        e.write(`\\
`);
        return;
      }
  },
  text(e, t) {
    e.text(t.text, !e.inAutolink);
  }
}, {
  em: { open: "*", close: "*", mixable: !0, expelEnclosingWhitespace: !0 },
  strong: { open: "**", close: "**", mixable: !0, expelEnclosingWhitespace: !0 },
  link: {
    open(e, t, n, r) {
      return e.inAutolink = oz(t, n, r), e.inAutolink ? "<" : "[";
    },
    close(e, t, n, r) {
      let { inAutolink: i } = e;
      return e.inAutolink = void 0, i ? ">" : "](" + t.attrs.href.replace(/[\(\)"]/g, "\\$&") + (t.attrs.title ? ` "${t.attrs.title.replace(/"/g, '\\"')}"` : "") + ")";
    },
    mixable: !0
  },
  code: {
    open(e, t, n, r) {
      return uy(n.child(r), -1);
    },
    close(e, t, n, r) {
      return uy(n.child(r - 1), 1);
    },
    escape: !1
  }
});
function uy(e, t) {
  let n = /`+/g, r, i = 0;
  if (e.isText)
    for (; r = n.exec(e.text); )
      i = Math.max(i, r[0].length);
  let o = i > 0 && t > 0 ? " `" : "`";
  for (let s = 0; s < i; s++)
    o += "`";
  return i > 0 && t < 0 && (o += " "), o;
}
function oz(e, t, n) {
  if (e.attrs.title || !/^\w+:/.test(e.attrs.href))
    return !1;
  let r = t.child(n);
  return !r.isText || r.text != e.attrs.href || r.marks[r.marks.length - 1] != e ? !1 : n == t.childCount - 1 || !e.isInSet(t.child(n + 1).marks);
}
let Jw = class {
  /**
  @internal
  */
  constructor(t, n, r) {
    this.nodes = t, this.marks = n, this.options = r, this.delim = "", this.out = "", this.closed = null, this.inAutolink = void 0, this.atBlockStart = !1, this.inTightList = !1, typeof this.options.tightLists > "u" && (this.options.tightLists = !1), typeof this.options.hardBreakNodeName > "u" && (this.options.hardBreakNodeName = "hard_break");
  }
  /**
  @internal
  */
  flushClose(t = 2) {
    if (this.closed) {
      if (this.atBlank() || (this.out += `
`), t > 1) {
        let n = this.delim, r = /\s+$/.exec(n);
        r && (n = n.slice(0, n.length - r[0].length));
        for (let i = 1; i < t; i++)
          this.out += n + `
`;
      }
      this.closed = null;
    }
  }
  /**
  @internal
  */
  getMark(t) {
    let n = this.marks[t];
    if (!n) {
      if (this.options.strict !== !1)
        throw new Error(`Mark type \`${t}\` not supported by Markdown renderer`);
      n = rz;
    }
    return n;
  }
  /**
  Render a block, prefixing each line with `delim`, and the first
  line in `firstDelim`. `node` should be the node that is closed at
  the end of the block, and `f` is a function that renders the
  content of the block.
  */
  wrapBlock(t, n, r, i) {
    let o = this.delim;
    this.write(n ?? t), this.delim += t, i(), this.delim = o, this.closeBlock(r);
  }
  /**
  @internal
  */
  atBlank() {
    return /(^|\n)$/.test(this.out);
  }
  /**
  Ensure the current content ends with a newline.
  */
  ensureNewLine() {
    this.atBlank() || (this.out += `
`);
  }
  /**
  Prepare the state for writing output (closing closed paragraphs,
  adding delimiters, and so on), and then optionally add content
  (unescaped) to the output.
  */
  write(t) {
    this.flushClose(), this.delim && this.atBlank() && (this.out += this.delim), t && (this.out += t);
  }
  /**
  Close the block for the given node.
  */
  closeBlock(t) {
    this.closed = t;
  }
  /**
  Add the given text to the document. When escape is not `false`,
  it will be escaped.
  */
  text(t, n = !0) {
    let r = t.split(`
`);
    for (let i = 0; i < r.length; i++)
      this.write(), !n && r[i][0] == "[" && /(^|[^\\])\!$/.test(this.out) && (this.out = this.out.slice(0, this.out.length - 1) + "\\!"), this.out += n ? this.esc(r[i], this.atBlockStart) : r[i], i != r.length - 1 && (this.out += `
`);
  }
  /**
  Render the given node as a block.
  */
  render(t, n, r) {
    if (this.nodes[t.type.name])
      this.nodes[t.type.name](this, t, n, r);
    else {
      if (this.options.strict !== !1)
        throw new Error("Token type `" + t.type.name + "` not supported by Markdown renderer");
      t.type.isLeaf || (t.type.inlineContent ? this.renderInline(t) : this.renderContent(t), t.isBlock && this.closeBlock(t));
    }
  }
  /**
  Render the contents of `parent` as block nodes.
  */
  renderContent(t) {
    t.forEach((n, r, i) => this.render(n, t, i));
  }
  /**
  Render the contents of `parent` as inline content.
  */
  renderInline(t, n = !0) {
    this.atBlockStart = n;
    let r = [], i = "", o = (s, a, l) => {
      let u = s ? s.marks : [];
      s && s.type.name === this.options.hardBreakNodeName && (u = u.filter((m) => {
        if (l + 1 == t.childCount)
          return !1;
        let g = t.child(l + 1);
        return m.isInSet(g.marks) && (!g.isText || /\S/.test(g.text));
      }));
      let c = i;
      if (i = "", s && s.isText && u.some((m) => {
        let g = this.getMark(m.type.name);
        return g && g.expelEnclosingWhitespace && !m.isInSet(r);
      })) {
        let [m, g, y] = /^(\s*)(.*)$/m.exec(s.text);
        g && (c += g, s = y ? s.withText(y) : null, s || (u = r));
      }
      if (s && s.isText && u.some((m) => {
        let g = this.getMark(m.type.name);
        return g && g.expelEnclosingWhitespace && (l == t.childCount - 1 || !m.isInSet(t.child(l + 1).marks));
      })) {
        let [m, g, y] = /^(.*?)(\s*)$/m.exec(s.text);
        y && (i = y, s = g ? s.withText(g) : null, s || (u = r));
      }
      let f = u.length ? u[u.length - 1] : null, d = f && this.getMark(f.type.name).escape === !1, p = u.length - (d ? 1 : 0);
      e: for (let m = 0; m < p; m++) {
        let g = u[m];
        if (!this.getMark(g.type.name).mixable)
          break;
        for (let y = 0; y < r.length; y++) {
          let _ = r[y];
          if (!this.getMark(_.type.name).mixable)
            break;
          if (g.eq(_)) {
            m > y ? u = u.slice(0, y).concat(g).concat(u.slice(y, m)).concat(u.slice(m + 1, p)) : y > m && (u = u.slice(0, m).concat(u.slice(m + 1, y)).concat(g).concat(u.slice(y, p)));
            continue e;
          }
        }
      }
      let h = 0;
      for (; h < Math.min(r.length, p) && u[h].eq(r[h]); )
        ++h;
      for (; h < r.length; )
        this.text(this.markString(r.pop(), !1, t, l), !1);
      if (c && this.text(c), s) {
        for (; r.length < p; ) {
          let m = u[r.length];
          r.push(m), this.text(this.markString(m, !0, t, l), !1), this.atBlockStart = !1;
        }
        d && s.isText ? this.text(this.markString(f, !0, t, l) + s.text + this.markString(f, !1, t, l + 1), !1) : this.render(s, t, l), this.atBlockStart = !1;
      }
      s != null && s.isText && s.nodeSize > 0 && (this.atBlockStart = !1);
    };
    t.forEach(o), o(null, 0, t.childCount), this.atBlockStart = !1;
  }
  /**
  Render a node's content as a list. `delim` should be the extra
  indentation added to all lines except the first in an item,
  `firstDelim` is a function going from an item index to a
  delimiter for the first line of the item.
  */
  renderList(t, n, r) {
    this.closed && this.closed.type == t.type ? this.flushClose(3) : this.inTightList && this.flushClose(1);
    let i = typeof t.attrs.tight < "u" ? t.attrs.tight : this.options.tightLists, o = this.inTightList;
    this.inTightList = i, t.forEach((s, a, l) => {
      l && i && this.flushClose(1), this.wrapBlock(n, r(l), t, () => this.render(s, t, l));
    }), this.inTightList = o;
  }
  /**
  Escape the given string so that it can safely appear in Markdown
  content. If `startOfLine` is true, also escape characters that
  have special meaning only at the start of the line.
  */
  esc(t, n = !1) {
    return t = t.replace(/[`*\\~\[\]_]/g, (r, i) => r == "_" && i > 0 && i + 1 < t.length && t[i - 1].match(/\w/) && t[i + 1].match(/\w/) ? r : "\\" + r), n && (t = t.replace(/^(\+[ ]|[\-*>])/, "\\$&").replace(/^(\s*)(#{1,6})(\s|$)/, "$1\\$2$3").replace(/^(\s*\d+)\.\s/, "$1\\. ")), this.options.escapeExtraCharacters && (t = t.replace(this.options.escapeExtraCharacters, "\\$&")), t;
  }
  /**
  @internal
  */
  quote(t) {
    let n = t.indexOf('"') == -1 ? '""' : t.indexOf("'") == -1 ? "''" : "()";
    return n[0] + t + n[1];
  }
  /**
  Repeat the given string `n` times.
  */
  repeat(t, n) {
    let r = "";
    for (let i = 0; i < n; i++)
      r += t;
    return r;
  }
  /**
  Get the markdown string for a given opening or closing mark.
  */
  markString(t, n, r, i) {
    let o = this.getMark(t.type.name), s = n ? o.open : o.close;
    return typeof s == "string" ? s : s(this, t, r, i);
  }
  /**
  Get leading and trailing whitespace from a string. Values of
  leading or trailing property of the return object will be undefined
  if there is no match.
  */
  getEnclosingWhitespace(t) {
    return {
      leading: (t.match(/^(\s+)/) || [void 0])[0],
      trailing: (t.match(/(\s+)$/) || [void 0])[0]
    };
  }
};
var sz = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ex(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Gh = !0, tx = !1, nx = !1, az = function(e, t) {
  t && (Gh = !t.enabled, tx = !!t.label, nx = !!t.labelAfter), e.core.ruler.after("inline", "github-task-lists", function(n) {
    for (var r = n.tokens, i = 2; i < r.length; i++)
      uz(r, i) && (cz(r[i], n.Token), cy(r[i - 2], "class", "task-list-item" + (Gh ? "" : " enabled")), cy(r[lz(r, i - 2)], "class", "contains-task-list"));
  });
};
function cy(e, t, n) {
  var r = e.attrIndex(t), i = [t, n];
  r < 0 ? e.attrPush(i) : e.attrs[r] = i;
}
function lz(e, t) {
  for (var n = e[t].level - 1, r = t - 1; r >= 0; r--)
    if (e[r].level === n)
      return r;
  return -1;
}
function uz(e, t) {
  return gz(e[t]) && mz(e[t - 1]) && bz(e[t - 2]) && yz(e[t]);
}
function cz(e, t) {
  if (e.children.unshift(fz(e, t)), e.children[1].content = e.children[1].content.slice(3), e.content = e.content.slice(3), tx)
    if (nx) {
      e.children.pop();
      var n = "task-item-" + Math.ceil(Math.random() * (1e4 * 1e3) - 1e3);
      e.children[0].content = e.children[0].content.slice(0, -1) + ' id="' + n + '">', e.children.push(hz(e.content, n, t));
    } else
      e.children.unshift(dz(t)), e.children.push(pz(t));
}
function fz(e, t) {
  var n = new t("html_inline", "", 0), r = Gh ? ' disabled="" ' : "";
  return e.content.indexOf("[ ] ") === 0 ? n.content = '<input class="task-list-item-checkbox"' + r + 'type="checkbox">' : (e.content.indexOf("[x] ") === 0 || e.content.indexOf("[X] ") === 0) && (n.content = '<input class="task-list-item-checkbox" checked=""' + r + 'type="checkbox">'), n;
}
function dz(e) {
  var t = new e("html_inline", "", 0);
  return t.content = "<label>", t;
}
function pz(e) {
  var t = new e("html_inline", "", 0);
  return t.content = "</label>", t;
}
function hz(e, t, n) {
  var r = new n("html_inline", "", 0);
  return r.content = '<label class="task-list-item-label" for="' + t + '">' + e + "</label>", r.attrs = [{ for: t }], r;
}
function gz(e) {
  return e.type === "inline";
}
function mz(e) {
  return e.type === "paragraph_open";
}
function bz(e) {
  return e.type === "list_item_open";
}
function yz(e) {
  return e.content.indexOf("[ ] ") === 0 || e.content.indexOf("[x] ") === 0 || e.content.indexOf("[X] ") === 0;
}
const vz = /* @__PURE__ */ ex(az);
var _z = Object.defineProperty, Ez = (e, t, n) => t in e ? _z(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Qc = (e, t, n) => (Ez(e, typeof t != "symbol" ? t + "" : t, n), n);
const wz = ht.create({
  name: "markdownTightLists",
  addOptions: () => ({
    tight: !0,
    tightClass: "tight",
    listTypes: ["bulletList", "orderedList"]
  }),
  addGlobalAttributes() {
    return [{
      types: this.options.listTypes,
      attributes: {
        tight: {
          default: this.options.tight,
          parseHTML: (e) => e.getAttribute("data-tight") === "true" || !e.querySelector("p"),
          renderHTML: (e) => ({
            class: e.tight ? this.options.tightClass : null,
            "data-tight": e.tight ? "true" : null
          })
        }
      }
    }];
  },
  addCommands() {
    var e = this;
    return {
      toggleTight: function() {
        let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        return (n) => {
          let {
            editor: r,
            commands: i
          } = n;
          function o(s) {
            if (!r.isActive(s))
              return !1;
            const a = r.getAttributes(s);
            return i.updateAttributes(s, {
              tight: t ?? !(a != null && a.tight)
            });
          }
          return e.options.listTypes.some((s) => o(s));
        };
      }
    };
  }
}), fy = Dn();
function rx(e, t) {
  return fy.inline.State.prototype.scanDelims.call({
    src: e,
    posMax: e.length
  }), new fy.inline.State(e, null, null, []).scanDelims(t, !0);
}
function ix(e, t, n, r) {
  let i = e.substring(0, n) + e.substring(n + t.length);
  return i = i.substring(0, n + r) + t + i.substring(n + r), i;
}
function xz(e, t, n, r) {
  let i = n, o = e;
  for (; i < r && !rx(o, i).can_open; )
    o = ix(o, t, i, 1), i++;
  return {
    text: o,
    from: i,
    to: r
  };
}
function kz(e, t, n, r) {
  let i = r, o = e;
  for (; i > n && !rx(o, i).can_close; )
    o = ix(o, t, i, -1), i--;
  return {
    text: o,
    from: n,
    to: i
  };
}
function Mz(e, t, n, r) {
  let i = {
    text: e,
    from: n,
    to: r
  };
  return i = xz(i.text, t, i.from, i.to), i = kz(i.text, t, i.from, i.to), i.to - i.from < t.length + 1 && (i.text = i.text.substring(0, i.from) + i.text.substring(i.to + t.length)), i.text;
}
class Az extends Jw {
  constructor(t, n, r) {
    super(t, n, r ?? {}), Qc(this, "inTable", !1), this.inlines = [];
  }
  render(t, n, r) {
    super.render(t, n, r);
    const i = this.inlines[this.inlines.length - 1];
    if (i != null && i.start && i !== null && i !== void 0 && i.end) {
      const {
        delimiter: o,
        start: s,
        end: a
      } = this.normalizeInline(i);
      this.out = Mz(this.out, o, s, a), this.inlines.pop();
    }
  }
  markString(t, n, r, i) {
    const o = this.marks[t.type.name];
    if (o.expelEnclosingWhitespace)
      if (n)
        this.inlines.push({
          start: this.out.length,
          delimiter: o.open
        });
      else {
        const s = this.inlines.pop();
        this.inlines.push({
          ...s,
          end: this.out.length
        });
      }
    return super.markString(t, n, r, i);
  }
  normalizeInline(t) {
    let {
      start: n,
      end: r
    } = t;
    for (; this.out.charAt(n).match(/\s/); )
      n++;
    return {
      ...t,
      start: n
    };
  }
}
const ox = Jt.create({
  name: "markdownHTMLMark",
  /**
   * @return {{markdown: MarkdownMarkSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: {
          open(e, t) {
            var n, r;
            return this.editor.storage.markdown.options.html ? (n = (r = dy(t)) === null || r === void 0 ? void 0 : r[0]) !== null && n !== void 0 ? n : "" : (console.warn(`Tiptap Markdown: "${t.type.name}" mark is only available in html mode`), "");
          },
          close(e, t) {
            var n, r;
            return this.editor.storage.markdown.options.html && (n = (r = dy(t)) === null || r === void 0 ? void 0 : r[1]) !== null && n !== void 0 ? n : "";
          }
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
function dy(e) {
  const t = e.type.schema, n = t.text(" ", [e]), i = Hl(te.from(n), t).match(/^(<.*?>) (<\/.*?>)$/);
  return i ? [i[1], i[2]] : null;
}
function Pg(e) {
  const t = `<body>${e}</body>`;
  return new window.DOMParser().parseFromString(t, "text/html").body;
}
function Tz(e) {
  return e == null ? void 0 : e.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function Sz(e) {
  const t = e.parentElement, n = t.cloneNode();
  for (; t.firstChild && t.firstChild !== e; )
    n.appendChild(t.firstChild);
  n.childNodes.length > 0 && t.parentElement.insertBefore(n, t), t.parentElement.insertBefore(e, t), t.childNodes.length === 0 && t.remove();
}
function Cz(e) {
  const t = e.parentNode;
  for (; e.firstChild; )
    t.insertBefore(e.firstChild, e);
  t.removeChild(e);
}
const wd = lt.create({
  name: "markdownHTMLNode",
  addStorage() {
    return {
      markdown: {
        serialize(e, t, n) {
          this.editor.storage.markdown.options.html ? e.write(Nz(t, n)) : (console.warn(`Tiptap Markdown: "${t.type.name}" node is only available in html mode`), e.write(`[${t.type.name}]`)), t.isBlock && e.closeBlock(t);
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
function Nz(e, t) {
  const n = e.type.schema, r = Hl(te.from(e), n);
  return e.isBlock && (t instanceof te || t.type.name === n.topNodeType.name) ? Dz(r) : r;
}
function Dz(e) {
  const n = Pg(e).firstElementChild;
  return n.innerHTML = n.innerHTML.trim() ? `
${n.innerHTML}
` : `
`, n.outerHTML;
}
const Oz = lt.create({
  name: "blockquote"
}), Iz = Oz.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: Zr.nodes.blockquote,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
}), Rz = lt.create({
  name: "bulletList"
}), sx = Rz.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize(e, t) {
          return e.renderList(t, "  ", () => (this.editor.storage.markdown.options.bulletListMarker || "-") + " ");
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
}), Lz = lt.create({
  name: "codeBlock"
}), Bz = Lz.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize(e, t) {
          e.write("```" + (t.attrs.language || "") + `
`), e.text(t.textContent, !1), e.ensureNewLine(), e.write("```"), e.closeBlock(t);
        },
        parse: {
          setup(e) {
            var t;
            e.set({
              langPrefix: (t = this.options.languageClassPrefix) !== null && t !== void 0 ? t : "language-"
            });
          },
          updateDOM(e) {
            e.innerHTML = e.innerHTML.replace(/\n<\/code><\/pre>/g, "</code></pre>");
          }
        }
      }
    };
  }
}), Pz = lt.create({
  name: "hardBreak"
}), ax = Pz.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize(e, t, n, r) {
          for (let i = r + 1; i < n.childCount; i++)
            if (n.child(i).type != t.type) {
              e.write(e.inTable ? wd.storage.markdown.serialize.call(this, e, t, n) : `\\
`);
              return;
            }
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
}), $z = lt.create({
  name: "heading"
}), zz = $z.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: Zr.nodes.heading,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
}), Fz = lt.create({
  name: "horizontalRule"
}), jz = Fz.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: Zr.nodes.horizontal_rule,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
}), Uz = lt.create({
  name: "image"
}), Vz = Uz.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: Zr.nodes.image,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
}), Hz = lt.create({
  name: "listItem"
}), qz = Hz.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: Zr.nodes.list_item,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
}), Gz = lt.create({
  name: "orderedList"
});
function Wz(e, t, n) {
  let r = 0;
  for (; n - r > 0 && t.child(n - r - 1).type.name === e.type.name; r++)
    ;
  return r;
}
const Kz = Gz.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize(e, t, n, r) {
          const i = t.attrs.start || 1, o = String(i + t.childCount - 1).length, s = e.repeat(" ", o + 2), l = Wz(t, n, r) % 2 ? ") " : ". ";
          e.renderList(t, s, (u) => {
            const c = String(i + u);
            return e.repeat(" ", o - c.length) + c + l;
          });
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
}), Yz = lt.create({
  name: "paragraph"
}), Qz = Yz.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: Zr.nodes.paragraph,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
function Lp(e) {
  var t, n;
  return (t = e == null || (n = e.content) === null || n === void 0 ? void 0 : n.content) !== null && t !== void 0 ? t : [];
}
const Zz = lt.create({
  name: "table"
}), Xz = Zz.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize(e, t, n) {
          if (!Jz(t)) {
            wd.storage.markdown.serialize.call(this, e, t, n);
            return;
          }
          e.inTable = !0, t.forEach((r, i, o) => {
            if (e.write("| "), r.forEach((s, a, l) => {
              l && e.write(" | ");
              const u = s.firstChild;
              u.textContent.trim() && e.renderInline(u);
            }), e.write(" |"), e.ensureNewLine(), !o) {
              const s = Array.from({
                length: r.childCount
              }).map(() => "---").join(" | ");
              e.write(`| ${s} |`), e.ensureNewLine();
            }
          }), e.closeBlock(t), e.inTable = !1;
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
function py(e) {
  return e.attrs.colspan > 1 || e.attrs.rowspan > 1;
}
function Jz(e) {
  const t = Lp(e), n = t[0], r = t.slice(1);
  return !(Lp(n).some((i) => i.type.name !== "tableHeader" || py(i) || i.childCount > 1) || r.some((i) => Lp(i).some((o) => o.type.name === "tableHeader" || py(o) || o.childCount > 1)));
}
const eF = lt.create({
  name: "taskItem"
}), tF = eF.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize(e, t) {
          const n = t.attrs.checked ? "[x]" : "[ ]";
          e.write(`${n} `), e.renderContent(t);
        },
        parse: {
          updateDOM(e) {
            [...e.querySelectorAll(".task-list-item")].forEach((t) => {
              const n = t.querySelector("input");
              t.setAttribute("data-type", "taskItem"), n && (t.setAttribute("data-checked", n.checked), n.remove());
            });
          }
        }
      }
    };
  }
}), nF = lt.create({
  name: "taskList"
}), rF = nF.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: sx.storage.markdown.serialize,
        parse: {
          setup(e) {
            e.use(vz);
          },
          updateDOM(e) {
            [...e.querySelectorAll(".contains-task-list")].forEach((t) => {
              t.setAttribute("data-type", "taskList");
            });
          }
        }
      }
    };
  }
}), iF = lt.create({
  name: "text"
}), oF = iF.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize(e, t) {
          e.text(Tz(t.text));
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
}), sF = Jt.create({
  name: "bold"
}), aF = sF.extend({
  /**
   * @return {{markdown: MarkdownMarkSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: Zr.marks.strong,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
}), lF = Jt.create({
  name: "code"
}), uF = lF.extend({
  /**
   * @return {{markdown: MarkdownMarkSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: Zr.marks.code,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
}), cF = Jt.create({
  name: "italic"
}), fF = cF.extend({
  /**
   * @return {{markdown: MarkdownMarkSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: Zr.marks.em,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
}), dF = Jt.create({
  name: "link"
}), pF = dF.extend({
  /**
   * @return {{markdown: MarkdownMarkSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: Zr.marks.link,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
}), hF = Jt.create({
  name: "strike"
}), gF = hF.extend({
  /**
   * @return {{markdown: MarkdownMarkSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: {
          open: "~~",
          close: "~~",
          expelEnclosingWhitespace: !0
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
}), mF = [Iz, sx, Bz, ax, zz, jz, wd, Vz, qz, Kz, Qz, Xz, tF, rF, oF, aF, uF, ox, fF, pF, gF];
function Zc(e) {
  var t, n;
  const r = (t = e.storage) === null || t === void 0 ? void 0 : t.markdown, i = (n = mF.find((o) => o.name === e.name)) === null || n === void 0 ? void 0 : n.storage.markdown;
  return r || i ? {
    ...i,
    ...r
  } : null;
}
class bF {
  constructor(t) {
    Qc(this, "editor", null), this.editor = t;
  }
  serialize(t) {
    const n = new Az(this.nodes, this.marks, {
      hardBreakNodeName: ax.name
    });
    return n.renderContent(t), n.out;
  }
  get nodes() {
    var t;
    return {
      ...Object.fromEntries(Object.keys(this.editor.schema.nodes).map((n) => [n, this.serializeNode(wd)])),
      ...Object.fromEntries((t = this.editor.extensionManager.extensions.filter((n) => n.type === "node" && this.serializeNode(n)).map((n) => [n.name, this.serializeNode(n)])) !== null && t !== void 0 ? t : [])
    };
  }
  get marks() {
    var t;
    return {
      ...Object.fromEntries(Object.keys(this.editor.schema.marks).map((n) => [n, this.serializeMark(ox)])),
      ...Object.fromEntries((t = this.editor.extensionManager.extensions.filter((n) => n.type === "mark" && this.serializeMark(n)).map((n) => [n.name, this.serializeMark(n)])) !== null && t !== void 0 ? t : [])
    };
  }
  serializeNode(t) {
    var n;
    return (n = Zc(t)) === null || n === void 0 || (n = n.serialize) === null || n === void 0 ? void 0 : n.bind({
      editor: this.editor,
      options: t.options
    });
  }
  serializeMark(t) {
    var n;
    const r = (n = Zc(t)) === null || n === void 0 ? void 0 : n.serialize;
    return r ? {
      ...r,
      open: typeof r.open == "function" ? r.open.bind({
        editor: this.editor,
        options: t.options
      }) : r.open,
      close: typeof r.close == "function" ? r.close.bind({
        editor: this.editor,
        options: t.options
      }) : r.close
    } : null;
  }
}
class yF {
  constructor(t, n) {
    Qc(this, "editor", null), Qc(this, "md", null);
    let {
      html: r,
      linkify: i,
      breaks: o
    } = n;
    this.editor = t, this.md = this.withPatchedRenderer(Dn({
      html: r,
      linkify: i,
      breaks: o
    }));
  }
  parse(t) {
    let {
      inline: n
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (typeof t == "string") {
      this.editor.extensionManager.extensions.forEach((o) => {
        var s;
        return (s = Zc(o)) === null || s === void 0 || (s = s.parse) === null || s === void 0 || (s = s.setup) === null || s === void 0 ? void 0 : s.call({
          editor: this.editor,
          options: o.options
        }, this.md);
      });
      const r = this.md.render(t), i = Pg(r);
      return this.editor.extensionManager.extensions.forEach((o) => {
        var s;
        return (s = Zc(o)) === null || s === void 0 || (s = s.parse) === null || s === void 0 || (s = s.updateDOM) === null || s === void 0 ? void 0 : s.call({
          editor: this.editor,
          options: o.options
        }, i);
      }), this.normalizeDOM(i, {
        inline: n,
        content: t
      }), i.innerHTML;
    }
    return t;
  }
  normalizeDOM(t, n) {
    let {
      inline: r,
      content: i
    } = n;
    return this.normalizeBlocks(t), t.querySelectorAll("*").forEach((o) => {
      var s;
      ((s = o.nextSibling) === null || s === void 0 ? void 0 : s.nodeType) === Node.TEXT_NODE && !o.closest("pre") && (o.nextSibling.textContent = o.nextSibling.textContent.replace(/^\n/, ""));
    }), r && this.normalizeInline(t, i), t;
  }
  normalizeBlocks(t) {
    const r = Object.values(this.editor.schema.nodes).filter((i) => i.isBlock).map((i) => {
      var o;
      return (o = i.spec.parseDOM) === null || o === void 0 ? void 0 : o.map((s) => s.tag);
    }).flat().filter(Boolean).join(",");
    r && [...t.querySelectorAll(r)].forEach((i) => {
      i.parentElement.matches("p") && Sz(i);
    });
  }
  normalizeInline(t, n) {
    var r;
    if ((r = t.firstElementChild) !== null && r !== void 0 && r.matches("p")) {
      var i, o, s, a;
      const l = t.firstElementChild, {
        nextElementSibling: u
      } = l, c = (i = (o = n.match(/^\s+/)) === null || o === void 0 ? void 0 : o[0]) !== null && i !== void 0 ? i : "", f = u ? "" : (s = (a = n.match(/\s+$/)) === null || a === void 0 ? void 0 : a[0]) !== null && s !== void 0 ? s : "";
      if (n.match(/^\n\n/)) {
        l.innerHTML = `${l.innerHTML}${f}`;
        return;
      }
      Cz(l), t.innerHTML = `${c}${t.innerHTML}${f}`;
    }
  }
  /**
   * @param {markdownit} md
   */
  withPatchedRenderer(t) {
    const n = (r) => function() {
      const i = r(...arguments);
      return i === `
` ? i : i[i.length - 1] === `
` ? i.slice(0, -1) : i;
    };
    return t.renderer.rules.hardbreak = n(t.renderer.rules.hardbreak), t.renderer.rules.softbreak = n(t.renderer.rules.softbreak), t.renderer.rules.fence = n(t.renderer.rules.fence), t.renderer.rules.code_block = n(t.renderer.rules.code_block), t.renderer.renderToken = n(t.renderer.renderToken.bind(t.renderer)), t;
  }
}
const vF = ht.create({
  name: "markdownClipboard",
  addOptions() {
    return {
      transformPastedText: !1,
      transformCopiedText: !1
    };
  },
  addProseMirrorPlugins() {
    return [new mt({
      key: new Pt("markdownClipboard"),
      props: {
        clipboardTextParser: (e, t, n) => {
          if (n || !this.options.transformPastedText)
            return null;
          const r = this.editor.storage.markdown.parser.parse(e, {
            inline: !0
          });
          return li.fromSchema(this.editor.schema).parseSlice(Pg(r), {
            preserveWhitespace: !0,
            context: t
          });
        },
        /**
         * @param {import('prosemirror-model').Slice} slice
         */
        clipboardTextSerializer: (e) => this.options.transformCopiedText ? this.editor.storage.markdown.serializer.serialize(e.content) : null
      }
    })];
  }
}), _F = ht.create({
  name: "markdown",
  priority: 50,
  addOptions() {
    return {
      html: !0,
      tightLists: !0,
      tightListClass: "tight",
      bulletListMarker: "-",
      linkify: !1,
      breaks: !1,
      transformPastedText: !1,
      transformCopiedText: !1
    };
  },
  addCommands() {
    const e = i5.Commands.config.addCommands();
    return {
      setContent: (t, n, r) => (i) => e.setContent(i.editor.storage.markdown.parser.parse(t), n, r)(i),
      insertContentAt: (t, n, r) => (i) => e.insertContentAt(t, i.editor.storage.markdown.parser.parse(n, {
        inline: !0
      }), r)(i)
    };
  },
  onBeforeCreate() {
    this.editor.storage.markdown = {
      options: {
        ...this.options
      },
      parser: new yF(this.editor, this.options),
      serializer: new bF(this.editor),
      getMarkdown: () => this.editor.storage.markdown.serializer.serialize(this.editor.state.doc)
    }, this.editor.options.initialContent = this.editor.options.content, this.editor.options.content = this.editor.storage.markdown.parser.parse(this.editor.options.content);
  },
  onCreate() {
    this.editor.options.content = this.editor.options.initialContent, delete this.editor.options.initialContent;
  },
  addStorage() {
    return {
      /// storage will be defined in onBeforeCreate() to prevent initial object overriding
    };
  },
  addExtensions() {
    return [wz.configure({
      tight: this.options.tightLists,
      tightClass: this.options.tightListClass
    }), vF.configure({
      transformPastedText: this.options.transformPastedText,
      transformCopiedText: this.options.transformCopiedText
    })];
  }
}), EF = lt.create({
  name: "taskList",
  addOptions() {
    return {
      itemTypeName: "taskItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      {
        tag: `ul[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["ul", At(this.options.HTMLAttributes, e, { "data-type": this.name }), 0];
  },
  addCommands() {
    return {
      toggleTaskList: () => ({ commands: e }) => e.toggleList(this.name, this.options.itemTypeName)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
    };
  }
}), wF = /^\s*(\[([( |x])?\])\s$/, xF = lt.create({
  name: "taskItem",
  addOptions() {
    return {
      nested: !1,
      HTMLAttributes: {},
      taskListTypeName: "taskList"
    };
  },
  content() {
    return this.options.nested ? "paragraph block*" : "paragraph+";
  },
  defining: !0,
  addAttributes() {
    return {
      checked: {
        default: !1,
        keepOnSplit: !1,
        parseHTML: (e) => {
          const t = e.getAttribute("data-checked");
          return t === "" || t === "true";
        },
        renderHTML: (e) => ({
          "data-checked": e.checked
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: `li[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ node: e, HTMLAttributes: t }) {
    return [
      "li",
      At(this.options.HTMLAttributes, t, {
        "data-type": this.name
      }),
      [
        "label",
        [
          "input",
          {
            type: "checkbox",
            checked: e.attrs.checked ? "checked" : null
          }
        ],
        ["span"]
      ],
      ["div", 0]
    ];
  },
  addKeyboardShortcuts() {
    const e = {
      Enter: () => this.editor.commands.splitListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
    return this.options.nested ? {
      ...e,
      Tab: () => this.editor.commands.sinkListItem(this.name)
    } : e;
  },
  addNodeView() {
    return ({ node: e, HTMLAttributes: t, getPos: n, editor: r }) => {
      const i = document.createElement("li"), o = document.createElement("label"), s = document.createElement("span"), a = document.createElement("input"), l = document.createElement("div");
      return o.contentEditable = "false", a.type = "checkbox", a.addEventListener("mousedown", (u) => u.preventDefault()), a.addEventListener("change", (u) => {
        if (!r.isEditable && !this.options.onReadOnlyChecked) {
          a.checked = !a.checked;
          return;
        }
        const { checked: c } = u.target;
        r.isEditable && typeof n == "function" && r.chain().focus(void 0, { scrollIntoView: !1 }).command(({ tr: f }) => {
          const d = n();
          if (typeof d != "number")
            return !1;
          const p = f.doc.nodeAt(d);
          return f.setNodeMarkup(d, void 0, {
            ...p == null ? void 0 : p.attrs,
            checked: c
          }), !0;
        }).run(), !r.isEditable && this.options.onReadOnlyChecked && (this.options.onReadOnlyChecked(e, c) || (a.checked = !a.checked));
      }), Object.entries(this.options.HTMLAttributes).forEach(([u, c]) => {
        i.setAttribute(u, c);
      }), i.dataset.checked = e.attrs.checked, e.attrs.checked && a.setAttribute("checked", "checked"), o.append(a, s), i.append(o, l), Object.entries(t).forEach(([u, c]) => {
        i.setAttribute(u, c);
      }), {
        dom: i,
        contentDOM: l,
        update: (u) => u.type !== this.type ? !1 : (i.dataset.checked = u.attrs.checked, u.attrs.checked ? a.setAttribute("checked", "checked") : a.removeAttribute("checked"), !0)
      };
    };
  },
  addInputRules() {
    return [
      Ts({
        find: wF,
        type: this.type,
        getAttributes: (e) => ({
          checked: e[e.length - 1] === "x"
        })
      })
    ];
  }
});
function kF(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function lx(e) {
  return e instanceof Map ? e.clear = e.delete = e.set = function() {
    throw new Error("map is read-only");
  } : e instanceof Set && (e.add = e.clear = e.delete = function() {
    throw new Error("set is read-only");
  }), Object.freeze(e), Object.getOwnPropertyNames(e).forEach((t) => {
    const n = e[t], r = typeof n;
    (r === "object" || r === "function") && !Object.isFrozen(n) && lx(n);
  }), e;
}
let hy = class {
  /**
   * @param {CompiledMode} mode
   */
  constructor(t) {
    t.data === void 0 && (t.data = {}), this.data = t.data, this.isMatchIgnored = !1;
  }
  ignoreMatch() {
    this.isMatchIgnored = !0;
  }
};
function ux(e) {
  return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function Bi(e, ...t) {
  const n = /* @__PURE__ */ Object.create(null);
  for (const r in e)
    n[r] = e[r];
  return t.forEach(function(r) {
    for (const i in r)
      n[i] = r[i];
  }), /** @type {T} */
  n;
}
const MF = "</span>", gy = (e) => !!e.scope, AF = (e, { prefix: t }) => {
  if (e.startsWith("language:"))
    return e.replace("language:", "language-");
  if (e.includes(".")) {
    const n = e.split(".");
    return [
      `${t}${n.shift()}`,
      ...n.map((r, i) => `${r}${"_".repeat(i + 1)}`)
    ].join(" ");
  }
  return `${t}${e}`;
};
let TF = class {
  /**
   * Creates a new HTMLRenderer
   *
   * @param {Tree} parseTree - the parse tree (must support `walk` API)
   * @param {{classPrefix: string}} options
   */
  constructor(t, n) {
    this.buffer = "", this.classPrefix = n.classPrefix, t.walk(this);
  }
  /**
   * Adds texts to the output stream
   *
   * @param {string} text */
  addText(t) {
    this.buffer += ux(t);
  }
  /**
   * Adds a node open to the output stream (if needed)
   *
   * @param {Node} node */
  openNode(t) {
    if (!gy(t)) return;
    const n = AF(
      t.scope,
      { prefix: this.classPrefix }
    );
    this.span(n);
  }
  /**
   * Adds a node close to the output stream (if needed)
   *
   * @param {Node} node */
  closeNode(t) {
    gy(t) && (this.buffer += MF);
  }
  /**
   * returns the accumulated buffer
  */
  value() {
    return this.buffer;
  }
  // helpers
  /**
   * Builds a span element
   *
   * @param {string} className */
  span(t) {
    this.buffer += `<span class="${t}">`;
  }
};
const my = (e = {}) => {
  const t = { children: [] };
  return Object.assign(t, e), t;
};
let SF = class cx {
  constructor() {
    this.rootNode = my(), this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  /** @param {Node} node */
  add(t) {
    this.top.children.push(t);
  }
  /** @param {string} scope */
  openNode(t) {
    const n = my({ scope: t });
    this.add(n), this.stack.push(n);
  }
  closeNode() {
    if (this.stack.length > 1)
      return this.stack.pop();
  }
  closeAllNodes() {
    for (; this.closeNode(); ) ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  /**
   * @typedef { import("./html_renderer").Renderer } Renderer
   * @param {Renderer} builder
   */
  walk(t) {
    return this.constructor._walk(t, this.rootNode);
  }
  /**
   * @param {Renderer} builder
   * @param {Node} node
   */
  static _walk(t, n) {
    return typeof n == "string" ? t.addText(n) : n.children && (t.openNode(n), n.children.forEach((r) => this._walk(t, r)), t.closeNode(n)), t;
  }
  /**
   * @param {Node} node
   */
  static _collapse(t) {
    typeof t != "string" && t.children && (t.children.every((n) => typeof n == "string") ? t.children = [t.children.join("")] : t.children.forEach((n) => {
      cx._collapse(n);
    }));
  }
}, CF = class extends SF {
  /**
   * @param {*} options
   */
  constructor(t) {
    super(), this.options = t;
  }
  /**
   * @param {string} text
   */
  addText(t) {
    t !== "" && this.add(t);
  }
  /** @param {string} scope */
  startScope(t) {
    this.openNode(t);
  }
  endScope() {
    this.closeNode();
  }
  /**
   * @param {Emitter & {root: DataNode}} emitter
   * @param {string} name
   */
  __addSublanguage(t, n) {
    const r = t.root;
    n && (r.scope = `language:${n}`), this.add(r);
  }
  toHTML() {
    return new TF(this, this.options).value();
  }
  finalize() {
    return this.closeAllNodes(), !0;
  }
};
function yl(e) {
  return e ? typeof e == "string" ? e : e.source : null;
}
function fx(e) {
  return zo("(?=", e, ")");
}
function NF(e) {
  return zo("(?:", e, ")*");
}
function DF(e) {
  return zo("(?:", e, ")?");
}
function zo(...e) {
  return e.map((n) => yl(n)).join("");
}
function OF(e) {
  const t = e[e.length - 1];
  return typeof t == "object" && t.constructor === Object ? (e.splice(e.length - 1, 1), t) : {};
}
function $g(...e) {
  return "(" + (OF(e).capture ? "" : "?:") + e.map((r) => yl(r)).join("|") + ")";
}
function dx(e) {
  return new RegExp(e.toString() + "|").exec("").length - 1;
}
function IF(e, t) {
  const n = e && e.exec(t);
  return n && n.index === 0;
}
const RF = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function zg(e, { joinWith: t }) {
  let n = 0;
  return e.map((r) => {
    n += 1;
    const i = n;
    let o = yl(r), s = "";
    for (; o.length > 0; ) {
      const a = RF.exec(o);
      if (!a) {
        s += o;
        break;
      }
      s += o.substring(0, a.index), o = o.substring(a.index + a[0].length), a[0][0] === "\\" && a[1] ? s += "\\" + String(Number(a[1]) + i) : (s += a[0], a[0] === "(" && n++);
    }
    return s;
  }).map((r) => `(${r})`).join(t);
}
const LF = /\b\B/, px = "[a-zA-Z]\\w*", Fg = "[a-zA-Z_]\\w*", hx = "\\b\\d+(\\.\\d+)?", gx = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", mx = "\\b(0b[01]+)", BF = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", PF = (e = {}) => {
  const t = /^#![ ]*\//;
  return e.binary && (e.begin = zo(
    t,
    /.*\b/,
    e.binary,
    /\b.*/
  )), Bi({
    scope: "meta",
    begin: t,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": (n, r) => {
      n.index !== 0 && r.ignoreMatch();
    }
  }, e);
}, vl = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
}, $F = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [vl]
}, zF = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [vl]
}, FF = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
}, xd = function(e, t, n = {}) {
  const r = Bi(
    {
      scope: "comment",
      begin: e,
      end: t,
      contains: []
    },
    n
  );
  r.contains.push({
    scope: "doctag",
    // hack to avoid the space from being included. the space is necessary to
    // match here to prevent the plain text rule below from gobbling up doctags
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: !0,
    relevance: 0
  });
  const i = $g(
    // list of common 1 and 2 letter words in English
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    // note: this is not an exhaustive list of contractions, just popular ones
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    // contractions - can't we'd they're let's, etc
    /[A-Za-z]+[-][a-z]+/,
    // `no-way`, etc.
    /[A-Za-z][a-z]{2,}/
    // allow capitalized words at beginning of sentences
  );
  return r.contains.push(
    {
      // TODO: how to include ", (, ) without breaking grammars that use these for
      // comment delimiters?
      // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
      // ---
      // this tries to find sequences of 3 english words in a row (without any
      // "programming" type syntax) this gives us a strong signal that we've
      // TRULY found a comment - vs perhaps scanning with the wrong language.
      // It's possible to find something that LOOKS like the start of the
      // comment - but then if there is no readable text - good chance it is a
      // false match and not a comment.
      //
      // for a visual example please see:
      // https://github.com/highlightjs/highlight.js/issues/2827
      begin: zo(
        /[ ]+/,
        // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
        "(",
        i,
        /[.]?[:]?([.][ ]|[ ])/,
        "){3}"
      )
      // look for 3 words in a row
    }
  ), r;
}, jF = xd("//", "$"), UF = xd("/\\*", "\\*/"), VF = xd("#", "$"), HF = {
  scope: "number",
  begin: hx,
  relevance: 0
}, qF = {
  scope: "number",
  begin: gx,
  relevance: 0
}, GF = {
  scope: "number",
  begin: mx,
  relevance: 0
}, WF = {
  scope: "regexp",
  begin: /\/(?=[^/\n]*\/)/,
  end: /\/[gimuy]*/,
  contains: [
    vl,
    {
      begin: /\[/,
      end: /\]/,
      relevance: 0,
      contains: [vl]
    }
  ]
}, KF = {
  scope: "title",
  begin: px,
  relevance: 0
}, YF = {
  scope: "title",
  begin: Fg,
  relevance: 0
}, QF = {
  // excludes method names from keyword processing
  begin: "\\.\\s*" + Fg,
  relevance: 0
}, ZF = function(e) {
  return Object.assign(
    e,
    {
      /** @type {ModeCallback} */
      "on:begin": (t, n) => {
        n.data._beginMatch = t[1];
      },
      /** @type {ModeCallback} */
      "on:end": (t, n) => {
        n.data._beginMatch !== t[1] && n.ignoreMatch();
      }
    }
  );
};
var Mu = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  APOS_STRING_MODE: $F,
  BACKSLASH_ESCAPE: vl,
  BINARY_NUMBER_MODE: GF,
  BINARY_NUMBER_RE: mx,
  COMMENT: xd,
  C_BLOCK_COMMENT_MODE: UF,
  C_LINE_COMMENT_MODE: jF,
  C_NUMBER_MODE: qF,
  C_NUMBER_RE: gx,
  END_SAME_AS_BEGIN: ZF,
  HASH_COMMENT_MODE: VF,
  IDENT_RE: px,
  MATCH_NOTHING_RE: LF,
  METHOD_GUARD: QF,
  NUMBER_MODE: HF,
  NUMBER_RE: hx,
  PHRASAL_WORDS_MODE: FF,
  QUOTE_STRING_MODE: zF,
  REGEXP_MODE: WF,
  RE_STARTERS_RE: BF,
  SHEBANG: PF,
  TITLE_MODE: KF,
  UNDERSCORE_IDENT_RE: Fg,
  UNDERSCORE_TITLE_MODE: YF
});
function XF(e, t) {
  e.input[e.index - 1] === "." && t.ignoreMatch();
}
function JF(e, t) {
  e.className !== void 0 && (e.scope = e.className, delete e.className);
}
function ej(e, t) {
  t && e.beginKeywords && (e.begin = "\\b(" + e.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", e.__beforeBegin = XF, e.keywords = e.keywords || e.beginKeywords, delete e.beginKeywords, e.relevance === void 0 && (e.relevance = 0));
}
function tj(e, t) {
  Array.isArray(e.illegal) && (e.illegal = $g(...e.illegal));
}
function nj(e, t) {
  if (e.match) {
    if (e.begin || e.end) throw new Error("begin & end are not supported with match");
    e.begin = e.match, delete e.match;
  }
}
function rj(e, t) {
  e.relevance === void 0 && (e.relevance = 1);
}
const ij = (e, t) => {
  if (!e.beforeMatch) return;
  if (e.starts) throw new Error("beforeMatch cannot be used with starts");
  const n = Object.assign({}, e);
  Object.keys(e).forEach((r) => {
    delete e[r];
  }), e.keywords = n.keywords, e.begin = zo(n.beforeMatch, fx(n.begin)), e.starts = {
    relevance: 0,
    contains: [
      Object.assign(n, { endsParent: !0 })
    ]
  }, e.relevance = 0, delete n.beforeMatch;
}, oj = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  // common variable name
  "list",
  // common variable name
  "value"
  // common variable name
], sj = "keyword";
function bx(e, t, n = sj) {
  const r = /* @__PURE__ */ Object.create(null);
  return typeof e == "string" ? i(n, e.split(" ")) : Array.isArray(e) ? i(n, e) : Object.keys(e).forEach(function(o) {
    Object.assign(
      r,
      bx(e[o], t, o)
    );
  }), r;
  function i(o, s) {
    t && (s = s.map((a) => a.toLowerCase())), s.forEach(function(a) {
      const l = a.split("|");
      r[l[0]] = [o, aj(l[0], l[1])];
    });
  }
}
function aj(e, t) {
  return t ? Number(t) : lj(e) ? 0 : 1;
}
function lj(e) {
  return oj.includes(e.toLowerCase());
}
const by = {}, ko = (e) => {
  console.error(e);
}, yy = (e, ...t) => {
  console.log(`WARN: ${e}`, ...t);
}, Wo = (e, t) => {
  by[`${e}/${t}`] || (console.log(`Deprecated as of ${e}. ${t}`), by[`${e}/${t}`] = !0);
}, Xc = new Error();
function yx(e, t, { key: n }) {
  let r = 0;
  const i = e[n], o = {}, s = {};
  for (let a = 1; a <= t.length; a++)
    s[a + r] = i[a], o[a + r] = !0, r += dx(t[a - 1]);
  e[n] = s, e[n]._emit = o, e[n]._multi = !0;
}
function uj(e) {
  if (Array.isArray(e.begin)) {
    if (e.skip || e.excludeBegin || e.returnBegin)
      throw ko("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), Xc;
    if (typeof e.beginScope != "object" || e.beginScope === null)
      throw ko("beginScope must be object"), Xc;
    yx(e, e.begin, { key: "beginScope" }), e.begin = zg(e.begin, { joinWith: "" });
  }
}
function cj(e) {
  if (Array.isArray(e.end)) {
    if (e.skip || e.excludeEnd || e.returnEnd)
      throw ko("skip, excludeEnd, returnEnd not compatible with endScope: {}"), Xc;
    if (typeof e.endScope != "object" || e.endScope === null)
      throw ko("endScope must be object"), Xc;
    yx(e, e.end, { key: "endScope" }), e.end = zg(e.end, { joinWith: "" });
  }
}
function fj(e) {
  e.scope && typeof e.scope == "object" && e.scope !== null && (e.beginScope = e.scope, delete e.scope);
}
function dj(e) {
  fj(e), typeof e.beginScope == "string" && (e.beginScope = { _wrap: e.beginScope }), typeof e.endScope == "string" && (e.endScope = { _wrap: e.endScope }), uj(e), cj(e);
}
function pj(e) {
  function t(s, a) {
    return new RegExp(
      yl(s),
      "m" + (e.case_insensitive ? "i" : "") + (e.unicodeRegex ? "u" : "") + (a ? "g" : "")
    );
  }
  class n {
    constructor() {
      this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
    }
    // @ts-ignore
    addRule(a, l) {
      l.position = this.position++, this.matchIndexes[this.matchAt] = l, this.regexes.push([l, a]), this.matchAt += dx(a) + 1;
    }
    compile() {
      this.regexes.length === 0 && (this.exec = () => null);
      const a = this.regexes.map((l) => l[1]);
      this.matcherRe = t(zg(a, { joinWith: "|" }), !0), this.lastIndex = 0;
    }
    /** @param {string} s */
    exec(a) {
      this.matcherRe.lastIndex = this.lastIndex;
      const l = this.matcherRe.exec(a);
      if (!l)
        return null;
      const u = l.findIndex((f, d) => d > 0 && f !== void 0), c = this.matchIndexes[u];
      return l.splice(0, u), Object.assign(l, c);
    }
  }
  class r {
    constructor() {
      this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
    }
    // @ts-ignore
    getMatcher(a) {
      if (this.multiRegexes[a]) return this.multiRegexes[a];
      const l = new n();
      return this.rules.slice(a).forEach(([u, c]) => l.addRule(u, c)), l.compile(), this.multiRegexes[a] = l, l;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    // @ts-ignore
    addRule(a, l) {
      this.rules.push([a, l]), l.type === "begin" && this.count++;
    }
    /** @param {string} s */
    exec(a) {
      const l = this.getMatcher(this.regexIndex);
      l.lastIndex = this.lastIndex;
      let u = l.exec(a);
      if (this.resumingScanAtSamePosition() && !(u && u.index === this.lastIndex)) {
        const c = this.getMatcher(0);
        c.lastIndex = this.lastIndex + 1, u = c.exec(a);
      }
      return u && (this.regexIndex += u.position + 1, this.regexIndex === this.count && this.considerAll()), u;
    }
  }
  function i(s) {
    const a = new r();
    return s.contains.forEach((l) => a.addRule(l.begin, { rule: l, type: "begin" })), s.terminatorEnd && a.addRule(s.terminatorEnd, { type: "end" }), s.illegal && a.addRule(s.illegal, { type: "illegal" }), a;
  }
  function o(s, a) {
    const l = (
      /** @type CompiledMode */
      s
    );
    if (s.isCompiled) return l;
    [
      JF,
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      nj,
      dj,
      ij
    ].forEach((c) => c(s, a)), e.compilerExtensions.forEach((c) => c(s, a)), s.__beforeBegin = null, [
      ej,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      tj,
      // default to 1 relevance if not specified
      rj
    ].forEach((c) => c(s, a)), s.isCompiled = !0;
    let u = null;
    return typeof s.keywords == "object" && s.keywords.$pattern && (s.keywords = Object.assign({}, s.keywords), u = s.keywords.$pattern, delete s.keywords.$pattern), u = u || /\w+/, s.keywords && (s.keywords = bx(s.keywords, e.case_insensitive)), l.keywordPatternRe = t(u, !0), a && (s.begin || (s.begin = /\B|\b/), l.beginRe = t(l.begin), !s.end && !s.endsWithParent && (s.end = /\B|\b/), s.end && (l.endRe = t(l.end)), l.terminatorEnd = yl(l.end) || "", s.endsWithParent && a.terminatorEnd && (l.terminatorEnd += (s.end ? "|" : "") + a.terminatorEnd)), s.illegal && (l.illegalRe = t(
      /** @type {RegExp | string} */
      s.illegal
    )), s.contains || (s.contains = []), s.contains = [].concat(...s.contains.map(function(c) {
      return hj(c === "self" ? s : c);
    })), s.contains.forEach(function(c) {
      o(
        /** @type Mode */
        c,
        l
      );
    }), s.starts && o(s.starts, a), l.matcher = i(l), l;
  }
  if (e.compilerExtensions || (e.compilerExtensions = []), e.contains && e.contains.includes("self"))
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  return e.classNameAliases = Bi(e.classNameAliases || {}), o(
    /** @type Mode */
    e
  );
}
function vx(e) {
  return e ? e.endsWithParent || vx(e.starts) : !1;
}
function hj(e) {
  return e.variants && !e.cachedVariants && (e.cachedVariants = e.variants.map(function(t) {
    return Bi(e, { variants: null }, t);
  })), e.cachedVariants ? e.cachedVariants : vx(e) ? Bi(e, { starts: e.starts ? Bi(e.starts) : null }) : Object.isFrozen(e) ? Bi(e) : e;
}
var gj = "11.10.0";
let mj = class extends Error {
  constructor(t, n) {
    super(t), this.name = "HTMLInjectionError", this.html = n;
  }
};
const Bp = ux, vy = Bi, _y = Symbol("nomatch"), bj = 7, _x = function(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null), r = [];
  let i = !0;
  const o = "Could not find the language '{}', did you forget to load/include a language module?", s = { disableAutodetect: !0, name: "Plain text", contains: [] };
  let a = {
    ignoreUnescapedHTML: !1,
    throwUnescapedHTML: !1,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: CF
  };
  function l(w) {
    return a.noHighlightRe.test(w);
  }
  function u(w) {
    let O = w.className + " ";
    O += w.parentNode ? w.parentNode.className : "";
    const q = a.languageDetectRe.exec(O);
    if (q) {
      const X = C(q[1]);
      return X || (yy(o.replace("{}", q[1])), yy("Falling back to no-highlight mode for this block.", w)), X ? q[1] : "no-highlight";
    }
    return O.split(/\s+/).find((X) => l(X) || C(X));
  }
  function c(w, O, q) {
    let X = "", se = "";
    typeof O == "object" ? (X = w, q = O.ignoreIllegals, se = O.language) : (Wo("10.7.0", "highlight(lang, code, ...args) has been deprecated."), Wo("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), se = w, X = O), q === void 0 && (q = !0);
    const fe = {
      code: X,
      language: se
    };
    le("before:highlight", fe);
    const Se = fe.result ? fe.result : f(fe.language, fe.code, q);
    return Se.code = fe.code, le("after:highlight", Se), Se;
  }
  function f(w, O, q, X) {
    const se = /* @__PURE__ */ Object.create(null);
    function fe(F, K) {
      return F.keywords[K];
    }
    function Se() {
      if (!ee.keywords) {
        Te.addText(we);
        return;
      }
      let F = 0;
      ee.keywordPatternRe.lastIndex = 0;
      let K = ee.keywordPatternRe.exec(we), ue = "";
      for (; K; ) {
        ue += we.substring(F, K.index);
        const ve = Fe.case_insensitive ? K[0].toLowerCase() : K[0], N = fe(ee, ve);
        if (N) {
          const [I, J] = N;
          if (Te.addText(ue), ue = "", se[ve] = (se[ve] || 0) + 1, se[ve] <= bj && (ut += J), I.startsWith("_"))
            ue += K[0];
          else {
            const D = Fe.classNameAliases[I] || I;
            Y(K[0], D);
          }
        } else
          ue += K[0];
        F = ee.keywordPatternRe.lastIndex, K = ee.keywordPatternRe.exec(we);
      }
      ue += we.substring(F), Te.addText(ue);
    }
    function P() {
      if (we === "") return;
      let F = null;
      if (typeof ee.subLanguage == "string") {
        if (!t[ee.subLanguage]) {
          Te.addText(we);
          return;
        }
        F = f(ee.subLanguage, we, !0, Ke[ee.subLanguage]), Ke[ee.subLanguage] = /** @type {CompiledMode} */
        F._top;
      } else
        F = p(we, ee.subLanguage.length ? ee.subLanguage : null);
      ee.relevance > 0 && (ut += F.relevance), Te.__addSublanguage(F._emitter, F.language);
    }
    function ie() {
      ee.subLanguage != null ? P() : Se(), we = "";
    }
    function Y(F, K) {
      F !== "" && (Te.startScope(K), Te.addText(F), Te.endScope());
    }
    function ge(F, K) {
      let ue = 1;
      const ve = K.length - 1;
      for (; ue <= ve; ) {
        if (!F._emit[ue]) {
          ue++;
          continue;
        }
        const N = Fe.classNameAliases[F[ue]] || F[ue], I = K[ue];
        N ? Y(I, N) : (we = I, Se(), we = ""), ue++;
      }
    }
    function me(F, K) {
      return F.scope && typeof F.scope == "string" && Te.openNode(Fe.classNameAliases[F.scope] || F.scope), F.beginScope && (F.beginScope._wrap ? (Y(we, Fe.classNameAliases[F.beginScope._wrap] || F.beginScope._wrap), we = "") : F.beginScope._multi && (ge(F.beginScope, K), we = "")), ee = Object.create(F, { parent: { value: ee } }), ee;
    }
    function xe(F, K, ue) {
      let ve = IF(F.endRe, ue);
      if (ve) {
        if (F["on:end"]) {
          const N = new hy(F);
          F["on:end"](K, N), N.isMatchIgnored && (ve = !1);
        }
        if (ve) {
          for (; F.endsParent && F.parent; )
            F = F.parent;
          return F;
        }
      }
      if (F.endsWithParent)
        return xe(F.parent, K, ue);
    }
    function Ve(F) {
      return ee.matcher.regexIndex === 0 ? (we += F[0], 1) : (vt = !0, 0);
    }
    function qe(F) {
      const K = F[0], ue = F.rule, ve = new hy(ue), N = [ue.__beforeBegin, ue["on:begin"]];
      for (const I of N)
        if (I && (I(F, ve), ve.isMatchIgnored))
          return Ve(K);
      return ue.skip ? we += K : (ue.excludeBegin && (we += K), ie(), !ue.returnBegin && !ue.excludeBegin && (we = K)), me(ue, F), ue.returnBegin ? 0 : K.length;
    }
    function ot(F) {
      const K = F[0], ue = O.substring(F.index), ve = xe(ee, F, ue);
      if (!ve)
        return _y;
      const N = ee;
      ee.endScope && ee.endScope._wrap ? (ie(), Y(K, ee.endScope._wrap)) : ee.endScope && ee.endScope._multi ? (ie(), ge(ee.endScope, F)) : N.skip ? we += K : (N.returnEnd || N.excludeEnd || (we += K), ie(), N.excludeEnd && (we = K));
      do
        ee.scope && Te.closeNode(), !ee.skip && !ee.subLanguage && (ut += ee.relevance), ee = ee.parent;
      while (ee !== ve.parent);
      return ve.starts && me(ve.starts, F), N.returnEnd ? 0 : K.length;
    }
    function Ie() {
      const F = [];
      for (let K = ee; K !== Fe; K = K.parent)
        K.scope && F.unshift(K.scope);
      F.forEach((K) => Te.openNode(K));
    }
    let ct = {};
    function yt(F, K) {
      const ue = K && K[0];
      if (we += F, ue == null)
        return ie(), 0;
      if (ct.type === "begin" && K.type === "end" && ct.index === K.index && ue === "") {
        if (we += O.slice(K.index, K.index + 1), !i) {
          const ve = new Error(`0 width match regex (${w})`);
          throw ve.languageName = w, ve.badRule = ct.rule, ve;
        }
        return 1;
      }
      if (ct = K, K.type === "begin")
        return qe(K);
      if (K.type === "illegal" && !q) {
        const ve = new Error('Illegal lexeme "' + ue + '" for mode "' + (ee.scope || "<unnamed>") + '"');
        throw ve.mode = ee, ve;
      } else if (K.type === "end") {
        const ve = ot(K);
        if (ve !== _y)
          return ve;
      }
      if (K.type === "illegal" && ue === "")
        return 1;
      if (Ct > 1e5 && Ct > K.index * 3)
        throw new Error("potential infinite loop, way more iterations than matches");
      return we += ue, ue.length;
    }
    const Fe = C(w);
    if (!Fe)
      throw ko(o.replace("{}", w)), new Error('Unknown language: "' + w + '"');
    const $t = pj(Fe);
    let St = "", ee = X || $t;
    const Ke = {}, Te = new a.__emitter(a);
    Ie();
    let we = "", ut = 0, Xe = 0, Ct = 0, vt = !1;
    try {
      if (Fe.__emitTokens)
        Fe.__emitTokens(O, Te);
      else {
        for (ee.matcher.considerAll(); ; ) {
          Ct++, vt ? vt = !1 : ee.matcher.considerAll(), ee.matcher.lastIndex = Xe;
          const F = ee.matcher.exec(O);
          if (!F) break;
          const K = O.substring(Xe, F.index), ue = yt(K, F);
          Xe = F.index + ue;
        }
        yt(O.substring(Xe));
      }
      return Te.finalize(), St = Te.toHTML(), {
        language: w,
        value: St,
        relevance: ut,
        illegal: !1,
        _emitter: Te,
        _top: ee
      };
    } catch (F) {
      if (F.message && F.message.includes("Illegal"))
        return {
          language: w,
          value: Bp(O),
          illegal: !0,
          relevance: 0,
          _illegalBy: {
            message: F.message,
            index: Xe,
            context: O.slice(Xe - 100, Xe + 100),
            mode: F.mode,
            resultSoFar: St
          },
          _emitter: Te
        };
      if (i)
        return {
          language: w,
          value: Bp(O),
          illegal: !1,
          relevance: 0,
          errorRaised: F,
          _emitter: Te,
          _top: ee
        };
      throw F;
    }
  }
  function d(w) {
    const O = {
      value: Bp(w),
      illegal: !1,
      relevance: 0,
      _top: s,
      _emitter: new a.__emitter(a)
    };
    return O._emitter.addText(w), O;
  }
  function p(w, O) {
    O = O || a.languages || Object.keys(t);
    const q = d(w), X = O.filter(C).filter(H).map(
      (ie) => f(ie, w, !1)
    );
    X.unshift(q);
    const se = X.sort((ie, Y) => {
      if (ie.relevance !== Y.relevance) return Y.relevance - ie.relevance;
      if (ie.language && Y.language) {
        if (C(ie.language).supersetOf === Y.language)
          return 1;
        if (C(Y.language).supersetOf === ie.language)
          return -1;
      }
      return 0;
    }), [fe, Se] = se, P = fe;
    return P.secondBest = Se, P;
  }
  function h(w, O, q) {
    const X = O && n[O] || q;
    w.classList.add("hljs"), w.classList.add(`language-${X}`);
  }
  function m(w) {
    let O = null;
    const q = u(w);
    if (l(q)) return;
    if (le(
      "before:highlightElement",
      { el: w, language: q }
    ), w.dataset.highlighted) {
      console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", w);
      return;
    }
    if (w.children.length > 0 && (a.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(w)), a.throwUnescapedHTML))
      throw new mj(
        "One of your code blocks includes unescaped HTML.",
        w.innerHTML
      );
    O = w;
    const X = O.textContent, se = q ? c(X, { language: q, ignoreIllegals: !0 }) : p(X);
    w.innerHTML = se.value, w.dataset.highlighted = "yes", h(w, q, se.language), w.result = {
      language: se.language,
      // TODO: remove with version 11.0
      re: se.relevance,
      relevance: se.relevance
    }, se.secondBest && (w.secondBest = {
      language: se.secondBest.language,
      relevance: se.secondBest.relevance
    }), le("after:highlightElement", { el: w, result: se, text: X });
  }
  function g(w) {
    a = vy(a, w);
  }
  const y = () => {
    v(), Wo("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function _() {
    v(), Wo("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let E = !1;
  function v() {
    if (document.readyState === "loading") {
      E = !0;
      return;
    }
    document.querySelectorAll(a.cssSelector).forEach(m);
  }
  function M() {
    E && v();
  }
  typeof window < "u" && window.addEventListener && window.addEventListener("DOMContentLoaded", M, !1);
  function k(w, O) {
    let q = null;
    try {
      q = O(e);
    } catch (X) {
      if (ko("Language definition for '{}' could not be registered.".replace("{}", w)), i)
        ko(X);
      else
        throw X;
      q = s;
    }
    q.name || (q.name = w), t[w] = q, q.rawDefinition = O.bind(null, e), q.aliases && z(q.aliases, { languageName: w });
  }
  function T(w) {
    delete t[w];
    for (const O of Object.keys(n))
      n[O] === w && delete n[O];
  }
  function U() {
    return Object.keys(t);
  }
  function C(w) {
    return w = (w || "").toLowerCase(), t[w] || t[n[w]];
  }
  function z(w, { languageName: O }) {
    typeof w == "string" && (w = [w]), w.forEach((q) => {
      n[q.toLowerCase()] = O;
    });
  }
  function H(w) {
    const O = C(w);
    return O && !O.disableAutodetect;
  }
  function j(w) {
    w["before:highlightBlock"] && !w["before:highlightElement"] && (w["before:highlightElement"] = (O) => {
      w["before:highlightBlock"](
        Object.assign({ block: O.el }, O)
      );
    }), w["after:highlightBlock"] && !w["after:highlightElement"] && (w["after:highlightElement"] = (O) => {
      w["after:highlightBlock"](
        Object.assign({ block: O.el }, O)
      );
    });
  }
  function V(w) {
    j(w), r.push(w);
  }
  function Q(w) {
    const O = r.indexOf(w);
    O !== -1 && r.splice(O, 1);
  }
  function le(w, O) {
    const q = w;
    r.forEach(function(X) {
      X[q] && X[q](O);
    });
  }
  function ne(w) {
    return Wo("10.7.0", "highlightBlock will be removed entirely in v12.0"), Wo("10.7.0", "Please use highlightElement now."), m(w);
  }
  Object.assign(e, {
    highlight: c,
    highlightAuto: p,
    highlightAll: v,
    highlightElement: m,
    // TODO: Remove with v12 API
    highlightBlock: ne,
    configure: g,
    initHighlighting: y,
    initHighlightingOnLoad: _,
    registerLanguage: k,
    unregisterLanguage: T,
    listLanguages: U,
    getLanguage: C,
    registerAliases: z,
    autoDetection: H,
    inherit: vy,
    addPlugin: V,
    removePlugin: Q
  }), e.debugMode = function() {
    i = !1;
  }, e.safeMode = function() {
    i = !0;
  }, e.versionString = gj, e.regex = {
    concat: zo,
    lookahead: fx,
    either: $g,
    optional: DF,
    anyNumberOfTimes: NF
  };
  for (const w in Mu)
    typeof Mu[w] == "object" && lx(Mu[w]);
  return Object.assign(e, Mu), e;
}, Fs = _x({});
Fs.newInstance = () => _x({});
var yj = Fs;
Fs.HighlightJS = Fs;
Fs.default = Fs;
var vj = /* @__PURE__ */ kF(yj);
function Ex(e, t = []) {
  return e.map((n) => {
    const r = [...t, ...n.properties ? n.properties.className : []];
    return n.children ? Ex(n.children, r) : {
      text: n.value,
      classes: r
    };
  }).flat();
}
function Ey(e) {
  return e.value || e.children || [];
}
function _j(e) {
  return !!vj.getLanguage(e);
}
function wy({ doc: e, name: t, lowlight: n, defaultLanguage: r }) {
  const i = [];
  return Dh(e, (o) => o.type.name === t).forEach((o) => {
    var s;
    let a = o.pos + 1;
    const l = o.node.attrs.language || r, u = n.listLanguages(), c = l && (u.includes(l) || _j(l) || !((s = n.registered) === null || s === void 0) && s.call(n, l)) ? Ey(n.highlight(l, o.node.textContent)) : Ey(n.highlightAuto(o.node.textContent));
    Ex(c).forEach((f) => {
      const d = a + f.text.length;
      if (f.classes.length) {
        const p = dn.inline(a, d, {
          class: f.classes.join(" ")
        });
        i.push(p);
      }
      a = d;
    });
  }), xt.create(e, i);
}
function Ej(e) {
  return typeof e == "function";
}
function wj({ name: e, lowlight: t, defaultLanguage: n }) {
  if (!["highlight", "highlightAuto", "listLanguages"].every((i) => Ej(t[i])))
    throw Error("You should provide an instance of lowlight to use the code-block-lowlight extension");
  const r = new mt({
    key: new Pt("lowlight"),
    state: {
      init: (i, { doc: o }) => wy({
        doc: o,
        name: e,
        lowlight: t,
        defaultLanguage: n
      }),
      apply: (i, o, s, a) => {
        const l = s.selection.$head.parent.type.name, u = a.selection.$head.parent.type.name, c = Dh(s.doc, (d) => d.type.name === e), f = Dh(a.doc, (d) => d.type.name === e);
        return i.docChanged && ([l, u].includes(e) || f.length !== c.length || i.steps.some((d) => (
          // @ts-ignore
          d.from !== void 0 && d.to !== void 0 && c.some((p) => (
            // @ts-ignore
            p.pos >= d.from && p.pos + p.node.nodeSize <= d.to
          ))
        ))) ? wy({
          doc: i.doc,
          name: e,
          lowlight: t,
          defaultLanguage: n
        }) : o.map(i.mapping, i.doc);
      }
    },
    props: {
      decorations(i) {
        return r.getState(i);
      }
    }
  });
  return r;
}
const xj = ww.extend({
  addOptions() {
    var e;
    return {
      ...(e = this.parent) === null || e === void 0 ? void 0 : e.call(this),
      lowlight: {},
      languageClassPrefix: "language-",
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      defaultLanguage: null,
      HTMLAttributes: {}
    };
  },
  addProseMirrorPlugins() {
    var e;
    return [
      ...((e = this.parent) === null || e === void 0 ? void 0 : e.call(this)) || [],
      wj({
        name: this.name,
        lowlight: this.options.lowlight,
        defaultLanguage: this.options.defaultLanguage
      })
    ];
  }
});
function kj(e) {
  const t = e.regex, n = e.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", i = "[a-zA-Z_]\\w*::", s = "(?!struct)(" + r + "|" + t.optional(i) + "[a-zA-Z_]\\w*" + t.optional("<[^<>]+>") + ")", a = {
    className: "type",
    begin: "\\b[a-z\\d_]*_t\\b"
  }, u = {
    className: "string",
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: "\\n",
        contains: [e.BACKSLASH_ESCAPE]
      },
      {
        begin: "(u8?|U|L)?'(" + "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)" + "|.)",
        end: "'",
        illegal: "."
      },
      e.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  }, c = {
    className: "number",
    variants: [
      { begin: "\\b(0b[01']+)" },
      { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)" },
      { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
    ],
    relevance: 0
  }, f = {
    className: "meta",
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      e.inherit(u, { className: "string" }),
      {
        className: "string",
        begin: /<.*?>/
      },
      n,
      e.C_BLOCK_COMMENT_MODE
    ]
  }, d = {
    className: "title",
    begin: t.optional(i) + e.IDENT_RE,
    relevance: 0
  }, p = t.optional(i) + e.IDENT_RE + "\\s*\\(", h = [
    "alignas",
    "alignof",
    "and",
    "and_eq",
    "asm",
    "atomic_cancel",
    "atomic_commit",
    "atomic_noexcept",
    "auto",
    "bitand",
    "bitor",
    "break",
    "case",
    "catch",
    "class",
    "co_await",
    "co_return",
    "co_yield",
    "compl",
    "concept",
    "const_cast|10",
    "consteval",
    "constexpr",
    "constinit",
    "continue",
    "decltype",
    "default",
    "delete",
    "do",
    "dynamic_cast|10",
    "else",
    "enum",
    "explicit",
    "export",
    "extern",
    "false",
    "final",
    "for",
    "friend",
    "goto",
    "if",
    "import",
    "inline",
    "module",
    "mutable",
    "namespace",
    "new",
    "noexcept",
    "not",
    "not_eq",
    "nullptr",
    "operator",
    "or",
    "or_eq",
    "override",
    "private",
    "protected",
    "public",
    "reflexpr",
    "register",
    "reinterpret_cast|10",
    "requires",
    "return",
    "sizeof",
    "static_assert",
    "static_cast|10",
    "struct",
    "switch",
    "synchronized",
    "template",
    "this",
    "thread_local",
    "throw",
    "transaction_safe",
    "transaction_safe_dynamic",
    "true",
    "try",
    "typedef",
    "typeid",
    "typename",
    "union",
    "using",
    "virtual",
    "volatile",
    "while",
    "xor",
    "xor_eq"
  ], m = [
    "bool",
    "char",
    "char16_t",
    "char32_t",
    "char8_t",
    "double",
    "float",
    "int",
    "long",
    "short",
    "void",
    "wchar_t",
    "unsigned",
    "signed",
    "const",
    "static"
  ], g = [
    "any",
    "auto_ptr",
    "barrier",
    "binary_semaphore",
    "bitset",
    "complex",
    "condition_variable",
    "condition_variable_any",
    "counting_semaphore",
    "deque",
    "false_type",
    "future",
    "imaginary",
    "initializer_list",
    "istringstream",
    "jthread",
    "latch",
    "lock_guard",
    "multimap",
    "multiset",
    "mutex",
    "optional",
    "ostringstream",
    "packaged_task",
    "pair",
    "promise",
    "priority_queue",
    "queue",
    "recursive_mutex",
    "recursive_timed_mutex",
    "scoped_lock",
    "set",
    "shared_future",
    "shared_lock",
    "shared_mutex",
    "shared_timed_mutex",
    "shared_ptr",
    "stack",
    "string_view",
    "stringstream",
    "timed_mutex",
    "thread",
    "true_type",
    "tuple",
    "unique_lock",
    "unique_ptr",
    "unordered_map",
    "unordered_multimap",
    "unordered_multiset",
    "unordered_set",
    "variant",
    "vector",
    "weak_ptr",
    "wstring",
    "wstring_view"
  ], y = [
    "abort",
    "abs",
    "acos",
    "apply",
    "as_const",
    "asin",
    "atan",
    "atan2",
    "calloc",
    "ceil",
    "cerr",
    "cin",
    "clog",
    "cos",
    "cosh",
    "cout",
    "declval",
    "endl",
    "exchange",
    "exit",
    "exp",
    "fabs",
    "floor",
    "fmod",
    "forward",
    "fprintf",
    "fputs",
    "free",
    "frexp",
    "fscanf",
    "future",
    "invoke",
    "isalnum",
    "isalpha",
    "iscntrl",
    "isdigit",
    "isgraph",
    "islower",
    "isprint",
    "ispunct",
    "isspace",
    "isupper",
    "isxdigit",
    "labs",
    "launder",
    "ldexp",
    "log",
    "log10",
    "make_pair",
    "make_shared",
    "make_shared_for_overwrite",
    "make_tuple",
    "make_unique",
    "malloc",
    "memchr",
    "memcmp",
    "memcpy",
    "memset",
    "modf",
    "move",
    "pow",
    "printf",
    "putchar",
    "puts",
    "realloc",
    "scanf",
    "sin",
    "sinh",
    "snprintf",
    "sprintf",
    "sqrt",
    "sscanf",
    "std",
    "stderr",
    "stdin",
    "stdout",
    "strcat",
    "strchr",
    "strcmp",
    "strcpy",
    "strcspn",
    "strlen",
    "strncat",
    "strncmp",
    "strncpy",
    "strpbrk",
    "strrchr",
    "strspn",
    "strstr",
    "swap",
    "tan",
    "tanh",
    "terminate",
    "to_underlying",
    "tolower",
    "toupper",
    "vfprintf",
    "visit",
    "vprintf",
    "vsprintf"
  ], v = {
    type: m,
    keyword: h,
    literal: [
      "NULL",
      "false",
      "nullopt",
      "nullptr",
      "true"
    ],
    built_in: ["_Pragma"],
    _type_hints: g
  }, M = {
    className: "function.dispatch",
    relevance: 0,
    keywords: {
      // Only for relevance, not highlighting.
      _hint: y
    },
    begin: t.concat(
      /\b/,
      /(?!decltype)/,
      /(?!if)/,
      /(?!for)/,
      /(?!switch)/,
      /(?!while)/,
      e.IDENT_RE,
      t.lookahead(/(<[^<>]+>|)\s*\(/)
    )
  }, k = [
    M,
    f,
    a,
    n,
    e.C_BLOCK_COMMENT_MODE,
    c,
    u
  ], T = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [
      {
        begin: /=/,
        end: /;/
      },
      {
        begin: /\(/,
        end: /\)/
      },
      {
        beginKeywords: "new throw return else",
        end: /;/
      }
    ],
    keywords: v,
    contains: k.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: v,
        contains: k.concat(["self"]),
        relevance: 0
      }
    ]),
    relevance: 0
  }, U = {
    className: "function",
    begin: "(" + s + "[\\*&\\s]+)+" + p,
    returnBegin: !0,
    end: /[{;=]/,
    excludeEnd: !0,
    keywords: v,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      {
        // to prevent it from being confused as the function title
        begin: r,
        keywords: v,
        relevance: 0
      },
      {
        begin: p,
        returnBegin: !0,
        contains: [d],
        relevance: 0
      },
      // needed because we do not have look-behind on the below rule
      // to prevent it from grabbing the final : in a :: pair
      {
        begin: /::/,
        relevance: 0
      },
      // initializers
      {
        begin: /:/,
        endsWithParent: !0,
        contains: [
          u,
          c
        ]
      },
      // allow for multiple declarations, e.g.:
      // extern void f(int), g(char);
      {
        relevance: 0,
        match: /,/
      },
      {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: v,
        relevance: 0,
        contains: [
          n,
          e.C_BLOCK_COMMENT_MODE,
          u,
          c,
          a,
          // Count matching parentheses.
          {
            begin: /\(/,
            end: /\)/,
            keywords: v,
            relevance: 0,
            contains: [
              "self",
              n,
              e.C_BLOCK_COMMENT_MODE,
              u,
              c,
              a
            ]
          }
        ]
      },
      a,
      n,
      e.C_BLOCK_COMMENT_MODE,
      f
    ]
  };
  return {
    name: "C++",
    aliases: [
      "cc",
      "c++",
      "h++",
      "hpp",
      "hh",
      "hxx",
      "cxx"
    ],
    keywords: v,
    illegal: "</",
    classNameAliases: { "function.dispatch": "built_in" },
    contains: [].concat(
      T,
      U,
      M,
      k,
      [
        f,
        {
          // containers: ie, `vector <int> rooms (9);`
          begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function)\\s*<(?!<)",
          end: ">",
          keywords: v,
          contains: [
            "self",
            a
          ]
        },
        {
          begin: e.IDENT_RE + "::",
          keywords: v
        },
        {
          match: [
            // extra complexity to deal with `enum class` and `enum struct`
            /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
            /\s+/,
            /\w+/
          ],
          className: {
            1: "keyword",
            3: "title.class"
          }
        }
      ]
    )
  };
}
function Mj(e) {
  const t = {
    type: [
      "boolean",
      "byte",
      "word",
      "String"
    ],
    built_in: [
      "KeyboardController",
      "MouseController",
      "SoftwareSerial",
      "EthernetServer",
      "EthernetClient",
      "LiquidCrystal",
      "RobotControl",
      "GSMVoiceCall",
      "EthernetUDP",
      "EsploraTFT",
      "HttpClient",
      "RobotMotor",
      "WiFiClient",
      "GSMScanner",
      "FileSystem",
      "Scheduler",
      "GSMServer",
      "YunClient",
      "YunServer",
      "IPAddress",
      "GSMClient",
      "GSMModem",
      "Keyboard",
      "Ethernet",
      "Console",
      "GSMBand",
      "Esplora",
      "Stepper",
      "Process",
      "WiFiUDP",
      "GSM_SMS",
      "Mailbox",
      "USBHost",
      "Firmata",
      "PImage",
      "Client",
      "Server",
      "GSMPIN",
      "FileIO",
      "Bridge",
      "Serial",
      "EEPROM",
      "Stream",
      "Mouse",
      "Audio",
      "Servo",
      "File",
      "Task",
      "GPRS",
      "WiFi",
      "Wire",
      "TFT",
      "GSM",
      "SPI",
      "SD"
    ],
    _hints: [
      "setup",
      "loop",
      "runShellCommandAsynchronously",
      "analogWriteResolution",
      "retrieveCallingNumber",
      "printFirmwareVersion",
      "analogReadResolution",
      "sendDigitalPortPair",
      "noListenOnLocalhost",
      "readJoystickButton",
      "setFirmwareVersion",
      "readJoystickSwitch",
      "scrollDisplayRight",
      "getVoiceCallStatus",
      "scrollDisplayLeft",
      "writeMicroseconds",
      "delayMicroseconds",
      "beginTransmission",
      "getSignalStrength",
      "runAsynchronously",
      "getAsynchronously",
      "listenOnLocalhost",
      "getCurrentCarrier",
      "readAccelerometer",
      "messageAvailable",
      "sendDigitalPorts",
      "lineFollowConfig",
      "countryNameWrite",
      "runShellCommand",
      "readStringUntil",
      "rewindDirectory",
      "readTemperature",
      "setClockDivider",
      "readLightSensor",
      "endTransmission",
      "analogReference",
      "detachInterrupt",
      "countryNameRead",
      "attachInterrupt",
      "encryptionType",
      "readBytesUntil",
      "robotNameWrite",
      "readMicrophone",
      "robotNameRead",
      "cityNameWrite",
      "userNameWrite",
      "readJoystickY",
      "readJoystickX",
      "mouseReleased",
      "openNextFile",
      "scanNetworks",
      "noInterrupts",
      "digitalWrite",
      "beginSpeaker",
      "mousePressed",
      "isActionDone",
      "mouseDragged",
      "displayLogos",
      "noAutoscroll",
      "addParameter",
      "remoteNumber",
      "getModifiers",
      "keyboardRead",
      "userNameRead",
      "waitContinue",
      "processInput",
      "parseCommand",
      "printVersion",
      "readNetworks",
      "writeMessage",
      "blinkVersion",
      "cityNameRead",
      "readMessage",
      "setDataMode",
      "parsePacket",
      "isListening",
      "setBitOrder",
      "beginPacket",
      "isDirectory",
      "motorsWrite",
      "drawCompass",
      "digitalRead",
      "clearScreen",
      "serialEvent",
      "rightToLeft",
      "setTextSize",
      "leftToRight",
      "requestFrom",
      "keyReleased",
      "compassRead",
      "analogWrite",
      "interrupts",
      "WiFiServer",
      "disconnect",
      "playMelody",
      "parseFloat",
      "autoscroll",
      "getPINUsed",
      "setPINUsed",
      "setTimeout",
      "sendAnalog",
      "readSlider",
      "analogRead",
      "beginWrite",
      "createChar",
      "motorsStop",
      "keyPressed",
      "tempoWrite",
      "readButton",
      "subnetMask",
      "debugPrint",
      "macAddress",
      "writeGreen",
      "randomSeed",
      "attachGPRS",
      "readString",
      "sendString",
      "remotePort",
      "releaseAll",
      "mouseMoved",
      "background",
      "getXChange",
      "getYChange",
      "answerCall",
      "getResult",
      "voiceCall",
      "endPacket",
      "constrain",
      "getSocket",
      "writeJSON",
      "getButton",
      "available",
      "connected",
      "findUntil",
      "readBytes",
      "exitValue",
      "readGreen",
      "writeBlue",
      "startLoop",
      "IPAddress",
      "isPressed",
      "sendSysex",
      "pauseMode",
      "gatewayIP",
      "setCursor",
      "getOemKey",
      "tuneWrite",
      "noDisplay",
      "loadImage",
      "switchPIN",
      "onRequest",
      "onReceive",
      "changePIN",
      "playFile",
      "noBuffer",
      "parseInt",
      "overflow",
      "checkPIN",
      "knobRead",
      "beginTFT",
      "bitClear",
      "updateIR",
      "bitWrite",
      "position",
      "writeRGB",
      "highByte",
      "writeRed",
      "setSpeed",
      "readBlue",
      "noStroke",
      "remoteIP",
      "transfer",
      "shutdown",
      "hangCall",
      "beginSMS",
      "endWrite",
      "attached",
      "maintain",
      "noCursor",
      "checkReg",
      "checkPUK",
      "shiftOut",
      "isValid",
      "shiftIn",
      "pulseIn",
      "connect",
      "println",
      "localIP",
      "pinMode",
      "getIMEI",
      "display",
      "noBlink",
      "process",
      "getBand",
      "running",
      "beginSD",
      "drawBMP",
      "lowByte",
      "setBand",
      "release",
      "bitRead",
      "prepare",
      "pointTo",
      "readRed",
      "setMode",
      "noFill",
      "remove",
      "listen",
      "stroke",
      "detach",
      "attach",
      "noTone",
      "exists",
      "buffer",
      "height",
      "bitSet",
      "circle",
      "config",
      "cursor",
      "random",
      "IRread",
      "setDNS",
      "endSMS",
      "getKey",
      "micros",
      "millis",
      "begin",
      "print",
      "write",
      "ready",
      "flush",
      "width",
      "isPIN",
      "blink",
      "clear",
      "press",
      "mkdir",
      "rmdir",
      "close",
      "point",
      "yield",
      "image",
      "BSSID",
      "click",
      "delay",
      "read",
      "text",
      "move",
      "peek",
      "beep",
      "rect",
      "line",
      "open",
      "seek",
      "fill",
      "size",
      "turn",
      "stop",
      "home",
      "find",
      "step",
      "tone",
      "sqrt",
      "RSSI",
      "SSID",
      "end",
      "bit",
      "tan",
      "cos",
      "sin",
      "pow",
      "map",
      "abs",
      "max",
      "min",
      "get",
      "run",
      "put"
    ],
    literal: [
      "DIGITAL_MESSAGE",
      "FIRMATA_STRING",
      "ANALOG_MESSAGE",
      "REPORT_DIGITAL",
      "REPORT_ANALOG",
      "INPUT_PULLUP",
      "SET_PIN_MODE",
      "INTERNAL2V56",
      "SYSTEM_RESET",
      "LED_BUILTIN",
      "INTERNAL1V1",
      "SYSEX_START",
      "INTERNAL",
      "EXTERNAL",
      "DEFAULT",
      "OUTPUT",
      "INPUT",
      "HIGH",
      "LOW"
    ]
  }, n = kj(e), r = (
    /** @type {Record<string,any>} */
    n.keywords
  );
  return r.type = [
    ...r.type,
    ...t.type
  ], r.literal = [
    ...r.literal,
    ...t.literal
  ], r.built_in = [
    ...r.built_in,
    ...t.built_in
  ], r._hints = t._hints, n.name = "Arduino", n.aliases = ["ino"], n.supersetOf = "cpp", n;
}
function Aj(e) {
  const t = e.regex, n = {}, r = {
    begin: /\$\{/,
    end: /\}/,
    contains: [
      "self",
      {
        begin: /:-/,
        contains: [n]
      }
      // default values
    ]
  };
  Object.assign(n, {
    className: "variable",
    variants: [
      { begin: t.concat(
        /\$[\w\d#@][\w\d_]*/,
        // negative look-ahead tries to avoid matching patterns that are not
        // Perl at all like $ident$, @ident@, etc.
        "(?![\\w\\d])(?![$])"
      ) },
      r
    ]
  });
  const i = {
    className: "subst",
    begin: /\$\(/,
    end: /\)/,
    contains: [e.BACKSLASH_ESCAPE]
  }, o = {
    begin: /<<-?\s*(?=\w+)/,
    starts: { contains: [
      e.END_SAME_AS_BEGIN({
        begin: /(\w+)/,
        end: /(\w+)/,
        className: "string"
      })
    ] }
  }, s = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      e.BACKSLASH_ESCAPE,
      n,
      i
    ]
  };
  i.contains.push(s);
  const a = {
    match: /\\"/
  }, l = {
    className: "string",
    begin: /'/,
    end: /'/
  }, u = {
    match: /\\'/
  }, c = {
    begin: /\$?\(\(/,
    end: /\)\)/,
    contains: [
      {
        begin: /\d+#[0-9a-f]+/,
        className: "number"
      },
      e.NUMBER_MODE,
      n
    ]
  }, f = [
    "fish",
    "bash",
    "zsh",
    "sh",
    "csh",
    "ksh",
    "tcsh",
    "dash",
    "scsh"
  ], d = e.SHEBANG({
    binary: `(${f.join("|")})`,
    relevance: 10
  }), p = {
    className: "function",
    begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
    returnBegin: !0,
    contains: [e.inherit(e.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
    relevance: 0
  }, h = [
    "if",
    "then",
    "else",
    "elif",
    "fi",
    "for",
    "while",
    "until",
    "in",
    "do",
    "done",
    "case",
    "esac",
    "function",
    "select"
  ], m = [
    "true",
    "false"
  ], g = { match: /(\/[a-z._-]+)+/ }, y = [
    "break",
    "cd",
    "continue",
    "eval",
    "exec",
    "exit",
    "export",
    "getopts",
    "hash",
    "pwd",
    "readonly",
    "return",
    "shift",
    "test",
    "times",
    "trap",
    "umask",
    "unset"
  ], _ = [
    "alias",
    "bind",
    "builtin",
    "caller",
    "command",
    "declare",
    "echo",
    "enable",
    "help",
    "let",
    "local",
    "logout",
    "mapfile",
    "printf",
    "read",
    "readarray",
    "source",
    "type",
    "typeset",
    "ulimit",
    "unalias"
  ], E = [
    "autoload",
    "bg",
    "bindkey",
    "bye",
    "cap",
    "chdir",
    "clone",
    "comparguments",
    "compcall",
    "compctl",
    "compdescribe",
    "compfiles",
    "compgroups",
    "compquote",
    "comptags",
    "comptry",
    "compvalues",
    "dirs",
    "disable",
    "disown",
    "echotc",
    "echoti",
    "emulate",
    "fc",
    "fg",
    "float",
    "functions",
    "getcap",
    "getln",
    "history",
    "integer",
    "jobs",
    "kill",
    "limit",
    "log",
    "noglob",
    "popd",
    "print",
    "pushd",
    "pushln",
    "rehash",
    "sched",
    "setcap",
    "setopt",
    "stat",
    "suspend",
    "ttyctl",
    "unfunction",
    "unhash",
    "unlimit",
    "unsetopt",
    "vared",
    "wait",
    "whence",
    "where",
    "which",
    "zcompile",
    "zformat",
    "zftp",
    "zle",
    "zmodload",
    "zparseopts",
    "zprof",
    "zpty",
    "zregexparse",
    "zsocket",
    "zstyle",
    "ztcp"
  ], v = [
    "chcon",
    "chgrp",
    "chown",
    "chmod",
    "cp",
    "dd",
    "df",
    "dir",
    "dircolors",
    "ln",
    "ls",
    "mkdir",
    "mkfifo",
    "mknod",
    "mktemp",
    "mv",
    "realpath",
    "rm",
    "rmdir",
    "shred",
    "sync",
    "touch",
    "truncate",
    "vdir",
    "b2sum",
    "base32",
    "base64",
    "cat",
    "cksum",
    "comm",
    "csplit",
    "cut",
    "expand",
    "fmt",
    "fold",
    "head",
    "join",
    "md5sum",
    "nl",
    "numfmt",
    "od",
    "paste",
    "ptx",
    "pr",
    "sha1sum",
    "sha224sum",
    "sha256sum",
    "sha384sum",
    "sha512sum",
    "shuf",
    "sort",
    "split",
    "sum",
    "tac",
    "tail",
    "tr",
    "tsort",
    "unexpand",
    "uniq",
    "wc",
    "arch",
    "basename",
    "chroot",
    "date",
    "dirname",
    "du",
    "echo",
    "env",
    "expr",
    "factor",
    // "false", // keyword literal already
    "groups",
    "hostid",
    "id",
    "link",
    "logname",
    "nice",
    "nohup",
    "nproc",
    "pathchk",
    "pinky",
    "printenv",
    "printf",
    "pwd",
    "readlink",
    "runcon",
    "seq",
    "sleep",
    "stat",
    "stdbuf",
    "stty",
    "tee",
    "test",
    "timeout",
    // "true", // keyword literal already
    "tty",
    "uname",
    "unlink",
    "uptime",
    "users",
    "who",
    "whoami",
    "yes"
  ];
  return {
    name: "Bash",
    aliases: ["sh"],
    keywords: {
      $pattern: /\b[a-z][a-z0-9._-]+\b/,
      keyword: h,
      literal: m,
      built_in: [
        ...y,
        ..._,
        // Shell modifiers
        "set",
        "shopt",
        ...E,
        ...v
      ]
    },
    contains: [
      d,
      // to catch known shells and boost relevancy
      e.SHEBANG(),
      // to catch unknown shells but still highlight the shebang
      p,
      c,
      e.HASH_COMMENT_MODE,
      o,
      g,
      s,
      a,
      l,
      u,
      n
    ]
  };
}
function Tj(e) {
  const t = e.regex, n = e.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", i = "[a-zA-Z_]\\w*::", s = "(" + r + "|" + t.optional(i) + "[a-zA-Z_]\\w*" + t.optional("<[^<>]+>") + ")", a = {
    className: "type",
    variants: [
      { begin: "\\b[a-z\\d_]*_t\\b" },
      { match: /\batomic_[a-z]{3,6}\b/ }
    ]
  }, u = {
    className: "string",
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: "\\n",
        contains: [e.BACKSLASH_ESCAPE]
      },
      {
        begin: "(u8?|U|L)?'(" + "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)" + "|.)",
        end: "'",
        illegal: "."
      },
      e.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  }, c = {
    className: "number",
    variants: [
      { begin: "\\b(0b[01']+)" },
      { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)" },
      { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
    ],
    relevance: 0
  }, f = {
    className: "meta",
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      e.inherit(u, { className: "string" }),
      {
        className: "string",
        begin: /<.*?>/
      },
      n,
      e.C_BLOCK_COMMENT_MODE
    ]
  }, d = {
    className: "title",
    begin: t.optional(i) + e.IDENT_RE,
    relevance: 0
  }, p = t.optional(i) + e.IDENT_RE + "\\s*\\(", g = {
    keyword: [
      "asm",
      "auto",
      "break",
      "case",
      "continue",
      "default",
      "do",
      "else",
      "enum",
      "extern",
      "for",
      "fortran",
      "goto",
      "if",
      "inline",
      "register",
      "restrict",
      "return",
      "sizeof",
      "struct",
      "switch",
      "typedef",
      "union",
      "volatile",
      "while",
      "_Alignas",
      "_Alignof",
      "_Atomic",
      "_Generic",
      "_Noreturn",
      "_Static_assert",
      "_Thread_local",
      // aliases
      "alignas",
      "alignof",
      "noreturn",
      "static_assert",
      "thread_local",
      // not a C keyword but is, for all intents and purposes, treated exactly like one.
      "_Pragma"
    ],
    type: [
      "float",
      "double",
      "signed",
      "unsigned",
      "int",
      "short",
      "long",
      "char",
      "void",
      "_Bool",
      "_Complex",
      "_Imaginary",
      "_Decimal32",
      "_Decimal64",
      "_Decimal128",
      // modifiers
      "const",
      "static",
      // aliases
      "complex",
      "bool",
      "imaginary"
    ],
    literal: "true false NULL",
    // TODO: apply hinting work similar to what was done in cpp.js
    built_in: "std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr"
  }, y = [
    f,
    a,
    n,
    e.C_BLOCK_COMMENT_MODE,
    c,
    u
  ], _ = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [
      {
        begin: /=/,
        end: /;/
      },
      {
        begin: /\(/,
        end: /\)/
      },
      {
        beginKeywords: "new throw return else",
        end: /;/
      }
    ],
    keywords: g,
    contains: y.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: g,
        contains: y.concat(["self"]),
        relevance: 0
      }
    ]),
    relevance: 0
  }, E = {
    begin: "(" + s + "[\\*&\\s]+)+" + p,
    returnBegin: !0,
    end: /[{;=]/,
    excludeEnd: !0,
    keywords: g,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      {
        // to prevent it from being confused as the function title
        begin: r,
        keywords: g,
        relevance: 0
      },
      {
        begin: p,
        returnBegin: !0,
        contains: [e.inherit(d, { className: "title.function" })],
        relevance: 0
      },
      // allow for multiple declarations, e.g.:
      // extern void f(int), g(char);
      {
        relevance: 0,
        match: /,/
      },
      {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: g,
        relevance: 0,
        contains: [
          n,
          e.C_BLOCK_COMMENT_MODE,
          u,
          c,
          a,
          // Count matching parentheses.
          {
            begin: /\(/,
            end: /\)/,
            keywords: g,
            relevance: 0,
            contains: [
              "self",
              n,
              e.C_BLOCK_COMMENT_MODE,
              u,
              c,
              a
            ]
          }
        ]
      },
      a,
      n,
      e.C_BLOCK_COMMENT_MODE,
      f
    ]
  };
  return {
    name: "C",
    aliases: ["h"],
    keywords: g,
    // Until differentiations are added between `c` and `cpp`, `c` will
    // not be auto-detected to avoid auto-detect conflicts between C and C++
    disableAutodetect: !0,
    illegal: "</",
    contains: [].concat(
      _,
      E,
      y,
      [
        f,
        {
          begin: e.IDENT_RE + "::",
          keywords: g
        },
        {
          className: "class",
          beginKeywords: "enum class struct union",
          end: /[{;:<>=]/,
          contains: [
            { beginKeywords: "final class struct" },
            e.TITLE_MODE
          ]
        }
      ]
    ),
    exports: {
      preprocessor: f,
      strings: u,
      keywords: g
    }
  };
}
function Sj(e) {
  const t = e.regex, n = e.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", i = "[a-zA-Z_]\\w*::", s = "(?!struct)(" + r + "|" + t.optional(i) + "[a-zA-Z_]\\w*" + t.optional("<[^<>]+>") + ")", a = {
    className: "type",
    begin: "\\b[a-z\\d_]*_t\\b"
  }, u = {
    className: "string",
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: "\\n",
        contains: [e.BACKSLASH_ESCAPE]
      },
      {
        begin: "(u8?|U|L)?'(" + "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)" + "|.)",
        end: "'",
        illegal: "."
      },
      e.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  }, c = {
    className: "number",
    variants: [
      { begin: "\\b(0b[01']+)" },
      { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)" },
      { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
    ],
    relevance: 0
  }, f = {
    className: "meta",
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      e.inherit(u, { className: "string" }),
      {
        className: "string",
        begin: /<.*?>/
      },
      n,
      e.C_BLOCK_COMMENT_MODE
    ]
  }, d = {
    className: "title",
    begin: t.optional(i) + e.IDENT_RE,
    relevance: 0
  }, p = t.optional(i) + e.IDENT_RE + "\\s*\\(", h = [
    "alignas",
    "alignof",
    "and",
    "and_eq",
    "asm",
    "atomic_cancel",
    "atomic_commit",
    "atomic_noexcept",
    "auto",
    "bitand",
    "bitor",
    "break",
    "case",
    "catch",
    "class",
    "co_await",
    "co_return",
    "co_yield",
    "compl",
    "concept",
    "const_cast|10",
    "consteval",
    "constexpr",
    "constinit",
    "continue",
    "decltype",
    "default",
    "delete",
    "do",
    "dynamic_cast|10",
    "else",
    "enum",
    "explicit",
    "export",
    "extern",
    "false",
    "final",
    "for",
    "friend",
    "goto",
    "if",
    "import",
    "inline",
    "module",
    "mutable",
    "namespace",
    "new",
    "noexcept",
    "not",
    "not_eq",
    "nullptr",
    "operator",
    "or",
    "or_eq",
    "override",
    "private",
    "protected",
    "public",
    "reflexpr",
    "register",
    "reinterpret_cast|10",
    "requires",
    "return",
    "sizeof",
    "static_assert",
    "static_cast|10",
    "struct",
    "switch",
    "synchronized",
    "template",
    "this",
    "thread_local",
    "throw",
    "transaction_safe",
    "transaction_safe_dynamic",
    "true",
    "try",
    "typedef",
    "typeid",
    "typename",
    "union",
    "using",
    "virtual",
    "volatile",
    "while",
    "xor",
    "xor_eq"
  ], m = [
    "bool",
    "char",
    "char16_t",
    "char32_t",
    "char8_t",
    "double",
    "float",
    "int",
    "long",
    "short",
    "void",
    "wchar_t",
    "unsigned",
    "signed",
    "const",
    "static"
  ], g = [
    "any",
    "auto_ptr",
    "barrier",
    "binary_semaphore",
    "bitset",
    "complex",
    "condition_variable",
    "condition_variable_any",
    "counting_semaphore",
    "deque",
    "false_type",
    "future",
    "imaginary",
    "initializer_list",
    "istringstream",
    "jthread",
    "latch",
    "lock_guard",
    "multimap",
    "multiset",
    "mutex",
    "optional",
    "ostringstream",
    "packaged_task",
    "pair",
    "promise",
    "priority_queue",
    "queue",
    "recursive_mutex",
    "recursive_timed_mutex",
    "scoped_lock",
    "set",
    "shared_future",
    "shared_lock",
    "shared_mutex",
    "shared_timed_mutex",
    "shared_ptr",
    "stack",
    "string_view",
    "stringstream",
    "timed_mutex",
    "thread",
    "true_type",
    "tuple",
    "unique_lock",
    "unique_ptr",
    "unordered_map",
    "unordered_multimap",
    "unordered_multiset",
    "unordered_set",
    "variant",
    "vector",
    "weak_ptr",
    "wstring",
    "wstring_view"
  ], y = [
    "abort",
    "abs",
    "acos",
    "apply",
    "as_const",
    "asin",
    "atan",
    "atan2",
    "calloc",
    "ceil",
    "cerr",
    "cin",
    "clog",
    "cos",
    "cosh",
    "cout",
    "declval",
    "endl",
    "exchange",
    "exit",
    "exp",
    "fabs",
    "floor",
    "fmod",
    "forward",
    "fprintf",
    "fputs",
    "free",
    "frexp",
    "fscanf",
    "future",
    "invoke",
    "isalnum",
    "isalpha",
    "iscntrl",
    "isdigit",
    "isgraph",
    "islower",
    "isprint",
    "ispunct",
    "isspace",
    "isupper",
    "isxdigit",
    "labs",
    "launder",
    "ldexp",
    "log",
    "log10",
    "make_pair",
    "make_shared",
    "make_shared_for_overwrite",
    "make_tuple",
    "make_unique",
    "malloc",
    "memchr",
    "memcmp",
    "memcpy",
    "memset",
    "modf",
    "move",
    "pow",
    "printf",
    "putchar",
    "puts",
    "realloc",
    "scanf",
    "sin",
    "sinh",
    "snprintf",
    "sprintf",
    "sqrt",
    "sscanf",
    "std",
    "stderr",
    "stdin",
    "stdout",
    "strcat",
    "strchr",
    "strcmp",
    "strcpy",
    "strcspn",
    "strlen",
    "strncat",
    "strncmp",
    "strncpy",
    "strpbrk",
    "strrchr",
    "strspn",
    "strstr",
    "swap",
    "tan",
    "tanh",
    "terminate",
    "to_underlying",
    "tolower",
    "toupper",
    "vfprintf",
    "visit",
    "vprintf",
    "vsprintf"
  ], v = {
    type: m,
    keyword: h,
    literal: [
      "NULL",
      "false",
      "nullopt",
      "nullptr",
      "true"
    ],
    built_in: ["_Pragma"],
    _type_hints: g
  }, M = {
    className: "function.dispatch",
    relevance: 0,
    keywords: {
      // Only for relevance, not highlighting.
      _hint: y
    },
    begin: t.concat(
      /\b/,
      /(?!decltype)/,
      /(?!if)/,
      /(?!for)/,
      /(?!switch)/,
      /(?!while)/,
      e.IDENT_RE,
      t.lookahead(/(<[^<>]+>|)\s*\(/)
    )
  }, k = [
    M,
    f,
    a,
    n,
    e.C_BLOCK_COMMENT_MODE,
    c,
    u
  ], T = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [
      {
        begin: /=/,
        end: /;/
      },
      {
        begin: /\(/,
        end: /\)/
      },
      {
        beginKeywords: "new throw return else",
        end: /;/
      }
    ],
    keywords: v,
    contains: k.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: v,
        contains: k.concat(["self"]),
        relevance: 0
      }
    ]),
    relevance: 0
  }, U = {
    className: "function",
    begin: "(" + s + "[\\*&\\s]+)+" + p,
    returnBegin: !0,
    end: /[{;=]/,
    excludeEnd: !0,
    keywords: v,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      {
        // to prevent it from being confused as the function title
        begin: r,
        keywords: v,
        relevance: 0
      },
      {
        begin: p,
        returnBegin: !0,
        contains: [d],
        relevance: 0
      },
      // needed because we do not have look-behind on the below rule
      // to prevent it from grabbing the final : in a :: pair
      {
        begin: /::/,
        relevance: 0
      },
      // initializers
      {
        begin: /:/,
        endsWithParent: !0,
        contains: [
          u,
          c
        ]
      },
      // allow for multiple declarations, e.g.:
      // extern void f(int), g(char);
      {
        relevance: 0,
        match: /,/
      },
      {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: v,
        relevance: 0,
        contains: [
          n,
          e.C_BLOCK_COMMENT_MODE,
          u,
          c,
          a,
          // Count matching parentheses.
          {
            begin: /\(/,
            end: /\)/,
            keywords: v,
            relevance: 0,
            contains: [
              "self",
              n,
              e.C_BLOCK_COMMENT_MODE,
              u,
              c,
              a
            ]
          }
        ]
      },
      a,
      n,
      e.C_BLOCK_COMMENT_MODE,
      f
    ]
  };
  return {
    name: "C++",
    aliases: [
      "cc",
      "c++",
      "h++",
      "hpp",
      "hh",
      "hxx",
      "cxx"
    ],
    keywords: v,
    illegal: "</",
    classNameAliases: { "function.dispatch": "built_in" },
    contains: [].concat(
      T,
      U,
      M,
      k,
      [
        f,
        {
          // containers: ie, `vector <int> rooms (9);`
          begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function)\\s*<(?!<)",
          end: ">",
          keywords: v,
          contains: [
            "self",
            a
          ]
        },
        {
          begin: e.IDENT_RE + "::",
          keywords: v
        },
        {
          match: [
            // extra complexity to deal with `enum class` and `enum struct`
            /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
            /\s+/,
            /\w+/
          ],
          className: {
            1: "keyword",
            3: "title.class"
          }
        }
      ]
    )
  };
}
function Cj(e) {
  const t = [
    "bool",
    "byte",
    "char",
    "decimal",
    "delegate",
    "double",
    "dynamic",
    "enum",
    "float",
    "int",
    "long",
    "nint",
    "nuint",
    "object",
    "sbyte",
    "short",
    "string",
    "ulong",
    "uint",
    "ushort"
  ], n = [
    "public",
    "private",
    "protected",
    "static",
    "internal",
    "protected",
    "abstract",
    "async",
    "extern",
    "override",
    "unsafe",
    "virtual",
    "new",
    "sealed",
    "partial"
  ], r = [
    "default",
    "false",
    "null",
    "true"
  ], i = [
    "abstract",
    "as",
    "base",
    "break",
    "case",
    "catch",
    "class",
    "const",
    "continue",
    "do",
    "else",
    "event",
    "explicit",
    "extern",
    "finally",
    "fixed",
    "for",
    "foreach",
    "goto",
    "if",
    "implicit",
    "in",
    "interface",
    "internal",
    "is",
    "lock",
    "namespace",
    "new",
    "operator",
    "out",
    "override",
    "params",
    "private",
    "protected",
    "public",
    "readonly",
    "record",
    "ref",
    "return",
    "scoped",
    "sealed",
    "sizeof",
    "stackalloc",
    "static",
    "struct",
    "switch",
    "this",
    "throw",
    "try",
    "typeof",
    "unchecked",
    "unsafe",
    "using",
    "virtual",
    "void",
    "volatile",
    "while"
  ], o = [
    "add",
    "alias",
    "and",
    "ascending",
    "async",
    "await",
    "by",
    "descending",
    "equals",
    "from",
    "get",
    "global",
    "group",
    "init",
    "into",
    "join",
    "let",
    "nameof",
    "not",
    "notnull",
    "on",
    "or",
    "orderby",
    "partial",
    "remove",
    "select",
    "set",
    "unmanaged",
    "value|0",
    "var",
    "when",
    "where",
    "with",
    "yield"
  ], s = {
    keyword: i.concat(o),
    built_in: t,
    literal: r
  }, a = e.inherit(e.TITLE_MODE, { begin: "[a-zA-Z](\\.?\\w)*" }), l = {
    className: "number",
    variants: [
      { begin: "\\b(0b[01']+)" },
      { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)" },
      { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
    ],
    relevance: 0
  }, u = {
    className: "string",
    begin: '@"',
    end: '"',
    contains: [{ begin: '""' }]
  }, c = e.inherit(u, { illegal: /\n/ }), f = {
    className: "subst",
    begin: /\{/,
    end: /\}/,
    keywords: s
  }, d = e.inherit(f, { illegal: /\n/ }), p = {
    className: "string",
    begin: /\$"/,
    end: '"',
    illegal: /\n/,
    contains: [
      { begin: /\{\{/ },
      { begin: /\}\}/ },
      e.BACKSLASH_ESCAPE,
      d
    ]
  }, h = {
    className: "string",
    begin: /\$@"/,
    end: '"',
    contains: [
      { begin: /\{\{/ },
      { begin: /\}\}/ },
      { begin: '""' },
      f
    ]
  }, m = e.inherit(h, {
    illegal: /\n/,
    contains: [
      { begin: /\{\{/ },
      { begin: /\}\}/ },
      { begin: '""' },
      d
    ]
  });
  f.contains = [
    h,
    p,
    u,
    e.APOS_STRING_MODE,
    e.QUOTE_STRING_MODE,
    l,
    e.C_BLOCK_COMMENT_MODE
  ], d.contains = [
    m,
    p,
    c,
    e.APOS_STRING_MODE,
    e.QUOTE_STRING_MODE,
    l,
    e.inherit(e.C_BLOCK_COMMENT_MODE, { illegal: /\n/ })
  ];
  const g = { variants: [
    h,
    p,
    u,
    e.APOS_STRING_MODE,
    e.QUOTE_STRING_MODE
  ] }, y = {
    begin: "<",
    end: ">",
    contains: [
      { beginKeywords: "in out" },
      a
    ]
  }, _ = e.IDENT_RE + "(<" + e.IDENT_RE + "(\\s*,\\s*" + e.IDENT_RE + ")*>)?(\\[\\])?", E = {
    // prevents expressions like `@class` from incorrect flagging
    // `class` as a keyword
    begin: "@" + e.IDENT_RE,
    relevance: 0
  };
  return {
    name: "C#",
    aliases: [
      "cs",
      "c#"
    ],
    keywords: s,
    illegal: /::/,
    contains: [
      e.COMMENT(
        "///",
        "$",
        {
          returnBegin: !0,
          contains: [
            {
              className: "doctag",
              variants: [
                {
                  begin: "///",
                  relevance: 0
                },
                { begin: "<!--|-->" },
                {
                  begin: "</?",
                  end: ">"
                }
              ]
            }
          ]
        }
      ),
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE,
      {
        className: "meta",
        begin: "#",
        end: "$",
        keywords: { keyword: "if else elif endif define undef warning error line region endregion pragma checksum" }
      },
      g,
      l,
      {
        beginKeywords: "class interface",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:,]/,
        contains: [
          { beginKeywords: "where class" },
          a,
          y,
          e.C_LINE_COMMENT_MODE,
          e.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        beginKeywords: "namespace",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:]/,
        contains: [
          a,
          e.C_LINE_COMMENT_MODE,
          e.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        beginKeywords: "record",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:]/,
        contains: [
          a,
          y,
          e.C_LINE_COMMENT_MODE,
          e.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        // [Attributes("")]
        className: "meta",
        begin: "^\\s*\\[(?=[\\w])",
        excludeBegin: !0,
        end: "\\]",
        excludeEnd: !0,
        contains: [
          {
            className: "string",
            begin: /"/,
            end: /"/
          }
        ]
      },
      {
        // Expression keywords prevent 'keyword Name(...)' from being
        // recognized as a function definition
        beginKeywords: "new return throw await else",
        relevance: 0
      },
      {
        className: "function",
        begin: "(" + _ + "\\s+)+" + e.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
        returnBegin: !0,
        end: /\s*[{;=]/,
        excludeEnd: !0,
        keywords: s,
        contains: [
          // prevents these from being highlighted `title`
          {
            beginKeywords: n.join(" "),
            relevance: 0
          },
          {
            begin: e.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
            returnBegin: !0,
            contains: [
              e.TITLE_MODE,
              y
            ],
            relevance: 0
          },
          { match: /\(\)/ },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            excludeBegin: !0,
            excludeEnd: !0,
            keywords: s,
            relevance: 0,
            contains: [
              g,
              l,
              e.C_BLOCK_COMMENT_MODE
            ]
          },
          e.C_LINE_COMMENT_MODE,
          e.C_BLOCK_COMMENT_MODE
        ]
      },
      E
    ]
  };
}
const Nj = (e) => ({
  IMPORTANT: {
    scope: "meta",
    begin: "!important"
  },
  BLOCK_COMMENT: e.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: "number",
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: {
    className: "built_in",
    begin: /[\w-]+(?=\()/
  },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: "selector-attr",
    begin: /\[/,
    end: /\]/,
    illegal: "$",
    contains: [
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE
    ]
  },
  CSS_NUMBER_MODE: {
    scope: "number",
    begin: e.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  },
  CSS_VARIABLE: {
    className: "attr",
    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
  }
}), Dj = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "p",
  "q",
  "quote",
  "samp",
  "section",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
], Oj = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
], Ij = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
], Rj = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
], Lj = [
  "align-content",
  "align-items",
  "align-self",
  "all",
  "animation",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-timing-function",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-repeat",
  "background-size",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-decoration-break",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "direction",
  "display",
  "empty-cells",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-size",
  "font-size-adjust",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-variant",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "gap",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "inline-size",
  "isolation",
  "justify-content",
  "left",
  "letter-spacing",
  "line-break",
  "line-height",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "pointer-events",
  "position",
  "quotes",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "row-gap",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-style",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-transform",
  "text-underline-position",
  "top",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "unicode-bidi",
  "vertical-align",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "z-index"
  // reverse makes sure longer attributes `font-weight` are matched fully
  // instead of getting false positives on say `font`
].reverse();
function Bj(e) {
  const t = e.regex, n = Nj(e), r = { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ }, i = "and or not only", o = /@-?\w[\w]*(-\w+)*/, s = "[a-zA-Z-][a-zA-Z0-9_-]*", a = [
    e.APOS_STRING_MODE,
    e.QUOTE_STRING_MODE
  ];
  return {
    name: "CSS",
    case_insensitive: !0,
    illegal: /[=|'\$]/,
    keywords: { keyframePosition: "from to" },
    classNameAliases: {
      // for visual continuity with `tag {}` and because we
      // don't have a great class for this?
      keyframePosition: "selector-tag"
    },
    contains: [
      n.BLOCK_COMMENT,
      r,
      // to recognize keyframe 40% etc which are outside the scope of our
      // attribute value mode
      n.CSS_NUMBER_MODE,
      {
        className: "selector-id",
        begin: /#[A-Za-z0-9_-]+/,
        relevance: 0
      },
      {
        className: "selector-class",
        begin: "\\." + s,
        relevance: 0
      },
      n.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-pseudo",
        variants: [
          { begin: ":(" + Ij.join("|") + ")" },
          { begin: ":(:)?(" + Rj.join("|") + ")" }
        ]
      },
      // we may actually need this (12/2020)
      // { // pseudo-selector params
      //   begin: /\(/,
      //   end: /\)/,
      //   contains: [ hljs.CSS_NUMBER_MODE ]
      // },
      n.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + Lj.join("|") + ")\\b"
      },
      // attribute values
      {
        begin: /:/,
        end: /[;}{]/,
        contains: [
          n.BLOCK_COMMENT,
          n.HEXCOLOR,
          n.IMPORTANT,
          n.CSS_NUMBER_MODE,
          ...a,
          // needed to highlight these as strings and to avoid issues with
          // illegal characters that might be inside urls that would tigger the
          // languages illegal stack
          {
            begin: /(url|data-uri)\(/,
            end: /\)/,
            relevance: 0,
            // from keywords
            keywords: { built_in: "url data-uri" },
            contains: [
              ...a,
              {
                className: "string",
                // any character other than `)` as in `url()` will be the start
                // of a string, which ends with `)` (from the parent mode)
                begin: /[^)]/,
                endsWithParent: !0,
                excludeEnd: !0
              }
            ]
          },
          n.FUNCTION_DISPATCH
        ]
      },
      {
        begin: t.lookahead(/@/),
        end: "[{;]",
        relevance: 0,
        illegal: /:/,
        // break on Less variables @var: ...
        contains: [
          {
            className: "keyword",
            begin: o
          },
          {
            begin: /\s/,
            endsWithParent: !0,
            excludeEnd: !0,
            relevance: 0,
            keywords: {
              $pattern: /[a-z-]+/,
              keyword: i,
              attribute: Oj.join(" ")
            },
            contains: [
              {
                begin: /[a-z-]+(?=:)/,
                className: "attribute"
              },
              ...a,
              n.CSS_NUMBER_MODE
            ]
          }
        ]
      },
      {
        className: "selector-tag",
        begin: "\\b(" + Dj.join("|") + ")\\b"
      }
    ]
  };
}
function Pj(e) {
  const t = e.regex;
  return {
    name: "Diff",
    aliases: ["patch"],
    contains: [
      {
        className: "meta",
        relevance: 10,
        match: t.either(
          /^@@ +-\d+,\d+ +\+\d+,\d+ +@@/,
          /^\*\*\* +\d+,\d+ +\*\*\*\*$/,
          /^--- +\d+,\d+ +----$/
        )
      },
      {
        className: "comment",
        variants: [
          {
            begin: t.either(
              /Index: /,
              /^index/,
              /={3,}/,
              /^-{3}/,
              /^\*{3} /,
              /^\+{3}/,
              /^diff --git/
            ),
            end: /$/
          },
          { match: /^\*{15}$/ }
        ]
      },
      {
        className: "addition",
        begin: /^\+/,
        end: /$/
      },
      {
        className: "deletion",
        begin: /^-/,
        end: /$/
      },
      {
        className: "addition",
        begin: /^!/,
        end: /$/
      }
    ]
  };
}
function $j(e) {
  const o = {
    keyword: [
      "break",
      "case",
      "chan",
      "const",
      "continue",
      "default",
      "defer",
      "else",
      "fallthrough",
      "for",
      "func",
      "go",
      "goto",
      "if",
      "import",
      "interface",
      "map",
      "package",
      "range",
      "return",
      "select",
      "struct",
      "switch",
      "type",
      "var"
    ],
    type: [
      "bool",
      "byte",
      "complex64",
      "complex128",
      "error",
      "float32",
      "float64",
      "int8",
      "int16",
      "int32",
      "int64",
      "string",
      "uint8",
      "uint16",
      "uint32",
      "uint64",
      "int",
      "uint",
      "uintptr",
      "rune"
    ],
    literal: [
      "true",
      "false",
      "iota",
      "nil"
    ],
    built_in: [
      "append",
      "cap",
      "close",
      "complex",
      "copy",
      "imag",
      "len",
      "make",
      "new",
      "panic",
      "print",
      "println",
      "real",
      "recover",
      "delete"
    ]
  };
  return {
    name: "Go",
    aliases: ["golang"],
    keywords: o,
    illegal: "</",
    contains: [
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE,
      {
        className: "string",
        variants: [
          e.QUOTE_STRING_MODE,
          e.APOS_STRING_MODE,
          {
            begin: "`",
            end: "`"
          }
        ]
      },
      {
        className: "number",
        variants: [
          {
            begin: e.C_NUMBER_RE + "[i]",
            relevance: 1
          },
          e.C_NUMBER_MODE
        ]
      },
      {
        begin: /:=/
        // relevance booster
      },
      {
        className: "function",
        beginKeywords: "func",
        end: "\\s*(\\{|$)",
        excludeEnd: !0,
        contains: [
          e.TITLE_MODE,
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            endsParent: !0,
            keywords: o,
            illegal: /["']/
          }
        ]
      }
    ]
  };
}
function zj(e) {
  const t = e.regex, n = /[_A-Za-z][_0-9A-Za-z]*/;
  return {
    name: "GraphQL",
    aliases: ["gql"],
    case_insensitive: !0,
    disableAutodetect: !1,
    keywords: {
      keyword: [
        "query",
        "mutation",
        "subscription",
        "type",
        "input",
        "schema",
        "directive",
        "interface",
        "union",
        "scalar",
        "fragment",
        "enum",
        "on"
      ],
      literal: [
        "true",
        "false",
        "null"
      ]
    },
    contains: [
      e.HASH_COMMENT_MODE,
      e.QUOTE_STRING_MODE,
      e.NUMBER_MODE,
      {
        scope: "punctuation",
        match: /[.]{3}/,
        relevance: 0
      },
      {
        scope: "punctuation",
        begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/,
        relevance: 0
      },
      {
        scope: "variable",
        begin: /\$/,
        end: /\W/,
        excludeEnd: !0,
        relevance: 0
      },
      {
        scope: "meta",
        match: /@\w+/,
        excludeEnd: !0
      },
      {
        scope: "symbol",
        begin: t.concat(n, t.lookahead(/\s*:/)),
        relevance: 0
      }
    ],
    illegal: [
      /[;<']/,
      /BEGIN/
    ]
  };
}
function Fj(e) {
  const t = e.regex, n = {
    className: "number",
    relevance: 0,
    variants: [
      { begin: /([+-]+)?[\d]+_[\d_]+/ },
      { begin: e.NUMBER_RE }
    ]
  }, r = e.COMMENT();
  r.variants = [
    {
      begin: /;/,
      end: /$/
    },
    {
      begin: /#/,
      end: /$/
    }
  ];
  const i = {
    className: "variable",
    variants: [
      { begin: /\$[\w\d"][\w\d_]*/ },
      { begin: /\$\{(.*?)\}/ }
    ]
  }, o = {
    className: "literal",
    begin: /\bon|off|true|false|yes|no\b/
  }, s = {
    className: "string",
    contains: [e.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: "'''",
        end: "'''",
        relevance: 10
      },
      {
        begin: '"""',
        end: '"""',
        relevance: 10
      },
      {
        begin: '"',
        end: '"'
      },
      {
        begin: "'",
        end: "'"
      }
    ]
  }, a = {
    begin: /\[/,
    end: /\]/,
    contains: [
      r,
      o,
      i,
      s,
      n,
      "self"
    ],
    relevance: 0
  }, l = /[A-Za-z0-9_-]+/, u = /"(\\"|[^"])*"/, c = /'[^']*'/, f = t.either(
    l,
    u,
    c
  ), d = t.concat(
    f,
    "(\\s*\\.\\s*",
    f,
    ")*",
    t.lookahead(/\s*=\s*[^#\s]/)
  );
  return {
    name: "TOML, also INI",
    aliases: ["toml"],
    case_insensitive: !0,
    illegal: /\S/,
    contains: [
      r,
      {
        className: "section",
        begin: /\[+/,
        end: /\]+/
      },
      {
        begin: d,
        className: "attr",
        starts: {
          end: /$/,
          contains: [
            r,
            a,
            o,
            i,
            s,
            n
          ]
        }
      }
    ]
  };
}
var es = "[0-9](_*[0-9])*", Au = `\\.(${es})`, Tu = "[0-9a-fA-F](_*[0-9a-fA-F])*", xy = {
  className: "number",
  variants: [
    // DecimalFloatingPointLiteral
    // including ExponentPart
    { begin: `(\\b(${es})((${Au})|\\.)?|(${Au}))[eE][+-]?(${es})[fFdD]?\\b` },
    // excluding ExponentPart
    { begin: `\\b(${es})((${Au})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
    { begin: `(${Au})[fFdD]?\\b` },
    { begin: `\\b(${es})[fFdD]\\b` },
    // HexadecimalFloatingPointLiteral
    { begin: `\\b0[xX]((${Tu})\\.?|(${Tu})?\\.(${Tu}))[pP][+-]?(${es})[fFdD]?\\b` },
    // DecimalIntegerLiteral
    { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
    // HexIntegerLiteral
    { begin: `\\b0[xX](${Tu})[lL]?\\b` },
    // OctalIntegerLiteral
    { begin: "\\b0(_*[0-7])*[lL]?\\b" },
    // BinaryIntegerLiteral
    { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
  ],
  relevance: 0
};
function wx(e, t, n) {
  return n === -1 ? "" : e.replace(t, (r) => wx(e, t, n - 1));
}
function jj(e) {
  const t = e.regex, n = "[-a-zA-Z_$][-a-zA-Z_$0-9]*", r = n + wx("(?:<" + n + "~~~(?:\\s*,\\s*" + n + "~~~)*>)?", /~~~/g, 2), l = {
    keyword: [
      "synchronized",
      "abstract",
      "private",
      "var",
      "static",
      "if",
      "const ",
      "for",
      "while",
      "strictfp",
      "finally",
      "protected",
      "import",
      "native",
      "final",
      "void",
      "enum",
      "else",
      "break",
      "transient",
      "catch",
      "instanceof",
      "volatile",
      "case",
      "assert",
      "package",
      "default",
      "public",
      "try",
      "switch",
      "continue",
      "throws",
      "protected",
      "public",
      "private",
      "module",
      "requires",
      "exports",
      "do",
      "sealed",
      "yield",
      "permits"
    ],
    literal: [
      "false",
      "true",
      "null"
    ],
    type: [
      "char",
      "boolean",
      "long",
      "float",
      "int",
      "byte",
      "short",
      "double"
    ],
    built_in: [
      "super",
      "this"
    ]
  }, u = {
    className: "meta",
    begin: "@" + n,
    contains: [
      {
        begin: /\(/,
        end: /\)/,
        contains: ["self"]
        // allow nested () inside our annotation
      }
    ]
  }, c = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    keywords: l,
    relevance: 0,
    contains: [e.C_BLOCK_COMMENT_MODE],
    endsParent: !0
  };
  return {
    name: "Java",
    aliases: ["jsp"],
    keywords: l,
    illegal: /<\/|#/,
    contains: [
      e.COMMENT(
        "/\\*\\*",
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              // eat up @'s in emails to prevent them to be recognized as doctags
              begin: /\w+@/,
              relevance: 0
            },
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            }
          ]
        }
      ),
      // relevance boost
      {
        begin: /import java\.[a-z]+\./,
        keywords: "import",
        relevance: 2
      },
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE,
      {
        begin: /"""/,
        end: /"""/,
        className: "string",
        contains: [e.BACKSLASH_ESCAPE]
      },
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE,
      {
        match: [
          /\b(?:class|interface|enum|extends|implements|new)/,
          /\s+/,
          n
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        // Exceptions for hyphenated keywords
        match: /non-sealed/,
        scope: "keyword"
      },
      {
        begin: [
          t.concat(/(?!else)/, n),
          /\s+/,
          n,
          /\s+/,
          /=(?!=)/
        ],
        className: {
          1: "type",
          3: "variable",
          5: "operator"
        }
      },
      {
        begin: [
          /record/,
          /\s+/,
          n
        ],
        className: {
          1: "keyword",
          3: "title.class"
        },
        contains: [
          c,
          e.C_LINE_COMMENT_MODE,
          e.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        // Expression keywords prevent 'keyword Name(...)' from being
        // recognized as a function definition
        beginKeywords: "new throw return else",
        relevance: 0
      },
      {
        begin: [
          "(?:" + r + "\\s+)",
          e.UNDERSCORE_IDENT_RE,
          /\s*(?=\()/
        ],
        className: { 2: "title.function" },
        keywords: l,
        contains: [
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: l,
            relevance: 0,
            contains: [
              u,
              e.APOS_STRING_MODE,
              e.QUOTE_STRING_MODE,
              xy,
              e.C_BLOCK_COMMENT_MODE
            ]
          },
          e.C_LINE_COMMENT_MODE,
          e.C_BLOCK_COMMENT_MODE
        ]
      },
      xy,
      u
    ]
  };
}
const ky = "[A-Za-z$_][0-9A-Za-z$_]*", Uj = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
], Vj = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
], xx = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
], kx = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
], Mx = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
], Hj = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
], qj = [].concat(
  Mx,
  xx,
  kx
);
function Gj(e) {
  const t = e.regex, n = (O, { after: q }) => {
    const X = "</" + O[0].slice(1);
    return O.input.indexOf(X, q) !== -1;
  }, r = ky, i = {
    begin: "<>",
    end: "</>"
  }, o = /<[A-Za-z0-9\\._:-]+\s*\/>/, s = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (O, q) => {
      const X = O[0].length + O.index, se = O.input[X];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        se === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        se === ","
      ) {
        q.ignoreMatch();
        return;
      }
      se === ">" && (n(O, { after: X }) || q.ignoreMatch());
      let fe;
      const Se = O.input.substring(X);
      if (fe = Se.match(/^\s*=/)) {
        q.ignoreMatch();
        return;
      }
      if ((fe = Se.match(/^\s+extends\s+/)) && fe.index === 0) {
        q.ignoreMatch();
        return;
      }
    }
  }, a = {
    $pattern: ky,
    keyword: Uj,
    literal: Vj,
    built_in: qj,
    "variable.language": Hj
  }, l = "[0-9](_?[0-9])*", u = `\\.(${l})`, c = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", f = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${c})((${u})|\\.)?|(${u}))[eE][+-]?(${l})\\b` },
      { begin: `\\b(${c})\\b((${u})\\b|\\.)?|(${u})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, d = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: a,
    contains: []
    // defined later
  }, p = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        e.BACKSLASH_ESCAPE,
        d
      ],
      subLanguage: "xml"
    }
  }, h = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        e.BACKSLASH_ESCAPE,
        d
      ],
      subLanguage: "css"
    }
  }, m = {
    begin: "gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        e.BACKSLASH_ESCAPE,
        d
      ],
      subLanguage: "graphql"
    }
  }, g = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      e.BACKSLASH_ESCAPE,
      d
    ]
  }, _ = {
    className: "comment",
    variants: [
      e.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: r + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      e.C_BLOCK_COMMENT_MODE,
      e.C_LINE_COMMENT_MODE
    ]
  }, E = [
    e.APOS_STRING_MODE,
    e.QUOTE_STRING_MODE,
    p,
    h,
    m,
    g,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    f
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  d.contains = E.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: a,
    contains: [
      "self"
    ].concat(E)
  });
  const v = [].concat(_, d.contains), M = v.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: a,
      contains: ["self"].concat(v)
    }
  ]), k = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: a,
    contains: M
  }, T = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          r,
          /\s+/,
          /extends/,
          /\s+/,
          t.concat(r, "(", t.concat(/\./, r), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          r
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, U = {
    relevance: 0,
    match: t.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...xx,
        ...kx
      ]
    }
  }, C = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, z = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          r,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [k],
    illegal: /%/
  }, H = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function j(O) {
    return t.concat("(?!", O.join("|"), ")");
  }
  const V = {
    match: t.concat(
      /\b/,
      j([
        ...Mx,
        "super",
        "import"
      ]),
      r,
      t.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  }, Q = {
    begin: t.concat(/\./, t.lookahead(
      t.concat(r, /(?![0-9A-Za-z$_(])/)
    )),
    end: r,
    excludeBegin: !0,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, le = {
    match: [
      /get|set/,
      /\s+/,
      r,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      k
    ]
  }, ne = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + e.UNDERSCORE_IDENT_RE + ")\\s*=>", w = {
    match: [
      /const|var|let/,
      /\s+/,
      r,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      t.lookahead(ne)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      k
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: a,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: M, CLASS_REFERENCE: U },
    illegal: /#(?![$_A-z])/,
    contains: [
      e.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      C,
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE,
      p,
      h,
      m,
      g,
      _,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      f,
      U,
      {
        className: "attr",
        begin: r + t.lookahead(":"),
        relevance: 0
      },
      w,
      {
        // "value" container
        begin: "(" + e.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          _,
          e.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: ne,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: e.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: a,
                    contains: M
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: i.begin, end: i.end },
              { match: o },
              {
                begin: s.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": s.isTrulyOpeningTag,
                end: s.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: s.begin,
                end: s.end,
                skip: !0,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      z,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + e.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: !0,
        label: "func.def",
        contains: [
          k,
          e.inherit(e.TITLE_MODE, { begin: r, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      Q,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + r,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [k]
      },
      V,
      H,
      T,
      le,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function Wj(e) {
  const t = {
    className: "attr",
    begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
    relevance: 1.01
  }, n = {
    match: /[{}[\],:]/,
    className: "punctuation",
    relevance: 0
  }, r = [
    "true",
    "false",
    "null"
  ], i = {
    scope: "literal",
    beginKeywords: r.join(" ")
  };
  return {
    name: "JSON",
    keywords: {
      literal: r
    },
    contains: [
      t,
      n,
      e.QUOTE_STRING_MODE,
      i,
      e.C_NUMBER_MODE,
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE
    ],
    illegal: "\\S"
  };
}
var ts = "[0-9](_*[0-9])*", Su = `\\.(${ts})`, Cu = "[0-9a-fA-F](_*[0-9a-fA-F])*", Kj = {
  className: "number",
  variants: [
    // DecimalFloatingPointLiteral
    // including ExponentPart
    { begin: `(\\b(${ts})((${Su})|\\.)?|(${Su}))[eE][+-]?(${ts})[fFdD]?\\b` },
    // excluding ExponentPart
    { begin: `\\b(${ts})((${Su})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
    { begin: `(${Su})[fFdD]?\\b` },
    { begin: `\\b(${ts})[fFdD]\\b` },
    // HexadecimalFloatingPointLiteral
    { begin: `\\b0[xX]((${Cu})\\.?|(${Cu})?\\.(${Cu}))[pP][+-]?(${ts})[fFdD]?\\b` },
    // DecimalIntegerLiteral
    { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
    // HexIntegerLiteral
    { begin: `\\b0[xX](${Cu})[lL]?\\b` },
    // OctalIntegerLiteral
    { begin: "\\b0(_*[0-7])*[lL]?\\b" },
    // BinaryIntegerLiteral
    { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
  ],
  relevance: 0
};
function Yj(e) {
  const t = {
    keyword: "abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual",
    built_in: "Byte Short Char Int Long Boolean Float Double Void Unit Nothing",
    literal: "true false null"
  }, n = {
    className: "keyword",
    begin: /\b(break|continue|return|this)\b/,
    starts: { contains: [
      {
        className: "symbol",
        begin: /@\w+/
      }
    ] }
  }, r = {
    className: "symbol",
    begin: e.UNDERSCORE_IDENT_RE + "@"
  }, i = {
    className: "subst",
    begin: /\$\{/,
    end: /\}/,
    contains: [e.C_NUMBER_MODE]
  }, o = {
    className: "variable",
    begin: "\\$" + e.UNDERSCORE_IDENT_RE
  }, s = {
    className: "string",
    variants: [
      {
        begin: '"""',
        end: '"""(?=[^"])',
        contains: [
          o,
          i
        ]
      },
      // Can't use built-in modes easily, as we want to use STRING in the meta
      // context as 'meta-string' and there's no syntax to remove explicitly set
      // classNames in built-in modes.
      {
        begin: "'",
        end: "'",
        illegal: /\n/,
        contains: [e.BACKSLASH_ESCAPE]
      },
      {
        begin: '"',
        end: '"',
        illegal: /\n/,
        contains: [
          e.BACKSLASH_ESCAPE,
          o,
          i
        ]
      }
    ]
  };
  i.contains.push(s);
  const a = {
    className: "meta",
    begin: "@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*" + e.UNDERSCORE_IDENT_RE + ")?"
  }, l = {
    className: "meta",
    begin: "@" + e.UNDERSCORE_IDENT_RE,
    contains: [
      {
        begin: /\(/,
        end: /\)/,
        contains: [
          e.inherit(s, { className: "string" }),
          "self"
        ]
      }
    ]
  }, u = Kj, c = e.COMMENT(
    "/\\*",
    "\\*/",
    { contains: [e.C_BLOCK_COMMENT_MODE] }
  ), f = { variants: [
    {
      className: "type",
      begin: e.UNDERSCORE_IDENT_RE
    },
    {
      begin: /\(/,
      end: /\)/,
      contains: []
      // defined later
    }
  ] }, d = f;
  return d.variants[1].contains = [f], f.variants[1].contains = [d], {
    name: "Kotlin",
    aliases: [
      "kt",
      "kts"
    ],
    keywords: t,
    contains: [
      e.COMMENT(
        "/\\*\\*",
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            }
          ]
        }
      ),
      e.C_LINE_COMMENT_MODE,
      c,
      n,
      r,
      a,
      l,
      {
        className: "function",
        beginKeywords: "fun",
        end: "[(]|$",
        returnBegin: !0,
        excludeEnd: !0,
        keywords: t,
        relevance: 5,
        contains: [
          {
            begin: e.UNDERSCORE_IDENT_RE + "\\s*\\(",
            returnBegin: !0,
            relevance: 0,
            contains: [e.UNDERSCORE_TITLE_MODE]
          },
          {
            className: "type",
            begin: /</,
            end: />/,
            keywords: "reified",
            relevance: 0
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            endsParent: !0,
            keywords: t,
            relevance: 0,
            contains: [
              {
                begin: /:/,
                end: /[=,\/]/,
                endsWithParent: !0,
                contains: [
                  f,
                  e.C_LINE_COMMENT_MODE,
                  c
                ],
                relevance: 0
              },
              e.C_LINE_COMMENT_MODE,
              c,
              a,
              l,
              s,
              e.C_NUMBER_MODE
            ]
          },
          c
        ]
      },
      {
        begin: [
          /class|interface|trait/,
          /\s+/,
          e.UNDERSCORE_IDENT_RE
        ],
        beginScope: {
          3: "title.class"
        },
        keywords: "class interface trait",
        end: /[:\{(]|$/,
        excludeEnd: !0,
        illegal: "extends implements",
        contains: [
          { beginKeywords: "public protected internal private constructor" },
          e.UNDERSCORE_TITLE_MODE,
          {
            className: "type",
            begin: /</,
            end: />/,
            excludeBegin: !0,
            excludeEnd: !0,
            relevance: 0
          },
          {
            className: "type",
            begin: /[,:]\s*/,
            end: /[<\(,){\s]|$/,
            excludeBegin: !0,
            returnEnd: !0
          },
          a,
          l
        ]
      },
      s,
      {
        className: "meta",
        begin: "^#!/usr/bin/env",
        end: "$",
        illegal: `
`
      },
      u
    ]
  };
}
const Qj = (e) => ({
  IMPORTANT: {
    scope: "meta",
    begin: "!important"
  },
  BLOCK_COMMENT: e.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: "number",
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: {
    className: "built_in",
    begin: /[\w-]+(?=\()/
  },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: "selector-attr",
    begin: /\[/,
    end: /\]/,
    illegal: "$",
    contains: [
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE
    ]
  },
  CSS_NUMBER_MODE: {
    scope: "number",
    begin: e.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  },
  CSS_VARIABLE: {
    className: "attr",
    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
  }
}), Zj = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "p",
  "q",
  "quote",
  "samp",
  "section",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
], Xj = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
], Ax = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
], Tx = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
], Jj = [
  "align-content",
  "align-items",
  "align-self",
  "all",
  "animation",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-timing-function",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-repeat",
  "background-size",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-decoration-break",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "direction",
  "display",
  "empty-cells",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-size",
  "font-size-adjust",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-variant",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "gap",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "inline-size",
  "isolation",
  "justify-content",
  "left",
  "letter-spacing",
  "line-break",
  "line-height",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "pointer-events",
  "position",
  "quotes",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "row-gap",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-style",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-transform",
  "text-underline-position",
  "top",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "unicode-bidi",
  "vertical-align",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "z-index"
  // reverse makes sure longer attributes `font-weight` are matched fully
  // instead of getting false positives on say `font`
].reverse(), eU = Ax.concat(Tx);
function tU(e) {
  const t = Qj(e), n = eU, r = "and or not only", i = "[\\w-]+", o = "(" + i + "|@\\{" + i + "\\})", s = [], a = [], l = function(E) {
    return {
      // Less strings are not multiline (also include '~' for more consistent coloring of "escaped" strings)
      className: "string",
      begin: "~?" + E + ".*?" + E
    };
  }, u = function(E, v, M) {
    return {
      className: E,
      begin: v,
      relevance: M
    };
  }, c = {
    $pattern: /[a-z-]+/,
    keyword: r,
    attribute: Xj.join(" ")
  }, f = {
    // used only to properly balance nested parens inside mixin call, def. arg list
    begin: "\\(",
    end: "\\)",
    contains: a,
    keywords: c,
    relevance: 0
  };
  a.push(
    e.C_LINE_COMMENT_MODE,
    e.C_BLOCK_COMMENT_MODE,
    l("'"),
    l('"'),
    t.CSS_NUMBER_MODE,
    // fixme: it does not include dot for numbers like .5em :(
    {
      begin: "(url|data-uri)\\(",
      starts: {
        className: "string",
        end: "[\\)\\n]",
        excludeEnd: !0
      }
    },
    t.HEXCOLOR,
    f,
    u("variable", "@@?" + i, 10),
    u("variable", "@\\{" + i + "\\}"),
    u("built_in", "~?`[^`]*?`"),
    // inline javascript (or whatever host language) *multiline* string
    {
      // @media features (its here to not duplicate things in AT_RULE_MODE with extra PARENS_MODE overriding):
      className: "attribute",
      begin: i + "\\s*:",
      end: ":",
      returnBegin: !0,
      excludeEnd: !0
    },
    t.IMPORTANT,
    { beginKeywords: "and not" },
    t.FUNCTION_DISPATCH
  );
  const d = a.concat({
    begin: /\{/,
    end: /\}/,
    contains: s
  }), p = {
    beginKeywords: "when",
    endsWithParent: !0,
    contains: [{ beginKeywords: "and not" }].concat(a)
    // using this form to override VALUEs 'function' match
  }, h = {
    begin: o + "\\s*:",
    returnBegin: !0,
    end: /[;}]/,
    relevance: 0,
    contains: [
      { begin: /-(webkit|moz|ms|o)-/ },
      t.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + Jj.join("|") + ")\\b",
        end: /(?=:)/,
        starts: {
          endsWithParent: !0,
          illegal: "[<=$]",
          relevance: 0,
          contains: a
        }
      }
    ]
  }, m = {
    className: "keyword",
    begin: "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b",
    starts: {
      end: "[;{}]",
      keywords: c,
      returnEnd: !0,
      contains: a,
      relevance: 0
    }
  }, g = {
    className: "variable",
    variants: [
      // using more strict pattern for higher relevance to increase chances of Less detection.
      // this is *the only* Less specific statement used in most of the sources, so...
      // (well still often loose to the css-parser unless there's '//' comment,
      // simply because 1 variable just can't beat 99 properties :)
      {
        begin: "@" + i + "\\s*:",
        relevance: 15
      },
      { begin: "@" + i }
    ],
    starts: {
      end: "[;}]",
      returnEnd: !0,
      contains: d
    }
  }, y = {
    // first parse unambiguous selectors (i.e. those not starting with tag)
    // then fall into the scary lookahead-discriminator variant.
    // this mode also handles mixin definitions and calls
    variants: [
      {
        begin: "[\\.#:&\\[>]",
        end: "[;{}]"
        // mixin calls end with ';'
      },
      {
        begin: o,
        end: /\{/
      }
    ],
    returnBegin: !0,
    returnEnd: !0,
    illegal: `[<='$"]`,
    relevance: 0,
    contains: [
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE,
      p,
      u("keyword", "all\\b"),
      u("variable", "@\\{" + i + "\\}"),
      // otherwise its identified as tag
      {
        begin: "\\b(" + Zj.join("|") + ")\\b",
        className: "selector-tag"
      },
      t.CSS_NUMBER_MODE,
      u("selector-tag", o, 0),
      u("selector-id", "#" + o),
      u("selector-class", "\\." + o, 0),
      u("selector-tag", "&", 0),
      t.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-pseudo",
        begin: ":(" + Ax.join("|") + ")"
      },
      {
        className: "selector-pseudo",
        begin: ":(:)?(" + Tx.join("|") + ")"
      },
      {
        begin: /\(/,
        end: /\)/,
        relevance: 0,
        contains: d
      },
      // argument list of parametric mixins
      { begin: "!important" },
      // eat !important after mixin call or it will be colored as tag
      t.FUNCTION_DISPATCH
    ]
  }, _ = {
    begin: i + `:(:)?(${n.join("|")})`,
    returnBegin: !0,
    contains: [y]
  };
  return s.push(
    e.C_LINE_COMMENT_MODE,
    e.C_BLOCK_COMMENT_MODE,
    m,
    g,
    _,
    h,
    y,
    p,
    t.FUNCTION_DISPATCH
  ), {
    name: "Less",
    case_insensitive: !0,
    illegal: `[=>'/<($"]`,
    contains: s
  };
}
function nU(e) {
  const t = "\\[=*\\[", n = "\\]=*\\]", r = {
    begin: t,
    end: n,
    contains: ["self"]
  }, i = [
    e.COMMENT("--(?!" + t + ")", "$"),
    e.COMMENT(
      "--" + t,
      n,
      {
        contains: [r],
        relevance: 10
      }
    )
  ];
  return {
    name: "Lua",
    keywords: {
      $pattern: e.UNDERSCORE_IDENT_RE,
      literal: "true false nil",
      keyword: "and break do else elseif end for goto if in local not or repeat return then until while",
      built_in: (
        // Metatags and globals:
        "_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove"
      )
    },
    contains: i.concat([
      {
        className: "function",
        beginKeywords: "function",
        end: "\\)",
        contains: [
          e.inherit(e.TITLE_MODE, { begin: "([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*" }),
          {
            className: "params",
            begin: "\\(",
            endsWithParent: !0,
            contains: i
          }
        ].concat(i)
      },
      e.C_NUMBER_MODE,
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE,
      {
        className: "string",
        begin: t,
        end: n,
        contains: [r],
        relevance: 5
      }
    ])
  };
}
function rU(e) {
  const t = {
    className: "variable",
    variants: [
      {
        begin: "\\$\\(" + e.UNDERSCORE_IDENT_RE + "\\)",
        contains: [e.BACKSLASH_ESCAPE]
      },
      { begin: /\$[@%<?\^\+\*]/ }
    ]
  }, n = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      e.BACKSLASH_ESCAPE,
      t
    ]
  }, r = {
    className: "variable",
    begin: /\$\([\w-]+\s/,
    end: /\)/,
    keywords: { built_in: "subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value" },
    contains: [t]
  }, i = { begin: "^" + e.UNDERSCORE_IDENT_RE + "\\s*(?=[:+?]?=)" }, o = {
    className: "meta",
    begin: /^\.PHONY:/,
    end: /$/,
    keywords: {
      $pattern: /[\.\w]+/,
      keyword: ".PHONY"
    }
  }, s = {
    className: "section",
    begin: /^[^\s]+:/,
    end: /$/,
    contains: [t]
  };
  return {
    name: "Makefile",
    aliases: [
      "mk",
      "mak",
      "make"
    ],
    keywords: {
      $pattern: /[\w-]+/,
      keyword: "define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath"
    },
    contains: [
      e.HASH_COMMENT_MODE,
      t,
      n,
      r,
      i,
      o,
      s
    ]
  };
}
function iU(e) {
  const t = e.regex, n = {
    begin: /<\/?[A-Za-z_]/,
    end: ">",
    subLanguage: "xml",
    relevance: 0
  }, r = {
    begin: "^[-\\*]{3,}",
    end: "$"
  }, i = {
    className: "code",
    variants: [
      // TODO: fix to allow these to work with sublanguage also
      { begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*" },
      { begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*" },
      // needed to allow markdown as a sublanguage to work
      {
        begin: "```",
        end: "```+[ ]*$"
      },
      {
        begin: "~~~",
        end: "~~~+[ ]*$"
      },
      { begin: "`.+?`" },
      {
        begin: "(?=^( {4}|\\t))",
        // use contains to gobble up multiple lines to allow the block to be whatever size
        // but only have a single open/close tag vs one per line
        contains: [
          {
            begin: "^( {4}|\\t)",
            end: "(\\n)$"
          }
        ],
        relevance: 0
      }
    ]
  }, o = {
    className: "bullet",
    begin: "^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)",
    end: "\\s+",
    excludeEnd: !0
  }, s = {
    begin: /^\[[^\n]+\]:/,
    returnBegin: !0,
    contains: [
      {
        className: "symbol",
        begin: /\[/,
        end: /\]/,
        excludeBegin: !0,
        excludeEnd: !0
      },
      {
        className: "link",
        begin: /:\s*/,
        end: /$/,
        excludeBegin: !0
      }
    ]
  }, a = /[A-Za-z][A-Za-z0-9+.-]*/, l = {
    variants: [
      // too much like nested array access in so many languages
      // to have any real relevance
      {
        begin: /\[.+?\]\[.*?\]/,
        relevance: 0
      },
      // popular internet URLs
      {
        begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,
        relevance: 2
      },
      {
        begin: t.concat(/\[.+?\]\(/, a, /:\/\/.*?\)/),
        relevance: 2
      },
      // relative urls
      {
        begin: /\[.+?\]\([./?&#].*?\)/,
        relevance: 1
      },
      // whatever else, lower relevance (might not be a link at all)
      {
        begin: /\[.*?\]\(.*?\)/,
        relevance: 0
      }
    ],
    returnBegin: !0,
    contains: [
      {
        // empty strings for alt or link text
        match: /\[(?=\])/
      },
      {
        className: "string",
        relevance: 0,
        begin: "\\[",
        end: "\\]",
        excludeBegin: !0,
        returnEnd: !0
      },
      {
        className: "link",
        relevance: 0,
        begin: "\\]\\(",
        end: "\\)",
        excludeBegin: !0,
        excludeEnd: !0
      },
      {
        className: "symbol",
        relevance: 0,
        begin: "\\]\\[",
        end: "\\]",
        excludeBegin: !0,
        excludeEnd: !0
      }
    ]
  }, u = {
    className: "strong",
    contains: [],
    // defined later
    variants: [
      {
        begin: /_{2}(?!\s)/,
        end: /_{2}/
      },
      {
        begin: /\*{2}(?!\s)/,
        end: /\*{2}/
      }
    ]
  }, c = {
    className: "emphasis",
    contains: [],
    // defined later
    variants: [
      {
        begin: /\*(?![*\s])/,
        end: /\*/
      },
      {
        begin: /_(?![_\s])/,
        end: /_/,
        relevance: 0
      }
    ]
  }, f = e.inherit(u, { contains: [] }), d = e.inherit(c, { contains: [] });
  u.contains.push(d), c.contains.push(f);
  let p = [
    n,
    l
  ];
  return [
    u,
    c,
    f,
    d
  ].forEach((g) => {
    g.contains = g.contains.concat(p);
  }), p = p.concat(u, c), {
    name: "Markdown",
    aliases: [
      "md",
      "mkdown",
      "mkd"
    ],
    contains: [
      {
        className: "section",
        variants: [
          {
            begin: "^#{1,6}",
            end: "$",
            contains: p
          },
          {
            begin: "(?=^.+?\\n[=-]{2,}$)",
            contains: [
              { begin: "^[=-]*$" },
              {
                begin: "^",
                end: "\\n",
                contains: p
              }
            ]
          }
        ]
      },
      n,
      o,
      u,
      c,
      {
        className: "quote",
        begin: "^>\\s+",
        contains: p,
        end: "$"
      },
      i,
      r,
      l,
      s
    ]
  };
}
function oU(e) {
  const t = {
    className: "built_in",
    begin: "\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+"
  }, n = /[a-zA-Z@][a-zA-Z0-9_]*/, a = {
    "variable.language": [
      "this",
      "super"
    ],
    $pattern: n,
    keyword: [
      "while",
      "export",
      "sizeof",
      "typedef",
      "const",
      "struct",
      "for",
      "union",
      "volatile",
      "static",
      "mutable",
      "if",
      "do",
      "return",
      "goto",
      "enum",
      "else",
      "break",
      "extern",
      "asm",
      "case",
      "default",
      "register",
      "explicit",
      "typename",
      "switch",
      "continue",
      "inline",
      "readonly",
      "assign",
      "readwrite",
      "self",
      "@synchronized",
      "id",
      "typeof",
      "nonatomic",
      "IBOutlet",
      "IBAction",
      "strong",
      "weak",
      "copy",
      "in",
      "out",
      "inout",
      "bycopy",
      "byref",
      "oneway",
      "__strong",
      "__weak",
      "__block",
      "__autoreleasing",
      "@private",
      "@protected",
      "@public",
      "@try",
      "@property",
      "@end",
      "@throw",
      "@catch",
      "@finally",
      "@autoreleasepool",
      "@synthesize",
      "@dynamic",
      "@selector",
      "@optional",
      "@required",
      "@encode",
      "@package",
      "@import",
      "@defs",
      "@compatibility_alias",
      "__bridge",
      "__bridge_transfer",
      "__bridge_retained",
      "__bridge_retain",
      "__covariant",
      "__contravariant",
      "__kindof",
      "_Nonnull",
      "_Nullable",
      "_Null_unspecified",
      "__FUNCTION__",
      "__PRETTY_FUNCTION__",
      "__attribute__",
      "getter",
      "setter",
      "retain",
      "unsafe_unretained",
      "nonnull",
      "nullable",
      "null_unspecified",
      "null_resettable",
      "class",
      "instancetype",
      "NS_DESIGNATED_INITIALIZER",
      "NS_UNAVAILABLE",
      "NS_REQUIRES_SUPER",
      "NS_RETURNS_INNER_POINTER",
      "NS_INLINE",
      "NS_AVAILABLE",
      "NS_DEPRECATED",
      "NS_ENUM",
      "NS_OPTIONS",
      "NS_SWIFT_UNAVAILABLE",
      "NS_ASSUME_NONNULL_BEGIN",
      "NS_ASSUME_NONNULL_END",
      "NS_REFINED_FOR_SWIFT",
      "NS_SWIFT_NAME",
      "NS_SWIFT_NOTHROW",
      "NS_DURING",
      "NS_HANDLER",
      "NS_ENDHANDLER",
      "NS_VALUERETURN",
      "NS_VOIDRETURN"
    ],
    literal: [
      "false",
      "true",
      "FALSE",
      "TRUE",
      "nil",
      "YES",
      "NO",
      "NULL"
    ],
    built_in: [
      "dispatch_once_t",
      "dispatch_queue_t",
      "dispatch_sync",
      "dispatch_async",
      "dispatch_once"
    ],
    type: [
      "int",
      "float",
      "char",
      "unsigned",
      "signed",
      "short",
      "long",
      "double",
      "wchar_t",
      "unichar",
      "void",
      "bool",
      "BOOL",
      "id|0",
      "_Bool"
    ]
  }, l = {
    $pattern: n,
    keyword: [
      "@interface",
      "@class",
      "@protocol",
      "@implementation"
    ]
  };
  return {
    name: "Objective-C",
    aliases: [
      "mm",
      "objc",
      "obj-c",
      "obj-c++",
      "objective-c++"
    ],
    keywords: a,
    illegal: "</",
    contains: [
      t,
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE,
      e.C_NUMBER_MODE,
      e.QUOTE_STRING_MODE,
      e.APOS_STRING_MODE,
      {
        className: "string",
        variants: [
          {
            begin: '@"',
            end: '"',
            illegal: "\\n",
            contains: [e.BACKSLASH_ESCAPE]
          }
        ]
      },
      {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: { keyword: "if else elif endif define undef warning error line pragma ifdef ifndef include" },
        contains: [
          {
            begin: /\\\n/,
            relevance: 0
          },
          e.inherit(e.QUOTE_STRING_MODE, { className: "string" }),
          {
            className: "string",
            begin: /<.*?>/,
            end: /$/,
            illegal: "\\n"
          },
          e.C_LINE_COMMENT_MODE,
          e.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        className: "class",
        begin: "(" + l.keyword.join("|") + ")\\b",
        end: /(\{|$)/,
        excludeEnd: !0,
        keywords: l,
        contains: [e.UNDERSCORE_TITLE_MODE]
      },
      {
        begin: "\\." + e.UNDERSCORE_IDENT_RE,
        relevance: 0
      }
    ]
  };
}
function sU(e) {
  const t = e.regex, n = [
    "abs",
    "accept",
    "alarm",
    "and",
    "atan2",
    "bind",
    "binmode",
    "bless",
    "break",
    "caller",
    "chdir",
    "chmod",
    "chomp",
    "chop",
    "chown",
    "chr",
    "chroot",
    "close",
    "closedir",
    "connect",
    "continue",
    "cos",
    "crypt",
    "dbmclose",
    "dbmopen",
    "defined",
    "delete",
    "die",
    "do",
    "dump",
    "each",
    "else",
    "elsif",
    "endgrent",
    "endhostent",
    "endnetent",
    "endprotoent",
    "endpwent",
    "endservent",
    "eof",
    "eval",
    "exec",
    "exists",
    "exit",
    "exp",
    "fcntl",
    "fileno",
    "flock",
    "for",
    "foreach",
    "fork",
    "format",
    "formline",
    "getc",
    "getgrent",
    "getgrgid",
    "getgrnam",
    "gethostbyaddr",
    "gethostbyname",
    "gethostent",
    "getlogin",
    "getnetbyaddr",
    "getnetbyname",
    "getnetent",
    "getpeername",
    "getpgrp",
    "getpriority",
    "getprotobyname",
    "getprotobynumber",
    "getprotoent",
    "getpwent",
    "getpwnam",
    "getpwuid",
    "getservbyname",
    "getservbyport",
    "getservent",
    "getsockname",
    "getsockopt",
    "given",
    "glob",
    "gmtime",
    "goto",
    "grep",
    "gt",
    "hex",
    "if",
    "index",
    "int",
    "ioctl",
    "join",
    "keys",
    "kill",
    "last",
    "lc",
    "lcfirst",
    "length",
    "link",
    "listen",
    "local",
    "localtime",
    "log",
    "lstat",
    "lt",
    "ma",
    "map",
    "mkdir",
    "msgctl",
    "msgget",
    "msgrcv",
    "msgsnd",
    "my",
    "ne",
    "next",
    "no",
    "not",
    "oct",
    "open",
    "opendir",
    "or",
    "ord",
    "our",
    "pack",
    "package",
    "pipe",
    "pop",
    "pos",
    "print",
    "printf",
    "prototype",
    "push",
    "q|0",
    "qq",
    "quotemeta",
    "qw",
    "qx",
    "rand",
    "read",
    "readdir",
    "readline",
    "readlink",
    "readpipe",
    "recv",
    "redo",
    "ref",
    "rename",
    "require",
    "reset",
    "return",
    "reverse",
    "rewinddir",
    "rindex",
    "rmdir",
    "say",
    "scalar",
    "seek",
    "seekdir",
    "select",
    "semctl",
    "semget",
    "semop",
    "send",
    "setgrent",
    "sethostent",
    "setnetent",
    "setpgrp",
    "setpriority",
    "setprotoent",
    "setpwent",
    "setservent",
    "setsockopt",
    "shift",
    "shmctl",
    "shmget",
    "shmread",
    "shmwrite",
    "shutdown",
    "sin",
    "sleep",
    "socket",
    "socketpair",
    "sort",
    "splice",
    "split",
    "sprintf",
    "sqrt",
    "srand",
    "stat",
    "state",
    "study",
    "sub",
    "substr",
    "symlink",
    "syscall",
    "sysopen",
    "sysread",
    "sysseek",
    "system",
    "syswrite",
    "tell",
    "telldir",
    "tie",
    "tied",
    "time",
    "times",
    "tr",
    "truncate",
    "uc",
    "ucfirst",
    "umask",
    "undef",
    "unless",
    "unlink",
    "unpack",
    "unshift",
    "untie",
    "until",
    "use",
    "utime",
    "values",
    "vec",
    "wait",
    "waitpid",
    "wantarray",
    "warn",
    "when",
    "while",
    "write",
    "x|0",
    "xor",
    "y|0"
  ], r = /[dualxmsipngr]{0,12}/, i = {
    $pattern: /[\w.]+/,
    keyword: n.join(" ")
  }, o = {
    className: "subst",
    begin: "[$@]\\{",
    end: "\\}",
    keywords: i
  }, s = {
    begin: /->\{/,
    end: /\}/
    // contains defined later
  }, a = { variants: [
    { begin: /\$\d/ },
    { begin: t.concat(
      /[$%@](\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/,
      // negative look-ahead tries to avoid matching patterns that are not
      // Perl at all like $ident$, @ident@, etc.
      "(?![A-Za-z])(?![@$%])"
    ) },
    {
      begin: /[$%@][^\s\w{]/,
      relevance: 0
    }
  ] }, l = [
    e.BACKSLASH_ESCAPE,
    o,
    a
  ], u = [
    /!/,
    /\//,
    /\|/,
    /\?/,
    /'/,
    /"/,
    // valid but infrequent and weird
    /#/
    // valid but infrequent and weird
  ], c = (p, h, m = "\\1") => {
    const g = m === "\\1" ? m : t.concat(m, h);
    return t.concat(
      t.concat("(?:", p, ")"),
      h,
      /(?:\\.|[^\\\/])*?/,
      g,
      /(?:\\.|[^\\\/])*?/,
      m,
      r
    );
  }, f = (p, h, m) => t.concat(
    t.concat("(?:", p, ")"),
    h,
    /(?:\\.|[^\\\/])*?/,
    m,
    r
  ), d = [
    a,
    e.HASH_COMMENT_MODE,
    e.COMMENT(
      /^=\w/,
      /=cut/,
      { endsWithParent: !0 }
    ),
    s,
    {
      className: "string",
      contains: l,
      variants: [
        {
          begin: "q[qwxr]?\\s*\\(",
          end: "\\)",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\[",
          end: "\\]",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\{",
          end: "\\}",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\|",
          end: "\\|",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*<",
          end: ">",
          relevance: 5
        },
        {
          begin: "qw\\s+q",
          end: "q",
          relevance: 5
        },
        {
          begin: "'",
          end: "'",
          contains: [e.BACKSLASH_ESCAPE]
        },
        {
          begin: '"',
          end: '"'
        },
        {
          begin: "`",
          end: "`",
          contains: [e.BACKSLASH_ESCAPE]
        },
        {
          begin: /\{\w+\}/,
          relevance: 0
        },
        {
          begin: "-?\\w+\\s*=>",
          relevance: 0
        }
      ]
    },
    {
      className: "number",
      begin: "(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",
      relevance: 0
    },
    {
      // regexp container
      begin: "(\\/\\/|" + e.RE_STARTERS_RE + "|\\b(split|return|print|reverse|grep)\\b)\\s*",
      keywords: "split return print reverse grep",
      relevance: 0,
      contains: [
        e.HASH_COMMENT_MODE,
        {
          className: "regexp",
          variants: [
            // allow matching common delimiters
            { begin: c("s|tr|y", t.either(...u, { capture: !0 })) },
            // and then paired delmis
            { begin: c("s|tr|y", "\\(", "\\)") },
            { begin: c("s|tr|y", "\\[", "\\]") },
            { begin: c("s|tr|y", "\\{", "\\}") }
          ],
          relevance: 2
        },
        {
          className: "regexp",
          variants: [
            {
              // could be a comment in many languages so do not count
              // as relevant
              begin: /(m|qr)\/\//,
              relevance: 0
            },
            // prefix is optional with /regex/
            { begin: f("(?:m|qr)?", /\//, /\//) },
            // allow matching common delimiters
            { begin: f("m|qr", t.either(...u, { capture: !0 }), /\1/) },
            // allow common paired delmins
            { begin: f("m|qr", /\(/, /\)/) },
            { begin: f("m|qr", /\[/, /\]/) },
            { begin: f("m|qr", /\{/, /\}/) }
          ]
        }
      ]
    },
    {
      className: "function",
      beginKeywords: "sub",
      end: "(\\s*\\(.*?\\))?[;{]",
      excludeEnd: !0,
      relevance: 5,
      contains: [e.TITLE_MODE]
    },
    {
      begin: "-\\w\\b",
      relevance: 0
    },
    {
      begin: "^__DATA__$",
      end: "^__END__$",
      subLanguage: "mojolicious",
      contains: [
        {
          begin: "^@@.*",
          end: "$",
          className: "comment"
        }
      ]
    }
  ];
  return o.contains = d, s.contains = d, {
    name: "Perl",
    aliases: [
      "pl",
      "pm"
    ],
    keywords: i,
    contains: d
  };
}
function aU(e) {
  const t = e.regex, n = /(?![A-Za-z0-9])(?![$])/, r = t.concat(
    /[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/,
    n
  ), i = t.concat(
    /(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/,
    n
  ), o = {
    scope: "variable",
    match: "\\$+" + r
  }, s = {
    scope: "meta",
    variants: [
      { begin: /<\?php/, relevance: 10 },
      // boost for obvious PHP
      { begin: /<\?=/ },
      // less relevant per PSR-1 which says not to use short-tags
      { begin: /<\?/, relevance: 0.1 },
      { begin: /\?>/ }
      // end php tag
    ]
  }, a = {
    scope: "subst",
    variants: [
      { begin: /\$\w+/ },
      {
        begin: /\{\$/,
        end: /\}/
      }
    ]
  }, l = e.inherit(e.APOS_STRING_MODE, { illegal: null }), u = e.inherit(e.QUOTE_STRING_MODE, {
    illegal: null,
    contains: e.QUOTE_STRING_MODE.contains.concat(a)
  }), c = {
    begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
    end: /[ \t]*(\w+)\b/,
    contains: e.QUOTE_STRING_MODE.contains.concat(a),
    "on:begin": (V, Q) => {
      Q.data._beginMatch = V[1] || V[2];
    },
    "on:end": (V, Q) => {
      Q.data._beginMatch !== V[1] && Q.ignoreMatch();
    }
  }, f = e.END_SAME_AS_BEGIN({
    begin: /<<<[ \t]*'(\w+)'\n/,
    end: /[ \t]*(\w+)\b/
  }), d = `[ 	
]`, p = {
    scope: "string",
    variants: [
      u,
      l,
      c,
      f
    ]
  }, h = {
    scope: "number",
    variants: [
      { begin: "\\b0[bB][01]+(?:_[01]+)*\\b" },
      // Binary w/ underscore support
      { begin: "\\b0[oO][0-7]+(?:_[0-7]+)*\\b" },
      // Octals w/ underscore support
      { begin: "\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b" },
      // Hex w/ underscore support
      // Decimals w/ underscore support, with optional fragments and scientific exponent (e) suffix.
      { begin: "(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?" }
    ],
    relevance: 0
  }, m = [
    "false",
    "null",
    "true"
  ], g = [
    // Magic constants:
    // <https://www.php.net/manual/en/language.constants.predefined.php>
    "__CLASS__",
    "__DIR__",
    "__FILE__",
    "__FUNCTION__",
    "__COMPILER_HALT_OFFSET__",
    "__LINE__",
    "__METHOD__",
    "__NAMESPACE__",
    "__TRAIT__",
    // Function that look like language construct or language construct that look like function:
    // List of keywords that may not require parenthesis
    "die",
    "echo",
    "exit",
    "include",
    "include_once",
    "print",
    "require",
    "require_once",
    // These are not language construct (function) but operate on the currently-executing function and can access the current symbol table
    // 'compact extract func_get_arg func_get_args func_num_args get_called_class get_parent_class ' +
    // Other keywords:
    // <https://www.php.net/manual/en/reserved.php>
    // <https://www.php.net/manual/en/language.types.type-juggling.php>
    "array",
    "abstract",
    "and",
    "as",
    "binary",
    "bool",
    "boolean",
    "break",
    "callable",
    "case",
    "catch",
    "class",
    "clone",
    "const",
    "continue",
    "declare",
    "default",
    "do",
    "double",
    "else",
    "elseif",
    "empty",
    "enddeclare",
    "endfor",
    "endforeach",
    "endif",
    "endswitch",
    "endwhile",
    "enum",
    "eval",
    "extends",
    "final",
    "finally",
    "float",
    "for",
    "foreach",
    "from",
    "global",
    "goto",
    "if",
    "implements",
    "instanceof",
    "insteadof",
    "int",
    "integer",
    "interface",
    "isset",
    "iterable",
    "list",
    "match|0",
    "mixed",
    "new",
    "never",
    "object",
    "or",
    "private",
    "protected",
    "public",
    "readonly",
    "real",
    "return",
    "string",
    "switch",
    "throw",
    "trait",
    "try",
    "unset",
    "use",
    "var",
    "void",
    "while",
    "xor",
    "yield"
  ], y = [
    // Standard PHP library:
    // <https://www.php.net/manual/en/book.spl.php>
    "Error|0",
    "AppendIterator",
    "ArgumentCountError",
    "ArithmeticError",
    "ArrayIterator",
    "ArrayObject",
    "AssertionError",
    "BadFunctionCallException",
    "BadMethodCallException",
    "CachingIterator",
    "CallbackFilterIterator",
    "CompileError",
    "Countable",
    "DirectoryIterator",
    "DivisionByZeroError",
    "DomainException",
    "EmptyIterator",
    "ErrorException",
    "Exception",
    "FilesystemIterator",
    "FilterIterator",
    "GlobIterator",
    "InfiniteIterator",
    "InvalidArgumentException",
    "IteratorIterator",
    "LengthException",
    "LimitIterator",
    "LogicException",
    "MultipleIterator",
    "NoRewindIterator",
    "OutOfBoundsException",
    "OutOfRangeException",
    "OuterIterator",
    "OverflowException",
    "ParentIterator",
    "ParseError",
    "RangeException",
    "RecursiveArrayIterator",
    "RecursiveCachingIterator",
    "RecursiveCallbackFilterIterator",
    "RecursiveDirectoryIterator",
    "RecursiveFilterIterator",
    "RecursiveIterator",
    "RecursiveIteratorIterator",
    "RecursiveRegexIterator",
    "RecursiveTreeIterator",
    "RegexIterator",
    "RuntimeException",
    "SeekableIterator",
    "SplDoublyLinkedList",
    "SplFileInfo",
    "SplFileObject",
    "SplFixedArray",
    "SplHeap",
    "SplMaxHeap",
    "SplMinHeap",
    "SplObjectStorage",
    "SplObserver",
    "SplPriorityQueue",
    "SplQueue",
    "SplStack",
    "SplSubject",
    "SplTempFileObject",
    "TypeError",
    "UnderflowException",
    "UnexpectedValueException",
    "UnhandledMatchError",
    // Reserved interfaces:
    // <https://www.php.net/manual/en/reserved.interfaces.php>
    "ArrayAccess",
    "BackedEnum",
    "Closure",
    "Fiber",
    "Generator",
    "Iterator",
    "IteratorAggregate",
    "Serializable",
    "Stringable",
    "Throwable",
    "Traversable",
    "UnitEnum",
    "WeakReference",
    "WeakMap",
    // Reserved classes:
    // <https://www.php.net/manual/en/reserved.classes.php>
    "Directory",
    "__PHP_Incomplete_Class",
    "parent",
    "php_user_filter",
    "self",
    "static",
    "stdClass"
  ], E = {
    keyword: g,
    literal: ((V) => {
      const Q = [];
      return V.forEach((le) => {
        Q.push(le), le.toLowerCase() === le ? Q.push(le.toUpperCase()) : Q.push(le.toLowerCase());
      }), Q;
    })(m),
    built_in: y
  }, v = (V) => V.map((Q) => Q.replace(/\|\d+$/, "")), M = { variants: [
    {
      match: [
        /new/,
        t.concat(d, "+"),
        // to prevent built ins from being confused as the class constructor call
        t.concat("(?!", v(y).join("\\b|"), "\\b)"),
        i
      ],
      scope: {
        1: "keyword",
        4: "title.class"
      }
    }
  ] }, k = t.concat(r, "\\b(?!\\()"), T = { variants: [
    {
      match: [
        t.concat(
          /::/,
          t.lookahead(/(?!class\b)/)
        ),
        k
      ],
      scope: { 2: "variable.constant" }
    },
    {
      match: [
        /::/,
        /class/
      ],
      scope: { 2: "variable.language" }
    },
    {
      match: [
        i,
        t.concat(
          /::/,
          t.lookahead(/(?!class\b)/)
        ),
        k
      ],
      scope: {
        1: "title.class",
        3: "variable.constant"
      }
    },
    {
      match: [
        i,
        t.concat(
          "::",
          t.lookahead(/(?!class\b)/)
        )
      ],
      scope: { 1: "title.class" }
    },
    {
      match: [
        i,
        /::/,
        /class/
      ],
      scope: {
        1: "title.class",
        3: "variable.language"
      }
    }
  ] }, U = {
    scope: "attr",
    match: t.concat(r, t.lookahead(":"), t.lookahead(/(?!::)/))
  }, C = {
    relevance: 0,
    begin: /\(/,
    end: /\)/,
    keywords: E,
    contains: [
      U,
      o,
      T,
      e.C_BLOCK_COMMENT_MODE,
      p,
      h,
      M
    ]
  }, z = {
    relevance: 0,
    match: [
      /\b/,
      // to prevent keywords from being confused as the function title
      t.concat("(?!fn\\b|function\\b|", v(g).join("\\b|"), "|", v(y).join("\\b|"), "\\b)"),
      r,
      t.concat(d, "*"),
      t.lookahead(/(?=\()/)
    ],
    scope: { 3: "title.function.invoke" },
    contains: [C]
  };
  C.contains.push(z);
  const H = [
    U,
    T,
    e.C_BLOCK_COMMENT_MODE,
    p,
    h,
    M
  ], j = {
    begin: t.concat(/#\[\s*/, i),
    beginScope: "meta",
    end: /]/,
    endScope: "meta",
    keywords: {
      literal: m,
      keyword: [
        "new",
        "array"
      ]
    },
    contains: [
      {
        begin: /\[/,
        end: /]/,
        keywords: {
          literal: m,
          keyword: [
            "new",
            "array"
          ]
        },
        contains: [
          "self",
          ...H
        ]
      },
      ...H,
      {
        scope: "meta",
        match: i
      }
    ]
  };
  return {
    case_insensitive: !1,
    keywords: E,
    contains: [
      j,
      e.HASH_COMMENT_MODE,
      e.COMMENT("//", "$"),
      e.COMMENT(
        "/\\*",
        "\\*/",
        { contains: [
          {
            scope: "doctag",
            match: "@[A-Za-z]+"
          }
        ] }
      ),
      {
        match: /__halt_compiler\(\);/,
        keywords: "__halt_compiler",
        starts: {
          scope: "comment",
          end: e.MATCH_NOTHING_RE,
          contains: [
            {
              match: /\?>/,
              scope: "meta",
              endsParent: !0
            }
          ]
        }
      },
      s,
      {
        scope: "variable.language",
        match: /\$this\b/
      },
      o,
      z,
      T,
      {
        match: [
          /const/,
          /\s/,
          r
        ],
        scope: {
          1: "keyword",
          3: "variable.constant"
        }
      },
      M,
      {
        scope: "function",
        relevance: 0,
        beginKeywords: "fn function",
        end: /[;{]/,
        excludeEnd: !0,
        illegal: "[$%\\[]",
        contains: [
          { beginKeywords: "use" },
          e.UNDERSCORE_TITLE_MODE,
          {
            begin: "=>",
            // No markup, just a relevance booster
            endsParent: !0
          },
          {
            scope: "params",
            begin: "\\(",
            end: "\\)",
            excludeBegin: !0,
            excludeEnd: !0,
            keywords: E,
            contains: [
              "self",
              o,
              T,
              e.C_BLOCK_COMMENT_MODE,
              p,
              h
            ]
          }
        ]
      },
      {
        scope: "class",
        variants: [
          {
            beginKeywords: "enum",
            illegal: /[($"]/
          },
          {
            beginKeywords: "class interface trait",
            illegal: /[:($"]/
          }
        ],
        relevance: 0,
        end: /\{/,
        excludeEnd: !0,
        contains: [
          { beginKeywords: "extends implements" },
          e.UNDERSCORE_TITLE_MODE
        ]
      },
      // both use and namespace still use "old style" rules (vs multi-match)
      // because the namespace name can include `\` and we still want each
      // element to be treated as its own *individual* title
      {
        beginKeywords: "namespace",
        relevance: 0,
        end: ";",
        illegal: /[.']/,
        contains: [e.inherit(e.UNDERSCORE_TITLE_MODE, { scope: "title.class" })]
      },
      {
        beginKeywords: "use",
        relevance: 0,
        end: ";",
        contains: [
          // TODO: title.function vs title.class
          {
            match: /\b(as|const|function)\b/,
            scope: "keyword"
          },
          // TODO: could be title.class or title.function
          e.UNDERSCORE_TITLE_MODE
        ]
      },
      p,
      h
    ]
  };
}
function lU(e) {
  return {
    name: "PHP template",
    subLanguage: "xml",
    contains: [
      {
        begin: /<\?(php|=)?/,
        end: /\?>/,
        subLanguage: "php",
        contains: [
          // We don't want the php closing tag ?> to close the PHP block when
          // inside any of the following blocks:
          {
            begin: "/\\*",
            end: "\\*/",
            skip: !0
          },
          {
            begin: 'b"',
            end: '"',
            skip: !0
          },
          {
            begin: "b'",
            end: "'",
            skip: !0
          },
          e.inherit(e.APOS_STRING_MODE, {
            illegal: null,
            className: null,
            contains: null,
            skip: !0
          }),
          e.inherit(e.QUOTE_STRING_MODE, {
            illegal: null,
            className: null,
            contains: null,
            skip: !0
          })
        ]
      }
    ]
  };
}
function uU(e) {
  return {
    name: "Plain text",
    aliases: [
      "text",
      "txt"
    ],
    disableAutodetect: !0
  };
}
function cU(e) {
  const t = e.regex, n = new RegExp("[\\p{XID_Start}_]\\p{XID_Continue}*", "u"), r = [
    "and",
    "as",
    "assert",
    "async",
    "await",
    "break",
    "case",
    "class",
    "continue",
    "def",
    "del",
    "elif",
    "else",
    "except",
    "finally",
    "for",
    "from",
    "global",
    "if",
    "import",
    "in",
    "is",
    "lambda",
    "match",
    "nonlocal|10",
    "not",
    "or",
    "pass",
    "raise",
    "return",
    "try",
    "while",
    "with",
    "yield"
  ], a = {
    $pattern: /[A-Za-z]\w+|__\w+__/,
    keyword: r,
    built_in: [
      "__import__",
      "abs",
      "all",
      "any",
      "ascii",
      "bin",
      "bool",
      "breakpoint",
      "bytearray",
      "bytes",
      "callable",
      "chr",
      "classmethod",
      "compile",
      "complex",
      "delattr",
      "dict",
      "dir",
      "divmod",
      "enumerate",
      "eval",
      "exec",
      "filter",
      "float",
      "format",
      "frozenset",
      "getattr",
      "globals",
      "hasattr",
      "hash",
      "help",
      "hex",
      "id",
      "input",
      "int",
      "isinstance",
      "issubclass",
      "iter",
      "len",
      "list",
      "locals",
      "map",
      "max",
      "memoryview",
      "min",
      "next",
      "object",
      "oct",
      "open",
      "ord",
      "pow",
      "print",
      "property",
      "range",
      "repr",
      "reversed",
      "round",
      "set",
      "setattr",
      "slice",
      "sorted",
      "staticmethod",
      "str",
      "sum",
      "super",
      "tuple",
      "type",
      "vars",
      "zip"
    ],
    literal: [
      "__debug__",
      "Ellipsis",
      "False",
      "None",
      "NotImplemented",
      "True"
    ],
    type: [
      "Any",
      "Callable",
      "Coroutine",
      "Dict",
      "List",
      "Literal",
      "Generic",
      "Optional",
      "Sequence",
      "Set",
      "Tuple",
      "Type",
      "Union"
    ]
  }, l = {
    className: "meta",
    begin: /^(>>>|\.\.\.) /
  }, u = {
    className: "subst",
    begin: /\{/,
    end: /\}/,
    keywords: a,
    illegal: /#/
  }, c = {
    begin: /\{\{/,
    relevance: 0
  }, f = {
    className: "string",
    contains: [e.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
        end: /'''/,
        contains: [
          e.BACKSLASH_ESCAPE,
          l
        ],
        relevance: 10
      },
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
        end: /"""/,
        contains: [
          e.BACKSLASH_ESCAPE,
          l
        ],
        relevance: 10
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'''/,
        end: /'''/,
        contains: [
          e.BACKSLASH_ESCAPE,
          l,
          c,
          u
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"""/,
        end: /"""/,
        contains: [
          e.BACKSLASH_ESCAPE,
          l,
          c,
          u
        ]
      },
      {
        begin: /([uU]|[rR])'/,
        end: /'/,
        relevance: 10
      },
      {
        begin: /([uU]|[rR])"/,
        end: /"/,
        relevance: 10
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])'/,
        end: /'/
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])"/,
        end: /"/
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'/,
        end: /'/,
        contains: [
          e.BACKSLASH_ESCAPE,
          c,
          u
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"/,
        end: /"/,
        contains: [
          e.BACKSLASH_ESCAPE,
          c,
          u
        ]
      },
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE
    ]
  }, d = "[0-9](_?[0-9])*", p = `(\\b(${d}))?\\.(${d})|\\b(${d})\\.`, h = `\\b|${r.join("|")}`, m = {
    className: "number",
    relevance: 0,
    variants: [
      // exponentfloat, pointfloat
      // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals
      // optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      // Note: no leading \b because floats can start with a decimal point
      // and we don't want to mishandle e.g. `fn(.5)`,
      // no trailing \b for pointfloat because it can end with a decimal point
      // and we don't want to mishandle e.g. `0..hex()`; this should be safe
      // because both MUST contain a decimal point and so cannot be confused with
      // the interior part of an identifier
      {
        begin: `(\\b(${d})|(${p}))[eE][+-]?(${d})[jJ]?(?=${h})`
      },
      {
        begin: `(${p})[jJ]?`
      },
      // decinteger, bininteger, octinteger, hexinteger
      // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals
      // optionally "long" in Python 2
      // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals
      // decinteger is optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${h})`
      },
      {
        begin: `\\b0[bB](_?[01])+[lL]?(?=${h})`
      },
      {
        begin: `\\b0[oO](_?[0-7])+[lL]?(?=${h})`
      },
      {
        begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${h})`
      },
      // imagnumber (digitpart-based)
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b(${d})[jJ](?=${h})`
      }
    ]
  }, g = {
    className: "comment",
    begin: t.lookahead(/# type:/),
    end: /$/,
    keywords: a,
    contains: [
      {
        // prevent keywords from coloring `type`
        begin: /# type:/
      },
      // comment within a datatype comment includes no keywords
      {
        begin: /#/,
        end: /\b\B/,
        endsWithParent: !0
      }
    ]
  }, y = {
    className: "params",
    variants: [
      // Exclude params in functions without params
      {
        className: "",
        begin: /\(\s*\)/,
        skip: !0
      },
      {
        begin: /\(/,
        end: /\)/,
        excludeBegin: !0,
        excludeEnd: !0,
        keywords: a,
        contains: [
          "self",
          l,
          m,
          f,
          e.HASH_COMMENT_MODE
        ]
      }
    ]
  };
  return u.contains = [
    f,
    m,
    l
  ], {
    name: "Python",
    aliases: [
      "py",
      "gyp",
      "ipython"
    ],
    unicodeRegex: !0,
    keywords: a,
    illegal: /(<\/|\?)|=>/,
    contains: [
      l,
      m,
      {
        // very common convention
        begin: /\bself\b/
      },
      {
        // eat "if" prior to string so that it won't accidentally be
        // labeled as an f-string
        beginKeywords: "if",
        relevance: 0
      },
      f,
      g,
      e.HASH_COMMENT_MODE,
      {
        match: [
          /\bdef/,
          /\s+/,
          n
        ],
        scope: {
          1: "keyword",
          3: "title.function"
        },
        contains: [y]
      },
      {
        variants: [
          {
            match: [
              /\bclass/,
              /\s+/,
              n,
              /\s*/,
              /\(\s*/,
              n,
              /\s*\)/
            ]
          },
          {
            match: [
              /\bclass/,
              /\s+/,
              n
            ]
          }
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          6: "title.class.inherited"
        }
      },
      {
        className: "meta",
        begin: /^[\t ]*@/,
        end: /(?=#)|$/,
        contains: [
          m,
          y,
          f
        ]
      }
    ]
  };
}
function fU(e) {
  return {
    aliases: ["pycon"],
    contains: [
      {
        className: "meta.prompt",
        starts: {
          // a space separates the REPL prefix from the actual code
          // this is purely for cleaner HTML output
          end: / |$/,
          starts: {
            end: "$",
            subLanguage: "python"
          }
        },
        variants: [
          { begin: /^>>>(?=[ ]|$)/ },
          { begin: /^\.\.\.(?=[ ]|$)/ }
        ]
      }
    ]
  };
}
function dU(e) {
  const t = e.regex, n = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/, r = t.either(
    // Special case: only hexadecimal binary powers can contain fractions
    /0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/,
    // Hexadecimal numbers without fraction and optional binary power
    /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/,
    // Decimal numbers
    /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/
  ), i = /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/, o = t.either(
    /[()]/,
    /[{}]/,
    /\[\[/,
    /[[\]]/,
    /\\/,
    /,/
  );
  return {
    name: "R",
    keywords: {
      $pattern: n,
      keyword: "function if in break next repeat else for while",
      literal: "NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10",
      built_in: (
        // Builtin constants
        "LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm"
      )
    },
    contains: [
      // Roxygen comments
      e.COMMENT(
        /#'/,
        /$/,
        { contains: [
          {
            // Handle `@examples` separately to cause all subsequent code
            // until the next `@`-tag on its own line to be kept as-is,
            // preventing highlighting. This code is example R code, so nested
            // doctags shouldnt be treated as such. See
            // `test/markup/r/roxygen.txt` for an example.
            scope: "doctag",
            match: /@examples/,
            starts: {
              end: t.lookahead(t.either(
                // end if another doc comment
                /\n^#'\s*(?=@[a-zA-Z]+)/,
                // or a line with no comment
                /\n^(?!#')/
              )),
              endsParent: !0
            }
          },
          {
            // Handle `@param` to highlight the parameter name following
            // after.
            scope: "doctag",
            begin: "@param",
            end: /$/,
            contains: [
              {
                scope: "variable",
                variants: [
                  { match: n },
                  { match: /`(?:\\.|[^`\\])+`/ }
                ],
                endsParent: !0
              }
            ]
          },
          {
            scope: "doctag",
            match: /@[a-zA-Z]+/
          },
          {
            scope: "keyword",
            match: /\\[a-zA-Z]+/
          }
        ] }
      ),
      e.HASH_COMMENT_MODE,
      {
        scope: "string",
        contains: [e.BACKSLASH_ESCAPE],
        variants: [
          e.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\(/,
            end: /\)(-*)"/
          }),
          e.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\{/,
            end: /\}(-*)"/
          }),
          e.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\[/,
            end: /\](-*)"/
          }),
          e.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\(/,
            end: /\)(-*)'/
          }),
          e.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\{/,
            end: /\}(-*)'/
          }),
          e.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\[/,
            end: /\](-*)'/
          }),
          {
            begin: '"',
            end: '"',
            relevance: 0
          },
          {
            begin: "'",
            end: "'",
            relevance: 0
          }
        ]
      },
      // Matching numbers immediately following punctuation and operators is
      // tricky since we need to look at the character ahead of a number to
      // ensure the number is not part of an identifier, and we cannot use
      // negative look-behind assertions. So instead we explicitly handle all
      // possible combinations of (operator|punctuation), number.
      // TODO: replace with negative look-behind when available
      // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/ },
      // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+([pP][+-]?\d+)?[Li]?/ },
      // { begin: /(?<![a-zA-Z0-9._])(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?[Li]?/ }
      {
        relevance: 0,
        variants: [
          {
            scope: {
              1: "operator",
              2: "number"
            },
            match: [
              i,
              r
            ]
          },
          {
            scope: {
              1: "operator",
              2: "number"
            },
            match: [
              /%[^%]*%/,
              r
            ]
          },
          {
            scope: {
              1: "punctuation",
              2: "number"
            },
            match: [
              o,
              r
            ]
          },
          {
            scope: { 2: "number" },
            match: [
              /[^a-zA-Z0-9._]|^/,
              // not part of an identifier, or start of document
              r
            ]
          }
        ]
      },
      // Operators/punctuation when they're not directly followed by numbers
      {
        // Relevance boost for the most common assignment form.
        scope: { 3: "operator" },
        match: [
          n,
          /\s+/,
          /<-/,
          /\s+/
        ]
      },
      {
        scope: "operator",
        relevance: 0,
        variants: [
          { match: i },
          { match: /%[^%]*%/ }
        ]
      },
      {
        scope: "punctuation",
        relevance: 0,
        match: o
      },
      {
        // Escaped identifier
        begin: "`",
        end: "`",
        contains: [{ begin: /\\./ }]
      }
    ]
  };
}
function pU(e) {
  const t = e.regex, n = "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)", r = t.either(
    /\b([A-Z]+[a-z0-9]+)+/,
    // ends in caps
    /\b([A-Z]+[a-z0-9]+)+[A-Z]+/
  ), i = t.concat(r, /(::\w+)*/), s = {
    "variable.constant": [
      "__FILE__",
      "__LINE__",
      "__ENCODING__"
    ],
    "variable.language": [
      "self",
      "super"
    ],
    keyword: [
      "alias",
      "and",
      "begin",
      "BEGIN",
      "break",
      "case",
      "class",
      "defined",
      "do",
      "else",
      "elsif",
      "end",
      "END",
      "ensure",
      "for",
      "if",
      "in",
      "module",
      "next",
      "not",
      "or",
      "redo",
      "require",
      "rescue",
      "retry",
      "return",
      "then",
      "undef",
      "unless",
      "until",
      "when",
      "while",
      "yield",
      ...[
        "include",
        "extend",
        "prepend",
        "public",
        "private",
        "protected",
        "raise",
        "throw"
      ]
    ],
    built_in: [
      "proc",
      "lambda",
      "attr_accessor",
      "attr_reader",
      "attr_writer",
      "define_method",
      "private_constant",
      "module_function"
    ],
    literal: [
      "true",
      "false",
      "nil"
    ]
  }, a = {
    className: "doctag",
    begin: "@[A-Za-z]+"
  }, l = {
    begin: "#<",
    end: ">"
  }, u = [
    e.COMMENT(
      "#",
      "$",
      { contains: [a] }
    ),
    e.COMMENT(
      "^=begin",
      "^=end",
      {
        contains: [a],
        relevance: 10
      }
    ),
    e.COMMENT("^__END__", e.MATCH_NOTHING_RE)
  ], c = {
    className: "subst",
    begin: /#\{/,
    end: /\}/,
    keywords: s
  }, f = {
    className: "string",
    contains: [
      e.BACKSLASH_ESCAPE,
      c
    ],
    variants: [
      {
        begin: /'/,
        end: /'/
      },
      {
        begin: /"/,
        end: /"/
      },
      {
        begin: /`/,
        end: /`/
      },
      {
        begin: /%[qQwWx]?\(/,
        end: /\)/
      },
      {
        begin: /%[qQwWx]?\[/,
        end: /\]/
      },
      {
        begin: /%[qQwWx]?\{/,
        end: /\}/
      },
      {
        begin: /%[qQwWx]?</,
        end: />/
      },
      {
        begin: /%[qQwWx]?\//,
        end: /\//
      },
      {
        begin: /%[qQwWx]?%/,
        end: /%/
      },
      {
        begin: /%[qQwWx]?-/,
        end: /-/
      },
      {
        begin: /%[qQwWx]?\|/,
        end: /\|/
      },
      // in the following expressions, \B in the beginning suppresses recognition of ?-sequences
      // where ? is the last character of a preceding identifier, as in: `func?4`
      { begin: /\B\?(\\\d{1,3})/ },
      { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ },
      { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ },
      { begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/ },
      { begin: /\B\?\\(c|C-)[\x20-\x7e]/ },
      { begin: /\B\?\\?\S/ },
      // heredocs
      {
        // this guard makes sure that we have an entire heredoc and not a false
        // positive (auto-detect, etc.)
        begin: t.concat(
          /<<[-~]?'?/,
          t.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)
        ),
        contains: [
          e.END_SAME_AS_BEGIN({
            begin: /(\w+)/,
            end: /(\w+)/,
            contains: [
              e.BACKSLASH_ESCAPE,
              c
            ]
          })
        ]
      }
    ]
  }, d = "[1-9](_?[0-9])*|0", p = "[0-9](_?[0-9])*", h = {
    className: "number",
    relevance: 0,
    variants: [
      // decimal integer/float, optionally exponential or rational, optionally imaginary
      { begin: `\\b(${d})(\\.(${p}))?([eE][+-]?(${p})|r)?i?\\b` },
      // explicit decimal/binary/octal/hexadecimal integer,
      // optionally rational and/or imaginary
      { begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b" },
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b" },
      // 0-prefixed implicit octal integer, optionally rational and/or imaginary
      { begin: "\\b0(_?[0-7])+r?i?\\b" }
    ]
  }, m = {
    variants: [
      {
        match: /\(\)/
      },
      {
        className: "params",
        begin: /\(/,
        end: /(?=\))/,
        excludeBegin: !0,
        endsParent: !0,
        keywords: s
      }
    ]
  }, k = [
    f,
    {
      variants: [
        {
          match: [
            /class\s+/,
            i,
            /\s+<\s+/,
            i
          ]
        },
        {
          match: [
            /\b(class|module)\s+/,
            i
          ]
        }
      ],
      scope: {
        2: "title.class",
        4: "title.class.inherited"
      },
      keywords: s
    },
    {
      match: [
        /(include|extend)\s+/,
        i
      ],
      scope: {
        2: "title.class"
      },
      keywords: s
    },
    {
      relevance: 0,
      match: [
        i,
        /\.new[. (]/
      ],
      scope: {
        1: "title.class"
      }
    },
    {
      relevance: 0,
      match: /\b[A-Z][A-Z_0-9]+\b/,
      className: "variable.constant"
    },
    {
      relevance: 0,
      match: r,
      scope: "title.class"
    },
    {
      match: [
        /def/,
        /\s+/,
        n
      ],
      scope: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        m
      ]
    },
    {
      // swallow namespace qualifiers before symbols
      begin: e.IDENT_RE + "::"
    },
    {
      className: "symbol",
      begin: e.UNDERSCORE_IDENT_RE + "(!|\\?)?:",
      relevance: 0
    },
    {
      className: "symbol",
      begin: ":(?!\\s)",
      contains: [
        f,
        { begin: n }
      ],
      relevance: 0
    },
    h,
    {
      // negative-look forward attempts to prevent false matches like:
      // @ident@ or $ident$ that might indicate this is not ruby at all
      className: "variable",
      begin: "(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])"
    },
    {
      className: "params",
      begin: /\|/,
      end: /\|/,
      excludeBegin: !0,
      excludeEnd: !0,
      relevance: 0,
      // this could be a lot of things (in other languages) other than params
      keywords: s
    },
    {
      // regexp container
      begin: "(" + e.RE_STARTERS_RE + "|unless)\\s*",
      keywords: "unless",
      contains: [
        {
          className: "regexp",
          contains: [
            e.BACKSLASH_ESCAPE,
            c
          ],
          illegal: /\n/,
          variants: [
            {
              begin: "/",
              end: "/[a-z]*"
            },
            {
              begin: /%r\{/,
              end: /\}[a-z]*/
            },
            {
              begin: "%r\\(",
              end: "\\)[a-z]*"
            },
            {
              begin: "%r!",
              end: "![a-z]*"
            },
            {
              begin: "%r\\[",
              end: "\\][a-z]*"
            }
          ]
        }
      ].concat(l, u),
      relevance: 0
    }
  ].concat(l, u);
  c.contains = k, m.contains = k;
  const z = [
    {
      begin: /^\s*=>/,
      starts: {
        end: "$",
        contains: k
      }
    },
    {
      className: "meta.prompt",
      begin: "^(" + "[>?]>" + "|" + "[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]" + "|" + "(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>" + ")(?=[ ])",
      starts: {
        end: "$",
        keywords: s,
        contains: k
      }
    }
  ];
  return u.unshift(l), {
    name: "Ruby",
    aliases: [
      "rb",
      "gemspec",
      "podspec",
      "thor",
      "irb"
    ],
    keywords: s,
    illegal: /\/\*/,
    contains: [e.SHEBANG({ binary: "ruby" })].concat(z).concat(u).concat(k)
  };
}
function hU(e) {
  const t = e.regex, n = {
    className: "title.function.invoke",
    relevance: 0,
    begin: t.concat(
      /\b/,
      /(?!let|for|while|if|else|match\b)/,
      e.IDENT_RE,
      t.lookahead(/\s*\(/)
    )
  }, r = "([ui](8|16|32|64|128|size)|f(32|64))?", i = [
    "abstract",
    "as",
    "async",
    "await",
    "become",
    "box",
    "break",
    "const",
    "continue",
    "crate",
    "do",
    "dyn",
    "else",
    "enum",
    "extern",
    "false",
    "final",
    "fn",
    "for",
    "if",
    "impl",
    "in",
    "let",
    "loop",
    "macro",
    "match",
    "mod",
    "move",
    "mut",
    "override",
    "priv",
    "pub",
    "ref",
    "return",
    "self",
    "Self",
    "static",
    "struct",
    "super",
    "trait",
    "true",
    "try",
    "type",
    "typeof",
    "unsafe",
    "unsized",
    "use",
    "virtual",
    "where",
    "while",
    "yield"
  ], o = [
    "true",
    "false",
    "Some",
    "None",
    "Ok",
    "Err"
  ], s = [
    // functions
    "drop ",
    // traits
    "Copy",
    "Send",
    "Sized",
    "Sync",
    "Drop",
    "Fn",
    "FnMut",
    "FnOnce",
    "ToOwned",
    "Clone",
    "Debug",
    "PartialEq",
    "PartialOrd",
    "Eq",
    "Ord",
    "AsRef",
    "AsMut",
    "Into",
    "From",
    "Default",
    "Iterator",
    "Extend",
    "IntoIterator",
    "DoubleEndedIterator",
    "ExactSizeIterator",
    "SliceConcatExt",
    "ToString",
    // macros
    "assert!",
    "assert_eq!",
    "bitflags!",
    "bytes!",
    "cfg!",
    "col!",
    "concat!",
    "concat_idents!",
    "debug_assert!",
    "debug_assert_eq!",
    "env!",
    "eprintln!",
    "panic!",
    "file!",
    "format!",
    "format_args!",
    "include_bytes!",
    "include_str!",
    "line!",
    "local_data_key!",
    "module_path!",
    "option_env!",
    "print!",
    "println!",
    "select!",
    "stringify!",
    "try!",
    "unimplemented!",
    "unreachable!",
    "vec!",
    "write!",
    "writeln!",
    "macro_rules!",
    "assert_ne!",
    "debug_assert_ne!"
  ], a = [
    "i8",
    "i16",
    "i32",
    "i64",
    "i128",
    "isize",
    "u8",
    "u16",
    "u32",
    "u64",
    "u128",
    "usize",
    "f32",
    "f64",
    "str",
    "char",
    "bool",
    "Box",
    "Option",
    "Result",
    "String",
    "Vec"
  ];
  return {
    name: "Rust",
    aliases: ["rs"],
    keywords: {
      $pattern: e.IDENT_RE + "!?",
      type: a,
      keyword: i,
      literal: o,
      built_in: s
    },
    illegal: "</",
    contains: [
      e.C_LINE_COMMENT_MODE,
      e.COMMENT("/\\*", "\\*/", { contains: ["self"] }),
      e.inherit(e.QUOTE_STRING_MODE, {
        begin: /b?"/,
        illegal: null
      }),
      {
        className: "string",
        variants: [
          { begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ },
          { begin: /b?'\\?(x\w{2}|u\w{4}|U\w{8}|.)'/ }
        ]
      },
      {
        className: "symbol",
        begin: /'[a-zA-Z_][a-zA-Z0-9_]*/
      },
      {
        className: "number",
        variants: [
          { begin: "\\b0b([01_]+)" + r },
          { begin: "\\b0o([0-7_]+)" + r },
          { begin: "\\b0x([A-Fa-f0-9_]+)" + r },
          { begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + r }
        ],
        relevance: 0
      },
      {
        begin: [
          /fn/,
          /\s+/,
          e.UNDERSCORE_IDENT_RE
        ],
        className: {
          1: "keyword",
          3: "title.function"
        }
      },
      {
        className: "meta",
        begin: "#!?\\[",
        end: "\\]",
        contains: [
          {
            className: "string",
            begin: /"/,
            end: /"/
          }
        ]
      },
      {
        begin: [
          /let/,
          /\s+/,
          /(?:mut\s+)?/,
          e.UNDERSCORE_IDENT_RE
        ],
        className: {
          1: "keyword",
          3: "keyword",
          4: "variable"
        }
      },
      // must come before impl/for rule later
      {
        begin: [
          /for/,
          /\s+/,
          e.UNDERSCORE_IDENT_RE,
          /\s+/,
          /in/
        ],
        className: {
          1: "keyword",
          3: "variable",
          5: "keyword"
        }
      },
      {
        begin: [
          /type/,
          /\s+/,
          e.UNDERSCORE_IDENT_RE
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        begin: [
          /(?:trait|enum|struct|union|impl|for)/,
          /\s+/,
          e.UNDERSCORE_IDENT_RE
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        begin: e.IDENT_RE + "::",
        keywords: {
          keyword: "Self",
          built_in: s,
          type: a
        }
      },
      {
        className: "punctuation",
        begin: "->"
      },
      n
    ]
  };
}
const gU = (e) => ({
  IMPORTANT: {
    scope: "meta",
    begin: "!important"
  },
  BLOCK_COMMENT: e.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: "number",
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: {
    className: "built_in",
    begin: /[\w-]+(?=\()/
  },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: "selector-attr",
    begin: /\[/,
    end: /\]/,
    illegal: "$",
    contains: [
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE
    ]
  },
  CSS_NUMBER_MODE: {
    scope: "number",
    begin: e.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  },
  CSS_VARIABLE: {
    className: "attr",
    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
  }
}), mU = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "p",
  "q",
  "quote",
  "samp",
  "section",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
], bU = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
], yU = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
], vU = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
], _U = [
  "align-content",
  "align-items",
  "align-self",
  "all",
  "animation",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-timing-function",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-repeat",
  "background-size",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-decoration-break",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "direction",
  "display",
  "empty-cells",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-size",
  "font-size-adjust",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-variant",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "gap",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "inline-size",
  "isolation",
  "justify-content",
  "left",
  "letter-spacing",
  "line-break",
  "line-height",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "pointer-events",
  "position",
  "quotes",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "row-gap",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-style",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-transform",
  "text-underline-position",
  "top",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "unicode-bidi",
  "vertical-align",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "z-index"
  // reverse makes sure longer attributes `font-weight` are matched fully
  // instead of getting false positives on say `font`
].reverse();
function EU(e) {
  const t = gU(e), n = vU, r = yU, i = "@[a-z-]+", o = "and or not only", a = {
    className: "variable",
    begin: "(\\$" + "[a-zA-Z-][a-zA-Z0-9_-]*" + ")\\b",
    relevance: 0
  };
  return {
    name: "SCSS",
    case_insensitive: !0,
    illegal: "[=/|']",
    contains: [
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE,
      // to recognize keyframe 40% etc which are outside the scope of our
      // attribute value mode
      t.CSS_NUMBER_MODE,
      {
        className: "selector-id",
        begin: "#[A-Za-z0-9_-]+",
        relevance: 0
      },
      {
        className: "selector-class",
        begin: "\\.[A-Za-z0-9_-]+",
        relevance: 0
      },
      t.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-tag",
        begin: "\\b(" + mU.join("|") + ")\\b",
        // was there, before, but why?
        relevance: 0
      },
      {
        className: "selector-pseudo",
        begin: ":(" + r.join("|") + ")"
      },
      {
        className: "selector-pseudo",
        begin: ":(:)?(" + n.join("|") + ")"
      },
      a,
      {
        // pseudo-selector params
        begin: /\(/,
        end: /\)/,
        contains: [t.CSS_NUMBER_MODE]
      },
      t.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + _U.join("|") + ")\\b"
      },
      { begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b" },
      {
        begin: /:/,
        end: /[;}{]/,
        relevance: 0,
        contains: [
          t.BLOCK_COMMENT,
          a,
          t.HEXCOLOR,
          t.CSS_NUMBER_MODE,
          e.QUOTE_STRING_MODE,
          e.APOS_STRING_MODE,
          t.IMPORTANT,
          t.FUNCTION_DISPATCH
        ]
      },
      // matching these here allows us to treat them more like regular CSS
      // rules so everything between the {} gets regular rule highlighting,
      // which is what we want for page and font-face
      {
        begin: "@(page|font-face)",
        keywords: {
          $pattern: i,
          keyword: "@page @font-face"
        }
      },
      {
        begin: "@",
        end: "[{;]",
        returnBegin: !0,
        keywords: {
          $pattern: /[a-z-]+/,
          keyword: o,
          attribute: bU.join(" ")
        },
        contains: [
          {
            begin: i,
            className: "keyword"
          },
          {
            begin: /[a-z-]+(?=:)/,
            className: "attribute"
          },
          a,
          e.QUOTE_STRING_MODE,
          e.APOS_STRING_MODE,
          t.HEXCOLOR,
          t.CSS_NUMBER_MODE
        ]
      },
      t.FUNCTION_DISPATCH
    ]
  };
}
function wU(e) {
  return {
    name: "Shell Session",
    aliases: [
      "console",
      "shellsession"
    ],
    contains: [
      {
        className: "meta.prompt",
        // We cannot add \s (spaces) in the regular expression otherwise it will be too broad and produce unexpected result.
        // For instance, in the following example, it would match "echo /path/to/home >" as a prompt:
        // echo /path/to/home > t.exe
        begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
        starts: {
          end: /[^\\](?=\s*$)/,
          subLanguage: "bash"
        }
      }
    ]
  };
}
function xU(e) {
  const t = e.regex, n = e.COMMENT("--", "$"), r = {
    className: "string",
    variants: [
      {
        begin: /'/,
        end: /'/,
        contains: [{ begin: /''/ }]
      }
    ]
  }, i = {
    begin: /"/,
    end: /"/,
    contains: [{ begin: /""/ }]
  }, o = [
    "true",
    "false",
    // Not sure it's correct to call NULL literal, and clauses like IS [NOT] NULL look strange that way.
    // "null",
    "unknown"
  ], s = [
    "double precision",
    "large object",
    "with timezone",
    "without timezone"
  ], a = [
    "bigint",
    "binary",
    "blob",
    "boolean",
    "char",
    "character",
    "clob",
    "date",
    "dec",
    "decfloat",
    "decimal",
    "float",
    "int",
    "integer",
    "interval",
    "nchar",
    "nclob",
    "national",
    "numeric",
    "real",
    "row",
    "smallint",
    "time",
    "timestamp",
    "varchar",
    "varying",
    // modifier (character varying)
    "varbinary"
  ], l = [
    "add",
    "asc",
    "collation",
    "desc",
    "final",
    "first",
    "last",
    "view"
  ], u = [
    "abs",
    "acos",
    "all",
    "allocate",
    "alter",
    "and",
    "any",
    "are",
    "array",
    "array_agg",
    "array_max_cardinality",
    "as",
    "asensitive",
    "asin",
    "asymmetric",
    "at",
    "atan",
    "atomic",
    "authorization",
    "avg",
    "begin",
    "begin_frame",
    "begin_partition",
    "between",
    "bigint",
    "binary",
    "blob",
    "boolean",
    "both",
    "by",
    "call",
    "called",
    "cardinality",
    "cascaded",
    "case",
    "cast",
    "ceil",
    "ceiling",
    "char",
    "char_length",
    "character",
    "character_length",
    "check",
    "classifier",
    "clob",
    "close",
    "coalesce",
    "collate",
    "collect",
    "column",
    "commit",
    "condition",
    "connect",
    "constraint",
    "contains",
    "convert",
    "copy",
    "corr",
    "corresponding",
    "cos",
    "cosh",
    "count",
    "covar_pop",
    "covar_samp",
    "create",
    "cross",
    "cube",
    "cume_dist",
    "current",
    "current_catalog",
    "current_date",
    "current_default_transform_group",
    "current_path",
    "current_role",
    "current_row",
    "current_schema",
    "current_time",
    "current_timestamp",
    "current_path",
    "current_role",
    "current_transform_group_for_type",
    "current_user",
    "cursor",
    "cycle",
    "date",
    "day",
    "deallocate",
    "dec",
    "decimal",
    "decfloat",
    "declare",
    "default",
    "define",
    "delete",
    "dense_rank",
    "deref",
    "describe",
    "deterministic",
    "disconnect",
    "distinct",
    "double",
    "drop",
    "dynamic",
    "each",
    "element",
    "else",
    "empty",
    "end",
    "end_frame",
    "end_partition",
    "end-exec",
    "equals",
    "escape",
    "every",
    "except",
    "exec",
    "execute",
    "exists",
    "exp",
    "external",
    "extract",
    "false",
    "fetch",
    "filter",
    "first_value",
    "float",
    "floor",
    "for",
    "foreign",
    "frame_row",
    "free",
    "from",
    "full",
    "function",
    "fusion",
    "get",
    "global",
    "grant",
    "group",
    "grouping",
    "groups",
    "having",
    "hold",
    "hour",
    "identity",
    "in",
    "indicator",
    "initial",
    "inner",
    "inout",
    "insensitive",
    "insert",
    "int",
    "integer",
    "intersect",
    "intersection",
    "interval",
    "into",
    "is",
    "join",
    "json_array",
    "json_arrayagg",
    "json_exists",
    "json_object",
    "json_objectagg",
    "json_query",
    "json_table",
    "json_table_primitive",
    "json_value",
    "lag",
    "language",
    "large",
    "last_value",
    "lateral",
    "lead",
    "leading",
    "left",
    "like",
    "like_regex",
    "listagg",
    "ln",
    "local",
    "localtime",
    "localtimestamp",
    "log",
    "log10",
    "lower",
    "match",
    "match_number",
    "match_recognize",
    "matches",
    "max",
    "member",
    "merge",
    "method",
    "min",
    "minute",
    "mod",
    "modifies",
    "module",
    "month",
    "multiset",
    "national",
    "natural",
    "nchar",
    "nclob",
    "new",
    "no",
    "none",
    "normalize",
    "not",
    "nth_value",
    "ntile",
    "null",
    "nullif",
    "numeric",
    "octet_length",
    "occurrences_regex",
    "of",
    "offset",
    "old",
    "omit",
    "on",
    "one",
    "only",
    "open",
    "or",
    "order",
    "out",
    "outer",
    "over",
    "overlaps",
    "overlay",
    "parameter",
    "partition",
    "pattern",
    "per",
    "percent",
    "percent_rank",
    "percentile_cont",
    "percentile_disc",
    "period",
    "portion",
    "position",
    "position_regex",
    "power",
    "precedes",
    "precision",
    "prepare",
    "primary",
    "procedure",
    "ptf",
    "range",
    "rank",
    "reads",
    "real",
    "recursive",
    "ref",
    "references",
    "referencing",
    "regr_avgx",
    "regr_avgy",
    "regr_count",
    "regr_intercept",
    "regr_r2",
    "regr_slope",
    "regr_sxx",
    "regr_sxy",
    "regr_syy",
    "release",
    "result",
    "return",
    "returns",
    "revoke",
    "right",
    "rollback",
    "rollup",
    "row",
    "row_number",
    "rows",
    "running",
    "savepoint",
    "scope",
    "scroll",
    "search",
    "second",
    "seek",
    "select",
    "sensitive",
    "session_user",
    "set",
    "show",
    "similar",
    "sin",
    "sinh",
    "skip",
    "smallint",
    "some",
    "specific",
    "specifictype",
    "sql",
    "sqlexception",
    "sqlstate",
    "sqlwarning",
    "sqrt",
    "start",
    "static",
    "stddev_pop",
    "stddev_samp",
    "submultiset",
    "subset",
    "substring",
    "substring_regex",
    "succeeds",
    "sum",
    "symmetric",
    "system",
    "system_time",
    "system_user",
    "table",
    "tablesample",
    "tan",
    "tanh",
    "then",
    "time",
    "timestamp",
    "timezone_hour",
    "timezone_minute",
    "to",
    "trailing",
    "translate",
    "translate_regex",
    "translation",
    "treat",
    "trigger",
    "trim",
    "trim_array",
    "true",
    "truncate",
    "uescape",
    "union",
    "unique",
    "unknown",
    "unnest",
    "update",
    "upper",
    "user",
    "using",
    "value",
    "values",
    "value_of",
    "var_pop",
    "var_samp",
    "varbinary",
    "varchar",
    "varying",
    "versioning",
    "when",
    "whenever",
    "where",
    "width_bucket",
    "window",
    "with",
    "within",
    "without",
    "year"
  ], c = [
    "abs",
    "acos",
    "array_agg",
    "asin",
    "atan",
    "avg",
    "cast",
    "ceil",
    "ceiling",
    "coalesce",
    "corr",
    "cos",
    "cosh",
    "count",
    "covar_pop",
    "covar_samp",
    "cume_dist",
    "dense_rank",
    "deref",
    "element",
    "exp",
    "extract",
    "first_value",
    "floor",
    "json_array",
    "json_arrayagg",
    "json_exists",
    "json_object",
    "json_objectagg",
    "json_query",
    "json_table",
    "json_table_primitive",
    "json_value",
    "lag",
    "last_value",
    "lead",
    "listagg",
    "ln",
    "log",
    "log10",
    "lower",
    "max",
    "min",
    "mod",
    "nth_value",
    "ntile",
    "nullif",
    "percent_rank",
    "percentile_cont",
    "percentile_disc",
    "position",
    "position_regex",
    "power",
    "rank",
    "regr_avgx",
    "regr_avgy",
    "regr_count",
    "regr_intercept",
    "regr_r2",
    "regr_slope",
    "regr_sxx",
    "regr_sxy",
    "regr_syy",
    "row_number",
    "sin",
    "sinh",
    "sqrt",
    "stddev_pop",
    "stddev_samp",
    "substring",
    "substring_regex",
    "sum",
    "tan",
    "tanh",
    "translate",
    "translate_regex",
    "treat",
    "trim",
    "trim_array",
    "unnest",
    "upper",
    "value_of",
    "var_pop",
    "var_samp",
    "width_bucket"
  ], f = [
    "current_catalog",
    "current_date",
    "current_default_transform_group",
    "current_path",
    "current_role",
    "current_schema",
    "current_transform_group_for_type",
    "current_user",
    "session_user",
    "system_time",
    "system_user",
    "current_time",
    "localtime",
    "current_timestamp",
    "localtimestamp"
  ], d = [
    "create table",
    "insert into",
    "primary key",
    "foreign key",
    "not null",
    "alter table",
    "add constraint",
    "grouping sets",
    "on overflow",
    "character set",
    "respect nulls",
    "ignore nulls",
    "nulls first",
    "nulls last",
    "depth first",
    "breadth first"
  ], p = c, h = [
    ...u,
    ...l
  ].filter((E) => !c.includes(E)), m = {
    className: "variable",
    begin: /@[a-z0-9][a-z0-9_]*/
  }, g = {
    className: "operator",
    begin: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
    relevance: 0
  }, y = {
    begin: t.concat(/\b/, t.either(...p), /\s*\(/),
    relevance: 0,
    keywords: { built_in: p }
  };
  function _(E, {
    exceptions: v,
    when: M
  } = {}) {
    const k = M;
    return v = v || [], E.map((T) => T.match(/\|\d+$/) || v.includes(T) ? T : k(T) ? `${T}|0` : T);
  }
  return {
    name: "SQL",
    case_insensitive: !0,
    // does not include {} or HTML tags `</`
    illegal: /[{}]|<\//,
    keywords: {
      $pattern: /\b[\w\.]+/,
      keyword: _(h, { when: (E) => E.length < 3 }),
      literal: o,
      type: a,
      built_in: f
    },
    contains: [
      {
        begin: t.either(...d),
        relevance: 0,
        keywords: {
          $pattern: /[\w\.]+/,
          keyword: h.concat(d),
          literal: o,
          type: a
        }
      },
      {
        className: "type",
        begin: t.either(...s)
      },
      y,
      m,
      r,
      i,
      e.C_NUMBER_MODE,
      e.C_BLOCK_COMMENT_MODE,
      n,
      g
    ]
  };
}
function Sx(e) {
  return e ? typeof e == "string" ? e : e.source : null;
}
function Nu(e) {
  return at("(?=", e, ")");
}
function at(...e) {
  return e.map((n) => Sx(n)).join("");
}
function kU(e) {
  const t = e[e.length - 1];
  return typeof t == "object" && t.constructor === Object ? (e.splice(e.length - 1, 1), t) : {};
}
function vn(...e) {
  return "(" + (kU(e).capture ? "" : "?:") + e.map((r) => Sx(r)).join("|") + ")";
}
const jg = (e) => at(
  /\b/,
  e,
  /\w$/.test(e) ? /\b/ : /\B/
), MU = [
  "Protocol",
  // contextual
  "Type"
  // contextual
].map(jg), My = [
  "init",
  "self"
].map(jg), AU = [
  "Any",
  "Self"
], Pp = [
  // strings below will be fed into the regular `keywords` engine while regex
  // will result in additional modes being created to scan for those keywords to
  // avoid conflicts with other rules
  "actor",
  "any",
  // contextual
  "associatedtype",
  "async",
  "await",
  /as\?/,
  // operator
  /as!/,
  // operator
  "as",
  // operator
  "borrowing",
  // contextual
  "break",
  "case",
  "catch",
  "class",
  "consume",
  // contextual
  "consuming",
  // contextual
  "continue",
  "convenience",
  // contextual
  "copy",
  // contextual
  "default",
  "defer",
  "deinit",
  "didSet",
  // contextual
  "distributed",
  "do",
  "dynamic",
  // contextual
  "each",
  "else",
  "enum",
  "extension",
  "fallthrough",
  /fileprivate\(set\)/,
  "fileprivate",
  "final",
  // contextual
  "for",
  "func",
  "get",
  // contextual
  "guard",
  "if",
  "import",
  "indirect",
  // contextual
  "infix",
  // contextual
  /init\?/,
  /init!/,
  "inout",
  /internal\(set\)/,
  "internal",
  "in",
  "is",
  // operator
  "isolated",
  // contextual
  "nonisolated",
  // contextual
  "lazy",
  // contextual
  "let",
  "macro",
  "mutating",
  // contextual
  "nonmutating",
  // contextual
  /open\(set\)/,
  // contextual
  "open",
  // contextual
  "operator",
  "optional",
  // contextual
  "override",
  // contextual
  "postfix",
  // contextual
  "precedencegroup",
  "prefix",
  // contextual
  /private\(set\)/,
  "private",
  "protocol",
  /public\(set\)/,
  "public",
  "repeat",
  "required",
  // contextual
  "rethrows",
  "return",
  "set",
  // contextual
  "some",
  // contextual
  "static",
  "struct",
  "subscript",
  "super",
  "switch",
  "throws",
  "throw",
  /try\?/,
  // operator
  /try!/,
  // operator
  "try",
  // operator
  "typealias",
  /unowned\(safe\)/,
  // contextual
  /unowned\(unsafe\)/,
  // contextual
  "unowned",
  // contextual
  "var",
  "weak",
  // contextual
  "where",
  "while",
  "willSet"
  // contextual
], Ay = [
  "false",
  "nil",
  "true"
], TU = [
  "assignment",
  "associativity",
  "higherThan",
  "left",
  "lowerThan",
  "none",
  "right"
], SU = [
  "#colorLiteral",
  "#column",
  "#dsohandle",
  "#else",
  "#elseif",
  "#endif",
  "#error",
  "#file",
  "#fileID",
  "#fileLiteral",
  "#filePath",
  "#function",
  "#if",
  "#imageLiteral",
  "#keyPath",
  "#line",
  "#selector",
  "#sourceLocation",
  "#warning"
], Ty = [
  "abs",
  "all",
  "any",
  "assert",
  "assertionFailure",
  "debugPrint",
  "dump",
  "fatalError",
  "getVaList",
  "isKnownUniquelyReferenced",
  "max",
  "min",
  "numericCast",
  "pointwiseMax",
  "pointwiseMin",
  "precondition",
  "preconditionFailure",
  "print",
  "readLine",
  "repeatElement",
  "sequence",
  "stride",
  "swap",
  "swift_unboxFromSwiftValueWithType",
  "transcode",
  "type",
  "unsafeBitCast",
  "unsafeDowncast",
  "withExtendedLifetime",
  "withUnsafeMutablePointer",
  "withUnsafePointer",
  "withVaList",
  "withoutActuallyEscaping",
  "zip"
], Cx = vn(
  /[/=\-+!*%<>&|^~?]/,
  /[\u00A1-\u00A7]/,
  /[\u00A9\u00AB]/,
  /[\u00AC\u00AE]/,
  /[\u00B0\u00B1]/,
  /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
  /[\u2016-\u2017]/,
  /[\u2020-\u2027]/,
  /[\u2030-\u203E]/,
  /[\u2041-\u2053]/,
  /[\u2055-\u205E]/,
  /[\u2190-\u23FF]/,
  /[\u2500-\u2775]/,
  /[\u2794-\u2BFF]/,
  /[\u2E00-\u2E7F]/,
  /[\u3001-\u3003]/,
  /[\u3008-\u3020]/,
  /[\u3030]/
), Nx = vn(
  Cx,
  /[\u0300-\u036F]/,
  /[\u1DC0-\u1DFF]/,
  /[\u20D0-\u20FF]/,
  /[\uFE00-\uFE0F]/,
  /[\uFE20-\uFE2F]/
  // TODO: The following characters are also allowed, but the regex isn't supported yet.
  // /[\u{E0100}-\u{E01EF}]/u
), $p = at(Cx, Nx, "*"), Dx = vn(
  /[a-zA-Z_]/,
  /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
  /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
  /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
  /[\u1E00-\u1FFF]/,
  /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
  /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
  /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
  /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
  /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
  /[\uFE47-\uFEFE\uFF00-\uFFFD]/
  // Should be /[\uFE47-\uFFFD]/, but we have to exclude FEFF.
  // The following characters are also allowed, but the regexes aren't supported yet.
  // /[\u{10000}-\u{1FFFD}\u{20000-\u{2FFFD}\u{30000}-\u{3FFFD}\u{40000}-\u{4FFFD}]/u,
  // /[\u{50000}-\u{5FFFD}\u{60000-\u{6FFFD}\u{70000}-\u{7FFFD}\u{80000}-\u{8FFFD}]/u,
  // /[\u{90000}-\u{9FFFD}\u{A0000-\u{AFFFD}\u{B0000}-\u{BFFFD}\u{C0000}-\u{CFFFD}]/u,
  // /[\u{D0000}-\u{DFFFD}\u{E0000-\u{EFFFD}]/u
), Jc = vn(
  Dx,
  /\d/,
  /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/
), ti = at(Dx, Jc, "*"), zp = at(/[A-Z]/, Jc, "*"), CU = [
  "attached",
  "autoclosure",
  at(/convention\(/, vn("swift", "block", "c"), /\)/),
  "discardableResult",
  "dynamicCallable",
  "dynamicMemberLookup",
  "escaping",
  "freestanding",
  "frozen",
  "GKInspectable",
  "IBAction",
  "IBDesignable",
  "IBInspectable",
  "IBOutlet",
  "IBSegueAction",
  "inlinable",
  "main",
  "nonobjc",
  "NSApplicationMain",
  "NSCopying",
  "NSManaged",
  at(/objc\(/, ti, /\)/),
  "objc",
  "objcMembers",
  "propertyWrapper",
  "requires_stored_property_inits",
  "resultBuilder",
  "Sendable",
  "testable",
  "UIApplicationMain",
  "unchecked",
  "unknown",
  "usableFromInline",
  "warn_unqualified_access"
], NU = [
  "iOS",
  "iOSApplicationExtension",
  "macOS",
  "macOSApplicationExtension",
  "macCatalyst",
  "macCatalystApplicationExtension",
  "watchOS",
  "watchOSApplicationExtension",
  "tvOS",
  "tvOSApplicationExtension",
  "swift"
];
function DU(e) {
  const t = {
    match: /\s+/,
    relevance: 0
  }, n = e.COMMENT(
    "/\\*",
    "\\*/",
    { contains: ["self"] }
  ), r = [
    e.C_LINE_COMMENT_MODE,
    n
  ], i = {
    match: [
      /\./,
      vn(...MU, ...My)
    ],
    className: { 2: "keyword" }
  }, o = {
    // Consume .keyword to prevent highlighting properties and methods as keywords.
    match: at(/\./, vn(...Pp)),
    relevance: 0
  }, s = Pp.filter((Ie) => typeof Ie == "string").concat(["_|0"]), a = Pp.filter((Ie) => typeof Ie != "string").concat(AU).map(jg), l = { variants: [
    {
      className: "keyword",
      match: vn(...a, ...My)
    }
  ] }, u = {
    $pattern: vn(
      /\b\w+/,
      // regular keywords
      /#\w+/
      // number keywords
    ),
    keyword: s.concat(SU),
    literal: Ay
  }, c = [
    i,
    o,
    l
  ], f = {
    // Consume .built_in to prevent highlighting properties and methods.
    match: at(/\./, vn(...Ty)),
    relevance: 0
  }, d = {
    className: "built_in",
    match: at(/\b/, vn(...Ty), /(?=\()/)
  }, p = [
    f,
    d
  ], h = {
    // Prevent -> from being highlighting as an operator.
    match: /->/,
    relevance: 0
  }, m = {
    className: "operator",
    relevance: 0,
    variants: [
      { match: $p },
      {
        // dot-operator: only operators that start with a dot are allowed to use dots as
        // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more
        // characters that may also include dots.
        match: `\\.(\\.|${Nx})+`
      }
    ]
  }, g = [
    h,
    m
  ], y = "([0-9]_*)+", _ = "([0-9a-fA-F]_*)+", E = {
    className: "number",
    relevance: 0,
    variants: [
      // decimal floating-point-literal (subsumes decimal-literal)
      { match: `\\b(${y})(\\.(${y}))?([eE][+-]?(${y}))?\\b` },
      // hexadecimal floating-point-literal (subsumes hexadecimal-literal)
      { match: `\\b0x(${_})(\\.(${_}))?([pP][+-]?(${y}))?\\b` },
      // octal-literal
      { match: /\b0o([0-7]_*)+\b/ },
      // binary-literal
      { match: /\b0b([01]_*)+\b/ }
    ]
  }, v = (Ie = "") => ({
    className: "subst",
    variants: [
      { match: at(/\\/, Ie, /[0\\tnr"']/) },
      { match: at(/\\/, Ie, /u\{[0-9a-fA-F]{1,8}\}/) }
    ]
  }), M = (Ie = "") => ({
    className: "subst",
    match: at(/\\/, Ie, /[\t ]*(?:[\r\n]|\r\n)/)
  }), k = (Ie = "") => ({
    className: "subst",
    label: "interpol",
    begin: at(/\\/, Ie, /\(/),
    end: /\)/
  }), T = (Ie = "") => ({
    begin: at(Ie, /"""/),
    end: at(/"""/, Ie),
    contains: [
      v(Ie),
      M(Ie),
      k(Ie)
    ]
  }), U = (Ie = "") => ({
    begin: at(Ie, /"/),
    end: at(/"/, Ie),
    contains: [
      v(Ie),
      k(Ie)
    ]
  }), C = {
    className: "string",
    variants: [
      T(),
      T("#"),
      T("##"),
      T("###"),
      U(),
      U("#"),
      U("##"),
      U("###")
    ]
  }, z = [
    e.BACKSLASH_ESCAPE,
    {
      begin: /\[/,
      end: /\]/,
      relevance: 0,
      contains: [e.BACKSLASH_ESCAPE]
    }
  ], H = {
    begin: /\/[^\s](?=[^/\n]*\/)/,
    end: /\//,
    contains: z
  }, j = (Ie) => {
    const ct = at(Ie, /\//), yt = at(/\//, Ie);
    return {
      begin: ct,
      end: yt,
      contains: [
        ...z,
        {
          scope: "comment",
          begin: `#(?!.*${yt})`,
          end: /$/
        }
      ]
    };
  }, V = {
    scope: "regexp",
    variants: [
      j("###"),
      j("##"),
      j("#"),
      H
    ]
  }, Q = { match: at(/`/, ti, /`/) }, le = {
    className: "variable",
    match: /\$\d+/
  }, ne = {
    className: "variable",
    match: `\\$${Jc}+`
  }, w = [
    Q,
    le,
    ne
  ], O = {
    match: /(@|#(un)?)available/,
    scope: "keyword",
    starts: { contains: [
      {
        begin: /\(/,
        end: /\)/,
        keywords: NU,
        contains: [
          ...g,
          E,
          C
        ]
      }
    ] }
  }, q = {
    scope: "keyword",
    match: at(/@/, vn(...CU))
  }, X = {
    scope: "meta",
    match: at(/@/, ti)
  }, se = [
    O,
    q,
    X
  ], fe = {
    match: Nu(/\b[A-Z]/),
    relevance: 0,
    contains: [
      {
        // Common Apple frameworks, for relevance boost
        className: "type",
        match: at(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, Jc, "+")
      },
      {
        // Type identifier
        className: "type",
        match: zp,
        relevance: 0
      },
      {
        // Optional type
        match: /[?!]+/,
        relevance: 0
      },
      {
        // Variadic parameter
        match: /\.\.\./,
        relevance: 0
      },
      {
        // Protocol composition
        match: at(/\s+&\s+/, Nu(zp)),
        relevance: 0
      }
    ]
  }, Se = {
    begin: /</,
    end: />/,
    keywords: u,
    contains: [
      ...r,
      ...c,
      ...se,
      h,
      fe
    ]
  };
  fe.contains.push(Se);
  const P = {
    match: at(ti, /\s*:/),
    keywords: "_|0",
    relevance: 0
  }, ie = {
    begin: /\(/,
    end: /\)/,
    relevance: 0,
    keywords: u,
    contains: [
      "self",
      P,
      ...r,
      V,
      ...c,
      ...p,
      ...g,
      E,
      C,
      ...w,
      ...se,
      fe
    ]
  }, Y = {
    begin: /</,
    end: />/,
    keywords: "repeat each",
    contains: [
      ...r,
      fe
    ]
  }, ge = {
    begin: vn(
      Nu(at(ti, /\s*:/)),
      Nu(at(ti, /\s+/, ti, /\s*:/))
    ),
    end: /:/,
    relevance: 0,
    contains: [
      {
        className: "keyword",
        match: /\b_\b/
      },
      {
        className: "params",
        match: ti
      }
    ]
  }, me = {
    begin: /\(/,
    end: /\)/,
    keywords: u,
    contains: [
      ge,
      ...r,
      ...c,
      ...g,
      E,
      C,
      ...se,
      fe,
      ie
    ],
    endsParent: !0,
    illegal: /["']/
  }, xe = {
    match: [
      /(func|macro)/,
      /\s+/,
      vn(Q.match, ti, $p)
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      Y,
      me,
      t
    ],
    illegal: [
      /\[/,
      /%/
    ]
  }, Ve = {
    match: [
      /\b(?:subscript|init[?!]?)/,
      /\s*(?=[<(])/
    ],
    className: { 1: "keyword" },
    contains: [
      Y,
      me,
      t
    ],
    illegal: /\[|%/
  }, qe = {
    match: [
      /operator/,
      /\s+/,
      $p
    ],
    className: {
      1: "keyword",
      3: "title"
    }
  }, ot = {
    begin: [
      /precedencegroup/,
      /\s+/,
      zp
    ],
    className: {
      1: "keyword",
      3: "title"
    },
    contains: [fe],
    keywords: [
      ...TU,
      ...Ay
    ],
    end: /}/
  };
  for (const Ie of C.variants) {
    const ct = Ie.contains.find((Fe) => Fe.label === "interpol");
    ct.keywords = u;
    const yt = [
      ...c,
      ...p,
      ...g,
      E,
      C,
      ...w
    ];
    ct.contains = [
      ...yt,
      {
        begin: /\(/,
        end: /\)/,
        contains: [
          "self",
          ...yt
        ]
      }
    ];
  }
  return {
    name: "Swift",
    keywords: u,
    contains: [
      ...r,
      xe,
      Ve,
      {
        beginKeywords: "struct protocol class extension enum actor",
        end: "\\{",
        excludeEnd: !0,
        keywords: u,
        contains: [
          e.inherit(e.TITLE_MODE, {
            className: "title.class",
            begin: /[A-Za-z$_][\u00C0-\u02B80-9A-Za-z$_]*/
          }),
          ...c
        ]
      },
      qe,
      ot,
      {
        beginKeywords: "import",
        end: /$/,
        contains: [...r],
        relevance: 0
      },
      V,
      ...c,
      ...p,
      ...g,
      E,
      C,
      ...w,
      ...se,
      fe,
      ie
    ]
  };
}
const ef = "[A-Za-z$_][0-9A-Za-z$_]*", Ox = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
], Ix = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
], Rx = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
], Lx = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
], Bx = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
], Px = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
], $x = [].concat(
  Bx,
  Rx,
  Lx
);
function OU(e) {
  const t = e.regex, n = (O, { after: q }) => {
    const X = "</" + O[0].slice(1);
    return O.input.indexOf(X, q) !== -1;
  }, r = ef, i = {
    begin: "<>",
    end: "</>"
  }, o = /<[A-Za-z0-9\\._:-]+\s*\/>/, s = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (O, q) => {
      const X = O[0].length + O.index, se = O.input[X];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        se === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        se === ","
      ) {
        q.ignoreMatch();
        return;
      }
      se === ">" && (n(O, { after: X }) || q.ignoreMatch());
      let fe;
      const Se = O.input.substring(X);
      if (fe = Se.match(/^\s*=/)) {
        q.ignoreMatch();
        return;
      }
      if ((fe = Se.match(/^\s+extends\s+/)) && fe.index === 0) {
        q.ignoreMatch();
        return;
      }
    }
  }, a = {
    $pattern: ef,
    keyword: Ox,
    literal: Ix,
    built_in: $x,
    "variable.language": Px
  }, l = "[0-9](_?[0-9])*", u = `\\.(${l})`, c = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", f = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${c})((${u})|\\.)?|(${u}))[eE][+-]?(${l})\\b` },
      { begin: `\\b(${c})\\b((${u})\\b|\\.)?|(${u})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, d = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: a,
    contains: []
    // defined later
  }, p = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        e.BACKSLASH_ESCAPE,
        d
      ],
      subLanguage: "xml"
    }
  }, h = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        e.BACKSLASH_ESCAPE,
        d
      ],
      subLanguage: "css"
    }
  }, m = {
    begin: "gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        e.BACKSLASH_ESCAPE,
        d
      ],
      subLanguage: "graphql"
    }
  }, g = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      e.BACKSLASH_ESCAPE,
      d
    ]
  }, _ = {
    className: "comment",
    variants: [
      e.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: r + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      e.C_BLOCK_COMMENT_MODE,
      e.C_LINE_COMMENT_MODE
    ]
  }, E = [
    e.APOS_STRING_MODE,
    e.QUOTE_STRING_MODE,
    p,
    h,
    m,
    g,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    f
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  d.contains = E.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: a,
    contains: [
      "self"
    ].concat(E)
  });
  const v = [].concat(_, d.contains), M = v.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: a,
      contains: ["self"].concat(v)
    }
  ]), k = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: a,
    contains: M
  }, T = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          r,
          /\s+/,
          /extends/,
          /\s+/,
          t.concat(r, "(", t.concat(/\./, r), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          r
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, U = {
    relevance: 0,
    match: t.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...Rx,
        ...Lx
      ]
    }
  }, C = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, z = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          r,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [k],
    illegal: /%/
  }, H = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function j(O) {
    return t.concat("(?!", O.join("|"), ")");
  }
  const V = {
    match: t.concat(
      /\b/,
      j([
        ...Bx,
        "super",
        "import"
      ]),
      r,
      t.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  }, Q = {
    begin: t.concat(/\./, t.lookahead(
      t.concat(r, /(?![0-9A-Za-z$_(])/)
    )),
    end: r,
    excludeBegin: !0,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, le = {
    match: [
      /get|set/,
      /\s+/,
      r,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      k
    ]
  }, ne = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + e.UNDERSCORE_IDENT_RE + ")\\s*=>", w = {
    match: [
      /const|var|let/,
      /\s+/,
      r,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      t.lookahead(ne)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      k
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: a,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: M, CLASS_REFERENCE: U },
    illegal: /#(?![$_A-z])/,
    contains: [
      e.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      C,
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE,
      p,
      h,
      m,
      g,
      _,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      f,
      U,
      {
        className: "attr",
        begin: r + t.lookahead(":"),
        relevance: 0
      },
      w,
      {
        // "value" container
        begin: "(" + e.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          _,
          e.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: ne,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: e.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: a,
                    contains: M
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: i.begin, end: i.end },
              { match: o },
              {
                begin: s.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": s.isTrulyOpeningTag,
                end: s.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: s.begin,
                end: s.end,
                skip: !0,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      z,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + e.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: !0,
        label: "func.def",
        contains: [
          k,
          e.inherit(e.TITLE_MODE, { begin: r, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      Q,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + r,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [k]
      },
      V,
      H,
      T,
      le,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function IU(e) {
  const t = OU(e), n = ef, r = [
    "any",
    "void",
    "number",
    "boolean",
    "string",
    "object",
    "never",
    "symbol",
    "bigint",
    "unknown"
  ], i = {
    beginKeywords: "namespace",
    end: /\{/,
    excludeEnd: !0,
    contains: [t.exports.CLASS_REFERENCE]
  }, o = {
    beginKeywords: "interface",
    end: /\{/,
    excludeEnd: !0,
    keywords: {
      keyword: "interface extends",
      built_in: r
    },
    contains: [t.exports.CLASS_REFERENCE]
  }, s = {
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use strict['"]/
  }, a = [
    "type",
    "namespace",
    "interface",
    "public",
    "private",
    "protected",
    "implements",
    "declare",
    "abstract",
    "readonly",
    "enum",
    "override"
  ], l = {
    $pattern: ef,
    keyword: Ox.concat(a),
    literal: Ix,
    built_in: $x.concat(r),
    "variable.language": Px
  }, u = {
    className: "meta",
    begin: "@" + n
  }, c = (d, p, h) => {
    const m = d.contains.findIndex((g) => g.label === p);
    if (m === -1)
      throw new Error("can not find mode to replace");
    d.contains.splice(m, 1, h);
  };
  Object.assign(t.keywords, l), t.exports.PARAMS_CONTAINS.push(u), t.contains = t.contains.concat([
    u,
    i,
    o
  ]), c(t, "shebang", e.SHEBANG()), c(t, "use_strict", s);
  const f = t.contains.find((d) => d.label === "func.def");
  return f.relevance = 0, Object.assign(t, {
    name: "TypeScript",
    aliases: [
      "ts",
      "tsx",
      "mts",
      "cts"
    ]
  }), t;
}
function RU(e) {
  const t = e.regex, n = {
    className: "string",
    begin: /"(""|[^/n])"C\b/
  }, r = {
    className: "string",
    begin: /"/,
    end: /"/,
    illegal: /\n/,
    contains: [
      {
        // double quote escape
        begin: /""/
      }
    ]
  }, i = /\d{1,2}\/\d{1,2}\/\d{4}/, o = /\d{4}-\d{1,2}-\d{1,2}/, s = /(\d|1[012])(:\d+){0,2} *(AM|PM)/, a = /\d{1,2}(:\d{1,2}){1,2}/, l = {
    className: "literal",
    variants: [
      {
        // #YYYY-MM-DD# (ISO-Date) or #M/D/YYYY# (US-Date)
        begin: t.concat(/# */, t.either(o, i), / *#/)
      },
      {
        // #H:mm[:ss]# (24h Time)
        begin: t.concat(/# */, a, / *#/)
      },
      {
        // #h[:mm[:ss]] A# (12h Time)
        begin: t.concat(/# */, s, / *#/)
      },
      {
        // date plus time
        begin: t.concat(
          /# */,
          t.either(o, i),
          / +/,
          t.either(s, a),
          / *#/
        )
      }
    ]
  }, u = {
    className: "number",
    relevance: 0,
    variants: [
      {
        // Float
        begin: /\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/
      },
      {
        // Integer (base 10)
        begin: /\b\d[\d_]*((U?[SIL])|[%&])?/
      },
      {
        // Integer (base 16)
        begin: /&H[\dA-F_]+((U?[SIL])|[%&])?/
      },
      {
        // Integer (base 8)
        begin: /&O[0-7_]+((U?[SIL])|[%&])?/
      },
      {
        // Integer (base 2)
        begin: /&B[01_]+((U?[SIL])|[%&])?/
      }
    ]
  }, c = {
    className: "label",
    begin: /^\w+:/
  }, f = e.COMMENT(/'''/, /$/, { contains: [
    {
      className: "doctag",
      begin: /<\/?/,
      end: />/
    }
  ] }), d = e.COMMENT(null, /$/, { variants: [
    { begin: /'/ },
    {
      // TODO: Use multi-class for leading spaces
      begin: /([\t ]|^)REM(?=\s)/
    }
  ] });
  return {
    name: "Visual Basic .NET",
    aliases: ["vb"],
    case_insensitive: !0,
    classNameAliases: { label: "symbol" },
    keywords: {
      keyword: "addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield",
      built_in: (
        // Operators https://docs.microsoft.com/dotnet/visual-basic/language-reference/operators
        "addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort"
      ),
      type: (
        // Data types https://docs.microsoft.com/dotnet/visual-basic/language-reference/data-types
        "boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort"
      ),
      literal: "true false nothing"
    },
    illegal: "//|\\{|\\}|endif|gosub|variant|wend|^\\$ ",
    contains: [
      n,
      r,
      l,
      u,
      c,
      f,
      d,
      {
        className: "meta",
        // TODO: Use multi-class for indentation once available
        begin: /[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/,
        end: /$/,
        keywords: { keyword: "const disable else elseif enable end externalsource if region then" },
        contains: [d]
      }
    ]
  };
}
function LU(e) {
  e.regex;
  const t = e.COMMENT(/\(;/, /;\)/);
  t.contains.push("self");
  const n = e.COMMENT(/;;/, /$/), r = [
    "anyfunc",
    "block",
    "br",
    "br_if",
    "br_table",
    "call",
    "call_indirect",
    "data",
    "drop",
    "elem",
    "else",
    "end",
    "export",
    "func",
    "global.get",
    "global.set",
    "local.get",
    "local.set",
    "local.tee",
    "get_global",
    "get_local",
    "global",
    "if",
    "import",
    "local",
    "loop",
    "memory",
    "memory.grow",
    "memory.size",
    "module",
    "mut",
    "nop",
    "offset",
    "param",
    "result",
    "return",
    "select",
    "set_global",
    "set_local",
    "start",
    "table",
    "tee_local",
    "then",
    "type",
    "unreachable"
  ], i = {
    begin: [
      /(?:func|call|call_indirect)/,
      /\s+/,
      /\$[^\s)]+/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    }
  }, o = {
    className: "variable",
    begin: /\$[\w_]+/
  }, s = {
    match: /(\((?!;)|\))+/,
    className: "punctuation",
    relevance: 0
  }, a = {
    className: "number",
    relevance: 0,
    // borrowed from Prism, TODO: split out into variants
    match: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/
  }, l = {
    // look-ahead prevents us from gobbling up opcodes
    match: /(i32|i64|f32|f64)(?!\.)/,
    className: "type"
  }, u = {
    className: "keyword",
    // borrowed from Prism, TODO: split out into variants
    match: /\b(f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))\b/
  };
  return {
    name: "WebAssembly",
    keywords: {
      $pattern: /[\w.]+/,
      keyword: r
    },
    contains: [
      n,
      t,
      {
        match: [
          /(?:offset|align)/,
          /\s*/,
          /=/
        ],
        className: {
          1: "keyword",
          3: "operator"
        }
      },
      o,
      s,
      i,
      e.QUOTE_STRING_MODE,
      l,
      u,
      a
    ]
  };
}
function BU(e) {
  const t = e.regex, n = t.concat(/[\p{L}_]/u, t.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u), r = /[\p{L}0-9._:-]+/u, i = {
    className: "symbol",
    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
  }, o = {
    begin: /\s/,
    contains: [
      {
        className: "keyword",
        begin: /#?[a-z_][a-z1-9_-]+/,
        illegal: /\n/
      }
    ]
  }, s = e.inherit(o, {
    begin: /\(/,
    end: /\)/
  }), a = e.inherit(e.APOS_STRING_MODE, { className: "string" }), l = e.inherit(e.QUOTE_STRING_MODE, { className: "string" }), u = {
    endsWithParent: !0,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: "attr",
        begin: r,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: "string",
            endsParent: !0,
            variants: [
              {
                begin: /"/,
                end: /"/,
                contains: [i]
              },
              {
                begin: /'/,
                end: /'/,
                contains: [i]
              },
              { begin: /[^\s"'=<>`]+/ }
            ]
          }
        ]
      }
    ]
  };
  return {
    name: "HTML, XML",
    aliases: [
      "html",
      "xhtml",
      "rss",
      "atom",
      "xjb",
      "xsd",
      "xsl",
      "plist",
      "wsf",
      "svg"
    ],
    case_insensitive: !0,
    unicodeRegex: !0,
    contains: [
      {
        className: "meta",
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          o,
          l,
          a,
          s,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                contains: [
                  o,
                  s,
                  l,
                  a
                ]
              }
            ]
          }
        ]
      },
      e.COMMENT(
        /<!--/,
        /-->/,
        { relevance: 10 }
      ),
      {
        begin: /<!\[CDATA\[/,
        end: /\]\]>/,
        relevance: 10
      },
      i,
      // xml processing instructions
      {
        className: "meta",
        end: /\?>/,
        variants: [
          {
            begin: /<\?xml/,
            relevance: 10,
            contains: [
              l
            ]
          },
          {
            begin: /<\?[a-z][a-z0-9]+/
          }
        ]
      },
      {
        className: "tag",
        /*
        The lookahead pattern (?=...) ensures that 'begin' only matches
        '<style' as a single word, followed by a whitespace or an
        ending bracket.
        */
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: { name: "style" },
        contains: [u],
        starts: {
          end: /<\/style>/,
          returnEnd: !0,
          subLanguage: [
            "css",
            "xml"
          ]
        }
      },
      {
        className: "tag",
        // See the comment in the <style tag about the lookahead pattern
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: { name: "script" },
        contains: [u],
        starts: {
          end: /<\/script>/,
          returnEnd: !0,
          subLanguage: [
            "javascript",
            "handlebars",
            "xml"
          ]
        }
      },
      // we need this for now for jSX
      {
        className: "tag",
        begin: /<>|<\/>/
      },
      // open tag
      {
        className: "tag",
        begin: t.concat(
          /</,
          t.lookahead(t.concat(
            n,
            // <tag/>
            // <tag>
            // <tag ...
            t.either(/\/>/, />/, /\s/)
          ))
        ),
        end: /\/?>/,
        contains: [
          {
            className: "name",
            begin: n,
            relevance: 0,
            starts: u
          }
        ]
      },
      // close tag
      {
        className: "tag",
        begin: t.concat(
          /<\//,
          t.lookahead(t.concat(
            n,
            />/
          ))
        ),
        contains: [
          {
            className: "name",
            begin: n,
            relevance: 0
          },
          {
            begin: />/,
            relevance: 0,
            endsParent: !0
          }
        ]
      }
    ]
  };
}
function PU(e) {
  const t = "true false yes no null", n = "[\\w#;/?:@&=+$,.~*'()[\\]]+", r = {
    className: "attr",
    variants: [
      { begin: "\\w[\\w :\\/.-]*:(?=[ 	]|$)" },
      {
        // double quoted keys
        begin: '"\\w[\\w :\\/.-]*":(?=[ 	]|$)'
      },
      {
        // single quoted keys
        begin: "'\\w[\\w :\\/.-]*':(?=[ 	]|$)"
      }
    ]
  }, i = {
    className: "template-variable",
    variants: [
      {
        // jinja templates Ansible
        begin: /\{\{/,
        end: /\}\}/
      },
      {
        // Ruby i18n
        begin: /%\{/,
        end: /\}/
      }
    ]
  }, o = {
    className: "string",
    relevance: 0,
    variants: [
      {
        begin: /'/,
        end: /'/
      },
      {
        begin: /"/,
        end: /"/
      },
      { begin: /\S+/ }
    ],
    contains: [
      e.BACKSLASH_ESCAPE,
      i
    ]
  }, s = e.inherit(o, { variants: [
    {
      begin: /'/,
      end: /'/
    },
    {
      begin: /"/,
      end: /"/
    },
    { begin: /[^\s,{}[\]]+/ }
  ] }), f = {
    className: "number",
    begin: "\\b" + "[0-9]{4}(-[0-9][0-9]){0,2}" + "([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?" + "(\\.[0-9]*)?" + "([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?" + "\\b"
  }, d = {
    end: ",",
    endsWithParent: !0,
    excludeEnd: !0,
    keywords: t,
    relevance: 0
  }, p = {
    begin: /\{/,
    end: /\}/,
    contains: [d],
    illegal: "\\n",
    relevance: 0
  }, h = {
    begin: "\\[",
    end: "\\]",
    contains: [d],
    illegal: "\\n",
    relevance: 0
  }, m = [
    r,
    {
      className: "meta",
      begin: "^---\\s*$",
      relevance: 10
    },
    {
      // multi line string
      // Blocks start with a | or > followed by a newline
      //
      // Indentation of subsequent lines must be the same to
      // be considered part of the block
      className: "string",
      begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
    },
    {
      // Ruby/Rails erb
      begin: "<%[%=-]?",
      end: "[%-]?%>",
      subLanguage: "ruby",
      excludeBegin: !0,
      excludeEnd: !0,
      relevance: 0
    },
    {
      // named tags
      className: "type",
      begin: "!\\w+!" + n
    },
    // https://yaml.org/spec/1.2/spec.html#id2784064
    {
      // verbatim tags
      className: "type",
      begin: "!<" + n + ">"
    },
    {
      // primary tags
      className: "type",
      begin: "!" + n
    },
    {
      // secondary tags
      className: "type",
      begin: "!!" + n
    },
    {
      // fragment id &ref
      className: "meta",
      begin: "&" + e.UNDERSCORE_IDENT_RE + "$"
    },
    {
      // fragment reference *ref
      className: "meta",
      begin: "\\*" + e.UNDERSCORE_IDENT_RE + "$"
    },
    {
      // array listing
      className: "bullet",
      // TODO: remove |$ hack when we have proper look-ahead support
      begin: "-(?=[ ]|$)",
      relevance: 0
    },
    e.HASH_COMMENT_MODE,
    {
      beginKeywords: t,
      keywords: { literal: t }
    },
    f,
    // numbers are any valid C-style number that
    // sit isolated from other words
    {
      className: "number",
      begin: e.C_NUMBER_RE + "\\b",
      relevance: 0
    },
    p,
    h,
    o
  ], g = [...m];
  return g.pop(), g.push(s), d.contains = g, {
    name: "YAML",
    case_insensitive: !0,
    aliases: ["yml"],
    contains: m
  };
}
const $U = {
  arduino: Mj,
  bash: Aj,
  c: Tj,
  cpp: Sj,
  csharp: Cj,
  css: Bj,
  diff: Pj,
  go: $j,
  graphql: zj,
  ini: Fj,
  java: jj,
  javascript: Gj,
  json: Wj,
  kotlin: Yj,
  less: tU,
  lua: nU,
  makefile: rU,
  markdown: iU,
  objectivec: oU,
  perl: sU,
  php: aU,
  "php-template": lU,
  plaintext: uU,
  python: cU,
  "python-repl": fU,
  r: dU,
  ruby: pU,
  rust: hU,
  scss: EU,
  shell: wU,
  sql: xU,
  swift: DU,
  typescript: IU,
  vbnet: RU,
  wasm: LU,
  xml: BU,
  yaml: PU
};
function zx(e) {
  return e instanceof Map ? e.clear = e.delete = e.set = function() {
    throw new Error("map is read-only");
  } : e instanceof Set && (e.add = e.clear = e.delete = function() {
    throw new Error("set is read-only");
  }), Object.freeze(e), Object.getOwnPropertyNames(e).forEach((t) => {
    const n = e[t], r = typeof n;
    (r === "object" || r === "function") && !Object.isFrozen(n) && zx(n);
  }), e;
}
class Sy {
  /**
   * @param {CompiledMode} mode
   */
  constructor(t) {
    t.data === void 0 && (t.data = {}), this.data = t.data, this.isMatchIgnored = !1;
  }
  ignoreMatch() {
    this.isMatchIgnored = !0;
  }
}
function Fx(e) {
  return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function Pi(e, ...t) {
  const n = /* @__PURE__ */ Object.create(null);
  for (const r in e)
    n[r] = e[r];
  return t.forEach(function(r) {
    for (const i in r)
      n[i] = r[i];
  }), /** @type {T} */
  n;
}
const zU = "</span>", Cy = (e) => !!e.scope, FU = (e, { prefix: t }) => {
  if (e.startsWith("language:"))
    return e.replace("language:", "language-");
  if (e.includes(".")) {
    const n = e.split(".");
    return [
      `${t}${n.shift()}`,
      ...n.map((r, i) => `${r}${"_".repeat(i + 1)}`)
    ].join(" ");
  }
  return `${t}${e}`;
};
class jU {
  /**
   * Creates a new HTMLRenderer
   *
   * @param {Tree} parseTree - the parse tree (must support `walk` API)
   * @param {{classPrefix: string}} options
   */
  constructor(t, n) {
    this.buffer = "", this.classPrefix = n.classPrefix, t.walk(this);
  }
  /**
   * Adds texts to the output stream
   *
   * @param {string} text */
  addText(t) {
    this.buffer += Fx(t);
  }
  /**
   * Adds a node open to the output stream (if needed)
   *
   * @param {Node} node */
  openNode(t) {
    if (!Cy(t)) return;
    const n = FU(
      t.scope,
      { prefix: this.classPrefix }
    );
    this.span(n);
  }
  /**
   * Adds a node close to the output stream (if needed)
   *
   * @param {Node} node */
  closeNode(t) {
    Cy(t) && (this.buffer += zU);
  }
  /**
   * returns the accumulated buffer
  */
  value() {
    return this.buffer;
  }
  // helpers
  /**
   * Builds a span element
   *
   * @param {string} className */
  span(t) {
    this.buffer += `<span class="${t}">`;
  }
}
const Ny = (e = {}) => {
  const t = { children: [] };
  return Object.assign(t, e), t;
};
class Ug {
  constructor() {
    this.rootNode = Ny(), this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  /** @param {Node} node */
  add(t) {
    this.top.children.push(t);
  }
  /** @param {string} scope */
  openNode(t) {
    const n = Ny({ scope: t });
    this.add(n), this.stack.push(n);
  }
  closeNode() {
    if (this.stack.length > 1)
      return this.stack.pop();
  }
  closeAllNodes() {
    for (; this.closeNode(); ) ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  /**
   * @typedef { import("./html_renderer").Renderer } Renderer
   * @param {Renderer} builder
   */
  walk(t) {
    return this.constructor._walk(t, this.rootNode);
  }
  /**
   * @param {Renderer} builder
   * @param {Node} node
   */
  static _walk(t, n) {
    return typeof n == "string" ? t.addText(n) : n.children && (t.openNode(n), n.children.forEach((r) => this._walk(t, r)), t.closeNode(n)), t;
  }
  /**
   * @param {Node} node
   */
  static _collapse(t) {
    typeof t != "string" && t.children && (t.children.every((n) => typeof n == "string") ? t.children = [t.children.join("")] : t.children.forEach((n) => {
      Ug._collapse(n);
    }));
  }
}
class UU extends Ug {
  /**
   * @param {*} options
   */
  constructor(t) {
    super(), this.options = t;
  }
  /**
   * @param {string} text
   */
  addText(t) {
    t !== "" && this.add(t);
  }
  /** @param {string} scope */
  startScope(t) {
    this.openNode(t);
  }
  endScope() {
    this.closeNode();
  }
  /**
   * @param {Emitter & {root: DataNode}} emitter
   * @param {string} name
   */
  __addSublanguage(t, n) {
    const r = t.root;
    n && (r.scope = `language:${n}`), this.add(r);
  }
  toHTML() {
    return new jU(this, this.options).value();
  }
  finalize() {
    return this.closeAllNodes(), !0;
  }
}
function _l(e) {
  return e ? typeof e == "string" ? e : e.source : null;
}
function jx(e) {
  return Fo("(?=", e, ")");
}
function VU(e) {
  return Fo("(?:", e, ")*");
}
function HU(e) {
  return Fo("(?:", e, ")?");
}
function Fo(...e) {
  return e.map((n) => _l(n)).join("");
}
function qU(e) {
  const t = e[e.length - 1];
  return typeof t == "object" && t.constructor === Object ? (e.splice(e.length - 1, 1), t) : {};
}
function Vg(...e) {
  return "(" + (qU(e).capture ? "" : "?:") + e.map((r) => _l(r)).join("|") + ")";
}
function Ux(e) {
  return new RegExp(e.toString() + "|").exec("").length - 1;
}
function GU(e, t) {
  const n = e && e.exec(t);
  return n && n.index === 0;
}
const WU = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function Hg(e, { joinWith: t }) {
  let n = 0;
  return e.map((r) => {
    n += 1;
    const i = n;
    let o = _l(r), s = "";
    for (; o.length > 0; ) {
      const a = WU.exec(o);
      if (!a) {
        s += o;
        break;
      }
      s += o.substring(0, a.index), o = o.substring(a.index + a[0].length), a[0][0] === "\\" && a[1] ? s += "\\" + String(Number(a[1]) + i) : (s += a[0], a[0] === "(" && n++);
    }
    return s;
  }).map((r) => `(${r})`).join(t);
}
const KU = /\b\B/, Vx = "[a-zA-Z]\\w*", qg = "[a-zA-Z_]\\w*", Hx = "\\b\\d+(\\.\\d+)?", qx = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", Gx = "\\b(0b[01]+)", YU = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", QU = (e = {}) => {
  const t = /^#![ ]*\//;
  return e.binary && (e.begin = Fo(
    t,
    /.*\b/,
    e.binary,
    /\b.*/
  )), Pi({
    scope: "meta",
    begin: t,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": (n, r) => {
      n.index !== 0 && r.ignoreMatch();
    }
  }, e);
}, El = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
}, ZU = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [El]
}, XU = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [El]
}, JU = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
}, kd = function(e, t, n = {}) {
  const r = Pi(
    {
      scope: "comment",
      begin: e,
      end: t,
      contains: []
    },
    n
  );
  r.contains.push({
    scope: "doctag",
    // hack to avoid the space from being included. the space is necessary to
    // match here to prevent the plain text rule below from gobbling up doctags
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: !0,
    relevance: 0
  });
  const i = Vg(
    // list of common 1 and 2 letter words in English
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    // note: this is not an exhaustive list of contractions, just popular ones
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    // contractions - can't we'd they're let's, etc
    /[A-Za-z]+[-][a-z]+/,
    // `no-way`, etc.
    /[A-Za-z][a-z]{2,}/
    // allow capitalized words at beginning of sentences
  );
  return r.contains.push(
    {
      // TODO: how to include ", (, ) without breaking grammars that use these for
      // comment delimiters?
      // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
      // ---
      // this tries to find sequences of 3 english words in a row (without any
      // "programming" type syntax) this gives us a strong signal that we've
      // TRULY found a comment - vs perhaps scanning with the wrong language.
      // It's possible to find something that LOOKS like the start of the
      // comment - but then if there is no readable text - good chance it is a
      // false match and not a comment.
      //
      // for a visual example please see:
      // https://github.com/highlightjs/highlight.js/issues/2827
      begin: Fo(
        /[ ]+/,
        // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
        "(",
        i,
        /[.]?[:]?([.][ ]|[ ])/,
        "){3}"
      )
      // look for 3 words in a row
    }
  ), r;
}, eV = kd("//", "$"), tV = kd("/\\*", "\\*/"), nV = kd("#", "$"), rV = {
  scope: "number",
  begin: Hx,
  relevance: 0
}, iV = {
  scope: "number",
  begin: qx,
  relevance: 0
}, oV = {
  scope: "number",
  begin: Gx,
  relevance: 0
}, sV = {
  scope: "regexp",
  begin: /\/(?=[^/\n]*\/)/,
  end: /\/[gimuy]*/,
  contains: [
    El,
    {
      begin: /\[/,
      end: /\]/,
      relevance: 0,
      contains: [El]
    }
  ]
}, aV = {
  scope: "title",
  begin: Vx,
  relevance: 0
}, lV = {
  scope: "title",
  begin: qg,
  relevance: 0
}, uV = {
  // excludes method names from keyword processing
  begin: "\\.\\s*" + qg,
  relevance: 0
}, cV = function(e) {
  return Object.assign(
    e,
    {
      /** @type {ModeCallback} */
      "on:begin": (t, n) => {
        n.data._beginMatch = t[1];
      },
      /** @type {ModeCallback} */
      "on:end": (t, n) => {
        n.data._beginMatch !== t[1] && n.ignoreMatch();
      }
    }
  );
};
var Du = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  APOS_STRING_MODE: ZU,
  BACKSLASH_ESCAPE: El,
  BINARY_NUMBER_MODE: oV,
  BINARY_NUMBER_RE: Gx,
  COMMENT: kd,
  C_BLOCK_COMMENT_MODE: tV,
  C_LINE_COMMENT_MODE: eV,
  C_NUMBER_MODE: iV,
  C_NUMBER_RE: qx,
  END_SAME_AS_BEGIN: cV,
  HASH_COMMENT_MODE: nV,
  IDENT_RE: Vx,
  MATCH_NOTHING_RE: KU,
  METHOD_GUARD: uV,
  NUMBER_MODE: rV,
  NUMBER_RE: Hx,
  PHRASAL_WORDS_MODE: JU,
  QUOTE_STRING_MODE: XU,
  REGEXP_MODE: sV,
  RE_STARTERS_RE: YU,
  SHEBANG: QU,
  TITLE_MODE: aV,
  UNDERSCORE_IDENT_RE: qg,
  UNDERSCORE_TITLE_MODE: lV
});
function fV(e, t) {
  e.input[e.index - 1] === "." && t.ignoreMatch();
}
function dV(e, t) {
  e.className !== void 0 && (e.scope = e.className, delete e.className);
}
function pV(e, t) {
  t && e.beginKeywords && (e.begin = "\\b(" + e.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", e.__beforeBegin = fV, e.keywords = e.keywords || e.beginKeywords, delete e.beginKeywords, e.relevance === void 0 && (e.relevance = 0));
}
function hV(e, t) {
  Array.isArray(e.illegal) && (e.illegal = Vg(...e.illegal));
}
function gV(e, t) {
  if (e.match) {
    if (e.begin || e.end) throw new Error("begin & end are not supported with match");
    e.begin = e.match, delete e.match;
  }
}
function mV(e, t) {
  e.relevance === void 0 && (e.relevance = 1);
}
const bV = (e, t) => {
  if (!e.beforeMatch) return;
  if (e.starts) throw new Error("beforeMatch cannot be used with starts");
  const n = Object.assign({}, e);
  Object.keys(e).forEach((r) => {
    delete e[r];
  }), e.keywords = n.keywords, e.begin = Fo(n.beforeMatch, jx(n.begin)), e.starts = {
    relevance: 0,
    contains: [
      Object.assign(n, { endsParent: !0 })
    ]
  }, e.relevance = 0, delete n.beforeMatch;
}, yV = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  // common variable name
  "list",
  // common variable name
  "value"
  // common variable name
], vV = "keyword";
function Wx(e, t, n = vV) {
  const r = /* @__PURE__ */ Object.create(null);
  return typeof e == "string" ? i(n, e.split(" ")) : Array.isArray(e) ? i(n, e) : Object.keys(e).forEach(function(o) {
    Object.assign(
      r,
      Wx(e[o], t, o)
    );
  }), r;
  function i(o, s) {
    t && (s = s.map((a) => a.toLowerCase())), s.forEach(function(a) {
      const l = a.split("|");
      r[l[0]] = [o, _V(l[0], l[1])];
    });
  }
}
function _V(e, t) {
  return t ? Number(t) : EV(e) ? 0 : 1;
}
function EV(e) {
  return yV.includes(e.toLowerCase());
}
const Dy = {}, Mo = (e) => {
  console.error(e);
}, Oy = (e, ...t) => {
  console.log(`WARN: ${e}`, ...t);
}, Ko = (e, t) => {
  Dy[`${e}/${t}`] || (console.log(`Deprecated as of ${e}. ${t}`), Dy[`${e}/${t}`] = !0);
}, tf = new Error();
function Kx(e, t, { key: n }) {
  let r = 0;
  const i = e[n], o = {}, s = {};
  for (let a = 1; a <= t.length; a++)
    s[a + r] = i[a], o[a + r] = !0, r += Ux(t[a - 1]);
  e[n] = s, e[n]._emit = o, e[n]._multi = !0;
}
function wV(e) {
  if (Array.isArray(e.begin)) {
    if (e.skip || e.excludeBegin || e.returnBegin)
      throw Mo("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), tf;
    if (typeof e.beginScope != "object" || e.beginScope === null)
      throw Mo("beginScope must be object"), tf;
    Kx(e, e.begin, { key: "beginScope" }), e.begin = Hg(e.begin, { joinWith: "" });
  }
}
function xV(e) {
  if (Array.isArray(e.end)) {
    if (e.skip || e.excludeEnd || e.returnEnd)
      throw Mo("skip, excludeEnd, returnEnd not compatible with endScope: {}"), tf;
    if (typeof e.endScope != "object" || e.endScope === null)
      throw Mo("endScope must be object"), tf;
    Kx(e, e.end, { key: "endScope" }), e.end = Hg(e.end, { joinWith: "" });
  }
}
function kV(e) {
  e.scope && typeof e.scope == "object" && e.scope !== null && (e.beginScope = e.scope, delete e.scope);
}
function MV(e) {
  kV(e), typeof e.beginScope == "string" && (e.beginScope = { _wrap: e.beginScope }), typeof e.endScope == "string" && (e.endScope = { _wrap: e.endScope }), wV(e), xV(e);
}
function AV(e) {
  function t(s, a) {
    return new RegExp(
      _l(s),
      "m" + (e.case_insensitive ? "i" : "") + (e.unicodeRegex ? "u" : "") + (a ? "g" : "")
    );
  }
  class n {
    constructor() {
      this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
    }
    // @ts-ignore
    addRule(a, l) {
      l.position = this.position++, this.matchIndexes[this.matchAt] = l, this.regexes.push([l, a]), this.matchAt += Ux(a) + 1;
    }
    compile() {
      this.regexes.length === 0 && (this.exec = () => null);
      const a = this.regexes.map((l) => l[1]);
      this.matcherRe = t(Hg(a, { joinWith: "|" }), !0), this.lastIndex = 0;
    }
    /** @param {string} s */
    exec(a) {
      this.matcherRe.lastIndex = this.lastIndex;
      const l = this.matcherRe.exec(a);
      if (!l)
        return null;
      const u = l.findIndex((f, d) => d > 0 && f !== void 0), c = this.matchIndexes[u];
      return l.splice(0, u), Object.assign(l, c);
    }
  }
  class r {
    constructor() {
      this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
    }
    // @ts-ignore
    getMatcher(a) {
      if (this.multiRegexes[a]) return this.multiRegexes[a];
      const l = new n();
      return this.rules.slice(a).forEach(([u, c]) => l.addRule(u, c)), l.compile(), this.multiRegexes[a] = l, l;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    // @ts-ignore
    addRule(a, l) {
      this.rules.push([a, l]), l.type === "begin" && this.count++;
    }
    /** @param {string} s */
    exec(a) {
      const l = this.getMatcher(this.regexIndex);
      l.lastIndex = this.lastIndex;
      let u = l.exec(a);
      if (this.resumingScanAtSamePosition() && !(u && u.index === this.lastIndex)) {
        const c = this.getMatcher(0);
        c.lastIndex = this.lastIndex + 1, u = c.exec(a);
      }
      return u && (this.regexIndex += u.position + 1, this.regexIndex === this.count && this.considerAll()), u;
    }
  }
  function i(s) {
    const a = new r();
    return s.contains.forEach((l) => a.addRule(l.begin, { rule: l, type: "begin" })), s.terminatorEnd && a.addRule(s.terminatorEnd, { type: "end" }), s.illegal && a.addRule(s.illegal, { type: "illegal" }), a;
  }
  function o(s, a) {
    const l = (
      /** @type CompiledMode */
      s
    );
    if (s.isCompiled) return l;
    [
      dV,
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      gV,
      MV,
      bV
    ].forEach((c) => c(s, a)), e.compilerExtensions.forEach((c) => c(s, a)), s.__beforeBegin = null, [
      pV,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      hV,
      // default to 1 relevance if not specified
      mV
    ].forEach((c) => c(s, a)), s.isCompiled = !0;
    let u = null;
    return typeof s.keywords == "object" && s.keywords.$pattern && (s.keywords = Object.assign({}, s.keywords), u = s.keywords.$pattern, delete s.keywords.$pattern), u = u || /\w+/, s.keywords && (s.keywords = Wx(s.keywords, e.case_insensitive)), l.keywordPatternRe = t(u, !0), a && (s.begin || (s.begin = /\B|\b/), l.beginRe = t(l.begin), !s.end && !s.endsWithParent && (s.end = /\B|\b/), s.end && (l.endRe = t(l.end)), l.terminatorEnd = _l(l.end) || "", s.endsWithParent && a.terminatorEnd && (l.terminatorEnd += (s.end ? "|" : "") + a.terminatorEnd)), s.illegal && (l.illegalRe = t(
      /** @type {RegExp | string} */
      s.illegal
    )), s.contains || (s.contains = []), s.contains = [].concat(...s.contains.map(function(c) {
      return TV(c === "self" ? s : c);
    })), s.contains.forEach(function(c) {
      o(
        /** @type Mode */
        c,
        l
      );
    }), s.starts && o(s.starts, a), l.matcher = i(l), l;
  }
  if (e.compilerExtensions || (e.compilerExtensions = []), e.contains && e.contains.includes("self"))
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  return e.classNameAliases = Pi(e.classNameAliases || {}), o(
    /** @type Mode */
    e
  );
}
function Yx(e) {
  return e ? e.endsWithParent || Yx(e.starts) : !1;
}
function TV(e) {
  return e.variants && !e.cachedVariants && (e.cachedVariants = e.variants.map(function(t) {
    return Pi(e, { variants: null }, t);
  })), e.cachedVariants ? e.cachedVariants : Yx(e) ? Pi(e, { starts: e.starts ? Pi(e.starts) : null }) : Object.isFrozen(e) ? Pi(e) : e;
}
var SV = "11.9.0";
class CV extends Error {
  constructor(t, n) {
    super(t), this.name = "HTMLInjectionError", this.html = n;
  }
}
const Fp = Fx, Iy = Pi, Ry = Symbol("nomatch"), NV = 7, Qx = function(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null), r = [];
  let i = !0;
  const o = "Could not find the language '{}', did you forget to load/include a language module?", s = { disableAutodetect: !0, name: "Plain text", contains: [] };
  let a = {
    ignoreUnescapedHTML: !1,
    throwUnescapedHTML: !1,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: UU
  };
  function l(w) {
    return a.noHighlightRe.test(w);
  }
  function u(w) {
    let O = w.className + " ";
    O += w.parentNode ? w.parentNode.className : "";
    const q = a.languageDetectRe.exec(O);
    if (q) {
      const X = C(q[1]);
      return X || (Oy(o.replace("{}", q[1])), Oy("Falling back to no-highlight mode for this block.", w)), X ? q[1] : "no-highlight";
    }
    return O.split(/\s+/).find((X) => l(X) || C(X));
  }
  function c(w, O, q) {
    let X = "", se = "";
    typeof O == "object" ? (X = w, q = O.ignoreIllegals, se = O.language) : (Ko("10.7.0", "highlight(lang, code, ...args) has been deprecated."), Ko("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), se = w, X = O), q === void 0 && (q = !0);
    const fe = {
      code: X,
      language: se
    };
    le("before:highlight", fe);
    const Se = fe.result ? fe.result : f(fe.language, fe.code, q);
    return Se.code = fe.code, le("after:highlight", Se), Se;
  }
  function f(w, O, q, X) {
    const se = /* @__PURE__ */ Object.create(null);
    function fe(F, K) {
      return F.keywords[K];
    }
    function Se() {
      if (!ee.keywords) {
        Te.addText(we);
        return;
      }
      let F = 0;
      ee.keywordPatternRe.lastIndex = 0;
      let K = ee.keywordPatternRe.exec(we), ue = "";
      for (; K; ) {
        ue += we.substring(F, K.index);
        const ve = Fe.case_insensitive ? K[0].toLowerCase() : K[0], N = fe(ee, ve);
        if (N) {
          const [I, J] = N;
          if (Te.addText(ue), ue = "", se[ve] = (se[ve] || 0) + 1, se[ve] <= NV && (ut += J), I.startsWith("_"))
            ue += K[0];
          else {
            const D = Fe.classNameAliases[I] || I;
            Y(K[0], D);
          }
        } else
          ue += K[0];
        F = ee.keywordPatternRe.lastIndex, K = ee.keywordPatternRe.exec(we);
      }
      ue += we.substring(F), Te.addText(ue);
    }
    function P() {
      if (we === "") return;
      let F = null;
      if (typeof ee.subLanguage == "string") {
        if (!t[ee.subLanguage]) {
          Te.addText(we);
          return;
        }
        F = f(ee.subLanguage, we, !0, Ke[ee.subLanguage]), Ke[ee.subLanguage] = /** @type {CompiledMode} */
        F._top;
      } else
        F = p(we, ee.subLanguage.length ? ee.subLanguage : null);
      ee.relevance > 0 && (ut += F.relevance), Te.__addSublanguage(F._emitter, F.language);
    }
    function ie() {
      ee.subLanguage != null ? P() : Se(), we = "";
    }
    function Y(F, K) {
      F !== "" && (Te.startScope(K), Te.addText(F), Te.endScope());
    }
    function ge(F, K) {
      let ue = 1;
      const ve = K.length - 1;
      for (; ue <= ve; ) {
        if (!F._emit[ue]) {
          ue++;
          continue;
        }
        const N = Fe.classNameAliases[F[ue]] || F[ue], I = K[ue];
        N ? Y(I, N) : (we = I, Se(), we = ""), ue++;
      }
    }
    function me(F, K) {
      return F.scope && typeof F.scope == "string" && Te.openNode(Fe.classNameAliases[F.scope] || F.scope), F.beginScope && (F.beginScope._wrap ? (Y(we, Fe.classNameAliases[F.beginScope._wrap] || F.beginScope._wrap), we = "") : F.beginScope._multi && (ge(F.beginScope, K), we = "")), ee = Object.create(F, { parent: { value: ee } }), ee;
    }
    function xe(F, K, ue) {
      let ve = GU(F.endRe, ue);
      if (ve) {
        if (F["on:end"]) {
          const N = new Sy(F);
          F["on:end"](K, N), N.isMatchIgnored && (ve = !1);
        }
        if (ve) {
          for (; F.endsParent && F.parent; )
            F = F.parent;
          return F;
        }
      }
      if (F.endsWithParent)
        return xe(F.parent, K, ue);
    }
    function Ve(F) {
      return ee.matcher.regexIndex === 0 ? (we += F[0], 1) : (vt = !0, 0);
    }
    function qe(F) {
      const K = F[0], ue = F.rule, ve = new Sy(ue), N = [ue.__beforeBegin, ue["on:begin"]];
      for (const I of N)
        if (I && (I(F, ve), ve.isMatchIgnored))
          return Ve(K);
      return ue.skip ? we += K : (ue.excludeBegin && (we += K), ie(), !ue.returnBegin && !ue.excludeBegin && (we = K)), me(ue, F), ue.returnBegin ? 0 : K.length;
    }
    function ot(F) {
      const K = F[0], ue = O.substring(F.index), ve = xe(ee, F, ue);
      if (!ve)
        return Ry;
      const N = ee;
      ee.endScope && ee.endScope._wrap ? (ie(), Y(K, ee.endScope._wrap)) : ee.endScope && ee.endScope._multi ? (ie(), ge(ee.endScope, F)) : N.skip ? we += K : (N.returnEnd || N.excludeEnd || (we += K), ie(), N.excludeEnd && (we = K));
      do
        ee.scope && Te.closeNode(), !ee.skip && !ee.subLanguage && (ut += ee.relevance), ee = ee.parent;
      while (ee !== ve.parent);
      return ve.starts && me(ve.starts, F), N.returnEnd ? 0 : K.length;
    }
    function Ie() {
      const F = [];
      for (let K = ee; K !== Fe; K = K.parent)
        K.scope && F.unshift(K.scope);
      F.forEach((K) => Te.openNode(K));
    }
    let ct = {};
    function yt(F, K) {
      const ue = K && K[0];
      if (we += F, ue == null)
        return ie(), 0;
      if (ct.type === "begin" && K.type === "end" && ct.index === K.index && ue === "") {
        if (we += O.slice(K.index, K.index + 1), !i) {
          const ve = new Error(`0 width match regex (${w})`);
          throw ve.languageName = w, ve.badRule = ct.rule, ve;
        }
        return 1;
      }
      if (ct = K, K.type === "begin")
        return qe(K);
      if (K.type === "illegal" && !q) {
        const ve = new Error('Illegal lexeme "' + ue + '" for mode "' + (ee.scope || "<unnamed>") + '"');
        throw ve.mode = ee, ve;
      } else if (K.type === "end") {
        const ve = ot(K);
        if (ve !== Ry)
          return ve;
      }
      if (K.type === "illegal" && ue === "")
        return 1;
      if (Ct > 1e5 && Ct > K.index * 3)
        throw new Error("potential infinite loop, way more iterations than matches");
      return we += ue, ue.length;
    }
    const Fe = C(w);
    if (!Fe)
      throw Mo(o.replace("{}", w)), new Error('Unknown language: "' + w + '"');
    const $t = AV(Fe);
    let St = "", ee = X || $t;
    const Ke = {}, Te = new a.__emitter(a);
    Ie();
    let we = "", ut = 0, Xe = 0, Ct = 0, vt = !1;
    try {
      if (Fe.__emitTokens)
        Fe.__emitTokens(O, Te);
      else {
        for (ee.matcher.considerAll(); ; ) {
          Ct++, vt ? vt = !1 : ee.matcher.considerAll(), ee.matcher.lastIndex = Xe;
          const F = ee.matcher.exec(O);
          if (!F) break;
          const K = O.substring(Xe, F.index), ue = yt(K, F);
          Xe = F.index + ue;
        }
        yt(O.substring(Xe));
      }
      return Te.finalize(), St = Te.toHTML(), {
        language: w,
        value: St,
        relevance: ut,
        illegal: !1,
        _emitter: Te,
        _top: ee
      };
    } catch (F) {
      if (F.message && F.message.includes("Illegal"))
        return {
          language: w,
          value: Fp(O),
          illegal: !0,
          relevance: 0,
          _illegalBy: {
            message: F.message,
            index: Xe,
            context: O.slice(Xe - 100, Xe + 100),
            mode: F.mode,
            resultSoFar: St
          },
          _emitter: Te
        };
      if (i)
        return {
          language: w,
          value: Fp(O),
          illegal: !1,
          relevance: 0,
          errorRaised: F,
          _emitter: Te,
          _top: ee
        };
      throw F;
    }
  }
  function d(w) {
    const O = {
      value: Fp(w),
      illegal: !1,
      relevance: 0,
      _top: s,
      _emitter: new a.__emitter(a)
    };
    return O._emitter.addText(w), O;
  }
  function p(w, O) {
    O = O || a.languages || Object.keys(t);
    const q = d(w), X = O.filter(C).filter(H).map(
      (ie) => f(ie, w, !1)
    );
    X.unshift(q);
    const se = X.sort((ie, Y) => {
      if (ie.relevance !== Y.relevance) return Y.relevance - ie.relevance;
      if (ie.language && Y.language) {
        if (C(ie.language).supersetOf === Y.language)
          return 1;
        if (C(Y.language).supersetOf === ie.language)
          return -1;
      }
      return 0;
    }), [fe, Se] = se, P = fe;
    return P.secondBest = Se, P;
  }
  function h(w, O, q) {
    const X = O && n[O] || q;
    w.classList.add("hljs"), w.classList.add(`language-${X}`);
  }
  function m(w) {
    let O = null;
    const q = u(w);
    if (l(q)) return;
    if (le(
      "before:highlightElement",
      { el: w, language: q }
    ), w.dataset.highlighted) {
      console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", w);
      return;
    }
    if (w.children.length > 0 && (a.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(w)), a.throwUnescapedHTML))
      throw new CV(
        "One of your code blocks includes unescaped HTML.",
        w.innerHTML
      );
    O = w;
    const X = O.textContent, se = q ? c(X, { language: q, ignoreIllegals: !0 }) : p(X);
    w.innerHTML = se.value, w.dataset.highlighted = "yes", h(w, q, se.language), w.result = {
      language: se.language,
      // TODO: remove with version 11.0
      re: se.relevance,
      relevance: se.relevance
    }, se.secondBest && (w.secondBest = {
      language: se.secondBest.language,
      relevance: se.secondBest.relevance
    }), le("after:highlightElement", { el: w, result: se, text: X });
  }
  function g(w) {
    a = Iy(a, w);
  }
  const y = () => {
    v(), Ko("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function _() {
    v(), Ko("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let E = !1;
  function v() {
    if (document.readyState === "loading") {
      E = !0;
      return;
    }
    document.querySelectorAll(a.cssSelector).forEach(m);
  }
  function M() {
    E && v();
  }
  typeof window < "u" && window.addEventListener && window.addEventListener("DOMContentLoaded", M, !1);
  function k(w, O) {
    let q = null;
    try {
      q = O(e);
    } catch (X) {
      if (Mo("Language definition for '{}' could not be registered.".replace("{}", w)), i)
        Mo(X);
      else
        throw X;
      q = s;
    }
    q.name || (q.name = w), t[w] = q, q.rawDefinition = O.bind(null, e), q.aliases && z(q.aliases, { languageName: w });
  }
  function T(w) {
    delete t[w];
    for (const O of Object.keys(n))
      n[O] === w && delete n[O];
  }
  function U() {
    return Object.keys(t);
  }
  function C(w) {
    return w = (w || "").toLowerCase(), t[w] || t[n[w]];
  }
  function z(w, { languageName: O }) {
    typeof w == "string" && (w = [w]), w.forEach((q) => {
      n[q.toLowerCase()] = O;
    });
  }
  function H(w) {
    const O = C(w);
    return O && !O.disableAutodetect;
  }
  function j(w) {
    w["before:highlightBlock"] && !w["before:highlightElement"] && (w["before:highlightElement"] = (O) => {
      w["before:highlightBlock"](
        Object.assign({ block: O.el }, O)
      );
    }), w["after:highlightBlock"] && !w["after:highlightElement"] && (w["after:highlightElement"] = (O) => {
      w["after:highlightBlock"](
        Object.assign({ block: O.el }, O)
      );
    });
  }
  function V(w) {
    j(w), r.push(w);
  }
  function Q(w) {
    const O = r.indexOf(w);
    O !== -1 && r.splice(O, 1);
  }
  function le(w, O) {
    const q = w;
    r.forEach(function(X) {
      X[q] && X[q](O);
    });
  }
  function ne(w) {
    return Ko("10.7.0", "highlightBlock will be removed entirely in v12.0"), Ko("10.7.0", "Please use highlightElement now."), m(w);
  }
  Object.assign(e, {
    highlight: c,
    highlightAuto: p,
    highlightAll: v,
    highlightElement: m,
    // TODO: Remove with v12 API
    highlightBlock: ne,
    configure: g,
    initHighlighting: y,
    initHighlightingOnLoad: _,
    registerLanguage: k,
    unregisterLanguage: T,
    listLanguages: U,
    getLanguage: C,
    registerAliases: z,
    autoDetection: H,
    inherit: Iy,
    addPlugin: V,
    removePlugin: Q
  }), e.debugMode = function() {
    i = !1;
  }, e.safeMode = function() {
    i = !0;
  }, e.versionString = SV, e.regex = {
    concat: Fo,
    lookahead: jx,
    either: Vg,
    optional: HU,
    anyNumberOfTimes: VU
  };
  for (const w in Du)
    typeof Du[w] == "object" && zx(Du[w]);
  return Object.assign(e, Du), e;
}, js = Qx({});
js.newInstance = () => Qx({});
var DV = js;
js.HighlightJS = js;
js.default = js;
const OV = /* @__PURE__ */ ex(DV), Ly = {}, IV = "hljs-";
function RV(e) {
  const t = OV.newInstance();
  return e && o(e), {
    highlight: n,
    highlightAuto: r,
    listLanguages: i,
    register: o,
    registerAlias: s,
    registered: a
  };
  function n(l, u, c) {
    const f = c || Ly, d = typeof f.prefix == "string" ? f.prefix : IV;
    if (!t.getLanguage(l))
      throw new Error("Unknown language: `" + l + "` is not registered");
    t.configure({ __emitter: LV, classPrefix: d });
    const p = (
      /** @type {HighlightResult & {_emitter: HastEmitter}} */
      t.highlight(u, { ignoreIllegals: !0, language: l })
    );
    if (p.errorRaised)
      throw new Error("Could not highlight with `Highlight.js`", {
        cause: p.errorRaised
      });
    const h = p._emitter.root, m = (
      /** @type {RootData} */
      h.data
    );
    return m.language = p.language, m.relevance = p.relevance, h;
  }
  function r(l, u) {
    const f = (u || Ly).subset || i();
    let d = -1, p = 0, h;
    for (; ++d < f.length; ) {
      const m = f[d];
      if (!t.getLanguage(m)) continue;
      const g = n(m, l, u);
      g.data && g.data.relevance !== void 0 && g.data.relevance > p && (p = g.data.relevance, h = g);
    }
    return h || {
      type: "root",
      children: [],
      data: { language: void 0, relevance: p }
    };
  }
  function i() {
    return t.listLanguages();
  }
  function o(l, u) {
    if (typeof l == "string")
      t.registerLanguage(l, u);
    else {
      let c;
      for (c in l)
        Object.hasOwn(l, c) && t.registerLanguage(c, l[c]);
    }
  }
  function s(l, u) {
    if (typeof l == "string")
      t.registerAliases(
        // Note: copy needed because hljs doesnt accept readonly arrays yet.
        typeof u == "string" ? u : [...u],
        { languageName: l }
      );
    else {
      let c;
      for (c in l)
        if (Object.hasOwn(l, c)) {
          const f = l[c];
          t.registerAliases(
            // Note: copy needed because hljs doesnt accept readonly arrays yet.
            typeof f == "string" ? f : [...f],
            { languageName: c }
          );
        }
    }
  }
  function a(l) {
    return !!t.getLanguage(l);
  }
}
class LV {
  /**
   * @param {Readonly<HljsOptions>} options
   *   Configuration.
   * @returns
   *   Instance.
   */
  constructor(t) {
    this.options = t, this.root = {
      type: "root",
      children: [],
      data: { language: void 0, relevance: 0 }
    }, this.stack = [this.root];
  }
  /**
   * @param {string} value
   *   Text to add.
   * @returns {undefined}
   *   Nothing.
   *
   */
  addText(t) {
    if (t === "") return;
    const n = this.stack[this.stack.length - 1], r = n.children[n.children.length - 1];
    r && r.type === "text" ? r.value += t : n.children.push({ type: "text", value: t });
  }
  /**
   *
   * @param {unknown} rawName
   *   Name to add.
   * @returns {undefined}
   *   Nothing.
   */
  startScope(t) {
    this.openNode(String(t));
  }
  /**
   * @returns {undefined}
   *   Nothing.
   */
  endScope() {
    this.closeNode();
  }
  /**
   * @param {HastEmitter} other
   *   Other emitter.
   * @param {string} name
   *   Name of the sublanguage.
   * @returns {undefined}
   *   Nothing.
   */
  __addSublanguage(t, n) {
    const r = this.stack[this.stack.length - 1], i = (
      /** @type {Array<ElementContent>} */
      t.root.children
    );
    n ? r.children.push({
      type: "element",
      tagName: "span",
      properties: { className: [n] },
      children: i
    }) : r.children.push(...i);
  }
  /**
   * @param {string} name
   *   Name to add.
   * @returns {undefined}
   *   Nothing.
   */
  openNode(t) {
    const n = this, r = t.split(".").map(function(s, a) {
      return a ? s + "_".repeat(a) : n.options.classPrefix + s;
    }), i = this.stack[this.stack.length - 1], o = {
      type: "element",
      tagName: "span",
      properties: { className: r },
      children: []
    };
    i.children.push(o), this.stack.push(o);
  }
  /**
   * @returns {undefined}
   *   Nothing.
   */
  closeNode() {
    this.stack.pop();
  }
  /**
   * @returns {undefined}
   *   Nothing.
   */
  finalize() {
  }
  /**
   * @returns {string}
   *   Nothing.
   */
  toHTML() {
    return "";
  }
}
const BV = xj.extend({
  addOptions() {
    var e;
    return {
      ...(e = this.parent) == null ? void 0 : e.call(this),
      lowlight: RV($U),
      defaultLanguage: null,
      HTMLAttributes: {
        class: "block-node"
      }
    };
  }
}), PV = ht.create({
  name: "color",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          color: {
            default: null,
            parseHTML: (e) => {
              var t;
              return (t = e.style.color) === null || t === void 0 ? void 0 : t.replace(/['"]+/g, "");
            },
            renderHTML: (e) => e.color ? {
              style: `color: ${e.color}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setColor: (e) => ({ chain: t }) => t().setMark("textStyle", { color: e }).run(),
      unsetColor: () => ({ chain: e }) => e().setMark("textStyle", { color: null }).removeEmptyTextStyle().run()
    };
  }
}), $V = PV.extend({
  addProseMirrorPlugins() {
    var e;
    return [
      ...((e = this.parent) == null ? void 0 : e.call(this)) || [],
      new mt({
        props: {
          handleKeyDown: (t, n) => (n.key === "Enter" && this.editor.commands.unsetColor(), !1)
        }
      })
    ];
  }
}), zV = Tw.extend({
  addKeyboardShortcuts() {
    return {
      "Mod-Alt--": () => this.editor.commands.insertContent({
        type: this.name
      })
    };
  }
}), FV = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", jV = "121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222", Us = (e, t) => {
  for (const n in t)
    e[n] = t[n];
  return e;
}, Wh = "numeric", Kh = "ascii", Yh = "alpha", sc = "asciinumeric", Ou = "alphanumeric", Qh = "domain", Zx = "emoji", UV = "scheme", VV = "slashscheme", By = "whitespace";
function HV(e, t) {
  return e in t || (t[e] = []), t[e];
}
function po(e, t, n) {
  t[Wh] && (t[sc] = !0, t[Ou] = !0), t[Kh] && (t[sc] = !0, t[Yh] = !0), t[sc] && (t[Ou] = !0), t[Yh] && (t[Ou] = !0), t[Ou] && (t[Qh] = !0), t[Zx] && (t[Qh] = !0);
  for (const r in t) {
    const i = HV(r, n);
    i.indexOf(e) < 0 && i.push(e);
  }
}
function qV(e, t) {
  const n = {};
  for (const r in t)
    t[r].indexOf(e) >= 0 && (n[r] = !0);
  return n;
}
function wn(e = null) {
  this.j = {}, this.jr = [], this.jd = null, this.t = e;
}
wn.groups = {};
wn.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(e) {
    const t = this, n = t.j[e];
    if (n)
      return n;
    for (let r = 0; r < t.jr.length; r++) {
      const i = t.jr[r][0], o = t.jr[r][1];
      if (o && i.test(e))
        return o;
    }
    return t.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(e, t = !1) {
    return t ? e in this.j : !!this.go(e);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(e, t, n, r) {
    for (let i = 0; i < e.length; i++)
      this.tt(e[i], t, n, r);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(e, t, n, r) {
    r = r || wn.groups;
    let i;
    return t && t.j ? i = t : (i = new wn(t), n && r && po(t, n, r)), this.jr.push([e, i]), i;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(e, t, n, r) {
    let i = this;
    const o = e.length;
    if (!o)
      return i;
    for (let s = 0; s < o - 1; s++)
      i = i.tt(e[s]);
    return i.tt(e[o - 1], t, n, r);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(e, t, n, r) {
    r = r || wn.groups;
    const i = this;
    if (t && t.j)
      return i.j[e] = t, t;
    const o = t;
    let s, a = i.go(e);
    if (a ? (s = new wn(), Us(s.j, a.j), s.jr.push.apply(s.jr, a.jr), s.jd = a.jd, s.t = a.t) : s = new wn(), o) {
      if (r)
        if (s.t && typeof s.t == "string") {
          const l = Us(qV(s.t, r), n);
          po(o, l, r);
        } else n && po(o, n, r);
      s.t = o;
    }
    return i.j[e] = s, s;
  }
};
const $e = (e, t, n, r, i) => e.ta(t, n, r, i), qn = (e, t, n, r, i) => e.tr(t, n, r, i), Py = (e, t, n, r, i) => e.ts(t, n, r, i), de = (e, t, n, r, i) => e.tt(t, n, r, i), ni = "WORD", Zh = "UWORD", wl = "LOCALHOST", Xh = "TLD", Jh = "UTLD", ac = "SCHEME", ns = "SLASH_SCHEME", Gg = "NUM", Xx = "WS", Wg = "NL", Ha = "OPENBRACE", qa = "CLOSEBRACE", nf = "OPENBRACKET", rf = "CLOSEBRACKET", of = "OPENPAREN", sf = "CLOSEPAREN", af = "OPENANGLEBRACKET", lf = "CLOSEANGLEBRACKET", uf = "FULLWIDTHLEFTPAREN", cf = "FULLWIDTHRIGHTPAREN", ff = "LEFTCORNERBRACKET", df = "RIGHTCORNERBRACKET", pf = "LEFTWHITECORNERBRACKET", hf = "RIGHTWHITECORNERBRACKET", gf = "FULLWIDTHLESSTHAN", mf = "FULLWIDTHGREATERTHAN", bf = "AMPERSAND", yf = "APOSTROPHE", vf = "ASTERISK", wi = "AT", _f = "BACKSLASH", Ef = "BACKTICK", wf = "CARET", Ci = "COLON", Kg = "COMMA", xf = "DOLLAR", wr = "DOT", kf = "EQUALS", Yg = "EXCLAMATION", xr = "HYPHEN", Mf = "PERCENT", Af = "PIPE", Tf = "PLUS", Sf = "POUND", Cf = "QUERY", Qg = "QUOTE", Jx = "FULLWIDTHMIDDLEDOT", Zg = "SEMI", kr = "SLASH", Ga = "TILDE", Nf = "UNDERSCORE", ek = "EMOJI", Df = "SYM";
var tk = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WORD: ni,
  UWORD: Zh,
  LOCALHOST: wl,
  TLD: Xh,
  UTLD: Jh,
  SCHEME: ac,
  SLASH_SCHEME: ns,
  NUM: Gg,
  WS: Xx,
  NL: Wg,
  OPENBRACE: Ha,
  CLOSEBRACE: qa,
  OPENBRACKET: nf,
  CLOSEBRACKET: rf,
  OPENPAREN: of,
  CLOSEPAREN: sf,
  OPENANGLEBRACKET: af,
  CLOSEANGLEBRACKET: lf,
  FULLWIDTHLEFTPAREN: uf,
  FULLWIDTHRIGHTPAREN: cf,
  LEFTCORNERBRACKET: ff,
  RIGHTCORNERBRACKET: df,
  LEFTWHITECORNERBRACKET: pf,
  RIGHTWHITECORNERBRACKET: hf,
  FULLWIDTHLESSTHAN: gf,
  FULLWIDTHGREATERTHAN: mf,
  AMPERSAND: bf,
  APOSTROPHE: yf,
  ASTERISK: vf,
  AT: wi,
  BACKSLASH: _f,
  BACKTICK: Ef,
  CARET: wf,
  COLON: Ci,
  COMMA: Kg,
  DOLLAR: xf,
  DOT: wr,
  EQUALS: kf,
  EXCLAMATION: Yg,
  HYPHEN: xr,
  PERCENT: Mf,
  PIPE: Af,
  PLUS: Tf,
  POUND: Sf,
  QUERY: Cf,
  QUOTE: Qg,
  FULLWIDTHMIDDLEDOT: Jx,
  SEMI: Zg,
  SLASH: kr,
  TILDE: Ga,
  UNDERSCORE: Nf,
  EMOJI: ek,
  SYM: Df
});
const Yo = /[a-z]/, jp = new RegExp("\\p{L}", "u"), Up = new RegExp("\\p{Emoji}", "u"), Vp = /\d/, $y = /\s/, zy = `
`, GV = "", WV = "";
let Iu = null, Ru = null;
function KV(e = []) {
  const t = {};
  wn.groups = t;
  const n = new wn();
  Iu == null && (Iu = Fy(FV)), Ru == null && (Ru = Fy(jV)), de(n, "'", yf), de(n, "{", Ha), de(n, "}", qa), de(n, "[", nf), de(n, "]", rf), de(n, "(", of), de(n, ")", sf), de(n, "<", af), de(n, ">", lf), de(n, "", uf), de(n, "", cf), de(n, "", ff), de(n, "", df), de(n, "", pf), de(n, "", hf), de(n, "", gf), de(n, "", mf), de(n, "&", bf), de(n, "*", vf), de(n, "@", wi), de(n, "`", Ef), de(n, "^", wf), de(n, ":", Ci), de(n, ",", Kg), de(n, "$", xf), de(n, ".", wr), de(n, "=", kf), de(n, "!", Yg), de(n, "-", xr), de(n, "%", Mf), de(n, "|", Af), de(n, "+", Tf), de(n, "#", Sf), de(n, "?", Cf), de(n, '"', Qg), de(n, "/", kr), de(n, ";", Zg), de(n, "~", Ga), de(n, "_", Nf), de(n, "\\", _f), de(n, "", Jx);
  const r = qn(n, Vp, Gg, {
    [Wh]: !0
  });
  qn(r, Vp, r);
  const i = qn(n, Yo, ni, {
    [Kh]: !0
  });
  qn(i, Yo, i);
  const o = qn(n, jp, Zh, {
    [Yh]: !0
  });
  qn(o, Yo), qn(o, jp, o);
  const s = qn(n, $y, Xx, {
    [By]: !0
  });
  de(n, zy, Wg, {
    [By]: !0
  }), de(s, zy), qn(s, $y, s);
  const a = qn(n, Up, ek, {
    [Zx]: !0
  });
  qn(a, Up, a), de(a, GV, a);
  const l = de(a, WV);
  qn(l, Up, a);
  const u = [[Yo, i]], c = [[Yo, null], [jp, o]];
  for (let f = 0; f < Iu.length; f++)
    mi(n, Iu[f], Xh, ni, u);
  for (let f = 0; f < Ru.length; f++)
    mi(n, Ru[f], Jh, Zh, c);
  po(Xh, {
    tld: !0,
    ascii: !0
  }, t), po(Jh, {
    utld: !0,
    alpha: !0
  }, t), mi(n, "file", ac, ni, u), mi(n, "mailto", ac, ni, u), mi(n, "http", ns, ni, u), mi(n, "https", ns, ni, u), mi(n, "ftp", ns, ni, u), mi(n, "ftps", ns, ni, u), po(ac, {
    scheme: !0,
    ascii: !0
  }, t), po(ns, {
    slashscheme: !0,
    ascii: !0
  }, t), e = e.sort((f, d) => f[0] > d[0] ? 1 : -1);
  for (let f = 0; f < e.length; f++) {
    const d = e[f][0], h = e[f][1] ? {
      [UV]: !0
    } : {
      [VV]: !0
    };
    d.indexOf("-") >= 0 ? h[Qh] = !0 : Yo.test(d) ? Vp.test(d) ? h[sc] = !0 : h[Kh] = !0 : h[Wh] = !0, Py(n, d, d, h);
  }
  return Py(n, "localhost", wl, {
    ascii: !0
  }), n.jd = new wn(Df), {
    start: n,
    tokens: Us({
      groups: t
    }, tk)
  };
}
function nk(e, t) {
  const n = YV(t.replace(/[A-Z]/g, (a) => a.toLowerCase())), r = n.length, i = [];
  let o = 0, s = 0;
  for (; s < r; ) {
    let a = e, l = null, u = 0, c = null, f = -1, d = -1;
    for (; s < r && (l = a.go(n[s])); )
      a = l, a.accepts() ? (f = 0, d = 0, c = a) : f >= 0 && (f += n[s].length, d++), u += n[s].length, o += n[s].length, s++;
    o -= f, s -= d, u -= f, i.push({
      t: c.t,
      // token type/name
      v: t.slice(o - u, o),
      // string value
      s: o - u,
      // start index
      e: o
      // end index (excluding)
    });
  }
  return i;
}
function YV(e) {
  const t = [], n = e.length;
  let r = 0;
  for (; r < n; ) {
    let i = e.charCodeAt(r), o, s = i < 55296 || i > 56319 || r + 1 === n || (o = e.charCodeAt(r + 1)) < 56320 || o > 57343 ? e[r] : e.slice(r, r + 2);
    t.push(s), r += s.length;
  }
  return t;
}
function mi(e, t, n, r, i) {
  let o;
  const s = t.length;
  for (let a = 0; a < s - 1; a++) {
    const l = t[a];
    e.j[l] ? o = e.j[l] : (o = new wn(r), o.jr = i.slice(), e.j[l] = o), e = o;
  }
  return o = new wn(n), o.jr = i.slice(), e.j[t[s - 1]] = o, o;
}
function Fy(e) {
  const t = [], n = [];
  let r = 0, i = "0123456789";
  for (; r < e.length; ) {
    let o = 0;
    for (; i.indexOf(e[r + o]) >= 0; )
      o++;
    if (o > 0) {
      t.push(n.join(""));
      for (let s = parseInt(e.substring(r, r + o), 10); s > 0; s--)
        n.pop();
      r += o;
    } else
      n.push(e[r]), r++;
  }
  return t;
}
const xl = {
  defaultProtocol: "http",
  events: null,
  format: jy,
  formatHref: jy,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function Xg(e, t = null) {
  let n = Us({}, xl);
  e && (n = Us(n, e instanceof Xg ? e.o : e));
  const r = n.ignoreTags, i = [];
  for (let o = 0; o < r.length; o++)
    i.push(r[o].toUpperCase());
  this.o = n, t && (this.defaultRender = t), this.ignoreTags = i;
}
Xg.prototype = {
  o: xl,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(e) {
    return e;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(e) {
    return this.get("validate", e.toString(), e);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(e, t, n) {
    const r = t != null;
    let i = this.o[e];
    return i && (typeof i == "object" ? (i = n.t in i ? i[n.t] : xl[e], typeof i == "function" && r && (i = i(t, n))) : typeof i == "function" && r && (i = i(t, n.t, n)), i);
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(e, t, n) {
    let r = this.o[e];
    return typeof r == "function" && t != null && (r = r(t, n.t, n)), r;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(e) {
    const t = e.render(this);
    return (this.get("render", null, e) || this.defaultRender)(t, e.t, e);
  }
};
function jy(e) {
  return e;
}
function rk(e, t) {
  this.t = "token", this.v = e, this.tk = t;
}
rk.prototype = {
  isLink: !1,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(e) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(e) {
    const t = this.toString(), n = e.get("truncate", t, this), r = e.get("format", t, this);
    return n && r.length > n ? r.substring(0, n) + "" : r;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(e) {
    return e.get("formatHref", this.toHref(e.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(e = xl.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(e),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(e) {
    return {
      type: this.t,
      value: this.toFormattedString(e),
      isLink: this.isLink,
      href: this.toFormattedHref(e),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(e) {
    return e.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(e) {
    const t = this, n = this.toHref(e.get("defaultProtocol")), r = e.get("formatHref", n, this), i = e.get("tagName", n, t), o = this.toFormattedString(e), s = {}, a = e.get("className", n, t), l = e.get("target", n, t), u = e.get("rel", n, t), c = e.getObj("attributes", n, t), f = e.getObj("events", n, t);
    return s.href = r, a && (s.class = a), l && (s.target = l), u && (s.rel = u), c && Us(s, c), {
      tagName: i,
      attributes: s,
      content: o,
      eventListeners: f
    };
  }
};
function Md(e, t) {
  class n extends rk {
    constructor(i, o) {
      super(i, o), this.t = e;
    }
  }
  for (const r in t)
    n.prototype[r] = t[r];
  return n.t = e, n;
}
const Uy = Md("email", {
  isLink: !0,
  toHref() {
    return "mailto:" + this.toString();
  }
}), Vy = Md("text"), QV = Md("nl"), Lu = Md("url", {
  isLink: !0,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(e = xl.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${e}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const e = this.tk;
    return e.length >= 2 && e[0].t !== wl && e[1].t === Ci;
  }
}), Gn = (e) => new wn(e);
function ZV({
  groups: e
}) {
  const t = e.domain.concat([bf, vf, wi, _f, Ef, wf, xf, kf, xr, Gg, Mf, Af, Tf, Sf, kr, Df, Ga, Nf]), n = [yf, Ci, Kg, wr, Yg, Cf, Qg, Zg, af, lf, Ha, qa, rf, nf, of, sf, uf, cf, ff, df, pf, hf, gf, mf], r = [bf, yf, vf, _f, Ef, wf, xf, kf, xr, Ha, qa, Mf, Af, Tf, Sf, Cf, kr, Df, Ga, Nf], i = Gn(), o = de(i, Ga);
  $e(o, r, o), $e(o, e.domain, o);
  const s = Gn(), a = Gn(), l = Gn();
  $e(i, e.domain, s), $e(i, e.scheme, a), $e(i, e.slashscheme, l), $e(s, r, o), $e(s, e.domain, s);
  const u = de(s, wi);
  de(o, wi, u), de(a, wi, u), de(l, wi, u);
  const c = de(o, wr);
  $e(c, r, o), $e(c, e.domain, o);
  const f = Gn();
  $e(u, e.domain, f), $e(f, e.domain, f);
  const d = de(f, wr);
  $e(d, e.domain, f);
  const p = Gn(Uy);
  $e(d, e.tld, p), $e(d, e.utld, p), de(u, wl, p);
  const h = de(f, xr);
  $e(h, e.domain, f), $e(p, e.domain, f), de(p, wr, d), de(p, xr, h);
  const m = de(p, Ci);
  $e(m, e.numeric, Uy);
  const g = de(s, xr), y = de(s, wr);
  $e(g, e.domain, s), $e(y, r, o), $e(y, e.domain, s);
  const _ = Gn(Lu);
  $e(y, e.tld, _), $e(y, e.utld, _), $e(_, e.domain, s), $e(_, r, o), de(_, wr, y), de(_, xr, g), de(_, wi, u);
  const E = de(_, Ci), v = Gn(Lu);
  $e(E, e.numeric, v);
  const M = Gn(Lu), k = Gn();
  $e(M, t, M), $e(M, n, k), $e(k, t, M), $e(k, n, k), de(_, kr, M), de(v, kr, M);
  const T = de(a, Ci), U = de(l, Ci), C = de(U, kr), z = de(C, kr);
  $e(a, e.domain, s), de(a, wr, y), de(a, xr, g), $e(l, e.domain, s), de(l, wr, y), de(l, xr, g), $e(T, e.domain, M), de(T, kr, M), $e(z, e.domain, M), $e(z, t, M), de(z, kr, M);
  const H = [
    [Ha, qa],
    // {}
    [nf, rf],
    // []
    [of, sf],
    // ()
    [af, lf],
    // <>
    [uf, cf],
    // 
    [ff, df],
    // 
    [pf, hf],
    // 
    [gf, mf]
    // 
  ];
  for (let j = 0; j < H.length; j++) {
    const [V, Q] = H[j], le = de(M, V);
    de(k, V, le), de(le, Q, M);
    const ne = Gn(Lu);
    $e(le, t, ne);
    const w = Gn();
    $e(le, n), $e(ne, t, ne), $e(ne, n, w), $e(w, t, ne), $e(w, n, w), de(ne, Q, M), de(w, Q, M);
  }
  return de(i, wl, _), de(i, Wg, QV), {
    start: i,
    tokens: tk
  };
}
function XV(e, t, n) {
  let r = n.length, i = 0, o = [], s = [];
  for (; i < r; ) {
    let a = e, l = null, u = null, c = 0, f = null, d = -1;
    for (; i < r && !(l = a.go(n[i].t)); )
      s.push(n[i++]);
    for (; i < r && (u = l || a.go(n[i].t)); )
      l = null, a = u, a.accepts() ? (d = 0, f = a) : d >= 0 && d++, i++, c++;
    if (d < 0)
      i -= c, i < r && (s.push(n[i]), i++);
    else {
      s.length > 0 && (o.push(Hp(Vy, t, s)), s = []), i -= d, c -= d;
      const p = f.t, h = n.slice(i - c, i);
      o.push(Hp(p, t, h));
    }
  }
  return s.length > 0 && o.push(Hp(Vy, t, s)), o;
}
function Hp(e, t, n) {
  const r = n[0].s, i = n[n.length - 1].e, o = t.slice(r, i);
  return new e(o, n);
}
const JV = typeof console < "u" && console && console.warn || (() => {
}), eH = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", gt = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1
};
function tH() {
  return wn.groups = {}, gt.scanner = null, gt.parser = null, gt.tokenQueue = [], gt.pluginQueue = [], gt.customSchemes = [], gt.initialized = !1, gt;
}
function Hy(e, t = !1) {
  if (gt.initialized && JV(`linkifyjs: already initialized - will not register custom scheme "${e}" ${eH}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(e))
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  gt.customSchemes.push([e, t]);
}
function nH() {
  gt.scanner = KV(gt.customSchemes);
  for (let e = 0; e < gt.tokenQueue.length; e++)
    gt.tokenQueue[e][1]({
      scanner: gt.scanner
    });
  gt.parser = ZV(gt.scanner.tokens);
  for (let e = 0; e < gt.pluginQueue.length; e++)
    gt.pluginQueue[e][1]({
      scanner: gt.scanner,
      parser: gt.parser
    });
  return gt.initialized = !0, gt;
}
function Jg(e) {
  return gt.initialized || nH(), XV(gt.parser.start, e, nk(gt.scanner.start, e));
}
Jg.scan = nk;
function ik(e, t = null, n = null) {
  if (t && typeof t == "object") {
    if (n)
      throw Error(`linkifyjs: Invalid link type ${t}; must be a string`);
    n = t, t = null;
  }
  const r = new Xg(n), i = Jg(e), o = [];
  for (let s = 0; s < i.length; s++) {
    const a = i[s];
    a.isLink && (!t || a.t === t) && r.check(a) && o.push(a.toFormattedObject(r));
  }
  return o;
}
function rH(e) {
  return e.length === 1 ? e[0].isLink : e.length === 3 && e[1].isLink ? ["()", "[]"].includes(e[0].value + e[2].value) : !1;
}
function iH(e) {
  return new mt({
    key: new Pt("autolink"),
    appendTransaction: (t, n, r) => {
      const i = t.some((u) => u.docChanged) && !n.doc.eq(r.doc), o = t.some((u) => u.getMeta("preventAutolink"));
      if (!i || o)
        return;
      const { tr: s } = r, a = SI(n.doc, [...t]);
      if (BI(a).forEach(({ newRange: u }) => {
        const c = NI(r.doc, u, (p) => p.isTextblock);
        let f, d;
        if (c.length > 1 ? (f = c[0], d = r.doc.textBetween(f.pos, f.pos + f.node.nodeSize, void 0, " ")) : c.length && r.doc.textBetween(u.from, u.to, " ", " ").endsWith(" ") && (f = c[0], d = r.doc.textBetween(f.pos, u.to, void 0, " ")), f && d) {
          const p = d.split(" ").filter((y) => y !== "");
          if (p.length <= 0)
            return !1;
          const h = p[p.length - 1], m = f.pos + d.lastIndexOf(h);
          if (!h)
            return !1;
          const g = Jg(h).map((y) => y.toObject(e.defaultProtocol));
          if (!rH(g))
            return !1;
          g.filter((y) => y.isLink).map((y) => ({
            ...y,
            from: m + y.start + 1,
            to: m + y.end + 1
          })).filter((y) => r.schema.marks.code ? !r.doc.rangeHasMark(y.from, y.to, r.schema.marks.code) : !0).filter((y) => e.validate(y.value)).filter((y) => e.shouldAutoLink(y.value)).forEach((y) => {
            ug(y.from, y.to, r.doc).some((_) => _.mark.type === e.type) || s.addMark(y.from, y.to, e.type.create({
              href: y.href
            }));
          });
        }
      }), !!s.steps.length)
        return s;
    }
  });
}
function oH(e) {
  return new mt({
    key: new Pt("handleClickLink"),
    props: {
      handleClick: (t, n, r) => {
        var i, o;
        if (r.button !== 0 || !t.editable)
          return !1;
        let s = r.target;
        const a = [];
        for (; s.nodeName !== "DIV"; )
          a.push(s), s = s.parentNode;
        if (!a.find((d) => d.nodeName === "A"))
          return !1;
        const l = x3(t.state, e.type.name), u = r.target, c = (i = u == null ? void 0 : u.href) !== null && i !== void 0 ? i : l.href, f = (o = u == null ? void 0 : u.target) !== null && o !== void 0 ? o : l.target;
        return u && c ? (window.open(c, f), !0) : !1;
      }
    }
  });
}
function sH(e) {
  return new mt({
    key: new Pt("handlePasteLink"),
    props: {
      handlePaste: (t, n, r) => {
        const { state: i } = t, { selection: o } = i, { empty: s } = o;
        if (s)
          return !1;
        let a = "";
        r.content.forEach((u) => {
          a += u.textContent;
        });
        const l = ik(a, { defaultProtocol: e.defaultProtocol }).find((u) => u.isLink && u.value === a);
        return !a || !l ? !1 : (e.editor.commands.setMark(e.type, {
          href: l.href
        }), !0);
      }
    }
  });
}
const aH = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
function da(e, t) {
  const n = [
    "http",
    "https",
    "ftp",
    "ftps",
    "mailto",
    "tel",
    "callto",
    "sms",
    "cid",
    "xmpp"
  ];
  return t && t.forEach((r) => {
    const i = typeof r == "string" ? r : r.scheme;
    i && n.push(i);
  }), !e || e.replace(aH, "").match(new RegExp(
    // eslint-disable-next-line no-useless-escape
    `^(?:(?:${n.join("|")}):|[^a-z]|[a-z+.-]+(?:[^a-z+.-:]|$))`,
    "i"
  ));
}
const lH = Jt.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: !1,
  exitable: !0,
  onCreate() {
    this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach((e) => {
      if (typeof e == "string") {
        Hy(e);
        return;
      }
      Hy(e.scheme, e.optionalSlashes);
    });
  },
  onDestroy() {
    tH();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: !0,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (e, t) => !!da(e, t.protocols),
      validate: (e) => !!e,
      shouldAutoLink: (e) => !!e
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(e) {
          return e.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (e) => {
          const t = e.getAttribute("href");
          return !t || !this.options.isAllowedUri(t, {
            defaultValidate: (n) => !!da(n, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          }) ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return this.options.isAllowedUri(e.href, {
      defaultValidate: (t) => !!da(t, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    }) ? ["a", At(this.options.HTMLAttributes, e), 0] : [
      "a",
      At(this.options.HTMLAttributes, { ...e, href: "" }),
      0
    ];
  },
  addCommands() {
    return {
      setLink: (e) => ({ chain: t }) => t().setMark(this.name, e).setMeta("preventAutolink", !0).run(),
      toggleLink: (e) => ({ chain: t }) => t().toggleMark(this.name, e, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run(),
      unsetLink: () => ({ chain: e }) => e().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run()
    };
  },
  addPasteRules() {
    return [
      Io({
        find: (e) => {
          const t = [];
          if (e) {
            const { protocols: n, defaultProtocol: r } = this.options, i = ik(e).filter((o) => o.isLink && this.options.isAllowedUri(o.value, {
              defaultValidate: (s) => !!da(s, n),
              protocols: n,
              defaultProtocol: r
            }));
            i.length && i.forEach((o) => t.push({
              text: o.value,
              data: {
                href: o.href
              },
              index: o.start
            }));
          }
          return t;
        },
        type: this.type,
        getAttributes: (e) => {
          var t;
          return {
            href: (t = e.data) === null || t === void 0 ? void 0 : t.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const e = [], { protocols: t, defaultProtocol: n } = this.options;
    return this.options.autolink && e.push(iH({
      type: this.type,
      defaultProtocol: this.options.defaultProtocol,
      validate: (r) => this.options.isAllowedUri(r, {
        defaultValidate: (i) => !!da(i, t),
        protocols: t,
        defaultProtocol: n
      }),
      shouldAutoLink: this.options.shouldAutoLink
    })), this.options.openOnClick === !0 && e.push(oH({
      type: this.type
    })), this.options.linkOnPaste && e.push(sH({
      editor: this.editor,
      defaultProtocol: this.options.defaultProtocol,
      type: this.type
    })), e;
  }
}), uH = lH.extend({
  /*
   * Determines whether typing next to a link automatically becomes part of the link.
   * In this case, we dont want any characters to be included as part of the link.
   */
  inclusive: !1,
  /*
   * Match all <a> elements that have an href attribute, except for:
   * - <a> elements with a data-type attribute set to button
   * - <a> elements with an href attribute that contains 'javascript:'
   */
  parseHTML() {
    return [{ tag: 'a[href]:not([data-type="button"]):not([href *= "javascript:" i])' }];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["a", At(this.options.HTMLAttributes, e), 0];
  },
  addOptions() {
    var e;
    return {
      ...(e = this.parent) == null ? void 0 : e.call(this),
      openOnClick: !1,
      HTMLAttributes: {
        class: "link"
      }
    };
  },
  addProseMirrorPlugins() {
    var t;
    const { editor: e } = this;
    return [
      ...((t = this.parent) == null ? void 0 : t.call(this)) || [],
      new mt({
        props: {
          handleKeyDown: (n, r) => {
            const { selection: i } = e.state;
            return r.key === "Escape" && i.empty !== !0 && e.commands.focus(i.to, { scrollIntoView: !1 }), !1;
          },
          handleClick(n, r) {
            const { schema: i, doc: o, tr: s } = n.state, a = dd(o.resolve(r), i.marks.link);
            if (!a)
              return;
            const { from: l, to: u } = a, c = Math.min(l, u), f = Math.max(l, u);
            if (r < c || r > f)
              return;
            const d = o.resolve(c), p = o.resolve(f), h = s.setSelection(new Oe(d, p));
            n.dispatch(h);
          }
        }
      })
    ];
  }
}), cH = ht.create({
  name: "selection",
  addProseMirrorPlugins() {
    const { editor: e } = this;
    return [
      new mt({
        key: new Pt("selection"),
        props: {
          decorations(t) {
            return t.selection.empty || e.isFocused === !0 ? null : xt.create(t.doc, [
              dn.inline(t.selection.from, t.selection.to, {
                class: "selection"
              })
            ]);
          }
        }
      })
    ];
  }
}), fH = ht.create({
  addKeyboardShortcuts() {
    return {
      "Mod-\\": () => this.editor.commands.unsetAllMarks()
    };
  }
}), dH = ht.create({
  name: "resetMarksOnEnter",
  addKeyboardShortcuts() {
    return {
      Enter: ({ editor: e }) => e.isActive("bold") || e.isActive("italic") || e.isActive("strike") || e.isActive("underline") || e.isActive("code") ? (e.commands.splitBlock({ keepMarks: !1 }), !0) : !1
    };
  }
}), pH = (e) => [
  FB.configure({
    horizontalRule: !1,
    codeBlock: !1,
    paragraph: { HTMLAttributes: { class: "text-node" } },
    heading: { HTMLAttributes: { class: "heading-node" } },
    blockquote: { HTMLAttributes: { class: "block-node" } },
    bulletList: { HTMLAttributes: { class: "list-node" } },
    orderedList: { HTMLAttributes: { class: "list-node" } },
    code: { HTMLAttributes: { class: "inline", spellcheck: "false" } },
    dropcursor: { width: 2, class: "ProseMirror-dropcursor border" }
  }),
  uH,
  fP,
  $V,
  dP,
  cH,
  uP,
  fH,
  zV,
  dH,
  BV,
  cP.configure({ placeholder: () => e }),
  _F,
  EF,
  xF
];
function hH({
  modelValue: e,
  output: t = "html",
  placeholder: n = "",
  editorClassName: r = "",
  onUpdate: i,
  onBlur: o,
  ...s
}) {
  const a = (c) => {
    i == null || i(xb(c, t));
  }, l = (c) => {
    e && c.isEmpty && c.commands.setContent(e);
  }, u = (c) => {
    o == null || o(xb(c, t));
  };
  return G9({
    extensions: pH(n),
    editorProps: {
      attributes: {
        autocomplete: "off",
        autocorrect: "off",
        autocapitalize: "off",
        class: `focus:outline-none ${r}`
      }
    },
    onUpdate: ({ editor: c }) => a(c),
    onCreate: ({ editor: c }) => l(c),
    onBlur: ({ editor: c }) => u(c),
    ...s
  });
}
const gH = { class: "shrink-0" }, mH = { class: "shrink-0" }, nne = /* @__PURE__ */ S({
  __name: "EnhancedTextarea",
  props: {
    modelValue: {},
    class: {},
    editorContentClassName: {},
    editorClassName: {},
    placeholder: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = _e(
      hH({
        modelValue: n.modelValue,
        placeholder: n.placeholder,
        editorClassName: G("grow", n.editorClassName),
        onUpdate(o) {
          r("update:modelValue", o);
        }
      })
    );
    return (o, s) => i.value ? (x(), W("div", {
      key: 0,
      class: ce(
        b(G)("flex flex-col rounded-md border border-input focus-within:border-primary", n.class)
      )
    }, [
      be("div", gH, [
        B(o.$slots, "top", { editor: i.value }, () => [
          $(UL, { editor: i.value }, null, 8, ["editor"])
        ])
      ]),
      $(b(q9), {
        editor: i.value,
        class: ce(
          b(G)(
            "minimal-tiptap-editor flex max-h-36 min-h-20 w-full grow flex-col overflow-y-auto p-4",
            o.editorContentClassName
          )
        )
      }, null, 8, ["editor", "class"]),
      be("div", mH, [
        B(o.$slots, "bottom", { editor: i.value })
      ])
    ], 2)) : Qe("", !0);
  }
});
var bH = Object.create, ok = Object.defineProperty, yH = Object.getOwnPropertyDescriptor, e1 = Object.getOwnPropertyNames, vH = Object.getPrototypeOf, _H = Object.prototype.hasOwnProperty, EH = (e, t) => function() {
  return e && (t = (0, e[e1(e)[0]])(e = 0)), t;
}, wH = (e, t) => function() {
  return t || (0, e[e1(e)[0]])((t = { exports: {} }).exports, t), t.exports;
}, xH = (e, t, n, r) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of e1(t))
      !_H.call(e, i) && i !== n && ok(e, i, { get: () => t[i], enumerable: !(r = yH(t, i)) || r.enumerable });
  return e;
}, kH = (e, t, n) => (n = e != null ? bH(vH(e)) : {}, xH(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  ok(n, "default", { value: e, enumerable: !0 }),
  e
)), eu = EH({
  "../../node_modules/.pnpm/tsup@8.3.5_@microsoft+api-extractor@7.43.0_@types+node@22.9.0__@swc+core@1.5.29_jiti@2.0.0_po_lnt5yfvawfblpk67opvcdwbq7u/node_modules/tsup/assets/esm_shims.js"() {
  }
}), MH = wH({
  "../../node_modules/.pnpm/rfdc@1.4.1/node_modules/rfdc/index.js"(e, t) {
    eu(), t.exports = r;
    function n(o) {
      return o instanceof Buffer ? Buffer.from(o) : new o.constructor(o.buffer.slice(), o.byteOffset, o.length);
    }
    function r(o) {
      if (o = o || {}, o.circles) return i(o);
      const s = /* @__PURE__ */ new Map();
      if (s.set(Date, (f) => new Date(f)), s.set(Map, (f, d) => new Map(l(Array.from(f), d))), s.set(Set, (f, d) => new Set(l(Array.from(f), d))), o.constructorHandlers)
        for (const f of o.constructorHandlers)
          s.set(f[0], f[1]);
      let a = null;
      return o.proto ? c : u;
      function l(f, d) {
        const p = Object.keys(f), h = new Array(p.length);
        for (let m = 0; m < p.length; m++) {
          const g = p[m], y = f[g];
          typeof y != "object" || y === null ? h[g] = y : y.constructor !== Object && (a = s.get(y.constructor)) ? h[g] = a(y, d) : ArrayBuffer.isView(y) ? h[g] = n(y) : h[g] = d(y);
        }
        return h;
      }
      function u(f) {
        if (typeof f != "object" || f === null) return f;
        if (Array.isArray(f)) return l(f, u);
        if (f.constructor !== Object && (a = s.get(f.constructor)))
          return a(f, u);
        const d = {};
        for (const p in f) {
          if (Object.hasOwnProperty.call(f, p) === !1) continue;
          const h = f[p];
          typeof h != "object" || h === null ? d[p] = h : h.constructor !== Object && (a = s.get(h.constructor)) ? d[p] = a(h, u) : ArrayBuffer.isView(h) ? d[p] = n(h) : d[p] = u(h);
        }
        return d;
      }
      function c(f) {
        if (typeof f != "object" || f === null) return f;
        if (Array.isArray(f)) return l(f, c);
        if (f.constructor !== Object && (a = s.get(f.constructor)))
          return a(f, c);
        const d = {};
        for (const p in f) {
          const h = f[p];
          typeof h != "object" || h === null ? d[p] = h : h.constructor !== Object && (a = s.get(h.constructor)) ? d[p] = a(h, c) : ArrayBuffer.isView(h) ? d[p] = n(h) : d[p] = c(h);
        }
        return d;
      }
    }
    function i(o) {
      const s = [], a = [], l = /* @__PURE__ */ new Map();
      if (l.set(Date, (p) => new Date(p)), l.set(Map, (p, h) => new Map(c(Array.from(p), h))), l.set(Set, (p, h) => new Set(c(Array.from(p), h))), o.constructorHandlers)
        for (const p of o.constructorHandlers)
          l.set(p[0], p[1]);
      let u = null;
      return o.proto ? d : f;
      function c(p, h) {
        const m = Object.keys(p), g = new Array(m.length);
        for (let y = 0; y < m.length; y++) {
          const _ = m[y], E = p[_];
          if (typeof E != "object" || E === null)
            g[_] = E;
          else if (E.constructor !== Object && (u = l.get(E.constructor)))
            g[_] = u(E, h);
          else if (ArrayBuffer.isView(E))
            g[_] = n(E);
          else {
            const v = s.indexOf(E);
            v !== -1 ? g[_] = a[v] : g[_] = h(E);
          }
        }
        return g;
      }
      function f(p) {
        if (typeof p != "object" || p === null) return p;
        if (Array.isArray(p)) return c(p, f);
        if (p.constructor !== Object && (u = l.get(p.constructor)))
          return u(p, f);
        const h = {};
        s.push(p), a.push(h);
        for (const m in p) {
          if (Object.hasOwnProperty.call(p, m) === !1) continue;
          const g = p[m];
          if (typeof g != "object" || g === null)
            h[m] = g;
          else if (g.constructor !== Object && (u = l.get(g.constructor)))
            h[m] = u(g, f);
          else if (ArrayBuffer.isView(g))
            h[m] = n(g);
          else {
            const y = s.indexOf(g);
            y !== -1 ? h[m] = a[y] : h[m] = f(g);
          }
        }
        return s.pop(), a.pop(), h;
      }
      function d(p) {
        if (typeof p != "object" || p === null) return p;
        if (Array.isArray(p)) return c(p, d);
        if (p.constructor !== Object && (u = l.get(p.constructor)))
          return u(p, d);
        const h = {};
        s.push(p), a.push(h);
        for (const m in p) {
          const g = p[m];
          if (typeof g != "object" || g === null)
            h[m] = g;
          else if (g.constructor !== Object && (u = l.get(g.constructor)))
            h[m] = u(g, d);
          else if (ArrayBuffer.isView(g))
            h[m] = n(g);
          else {
            const y = s.indexOf(g);
            y !== -1 ? h[m] = a[y] : h[m] = d(g);
          }
        }
        return s.pop(), a.pop(), h;
      }
    }
  }
});
eu();
eu();
eu();
var sk = typeof navigator < "u", Ee = typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : {};
typeof Ee.chrome < "u" && Ee.chrome.devtools;
sk && (Ee.self, Ee.top);
var qy;
typeof navigator < "u" && ((qy = navigator.userAgent) == null || qy.toLowerCase().includes("electron"));
eu();
var AH = kH(MH()), TH = /(?:^|[-_/])(\w)/g;
function SH(e, t) {
  return t ? t.toUpperCase() : "";
}
function CH(e) {
  return e && `${e}`.replace(TH, SH);
}
function NH(e, t) {
  let n = e.replace(/^[a-z]:/i, "").replace(/\\/g, "/");
  n.endsWith(`index${t}`) && (n = n.replace(`/index${t}`, t));
  const r = n.lastIndexOf("/"), i = n.substring(r + 1);
  {
    const o = i.lastIndexOf(t);
    return i.substring(0, o);
  }
}
var Gy = (0, AH.default)({ circles: !0 });
const DH = {
  trailing: !0
};
function Vs(e, t = 25, n = {}) {
  if (n = { ...DH, ...n }, !Number.isFinite(t))
    throw new TypeError("Expected `wait` to be a finite number");
  let r, i, o = [], s, a;
  const l = (u, c) => (s = OH(e, u, c), s.finally(() => {
    if (s = null, n.trailing && a && !i) {
      const f = l(u, a);
      return a = null, f;
    }
  }), s);
  return function(...u) {
    return s ? (n.trailing && (a = u), s) : new Promise((c) => {
      const f = !i && n.leading;
      clearTimeout(i), i = setTimeout(() => {
        i = null;
        const d = n.leading ? r : l(this, u);
        for (const p of o)
          p(d);
        o = [];
      }, t), f ? (r = l(this, u), c(r)) : o.push(c);
    });
  };
}
async function OH(e, t, n) {
  return await e.apply(t, n);
}
function e0(e, t = {}, n) {
  for (const r in e) {
    const i = e[r], o = n ? `${n}:${r}` : r;
    typeof i == "object" && i !== null ? e0(i, t, o) : typeof i == "function" && (t[o] = i);
  }
  return t;
}
const IH = { run: (e) => e() }, RH = () => IH, ak = typeof console.createTask < "u" ? console.createTask : RH;
function LH(e, t) {
  const n = t.shift(), r = ak(n);
  return e.reduce(
    (i, o) => i.then(() => r.run(() => o(...t))),
    Promise.resolve()
  );
}
function BH(e, t) {
  const n = t.shift(), r = ak(n);
  return Promise.all(e.map((i) => r.run(() => i(...t))));
}
function qp(e, t) {
  for (const n of [...e])
    n(t);
}
class PH {
  constructor() {
    this._hooks = {}, this._before = void 0, this._after = void 0, this._deprecatedMessages = void 0, this._deprecatedHooks = {}, this.hook = this.hook.bind(this), this.callHook = this.callHook.bind(this), this.callHookWith = this.callHookWith.bind(this);
  }
  hook(t, n, r = {}) {
    if (!t || typeof n != "function")
      return () => {
      };
    const i = t;
    let o;
    for (; this._deprecatedHooks[t]; )
      o = this._deprecatedHooks[t], t = o.to;
    if (o && !r.allowDeprecated) {
      let s = o.message;
      s || (s = `${i} hook has been deprecated` + (o.to ? `, please use ${o.to}` : "")), this._deprecatedMessages || (this._deprecatedMessages = /* @__PURE__ */ new Set()), this._deprecatedMessages.has(s) || (console.warn(s), this._deprecatedMessages.add(s));
    }
    if (!n.name)
      try {
        Object.defineProperty(n, "name", {
          get: () => "_" + t.replace(/\W+/g, "_") + "_hook_cb",
          configurable: !0
        });
      } catch {
      }
    return this._hooks[t] = this._hooks[t] || [], this._hooks[t].push(n), () => {
      n && (this.removeHook(t, n), n = void 0);
    };
  }
  hookOnce(t, n) {
    let r, i = (...o) => (typeof r == "function" && r(), r = void 0, i = void 0, n(...o));
    return r = this.hook(t, i), r;
  }
  removeHook(t, n) {
    if (this._hooks[t]) {
      const r = this._hooks[t].indexOf(n);
      r !== -1 && this._hooks[t].splice(r, 1), this._hooks[t].length === 0 && delete this._hooks[t];
    }
  }
  deprecateHook(t, n) {
    this._deprecatedHooks[t] = typeof n == "string" ? { to: n } : n;
    const r = this._hooks[t] || [];
    delete this._hooks[t];
    for (const i of r)
      this.hook(t, i);
  }
  deprecateHooks(t) {
    Object.assign(this._deprecatedHooks, t);
    for (const n in t)
      this.deprecateHook(n, t[n]);
  }
  addHooks(t) {
    const n = e0(t), r = Object.keys(n).map(
      (i) => this.hook(i, n[i])
    );
    return () => {
      for (const i of r.splice(0, r.length))
        i();
    };
  }
  removeHooks(t) {
    const n = e0(t);
    for (const r in n)
      this.removeHook(r, n[r]);
  }
  removeAllHooks() {
    for (const t in this._hooks)
      delete this._hooks[t];
  }
  callHook(t, ...n) {
    return n.unshift(t), this.callHookWith(LH, t, ...n);
  }
  callHookParallel(t, ...n) {
    return n.unshift(t), this.callHookWith(BH, t, ...n);
  }
  callHookWith(t, n, ...r) {
    const i = this._before || this._after ? { name: n, args: r, context: {} } : void 0;
    this._before && qp(this._before, i);
    const o = t(
      n in this._hooks ? [...this._hooks[n]] : [],
      r
    );
    return o instanceof Promise ? o.finally(() => {
      this._after && i && qp(this._after, i);
    }) : (this._after && i && qp(this._after, i), o);
  }
  beforeEach(t) {
    return this._before = this._before || [], this._before.push(t), () => {
      if (this._before !== void 0) {
        const n = this._before.indexOf(t);
        n !== -1 && this._before.splice(n, 1);
      }
    };
  }
  afterEach(t) {
    return this._after = this._after || [], this._after.push(t), () => {
      if (this._after !== void 0) {
        const n = this._after.indexOf(t);
        n !== -1 && this._after.splice(n, 1);
      }
    };
  }
}
function lk() {
  return new PH();
}
var $H = Object.create, uk = Object.defineProperty, zH = Object.getOwnPropertyDescriptor, t1 = Object.getOwnPropertyNames, FH = Object.getPrototypeOf, jH = Object.prototype.hasOwnProperty, UH = (e, t) => function() {
  return e && (t = (0, e[t1(e)[0]])(e = 0)), t;
}, ck = (e, t) => function() {
  return t || (0, e[t1(e)[0]])((t = { exports: {} }).exports, t), t.exports;
}, VH = (e, t, n, r) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of t1(t))
      !jH.call(e, i) && i !== n && uk(e, i, { get: () => t[i], enumerable: !(r = zH(t, i)) || r.enumerable });
  return e;
}, HH = (e, t, n) => (n = e != null ? $H(FH(e)) : {}, VH(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  uk(n, "default", { value: e, enumerable: !0 }),
  e
)), re = UH({
  "../../node_modules/.pnpm/tsup@8.3.5_@microsoft+api-extractor@7.43.0_@types+node@22.9.0__@swc+core@1.5.29_jiti@2.0.0_po_lnt5yfvawfblpk67opvcdwbq7u/node_modules/tsup/assets/esm_shims.js"() {
  }
}), qH = ck({
  "../../node_modules/.pnpm/speakingurl@14.0.1/node_modules/speakingurl/lib/speakingurl.js"(e, t) {
    re(), function(n) {
      var r = {
        // latin
        : "A",
        : "A",
        : "A",
        : "A",
        : "Ae",
        : "A",
        : "AE",
        : "C",
        : "E",
        : "E",
        : "E",
        : "E",
        : "I",
        : "I",
        : "I",
        : "I",
        : "D",
        : "N",
        : "O",
        : "O",
        : "O",
        : "O",
        : "Oe",
        : "O",
        : "O",
        : "U",
        : "U",
        : "U",
        : "Ue",
        : "U",
        : "Y",
        : "TH",
        : "ss",
        : "a",
        : "a",
        : "a",
        : "a",
        : "ae",
        : "a",
        : "ae",
        : "c",
        : "e",
        : "e",
        : "e",
        : "e",
        : "i",
        : "i",
        : "i",
        : "i",
        : "d",
        : "n",
        : "o",
        : "o",
        : "o",
        : "o",
        : "oe",
        : "o",
        : "o",
        : "u",
        : "u",
        : "u",
        : "ue",
        : "u",
        : "y",
        : "th",
        : "y",
        "": "SS",
        // language specific
        // Arabic
        : "a",
        : "a",
        : "i",
        : "aa",
        : "u",
        : "e",
        : "a",
        : "b",
        : "t",
        : "th",
        : "j",
        : "h",
        : "kh",
        : "d",
        : "th",
        : "r",
        : "z",
        : "s",
        : "sh",
        : "s",
        : "dh",
        : "t",
        : "z",
        : "a",
        : "gh",
        : "f",
        : "q",
        : "k",
        : "l",
        : "m",
        : "n",
        : "h",
        : "w",
        : "y",
        : "a",
        : "h",
        : "la",
        : "laa",
        : "lai",
        : "laa",
        // Persian additional characters than Arabic
        : "g",
        : "ch",
        : "p",
        : "zh",
        : "k",
        : "y",
        // Arabic diactrics
        "": "a",
        "": "an",
        "": "e",
        "": "en",
        "": "u",
        "": "on",
        "": "",
        // Arabic numbers
        "": "0",
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        // Persian numbers
        "": "0",
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        // Burmese consonants
        : "k",
        : "kh",
        : "g",
        : "ga",
        : "ng",
        : "s",
        : "sa",
        : "z",
        "": "za",
        : "ny",
        : "t",
        : "ta",
        : "d",
        : "da",
        : "na",
        : "t",
        : "ta",
        : "d",
        : "da",
        : "n",
        : "p",
        : "pa",
        : "b",
        : "ba",
        : "m",
        : "y",
        : "ya",
        : "l",
        : "w",
        : "th",
        : "h",
        : "la",
        : "a",
        // consonant character combos
        "": "y",
        "": "ya",
        "": "w",
        "": "yw",
        "": "ywa",
        "": "h",
        // independent vowels
        : "e",
        "": "-e",
        : "i",
        : "-i",
        : "u",
        : "-u",
        : "aw",
        "": "aw",
        : "aw",
        // numbers
        "": "0",
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        // virama and tone marks which are silent in transliteration
        "": "",
        "": "",
        "": "",
        // Czech
        : "c",
        : "d",
        : "e",
        : "n",
        : "r",
        : "s",
        : "t",
        : "u",
        : "z",
        : "C",
        : "D",
        : "E",
        : "N",
        : "R",
        : "S",
        : "T",
        : "U",
        : "Z",
        // Dhivehi
        : "h",
        : "sh",
        : "n",
        : "r",
        : "b",
        : "lh",
        : "k",
        : "a",
        : "v",
        : "m",
        : "f",
        : "dh",
        : "th",
        : "l",
        : "g",
        : "gn",
        : "s",
        : "d",
        : "z",
        : "t",
        : "y",
        : "p",
        : "j",
        : "ch",
        : "tt",
        : "hh",
        : "kh",
        : "th",
        : "z",
        : "sh",
        : "s",
        : "d",
        : "t",
        : "z",
        : "a",
        : "gh",
        : "q",
        : "w",
        "": "a",
        "": "aa",
        "": "i",
        "": "ee",
        "": "u",
        "": "oo",
        "": "e",
        "": "ey",
        "": "o",
        "": "oa",
        "": "",
        // Georgian https://en.wikipedia.org/wiki/Romanization_of_Georgian
        // National system (2002)
        : "a",
        : "b",
        : "g",
        : "d",
        : "e",
        : "v",
        : "z",
        : "t",
        : "i",
        : "k",
        : "l",
        : "m",
        : "n",
        : "o",
        : "p",
        : "zh",
        : "r",
        : "s",
        : "t",
        : "u",
        : "p",
        : "k",
        : "gh",
        : "q",
        : "sh",
        : "ch",
        : "ts",
        : "dz",
        : "ts",
        : "ch",
        : "kh",
        : "j",
        : "h",
        // Greek
        : "a",
        : "v",
        : "g",
        : "d",
        : "e",
        : "z",
        : "i",
        : "th",
        : "i",
        : "k",
        : "l",
        : "m",
        : "n",
        : "ks",
        : "o",
        : "p",
        : "r",
        : "s",
        : "t",
        : "y",
        : "f",
        : "x",
        : "ps",
        : "o",
        : "a",
        : "e",
        : "i",
        : "o",
        : "y",
        : "i",
        : "o",
        : "s",
        : "i",
        : "y",
        : "y",
        : "i",
        : "A",
        : "B",
        : "G",
        : "D",
        : "E",
        : "Z",
        : "I",
        : "TH",
        : "I",
        : "K",
        : "L",
        : "M",
        : "N",
        : "KS",
        : "O",
        : "P",
        : "R",
        : "S",
        : "T",
        : "Y",
        : "F",
        : "X",
        : "PS",
        : "O",
        : "A",
        : "E",
        : "I",
        : "O",
        : "Y",
        : "I",
        : "O",
        : "I",
        : "Y",
        // Latvian
        : "a",
        // '': 'c', // duplicate
        : "e",
        : "g",
        : "i",
        : "k",
        : "l",
        : "n",
        // '': 's', // duplicate
        : "u",
        // '': 'z', // duplicate
        : "A",
        // '': 'C', // duplicate
        : "E",
        : "G",
        : "I",
        : "k",
        : "L",
        : "N",
        // '': 'S', // duplicate
        : "U",
        // '': 'Z', // duplicate
        // Macedonian
        : "Kj",
        : "kj",
        : "Lj",
        : "lj",
        : "Nj",
        : "nj",
        : "Ts",
        : "ts",
        // Polish
        : "a",
        : "c",
        : "e",
        : "l",
        : "n",
        // '': 'o', // duplicate
        : "s",
        : "z",
        : "z",
        : "A",
        : "C",
        : "E",
        : "L",
        : "N",
        : "S",
        : "Z",
        : "Z",
        // Ukranian
        : "Ye",
        : "I",
        : "Yi",
        : "G",
        : "ye",
        : "i",
        : "yi",
        : "g",
        // Romanian
        : "a",
        : "A",
        : "s",
        : "S",
        // '': 's', // duplicate
        // '': 'S', // duplicate
        : "t",
        : "T",
        : "t",
        : "T",
        // Russian https://en.wikipedia.org/wiki/Romanization_of_Russian
        // ICAO
        : "a",
        : "b",
        : "v",
        : "g",
        : "d",
        : "e",
        : "yo",
        : "zh",
        : "z",
        : "i",
        : "i",
        : "k",
        : "l",
        : "m",
        : "n",
        : "o",
        : "p",
        : "r",
        : "s",
        : "t",
        : "u",
        : "f",
        : "kh",
        : "c",
        : "ch",
        : "sh",
        : "sh",
        : "",
        : "y",
        : "",
        : "e",
        : "yu",
        : "ya",
        : "A",
        : "B",
        : "V",
        : "G",
        : "D",
        : "E",
        : "Yo",
        : "Zh",
        : "Z",
        : "I",
        : "I",
        : "K",
        : "L",
        : "M",
        : "N",
        : "O",
        : "P",
        : "R",
        : "S",
        : "T",
        : "U",
        : "F",
        : "Kh",
        : "C",
        : "Ch",
        : "Sh",
        : "Sh",
        : "",
        : "Y",
        : "",
        : "E",
        : "Yu",
        : "Ya",
        // Serbian
        : "dj",
        : "j",
        // '': 'lj',  // duplicate
        // '': 'nj', // duplicate
        : "c",
        : "dz",
        : "Dj",
        : "j",
        // '': 'Lj', // duplicate
        // '': 'Nj', // duplicate
        : "C",
        : "Dz",
        // Slovak
        : "l",
        : "l",
        : "r",
        : "L",
        : "L",
        : "R",
        // Turkish
        : "s",
        : "S",
        : "i",
        : "I",
        // '': 'c', // duplicate
        // '': 'C', // duplicate
        // '': 'u', // duplicate, see langCharMap
        // '': 'U', // duplicate, see langCharMap
        // '': 'o', // duplicate, see langCharMap
        // '': 'O', // duplicate, see langCharMap
        : "g",
        : "G",
        // Vietnamese
        : "a",
        : "A",
        : "a",
        : "A",
        : "a",
        : "A",
        : "d",
        : "D",
        : "e",
        : "E",
        : "e",
        : "E",
        : "e",
        : "E",
        : "e",
        : "E",
        : "e",
        : "E",
        : "e",
        : "E",
        : "e",
        : "E",
        : "e",
        : "E",
        : "o",
        : "o",
        : "o",
        : "o",
        : "O",
        : "o",
        : "O",
        : "o",
        : "O",
        : "o",
        : "O",
        : "o",
        : "O",
        : "o",
        : "O",
        : "o",
        : "O",
        : "o",
        : "O",
        : "o",
        : "O",
        : "o",
        : "O",
        : "o",
        : "o",
        : "i",
        : "I",
        : "i",
        : "I",
        : "i",
        : "i",
        : "u",
        : "U",
        : "u",
        : "U",
        : "u",
        : "U",
        : "u",
        : "U",
        : "u",
        : "U",
        : "u",
        : "U",
        : "u",
        : "U",
        : "u",
        : "U",
        : "u",
        : "",
        : "y",
        : "y",
        : "y",
        : "Y",
        : "y",
        : "Y",
        : "y",
        : "Y",
        : "a",
        : "A",
        : "a",
        : "A",
        : "a",
        : "A",
        : "a",
        : "A",
        : "a",
        : "A",
        // '': 'a', // duplicate
        // '': 'A', // duplicate
        : "a",
        : "A",
        : "a",
        : "A",
        : "a",
        : "A",
        : "a",
        : "A",
        "": "0",
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "10",
        "": "11",
        "": "12",
        "": "13",
        "": "14",
        "": "15",
        "": "16",
        "": "17",
        "": "18",
        "": "18",
        "": "18",
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "10",
        "": "0",
        "": "11",
        "": "12",
        "": "13",
        "": "14",
        "": "15",
        "": "16",
        "": "17",
        "": "18",
        "": "19",
        "": "20",
        "": "A",
        "": "B",
        "": "C",
        "": "D",
        "": "E",
        "": "F",
        "": "G",
        "": "H",
        "": "I",
        "": "J",
        "": "K",
        "": "L",
        "": "M",
        "": "N",
        "": "O",
        "": "P",
        "": "Q",
        "": "R",
        "": "S",
        "": "T",
        "": "U",
        "": "V",
        "": "W",
        "": "X",
        "": "Y",
        "": "Z",
        "": "a",
        "": "b",
        "": "c",
        "": "d",
        "": "e",
        "": "f",
        "": "g",
        "": "h",
        "": "i",
        "": "j",
        "": "k",
        "": "l",
        "": "m",
        "": "n",
        "": "o",
        "": "p",
        "": "q",
        "": "r",
        "": "s",
        "": "t",
        "": "u",
        "": "v",
        "": "w",
        "": "x",
        "": "y",
        "": "z",
        // symbols
        "": '"',
        "": '"',
        "": "'",
        "": "'",
        "": "d",
        : "f",
        "": "(TM)",
        "": "(C)",
        : "oe",
        : "OE",
        "": "(R)",
        "": "+",
        "": "(SM)",
        "": "...",
        "": "o",
        : "o",
        : "a",
        "": "*",
        "": ",",
        "": ".",
        // currency
        $: "USD",
        "": "EUR",
        "": "BRN",
        "": "FRF",
        "": "GBP",
        "": "ITL",
        "": "NGN",
        "": "ESP",
        "": "KRW",
        "": "ILS",
        "": "VND",
        "": "LAK",
        "": "MNT",
        "": "GRD",
        "": "ARS",
        "": "PYG",
        "": "ARA",
        "": "UAH",
        "": "GHS",
        "": "cent",
        "": "CNY",
        : "CNY",
        : "YEN",
        "": "IRR",
        "": "EWE",
        "": "THB",
        "": "INR",
        "": "INR",
        "": "PF",
        "": "TRY",
        "": "AFN",
        "": "AZN",
        : "BGN",
        "": "KHR",
        "": "CRC",
        "": "KZT",
        : "MKD",
        z: "PLN",
        "": "RUB",
        "": "GEL"
      }, i = [
        // burmese
        "",
        // Dhivehi
        ""
      ], o = {
        // Burmese
        // dependent vowels
        "": "a",
        "": "a",
        "": "e",
        "": "e",
        "": "i",
        "": "i",
        "": "o",
        "": "u",
        "": "u",
        "": "aung",
        "": "aw",
        "": "aw",
        "": "aw",
        "": "aw",
        "": "",
        // this is special case but the character will be converted to latin in the code
        "": "et",
        "": "aik",
        "": "auk",
        "": "in",
        "": "aing",
        "": "aung",
        "": "it",
        "": "i",
        "": "at",
        "": "eik",
        "": "ok",
        "": "ut",
        "": "it",
        "": "d",
        "": "ok",
        "": "ait",
        "": "an",
        "": "an",
        "": "ein",
        "": "on",
        "": "un",
        "": "at",
        "": "eik",
        "": "ok",
        "": "ut",
        "": "nub",
        "": "an",
        "": "ein",
        "": "on",
        "": "un",
        "": "e",
        "": "ol",
        "": "in",
        "": "an",
        "": "ein",
        "": "on",
        // Dhivehi
        "": "ah",
        "": "ah"
      }, s = {
        en: {},
        // default language
        az: {
          // Azerbaijani
          : "c",
          : "e",
          : "g",
          : "i",
          : "o",
          : "s",
          : "u",
          : "C",
          : "E",
          : "G",
          : "I",
          : "O",
          : "S",
          : "U"
        },
        cs: {
          // Czech
          : "c",
          : "d",
          : "e",
          : "n",
          : "r",
          : "s",
          : "t",
          : "u",
          : "z",
          : "C",
          : "D",
          : "E",
          : "N",
          : "R",
          : "S",
          : "T",
          : "U",
          : "Z"
        },
        fi: {
          // Finnish
          // '': 'a', duplicate see charMap/latin
          // '': 'A', duplicate see charMap/latin
          : "a",
          // ok
          : "A",
          // ok
          : "o",
          // ok
          : "O"
          // ok
        },
        hu: {
          // Hungarian
          : "a",
          // ok
          : "A",
          // ok
          // '': 'a', duplicate see charMap/latin
          // '': 'A', duplicate see charMap/latin
          : "o",
          // ok
          : "O",
          // ok
          // '': 'o', duplicate see charMap/latin
          // '': 'O', duplicate see charMap/latin
          : "u",
          : "U",
          : "u",
          : "U"
        },
        lt: {
          // Lithuanian
          : "a",
          : "c",
          : "e",
          : "e",
          : "i",
          : "s",
          : "u",
          : "u",
          : "z",
          : "A",
          : "C",
          : "E",
          : "E",
          : "I",
          : "S",
          : "U",
          : "U"
        },
        lv: {
          // Latvian
          : "a",
          : "c",
          : "e",
          : "g",
          : "i",
          : "k",
          : "l",
          : "n",
          : "s",
          : "u",
          : "z",
          : "A",
          : "C",
          : "E",
          : "G",
          : "i",
          : "k",
          : "L",
          : "N",
          : "S",
          : "u",
          : "Z"
        },
        pl: {
          // Polish
          : "a",
          : "c",
          : "e",
          : "l",
          : "n",
          : "o",
          : "s",
          : "z",
          : "z",
          : "A",
          : "C",
          : "e",
          : "L",
          : "N",
          : "O",
          : "S",
          : "Z",
          : "Z"
        },
        sv: {
          // Swedish
          // '': 'a', duplicate see charMap/latin
          // '': 'A', duplicate see charMap/latin
          : "a",
          // ok
          : "A",
          // ok
          : "o",
          // ok
          : "O"
          // ok
        },
        sk: {
          // Slovak
          : "a",
          : "A"
        },
        sr: {
          // Serbian
          : "lj",
          : "nj",
          : "Lj",
          : "Nj",
          : "dj",
          : "Dj"
        },
        tr: {
          // Turkish
          : "U",
          : "O",
          : "u",
          : "o"
        }
      }, a = {
        ar: {
          "": "delta",
          "": "la-nihaya",
          "": "hob",
          "&": "wa",
          "|": "aw",
          "<": "aqal-men",
          ">": "akbar-men",
          "": "majmou",
          "": "omla"
        },
        az: {},
        ca: {
          "": "delta",
          "": "infinit",
          "": "amor",
          "&": "i",
          "|": "o",
          "<": "menys que",
          ">": "mes que",
          "": "suma dels",
          "": "moneda"
        },
        cs: {
          "": "delta",
          "": "nekonecno",
          "": "laska",
          "&": "a",
          "|": "nebo",
          "<": "mensi nez",
          ">": "vetsi nez",
          "": "soucet",
          "": "mena"
        },
        de: {
          "": "delta",
          "": "unendlich",
          "": "Liebe",
          "&": "und",
          "|": "oder",
          "<": "kleiner als",
          ">": "groesser als",
          "": "Summe von",
          "": "Waehrung"
        },
        dv: {
          "": "delta",
          "": "kolunulaa",
          "": "loabi",
          "&": "aai",
          "|": "noonee",
          "<": "ah vure kuda",
          ">": "ah vure bodu",
          "": "jumula",
          "": "faisaa"
        },
        en: {
          "": "delta",
          "": "infinity",
          "": "love",
          "&": "and",
          "|": "or",
          "<": "less than",
          ">": "greater than",
          "": "sum",
          "": "currency"
        },
        es: {
          "": "delta",
          "": "infinito",
          "": "amor",
          "&": "y",
          "|": "u",
          "<": "menos que",
          ">": "mas que",
          "": "suma de los",
          "": "moneda"
        },
        fa: {
          "": "delta",
          "": "bi-nahayat",
          "": "eshgh",
          "&": "va",
          "|": "ya",
          "<": "kamtar-az",
          ">": "bishtar-az",
          "": "majmooe",
          "": "vahed"
        },
        fi: {
          "": "delta",
          "": "aarettomyys",
          "": "rakkaus",
          "&": "ja",
          "|": "tai",
          "<": "pienempi kuin",
          ">": "suurempi kuin",
          "": "summa",
          "": "valuutta"
        },
        fr: {
          "": "delta",
          "": "infiniment",
          "": "Amour",
          "&": "et",
          "|": "ou",
          "<": "moins que",
          ">": "superieure a",
          "": "somme des",
          "": "monnaie"
        },
        ge: {
          "": "delta",
          "": "usasruloba",
          "": "siqvaruli",
          "&": "da",
          "|": "an",
          "<": "naklebi",
          ">": "meti",
          "": "jami",
          "": "valuta"
        },
        gr: {},
        hu: {
          "": "delta",
          "": "vegtelen",
          "": "szerelem",
          "&": "es",
          "|": "vagy",
          "<": "kisebb mint",
          ">": "nagyobb mint",
          "": "szumma",
          "": "penznem"
        },
        it: {
          "": "delta",
          "": "infinito",
          "": "amore",
          "&": "e",
          "|": "o",
          "<": "minore di",
          ">": "maggiore di",
          "": "somma",
          "": "moneta"
        },
        lt: {
          "": "delta",
          "": "begalybe",
          "": "meile",
          "&": "ir",
          "|": "ar",
          "<": "maziau nei",
          ">": "daugiau nei",
          "": "suma",
          "": "valiuta"
        },
        lv: {
          "": "delta",
          "": "bezgaliba",
          "": "milestiba",
          "&": "un",
          "|": "vai",
          "<": "mazak neka",
          ">": "lielaks neka",
          "": "summa",
          "": "valuta"
        },
        my: {
          "": "kwahkhyaet",
          "": "asaonasme",
          "": "akhyait",
          "&": "nhin",
          "|": "tho",
          "<": "ngethaw",
          ">": "kyithaw",
          "": "paungld",
          "": "ngwekye"
        },
        mk: {},
        nl: {
          "": "delta",
          "": "oneindig",
          "": "liefde",
          "&": "en",
          "|": "of",
          "<": "kleiner dan",
          ">": "groter dan",
          "": "som",
          "": "valuta"
        },
        pl: {
          "": "delta",
          "": "nieskonczonosc",
          "": "milosc",
          "&": "i",
          "|": "lub",
          "<": "mniejsze niz",
          ">": "wieksze niz",
          "": "suma",
          "": "waluta"
        },
        pt: {
          "": "delta",
          "": "infinito",
          "": "amor",
          "&": "e",
          "|": "ou",
          "<": "menor que",
          ">": "maior que",
          "": "soma",
          "": "moeda"
        },
        ro: {
          "": "delta",
          "": "infinit",
          "": "dragoste",
          "&": "si",
          "|": "sau",
          "<": "mai mic ca",
          ">": "mai mare ca",
          "": "suma",
          "": "valuta"
        },
        ru: {
          "": "delta",
          "": "beskonechno",
          "": "lubov",
          "&": "i",
          "|": "ili",
          "<": "menshe",
          ">": "bolshe",
          "": "summa",
          "": "valjuta"
        },
        sk: {
          "": "delta",
          "": "nekonecno",
          "": "laska",
          "&": "a",
          "|": "alebo",
          "<": "menej ako",
          ">": "viac ako",
          "": "sucet",
          "": "mena"
        },
        sr: {},
        tr: {
          "": "delta",
          "": "sonsuzluk",
          "": "ask",
          "&": "ve",
          "|": "veya",
          "<": "kucuktur",
          ">": "buyuktur",
          "": "toplam",
          "": "para birimi"
        },
        uk: {
          "": "delta",
          "": "bezkinechnist",
          "": "lubov",
          "&": "i",
          "|": "abo",
          "<": "menshe",
          ">": "bilshe",
          "": "suma",
          "": "valjuta"
        },
        vn: {
          "": "delta",
          "": "vo cuc",
          "": "yeu",
          "&": "va",
          "|": "hoac",
          "<": "nho hon",
          ">": "lon hon",
          "": "tong",
          "": "tien te"
        }
      }, l = [";", "?", ":", "@", "&", "=", "+", "$", ",", "/"].join(""), u = [";", "?", ":", "@", "&", "=", "+", "$", ","].join(""), c = [".", "!", "~", "*", "'", "(", ")"].join(""), f = function(g, y) {
        var _ = "-", E = "", v = "", M = !0, k = {}, T, U, C, z, H, j, V, Q, le, ne, w, O, q, X, se = "";
        if (typeof g != "string")
          return "";
        if (typeof y == "string" && (_ = y), V = a.en, Q = s.en, typeof y == "object") {
          T = y.maintainCase || !1, k = y.custom && typeof y.custom == "object" ? y.custom : k, C = +y.truncate > 1 && y.truncate || !1, z = y.uric || !1, H = y.uricNoSlash || !1, j = y.mark || !1, M = !(y.symbols === !1 || y.lang === !1), _ = y.separator || _, z && (se += l), H && (se += u), j && (se += c), V = y.lang && a[y.lang] && M ? a[y.lang] : M ? a.en : {}, Q = y.lang && s[y.lang] ? s[y.lang] : y.lang === !1 || y.lang === !0 ? {} : s.en, y.titleCase && typeof y.titleCase.length == "number" && Array.prototype.toString.call(y.titleCase) ? (y.titleCase.forEach(function(fe) {
            k[fe + ""] = fe + "";
          }), U = !0) : U = !!y.titleCase, y.custom && typeof y.custom.length == "number" && Array.prototype.toString.call(y.custom) && y.custom.forEach(function(fe) {
            k[fe + ""] = fe + "";
          }), Object.keys(k).forEach(function(fe) {
            var Se;
            fe.length > 1 ? Se = new RegExp("\\b" + p(fe) + "\\b", "gi") : Se = new RegExp(p(fe), "gi"), g = g.replace(Se, k[fe]);
          });
          for (w in k)
            se += w;
        }
        for (se += _, se = p(se), g = g.replace(/(^\s+|\s+$)/g, ""), q = !1, X = !1, ne = 0, O = g.length; ne < O; ne++)
          w = g[ne], h(w, k) ? q = !1 : Q[w] ? (w = q && Q[w].match(/[A-Za-z0-9]/) ? " " + Q[w] : Q[w], q = !1) : w in r ? (ne + 1 < O && i.indexOf(g[ne + 1]) >= 0 ? (v += w, w = "") : X === !0 ? (w = o[v] + r[w], v = "") : w = q && r[w].match(/[A-Za-z0-9]/) ? " " + r[w] : r[w], q = !1, X = !1) : w in o ? (v += w, w = "", ne === O - 1 && (w = o[v]), X = !0) : /* process symbol chars */ V[w] && !(z && l.indexOf(w) !== -1) && !(H && u.indexOf(w) !== -1) ? (w = q || E.substr(-1).match(/[A-Za-z0-9]/) ? _ + V[w] : V[w], w += g[ne + 1] !== void 0 && g[ne + 1].match(/[A-Za-z0-9]/) ? _ : "", q = !0) : (X === !0 ? (w = o[v] + w, v = "", X = !1) : q && (/[A-Za-z0-9]/.test(w) || E.substr(-1).match(/A-Za-z0-9]/)) && (w = " " + w), q = !1), E += w.replace(new RegExp("[^\\w\\s" + se + "_-]", "g"), _);
        return U && (E = E.replace(/(\w)(\S*)/g, function(fe, Se, P) {
          var ie = Se.toUpperCase() + (P !== null ? P : "");
          return Object.keys(k).indexOf(ie.toLowerCase()) < 0 ? ie : ie.toLowerCase();
        })), E = E.replace(/\s+/g, _).replace(new RegExp("\\" + _ + "+", "g"), _).replace(new RegExp("(^\\" + _ + "+|\\" + _ + "+$)", "g"), ""), C && E.length > C && (le = E.charAt(C) === _, E = E.slice(0, C), le || (E = E.slice(0, E.lastIndexOf(_)))), !T && !U && (E = E.toLowerCase()), E;
      }, d = function(g) {
        return function(_) {
          return f(_, g);
        };
      }, p = function(g) {
        return g.replace(/[-\\^$*+?.()|[\]{}\/]/g, "\\$&");
      }, h = function(m, g) {
        for (var y in g)
          if (g[y] === m)
            return !0;
      };
      if (typeof t < "u" && t.exports)
        t.exports = f, t.exports.createSlug = d;
      else if (typeof define < "u" && define.amd)
        define([], function() {
          return f;
        });
      else
        try {
          if (n.getSlug || n.createSlug)
            throw "speakingurl: globals exists /(getSlug|createSlug)/";
          n.getSlug = f, n.createSlug = d;
        } catch {
        }
    }(e);
  }
}), GH = ck({
  "../../node_modules/.pnpm/speakingurl@14.0.1/node_modules/speakingurl/index.js"(e, t) {
    re(), t.exports = qH();
  }
});
re();
re();
re();
re();
re();
re();
re();
function WH(e) {
  return !!(e && e.__v_isReadonly);
}
function fk(e) {
  return WH(e) ? fk(e.__v_raw) : !!(e && e.__v_isReactive);
}
function Gp(e) {
  return !!(e && e.__v_isRef === !0);
}
function wa(e) {
  const t = e && e.__v_raw;
  return t ? wa(t) : e;
}
re();
function KH(e) {
  var t;
  const n = e.name || e._componentTag || e.__VUE_DEVTOOLS_COMPONENT_GUSSED_NAME__ || e.__name;
  return n === "index" && ((t = e.__file) != null && t.endsWith("index.vue")) ? "" : n;
}
function YH(e) {
  const t = e.__file;
  if (t)
    return CH(NH(t, ".vue"));
}
function Wy(e, t) {
  return e.type.__VUE_DEVTOOLS_COMPONENT_GUSSED_NAME__ = t, t;
}
function Ad(e) {
  if (e.__VUE_DEVTOOLS_NEXT_APP_RECORD__)
    return e.__VUE_DEVTOOLS_NEXT_APP_RECORD__;
  if (e.root)
    return e.appContext.app.__VUE_DEVTOOLS_NEXT_APP_RECORD__;
}
async function QH(e) {
  const { app: t, uid: n, instance: r } = e;
  try {
    if (r.__VUE_DEVTOOLS_NEXT_UID__)
      return r.__VUE_DEVTOOLS_NEXT_UID__;
    const i = await Ad(t);
    if (!i)
      return null;
    const o = i.rootInstance === r;
    return `${i.id}:${o ? "root" : n}`;
  } catch {
  }
}
function dk(e) {
  var t, n;
  const r = (t = e.subTree) == null ? void 0 : t.type, i = Ad(e);
  return i ? ((n = i == null ? void 0 : i.types) == null ? void 0 : n.Fragment) === r : !1;
}
function Td(e) {
  var t, n, r;
  const i = KH((e == null ? void 0 : e.type) || {});
  if (i)
    return i;
  if ((e == null ? void 0 : e.root) === e)
    return "Root";
  for (const s in (n = (t = e.parent) == null ? void 0 : t.type) == null ? void 0 : n.components)
    if (e.parent.type.components[s] === (e == null ? void 0 : e.type))
      return Wy(e, s);
  for (const s in (r = e.appContext) == null ? void 0 : r.components)
    if (e.appContext.components[s] === (e == null ? void 0 : e.type))
      return Wy(e, s);
  const o = YH((e == null ? void 0 : e.type) || {});
  return o || "Anonymous Component";
}
function t0(e, t) {
  return t = t || `${e.id}:root`, e.instanceMap.get(t) || e.instanceMap.get(":root");
}
var ZH = class {
  constructor() {
    this.refEditor = new XH();
  }
  set(e, t, n, r) {
    const i = Array.isArray(t) ? t : t.split(".");
    for (; i.length > 1; ) {
      const a = i.shift();
      e instanceof Map && (e = e.get(a)), e instanceof Set ? e = Array.from(e.values())[a] : e = e[a], this.refEditor.isRef(e) && (e = this.refEditor.get(e));
    }
    const o = i[0], s = this.refEditor.get(e)[o];
    r ? r(e, o, n) : this.refEditor.isRef(s) ? this.refEditor.set(s, n) : e[o] = n;
  }
  get(e, t) {
    const n = Array.isArray(t) ? t : t.split(".");
    for (let r = 0; r < n.length; r++)
      if (e instanceof Map ? e = e.get(n[r]) : e = e[n[r]], this.refEditor.isRef(e) && (e = this.refEditor.get(e)), !e)
        return;
    return e;
  }
  has(e, t, n = !1) {
    if (typeof e > "u")
      return !1;
    const r = Array.isArray(t) ? t.slice() : t.split("."), i = n ? 2 : 1;
    for (; e && r.length > i; ) {
      const o = r.shift();
      e = e[o], this.refEditor.isRef(e) && (e = this.refEditor.get(e));
    }
    return e != null && Object.prototype.hasOwnProperty.call(e, r[0]);
  }
  createDefaultSetCallback(e) {
    return (t, n, r) => {
      if ((e.remove || e.newKey) && (Array.isArray(t) ? t.splice(n, 1) : wa(t) instanceof Map ? t.delete(n) : wa(t) instanceof Set ? t.delete(Array.from(t.values())[n]) : Reflect.deleteProperty(t, n)), !e.remove) {
        const i = t[e.newKey || n];
        this.refEditor.isRef(i) ? this.refEditor.set(i, r) : wa(t) instanceof Map ? t.set(e.newKey || n, r) : wa(t) instanceof Set ? t.add(r) : t[e.newKey || n] = r;
      }
    };
  }
}, XH = class {
  set(e, t) {
    if (Gp(e))
      e.value = t;
    else {
      if (e instanceof Set && Array.isArray(t)) {
        e.clear(), t.forEach((i) => e.add(i));
        return;
      }
      const n = Object.keys(t);
      if (e instanceof Map) {
        const i = new Set(e.keys());
        n.forEach((o) => {
          e.set(o, Reflect.get(t, o)), i.delete(o);
        }), i.forEach((o) => e.delete(o));
        return;
      }
      const r = new Set(Object.keys(e));
      n.forEach((i) => {
        Reflect.set(e, i, Reflect.get(t, i)), r.delete(i);
      }), r.forEach((i) => Reflect.deleteProperty(e, i));
    }
  }
  get(e) {
    return Gp(e) ? e.value : e;
  }
  isRef(e) {
    return Gp(e) || fk(e);
  }
};
re();
function n1(e) {
  return dk(e) ? JH(e.subTree) : e.subTree ? [e.subTree.el] : [];
}
function JH(e) {
  if (!e.children)
    return [];
  const t = [];
  return e.children.forEach((n) => {
    n.component ? t.push(...n1(n.component)) : n != null && n.el && t.push(n.el);
  }), t;
}
re();
re();
function eq() {
  const e = {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    get width() {
      return e.right - e.left;
    },
    get height() {
      return e.bottom - e.top;
    }
  };
  return e;
}
var Bu;
function tq(e) {
  return Bu || (Bu = document.createRange()), Bu.selectNode(e), Bu.getBoundingClientRect();
}
function nq(e) {
  const t = eq();
  if (!e.children)
    return t;
  for (let n = 0, r = e.children.length; n < r; n++) {
    const i = e.children[n];
    let o;
    if (i.component)
      o = Lo(i.component);
    else if (i.el) {
      const s = i.el;
      s.nodeType === 1 || s.getBoundingClientRect ? o = s.getBoundingClientRect() : s.nodeType === 3 && s.data.trim() && (o = tq(s));
    }
    o && rq(t, o);
  }
  return t;
}
function rq(e, t) {
  return (!e.top || t.top < e.top) && (e.top = t.top), (!e.bottom || t.bottom > e.bottom) && (e.bottom = t.bottom), (!e.left || t.left < e.left) && (e.left = t.left), (!e.right || t.right > e.right) && (e.right = t.right), e;
}
var Ky = {
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  width: 0,
  height: 0
};
function Lo(e) {
  const t = e.subTree.el;
  return typeof window > "u" ? Ky : dk(e) ? nq(e.subTree) : (t == null ? void 0 : t.nodeType) === 1 ? t == null ? void 0 : t.getBoundingClientRect() : e.subTree.component ? Lo(e.subTree.component) : Ky;
}
var pk = "__vue-devtools-component-inspector__", hk = "__vue-devtools-component-inspector__card__", gk = "__vue-devtools-component-inspector__name__", mk = "__vue-devtools-component-inspector__indicator__", bk = {
  display: "block",
  zIndex: 2147483640,
  position: "fixed",
  backgroundColor: "#42b88325",
  border: "1px solid #42b88350",
  borderRadius: "5px",
  transition: "all 0.1s ease-in",
  pointerEvents: "none"
}, iq = {
  fontFamily: "Arial, Helvetica, sans-serif",
  padding: "5px 8px",
  borderRadius: "4px",
  textAlign: "left",
  position: "absolute",
  left: 0,
  color: "#e9e9e9",
  fontSize: "14px",
  fontWeight: 600,
  lineHeight: "24px",
  backgroundColor: "#42b883",
  boxShadow: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1)"
}, oq = {
  display: "inline-block",
  fontWeight: 400,
  fontStyle: "normal",
  fontSize: "12px",
  opacity: 0.7
};
function ia() {
  return document.getElementById(pk);
}
function sq() {
  return document.getElementById(hk);
}
function aq() {
  return document.getElementById(mk);
}
function lq() {
  return document.getElementById(gk);
}
function r1(e) {
  return {
    left: `${Math.round(e.left * 100) / 100}px`,
    top: `${Math.round(e.top * 100) / 100}px`,
    width: `${Math.round(e.width * 100) / 100}px`,
    height: `${Math.round(e.height * 100) / 100}px`
  };
}
function i1(e) {
  var t;
  const n = document.createElement("div");
  n.id = (t = e.elementId) != null ? t : pk, Object.assign(n.style, {
    ...bk,
    ...r1(e.bounds),
    ...e.style
  });
  const r = document.createElement("span");
  r.id = hk, Object.assign(r.style, {
    ...iq,
    top: e.bounds.top < 35 ? 0 : "-35px"
  });
  const i = document.createElement("span");
  i.id = gk, i.innerHTML = `&lt;${e.name}&gt;&nbsp;&nbsp;`;
  const o = document.createElement("i");
  return o.id = mk, o.innerHTML = `${Math.round(e.bounds.width * 100) / 100} x ${Math.round(e.bounds.height * 100) / 100}`, Object.assign(o.style, oq), r.appendChild(i), r.appendChild(o), n.appendChild(r), document.body.appendChild(n), n;
}
function o1(e) {
  const t = ia(), n = sq(), r = lq(), i = aq();
  t && (Object.assign(t.style, {
    ...bk,
    ...r1(e.bounds)
  }), Object.assign(n.style, {
    top: e.bounds.top < 35 ? 0 : "-35px"
  }), r.innerHTML = `&lt;${e.name}&gt;&nbsp;&nbsp;`, i.innerHTML = `${Math.round(e.bounds.width * 100) / 100} x ${Math.round(e.bounds.height * 100) / 100}`);
}
function uq(e) {
  const t = Lo(e);
  if (!t.width && !t.height)
    return;
  const n = Td(e);
  ia() ? o1({ bounds: t, name: n }) : i1({ bounds: t, name: n });
}
function yk() {
  const e = ia();
  e && (e.style.display = "none");
}
var n0 = null;
function r0(e) {
  const t = e.target;
  if (t) {
    const n = t.__vueParentComponent;
    if (n && (n0 = n, n.vnode.el)) {
      const i = Lo(n), o = Td(n);
      ia() ? o1({ bounds: i, name: o }) : i1({ bounds: i, name: o });
    }
  }
}
function cq(e, t) {
  var n;
  if (e.preventDefault(), e.stopPropagation(), n0) {
    const r = (n = sn.value) == null ? void 0 : n.app;
    QH({
      app: r,
      uid: r.uid,
      instance: n0
    }).then((i) => {
      t(i);
    });
  }
}
var Of = null;
function fq() {
  yk(), window.removeEventListener("mouseover", r0), window.removeEventListener("click", Of, !0), Of = null;
}
function dq() {
  return window.addEventListener("mouseover", r0), new Promise((e) => {
    function t(n) {
      n.preventDefault(), n.stopPropagation(), cq(n, (r) => {
        window.removeEventListener("click", t, !0), Of = null, window.removeEventListener("mouseover", r0);
        const i = ia();
        i && (i.style.display = "none"), e(JSON.stringify({ id: r }));
      });
    }
    Of = t, window.addEventListener("click", t, !0);
  });
}
function pq(e) {
  const t = t0(sn.value, e.id);
  if (t) {
    const [n] = n1(t);
    if (typeof n.scrollIntoView == "function")
      n.scrollIntoView({
        behavior: "smooth"
      });
    else {
      const r = Lo(t), i = document.createElement("div"), o = {
        ...r1(r),
        position: "absolute"
      };
      Object.assign(i.style, o), document.body.appendChild(i), i.scrollIntoView({
        behavior: "smooth"
      }), setTimeout(() => {
        document.body.removeChild(i);
      }, 2e3);
    }
    setTimeout(() => {
      const r = Lo(t);
      if (r.width || r.height) {
        const i = Td(t), o = ia();
        o ? o1({ ...e, name: i, bounds: r }) : i1({ ...e, name: i, bounds: r }), setTimeout(() => {
          o && (o.style.display = "none");
        }, 1500);
      }
    }, 1200);
  }
}
re();
var Yy, Qy;
(Qy = (Yy = Ee).__VUE_DEVTOOLS_COMPONENT_INSPECTOR_ENABLED__) != null || (Yy.__VUE_DEVTOOLS_COMPONENT_INSPECTOR_ENABLED__ = !0);
function hq(e) {
  let t = 0;
  const n = setInterval(() => {
    Ee.__VUE_INSPECTOR__ && (clearInterval(n), t += 30, e()), t >= /* 5s */
    5e3 && clearInterval(n);
  }, 30);
}
function gq() {
  const e = Ee.__VUE_INSPECTOR__, t = e.openInEditor;
  e.openInEditor = async (...n) => {
    e.disable(), t(...n);
  };
}
function mq() {
  return new Promise((e) => {
    function t() {
      gq(), e(Ee.__VUE_INSPECTOR__);
    }
    Ee.__VUE_INSPECTOR__ ? t() : hq(() => {
      t();
    });
  });
}
re();
re();
re();
var bq = "__VUE_DEVTOOLS_KIT_TIMELINE_LAYERS_STATE__";
function yq() {
  if (!sk || typeof localStorage > "u" || localStorage === null)
    return {
      recordingState: !1,
      mouseEventEnabled: !1,
      keyboardEventEnabled: !1,
      componentEventEnabled: !1,
      performanceEventEnabled: !1,
      selected: ""
    };
  const e = localStorage.getItem(bq);
  return e ? JSON.parse(e) : {
    recordingState: !1,
    mouseEventEnabled: !1,
    keyboardEventEnabled: !1,
    componentEventEnabled: !1,
    performanceEventEnabled: !1,
    selected: ""
  };
}
re();
re();
re();
var Zy, Xy;
(Xy = (Zy = Ee).__VUE_DEVTOOLS_KIT_TIMELINE_LAYERS) != null || (Zy.__VUE_DEVTOOLS_KIT_TIMELINE_LAYERS = []);
var vq = new Proxy(Ee.__VUE_DEVTOOLS_KIT_TIMELINE_LAYERS, {
  get(e, t, n) {
    return Reflect.get(e, t, n);
  }
});
function _q(e, t) {
  Bt.timelineLayersState[t.id] = !1, vq.push({
    ...e,
    descriptorId: t.id,
    appRecord: Ad(t.app)
  });
}
var Jy, ev;
(ev = (Jy = Ee).__VUE_DEVTOOLS_KIT_INSPECTOR__) != null || (Jy.__VUE_DEVTOOLS_KIT_INSPECTOR__ = []);
var s1 = new Proxy(Ee.__VUE_DEVTOOLS_KIT_INSPECTOR__, {
  get(e, t, n) {
    return Reflect.get(e, t, n);
  }
}), vk = Vs(() => {
  oa.hooks.callHook("sendInspectorToClient", _k());
});
function Eq(e, t) {
  var n, r;
  s1.push({
    options: e,
    descriptor: t,
    treeFilterPlaceholder: (n = e.treeFilterPlaceholder) != null ? n : "Search tree...",
    stateFilterPlaceholder: (r = e.stateFilterPlaceholder) != null ? r : "Search state...",
    treeFilter: "",
    selectedNodeId: "",
    appRecord: Ad(t.app)
  }), vk();
}
function _k() {
  return s1.filter((e) => e.descriptor.app === sn.value.app).filter((e) => e.descriptor.id !== "components").map((e) => {
    var t;
    const n = e.descriptor, r = e.options;
    return {
      id: r.id,
      label: r.label,
      logo: n.logo,
      icon: `custom-ic-baseline-${(t = r == null ? void 0 : r.icon) == null ? void 0 : t.replace(/_/g, "-")}`,
      packageName: n.packageName,
      homepage: n.homepage,
      pluginId: n.id
    };
  });
}
function lc(e, t) {
  return s1.find((n) => n.options.id === e && (t ? n.descriptor.app === t : !0));
}
function wq() {
  const e = lk();
  e.hook("addInspector", ({ inspector: r, plugin: i }) => {
    Eq(r, i.descriptor);
  });
  const t = Vs(async ({ inspectorId: r, plugin: i }) => {
    var o;
    if (!r || !((o = i == null ? void 0 : i.descriptor) != null && o.app) || Bt.highPerfModeEnabled)
      return;
    const s = lc(r, i.descriptor.app), a = {
      app: i.descriptor.app,
      inspectorId: r,
      filter: (s == null ? void 0 : s.treeFilter) || "",
      rootNodes: []
    };
    await new Promise((l) => {
      e.callHookWith(
        async (u) => {
          await Promise.all(u.map((c) => c(a))), l();
        },
        "getInspectorTree"
        /* GET_INSPECTOR_TREE */
      );
    }), e.callHookWith(
      async (l) => {
        await Promise.all(l.map((u) => u({
          inspectorId: r,
          rootNodes: a.rootNodes
        })));
      },
      "sendInspectorTreeToClient"
      /* SEND_INSPECTOR_TREE_TO_CLIENT */
    );
  }, 120);
  e.hook("sendInspectorTree", t);
  const n = Vs(async ({ inspectorId: r, plugin: i }) => {
    var o;
    if (!r || !((o = i == null ? void 0 : i.descriptor) != null && o.app) || Bt.highPerfModeEnabled)
      return;
    const s = lc(r, i.descriptor.app), a = {
      app: i.descriptor.app,
      inspectorId: r,
      nodeId: (s == null ? void 0 : s.selectedNodeId) || "",
      state: null
    }, l = {
      currentTab: `custom-inspector:${r}`
    };
    a.nodeId && await new Promise((u) => {
      e.callHookWith(
        async (c) => {
          await Promise.all(c.map((f) => f(a, l))), u();
        },
        "getInspectorState"
        /* GET_INSPECTOR_STATE */
      );
    }), e.callHookWith(
      async (u) => {
        await Promise.all(u.map((c) => c({
          inspectorId: r,
          nodeId: a.nodeId,
          state: a.state
        })));
      },
      "sendInspectorStateToClient"
      /* SEND_INSPECTOR_STATE_TO_CLIENT */
    );
  }, 120);
  return e.hook("sendInspectorState", n), e.hook("customInspectorSelectNode", ({ inspectorId: r, nodeId: i, plugin: o }) => {
    const s = lc(r, o.descriptor.app);
    s && (s.selectedNodeId = i);
  }), e.hook("timelineLayerAdded", ({ options: r, plugin: i }) => {
    _q(r, i.descriptor);
  }), e.hook("timelineEventAdded", ({ options: r, plugin: i }) => {
    var o;
    const s = ["performance", "component-event", "keyboard", "mouse"];
    Bt.highPerfModeEnabled || !((o = Bt.timelineLayersState) != null && o[i.descriptor.id]) && !s.includes(r.layerId) || e.callHookWith(
      async (a) => {
        await Promise.all(a.map((l) => l(r)));
      },
      "sendTimelineEventToClient"
      /* SEND_TIMELINE_EVENT_TO_CLIENT */
    );
  }), e.hook("getComponentInstances", async ({ app: r }) => {
    const i = r.__VUE_DEVTOOLS_NEXT_APP_RECORD__;
    if (!i)
      return null;
    const o = i.id.toString();
    return [...i.instanceMap].filter(([a]) => a.split(":")[0] === o).map(([, a]) => a);
  }), e.hook("getComponentBounds", async ({ instance: r }) => Lo(r)), e.hook("getComponentName", ({ instance: r }) => Td(r)), e.hook("componentHighlight", ({ uid: r }) => {
    const i = sn.value.instanceMap.get(r);
    i && uq(i);
  }), e.hook("componentUnhighlight", () => {
    yk();
  }), e;
}
var tv, nv;
(nv = (tv = Ee).__VUE_DEVTOOLS_KIT_APP_RECORDS__) != null || (tv.__VUE_DEVTOOLS_KIT_APP_RECORDS__ = []);
var rv, iv;
(iv = (rv = Ee).__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__) != null || (rv.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__ = {});
var ov, sv;
(sv = (ov = Ee).__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD_ID__) != null || (ov.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD_ID__ = "");
var av, lv;
(lv = (av = Ee).__VUE_DEVTOOLS_KIT_CUSTOM_TABS__) != null || (av.__VUE_DEVTOOLS_KIT_CUSTOM_TABS__ = []);
var uv, cv;
(cv = (uv = Ee).__VUE_DEVTOOLS_KIT_CUSTOM_COMMANDS__) != null || (uv.__VUE_DEVTOOLS_KIT_CUSTOM_COMMANDS__ = []);
var ho = "__VUE_DEVTOOLS_KIT_GLOBAL_STATE__";
function xq() {
  return {
    connected: !1,
    clientConnected: !1,
    vitePluginDetected: !0,
    appRecords: [],
    activeAppRecordId: "",
    tabs: [],
    commands: [],
    highPerfModeEnabled: !0,
    devtoolsClientDetected: {},
    perfUniqueGroupId: 0,
    timelineLayersState: yq()
  };
}
var fv, dv;
(dv = (fv = Ee)[ho]) != null || (fv[ho] = xq());
var kq = Vs((e) => {
  oa.hooks.callHook("devtoolsStateUpdated", { state: e });
});
Vs((e, t) => {
  oa.hooks.callHook("devtoolsConnectedUpdated", { state: e, oldState: t });
});
var Sd = new Proxy(Ee.__VUE_DEVTOOLS_KIT_APP_RECORDS__, {
  get(e, t, n) {
    return t === "value" ? Ee.__VUE_DEVTOOLS_KIT_APP_RECORDS__ : Ee.__VUE_DEVTOOLS_KIT_APP_RECORDS__[t];
  }
}), sn = new Proxy(Ee.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__, {
  get(e, t, n) {
    return t === "value" ? Ee.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__ : t === "id" ? Ee.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD_ID__ : Ee.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__[t];
  }
});
function Ek() {
  kq({
    ...Ee[ho],
    appRecords: Sd.value,
    activeAppRecordId: sn.id,
    tabs: Ee.__VUE_DEVTOOLS_KIT_CUSTOM_TABS__,
    commands: Ee.__VUE_DEVTOOLS_KIT_CUSTOM_COMMANDS__
  });
}
function Mq(e) {
  Ee.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__ = e, Ek();
}
function Aq(e) {
  Ee.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD_ID__ = e, Ek();
}
var Bt = new Proxy(Ee[ho], {
  get(e, t) {
    return t === "appRecords" ? Sd : t === "activeAppRecordId" ? sn.id : t === "tabs" ? Ee.__VUE_DEVTOOLS_KIT_CUSTOM_TABS__ : t === "commands" ? Ee.__VUE_DEVTOOLS_KIT_CUSTOM_COMMANDS__ : Ee[ho][t];
  },
  deleteProperty(e, t) {
    return delete e[t], !0;
  },
  set(e, t, n) {
    return { ...Ee[ho] }, e[t] = n, Ee[ho][t] = n, !0;
  }
});
function Tq(e = {}) {
  var t, n, r;
  const { file: i, host: o, baseUrl: s = window.location.origin, line: a = 0, column: l = 0 } = e;
  if (i) {
    if (o === "chrome-extension") {
      const u = i.replace(/\\/g, "\\\\"), c = (n = (t = window.VUE_DEVTOOLS_CONFIG) == null ? void 0 : t.openInEditorHost) != null ? n : "/";
      fetch(`${c}__open-in-editor?file=${encodeURI(i)}`).then((f) => {
        if (!f.ok) {
          const d = `Opening component ${u} failed`;
          console.log(`%c${d}`, "color:red");
        }
      });
    } else if (Bt.vitePluginDetected) {
      const u = (r = Ee.__VUE_DEVTOOLS_OPEN_IN_EDITOR_BASE_URL__) != null ? r : s;
      Ee.__VUE_INSPECTOR__.openInEditor(u, i, a, l);
    }
  }
}
re();
re();
re();
re();
re();
var pv, hv;
(hv = (pv = Ee).__VUE_DEVTOOLS_KIT_PLUGIN_BUFFER__) != null || (pv.__VUE_DEVTOOLS_KIT_PLUGIN_BUFFER__ = []);
var a1 = new Proxy(Ee.__VUE_DEVTOOLS_KIT_PLUGIN_BUFFER__, {
  get(e, t, n) {
    return Reflect.get(e, t, n);
  }
});
function i0(e) {
  const t = {};
  return Object.keys(e).forEach((n) => {
    t[n] = e[n].defaultValue;
  }), t;
}
function l1(e) {
  return `__VUE_DEVTOOLS_NEXT_PLUGIN_SETTINGS__${e}__`;
}
function Sq(e) {
  var t, n, r;
  const i = (n = (t = a1.find((o) => {
    var s;
    return o[0].id === e && !!((s = o[0]) != null && s.settings);
  })) == null ? void 0 : t[0]) != null ? n : null;
  return (r = i == null ? void 0 : i.settings) != null ? r : null;
}
function wk(e, t) {
  var n, r, i;
  const o = l1(e);
  if (o) {
    const s = localStorage.getItem(o);
    if (s)
      return JSON.parse(s);
  }
  if (e) {
    const s = (r = (n = a1.find((a) => a[0].id === e)) == null ? void 0 : n[0]) != null ? r : null;
    return i0((i = s == null ? void 0 : s.settings) != null ? i : {});
  }
  return i0(t);
}
function Cq(e, t) {
  const n = l1(e);
  localStorage.getItem(n) || localStorage.setItem(n, JSON.stringify(i0(t)));
}
function Nq(e, t, n) {
  const r = l1(e), i = localStorage.getItem(r), o = JSON.parse(i || "{}"), s = {
    ...o,
    [t]: n
  };
  localStorage.setItem(r, JSON.stringify(s)), oa.hooks.callHookWith(
    (a) => {
      a.forEach((l) => l({
        pluginId: e,
        key: t,
        oldValue: o[t],
        newValue: n,
        settings: s
      }));
    },
    "setPluginSettings"
    /* SET_PLUGIN_SETTINGS */
  );
}
re();
re();
re();
re();
re();
re();
re();
re();
re();
re();
re();
var gv, mv, Ln = (mv = (gv = Ee).__VUE_DEVTOOLS_HOOK) != null ? mv : gv.__VUE_DEVTOOLS_HOOK = lk(), Dq = {
  vueAppInit(e) {
    Ln.hook("app:init", e);
  },
  vueAppUnmount(e) {
    Ln.hook("app:unmount", e);
  },
  vueAppConnected(e) {
    Ln.hook("app:connected", e);
  },
  componentAdded(e) {
    return Ln.hook("component:added", e);
  },
  componentEmit(e) {
    return Ln.hook("component:emit", e);
  },
  componentUpdated(e) {
    return Ln.hook("component:updated", e);
  },
  componentRemoved(e) {
    return Ln.hook("component:removed", e);
  },
  setupDevtoolsPlugin(e) {
    Ln.hook("devtools-plugin:setup", e);
  },
  perfStart(e) {
    return Ln.hook("perf:start", e);
  },
  perfEnd(e) {
    return Ln.hook("perf:end", e);
  }
}, xk = {
  on: Dq,
  setupDevToolsPlugin(e, t) {
    return Ln.callHook("devtools-plugin:setup", e, t);
  }
}, Oq = class {
  constructor({ plugin: e, ctx: t }) {
    this.hooks = t.hooks, this.plugin = e;
  }
  get on() {
    return {
      // component inspector
      visitComponentTree: (e) => {
        this.hooks.hook("visitComponentTree", e);
      },
      inspectComponent: (e) => {
        this.hooks.hook("inspectComponent", e);
      },
      editComponentState: (e) => {
        this.hooks.hook("editComponentState", e);
      },
      // custom inspector
      getInspectorTree: (e) => {
        this.hooks.hook("getInspectorTree", e);
      },
      getInspectorState: (e) => {
        this.hooks.hook("getInspectorState", e);
      },
      editInspectorState: (e) => {
        this.hooks.hook("editInspectorState", e);
      },
      // timeline
      inspectTimelineEvent: (e) => {
        this.hooks.hook("inspectTimelineEvent", e);
      },
      timelineCleared: (e) => {
        this.hooks.hook("timelineCleared", e);
      },
      // settings
      setPluginSettings: (e) => {
        this.hooks.hook("setPluginSettings", e);
      }
    };
  }
  // component inspector
  notifyComponentUpdate(e) {
    var t;
    if (Bt.highPerfModeEnabled)
      return;
    const n = _k().find((r) => r.packageName === this.plugin.descriptor.packageName);
    if (n != null && n.id) {
      if (e) {
        const r = [
          e.appContext.app,
          e.uid,
          (t = e.parent) == null ? void 0 : t.uid,
          e
        ];
        Ln.callHook("component:updated", ...r);
      } else
        Ln.callHook(
          "component:updated"
          /* COMPONENT_UPDATED */
        );
      this.hooks.callHook("sendInspectorState", { inspectorId: n.id, plugin: this.plugin });
    }
  }
  // custom inspector
  addInspector(e) {
    this.hooks.callHook("addInspector", { inspector: e, plugin: this.plugin }), this.plugin.descriptor.settings && Cq(e.id, this.plugin.descriptor.settings);
  }
  sendInspectorTree(e) {
    Bt.highPerfModeEnabled || this.hooks.callHook("sendInspectorTree", { inspectorId: e, plugin: this.plugin });
  }
  sendInspectorState(e) {
    Bt.highPerfModeEnabled || this.hooks.callHook("sendInspectorState", { inspectorId: e, plugin: this.plugin });
  }
  selectInspectorNode(e, t) {
    this.hooks.callHook("customInspectorSelectNode", { inspectorId: e, nodeId: t, plugin: this.plugin });
  }
  visitComponentTree(e) {
    return this.hooks.callHook("visitComponentTree", e);
  }
  // timeline
  now() {
    return Bt.highPerfModeEnabled ? 0 : Date.now();
  }
  addTimelineLayer(e) {
    this.hooks.callHook("timelineLayerAdded", { options: e, plugin: this.plugin });
  }
  addTimelineEvent(e) {
    Bt.highPerfModeEnabled || this.hooks.callHook("timelineEventAdded", { options: e, plugin: this.plugin });
  }
  // settings
  getSettings(e) {
    return wk(e ?? this.plugin.descriptor.id, this.plugin.descriptor.settings);
  }
  // utilities
  getComponentInstances(e) {
    return this.hooks.callHook("getComponentInstances", { app: e });
  }
  getComponentBounds(e) {
    return this.hooks.callHook("getComponentBounds", { instance: e });
  }
  getComponentName(e) {
    return this.hooks.callHook("getComponentName", { instance: e });
  }
  highlightElement(e) {
    const t = e.__VUE_DEVTOOLS_NEXT_UID__;
    return this.hooks.callHook("componentHighlight", { uid: t });
  }
  unhighlightElement() {
    return this.hooks.callHook(
      "componentUnhighlight"
      /* COMPONENT_UNHIGHLIGHT */
    );
  }
}, Iq = Oq;
re();
re();
re();
re();
var Rq = "__vue_devtool_undefined__", Lq = "__vue_devtool_infinity__", Bq = "__vue_devtool_negative_infinity__", Pq = "__vue_devtool_nan__";
re();
re();
var $q = {
  [Rq]: "undefined",
  [Pq]: "NaN",
  [Lq]: "Infinity",
  [Bq]: "-Infinity"
};
Object.entries($q).reduce((e, [t, n]) => (e[n] = t, e), {});
re();
re();
re();
re();
re();
var bv, yv;
(yv = (bv = Ee).__VUE_DEVTOOLS_KIT__REGISTERED_PLUGIN_APPS__) != null || (bv.__VUE_DEVTOOLS_KIT__REGISTERED_PLUGIN_APPS__ = /* @__PURE__ */ new Set());
function zq(e, t) {
  return xk.setupDevToolsPlugin(e, t);
}
function Fq(e, t) {
  const [n, r] = e;
  if (n.app !== t)
    return;
  const i = new Iq({
    plugin: {
      setupFn: r,
      descriptor: n
    },
    ctx: oa
  });
  n.packageName === "vuex" && i.on.editInspectorState((o) => {
    i.sendInspectorState(o.inspectorId);
  }), r(i);
}
function kk(e) {
  Ee.__VUE_DEVTOOLS_KIT__REGISTERED_PLUGIN_APPS__.has(e) || Bt.highPerfModeEnabled || (Ee.__VUE_DEVTOOLS_KIT__REGISTERED_PLUGIN_APPS__.add(e), a1.forEach((t) => {
    Fq(t, e);
  }));
}
re();
re();
var kl = "__VUE_DEVTOOLS_ROUTER__", Hs = "__VUE_DEVTOOLS_ROUTER_INFO__", vv, _v;
(_v = (vv = Ee)[Hs]) != null || (vv[Hs] = {
  currentRoute: null,
  routes: []
});
var Ev, wv;
(wv = (Ev = Ee)[kl]) != null || (Ev[kl] = {});
new Proxy(Ee[Hs], {
  get(e, t) {
    return Ee[Hs][t];
  }
});
new Proxy(Ee[kl], {
  get(e, t) {
    if (t === "value")
      return Ee[kl];
  }
});
function jq(e) {
  const t = /* @__PURE__ */ new Map();
  return ((e == null ? void 0 : e.getRoutes()) || []).filter((n) => !t.has(n.path) && t.set(n.path, 1));
}
function u1(e) {
  return e.map((t) => {
    let { path: n, name: r, children: i, meta: o } = t;
    return i != null && i.length && (i = u1(i)), {
      path: n,
      name: r,
      children: i,
      meta: o
    };
  });
}
function Uq(e) {
  if (e) {
    const { fullPath: t, hash: n, href: r, path: i, name: o, matched: s, params: a, query: l } = e;
    return {
      fullPath: t,
      hash: n,
      href: r,
      path: i,
      name: o,
      params: a,
      query: l,
      matched: u1(s)
    };
  }
  return e;
}
function Vq(e, t) {
  function n() {
    var r;
    const i = (r = e.app) == null ? void 0 : r.config.globalProperties.$router, o = Uq(i == null ? void 0 : i.currentRoute.value), s = u1(jq(i)), a = console.warn;
    console.warn = () => {
    }, Ee[Hs] = {
      currentRoute: o ? Gy(o) : {},
      routes: Gy(s)
    }, Ee[kl] = i, console.warn = a;
  }
  n(), xk.on.componentUpdated(Vs(() => {
    var r;
    ((r = t.value) == null ? void 0 : r.app) === e.app && (n(), !Bt.highPerfModeEnabled && oa.hooks.callHook("routerInfoUpdated", { state: Ee[Hs] }));
  }, 200));
}
function Hq(e) {
  return {
    // get inspector tree
    async getInspectorTree(t) {
      const n = {
        ...t,
        app: sn.value.app,
        rootNodes: []
      };
      return await new Promise((r) => {
        e.callHookWith(
          async (i) => {
            await Promise.all(i.map((o) => o(n))), r();
          },
          "getInspectorTree"
          /* GET_INSPECTOR_TREE */
        );
      }), n.rootNodes;
    },
    // get inspector state
    async getInspectorState(t) {
      const n = {
        ...t,
        app: sn.value.app,
        state: null
      }, r = {
        currentTab: `custom-inspector:${t.inspectorId}`
      };
      return await new Promise((i) => {
        e.callHookWith(
          async (o) => {
            await Promise.all(o.map((s) => s(n, r))), i();
          },
          "getInspectorState"
          /* GET_INSPECTOR_STATE */
        );
      }), n.state;
    },
    // edit inspector state
    editInspectorState(t) {
      const n = new ZH(), r = {
        ...t,
        app: sn.value.app,
        set: (i, o = t.path, s = t.state.value, a) => {
          n.set(i, o, s, a || n.createDefaultSetCallback(t.state));
        }
      };
      e.callHookWith(
        (i) => {
          i.forEach((o) => o(r));
        },
        "editInspectorState"
        /* EDIT_INSPECTOR_STATE */
      );
    },
    // send inspector state
    sendInspectorState(t) {
      const n = lc(t);
      e.callHook("sendInspectorState", { inspectorId: t, plugin: {
        descriptor: n.descriptor,
        setupFn: () => ({})
      } });
    },
    // inspect component inspector
    inspectComponentInspector() {
      return dq();
    },
    // cancel inspect component inspector
    cancelInspectComponentInspector() {
      return fq();
    },
    // get component render code
    getComponentRenderCode(t) {
      const n = t0(sn.value, t);
      if (n)
        return (n == null ? void 0 : n.type) instanceof Function ? n.type.toString() : n.render.toString();
    },
    // scroll to component
    scrollToComponent(t) {
      return pq({ id: t });
    },
    // open in editor
    openInEditor: Tq,
    // get vue inspector
    getVueInspector: mq,
    // toggle app
    toggleApp(t) {
      const n = Sd.value.find((r) => r.id === t);
      n && (Aq(t), Mq(n), Vq(n, sn), vk(), kk(n.app));
    },
    // inspect dom
    inspectDOM(t) {
      const n = t0(sn.value, t);
      if (n) {
        const [r] = n1(n);
        r && (Ee.__VUE_DEVTOOLS_INSPECT_DOM_TARGET__ = r);
      }
    },
    updatePluginSettings(t, n, r) {
      Nq(t, n, r);
    },
    getPluginSettings(t) {
      return {
        options: Sq(t),
        values: wk(t)
      };
    }
  };
}
re();
var xv, kv;
(kv = (xv = Ee).__VUE_DEVTOOLS_ENV__) != null || (xv.__VUE_DEVTOOLS_ENV__ = {
  vitePluginDetected: !1
});
var Mv = wq(), Av, Tv;
(Tv = (Av = Ee).__VUE_DEVTOOLS_KIT_CONTEXT__) != null || (Av.__VUE_DEVTOOLS_KIT_CONTEXT__ = {
  hooks: Mv,
  get state() {
    return {
      ...Bt,
      activeAppRecordId: sn.id,
      activeAppRecord: sn.value,
      appRecords: Sd.value
    };
  },
  api: Hq(Mv)
});
var oa = Ee.__VUE_DEVTOOLS_KIT_CONTEXT__;
re();
HH(GH());
var Sv, Cv;
(Cv = (Sv = Ee).__VUE_DEVTOOLS_NEXT_APP_RECORD_INFO__) != null || (Sv.__VUE_DEVTOOLS_NEXT_APP_RECORD_INFO__ = {
  id: 0,
  appIds: /* @__PURE__ */ new Set()
});
re();
function qq(e) {
  Bt.highPerfModeEnabled = e ?? !Bt.highPerfModeEnabled, !e && sn.value && kk(sn.value.app);
}
re();
re();
re();
function Gq(e) {
  Bt.devtoolsClientDetected = {
    ...Bt.devtoolsClientDetected,
    ...e
  };
  const t = Object.values(Bt.devtoolsClientDetected).some(Boolean);
  qq(!t);
}
var Nv, Dv;
(Dv = (Nv = Ee).__VUE_DEVTOOLS_UPDATE_CLIENT_DETECTED__) != null || (Nv.__VUE_DEVTOOLS_UPDATE_CLIENT_DETECTED__ = Gq);
re();
re();
re();
re();
re();
re();
re();
var Wq = class {
  constructor() {
    this.keyToValue = /* @__PURE__ */ new Map(), this.valueToKey = /* @__PURE__ */ new Map();
  }
  set(e, t) {
    this.keyToValue.set(e, t), this.valueToKey.set(t, e);
  }
  getByKey(e) {
    return this.keyToValue.get(e);
  }
  getByValue(e) {
    return this.valueToKey.get(e);
  }
  clear() {
    this.keyToValue.clear(), this.valueToKey.clear();
  }
}, Mk = class {
  constructor(e) {
    this.generateIdentifier = e, this.kv = new Wq();
  }
  register(e, t) {
    this.kv.getByValue(e) || (t || (t = this.generateIdentifier(e)), this.kv.set(t, e));
  }
  clear() {
    this.kv.clear();
  }
  getIdentifier(e) {
    return this.kv.getByValue(e);
  }
  getValue(e) {
    return this.kv.getByKey(e);
  }
}, Kq = class extends Mk {
  constructor() {
    super((e) => e.name), this.classToAllowedProps = /* @__PURE__ */ new Map();
  }
  register(e, t) {
    typeof t == "object" ? (t.allowProps && this.classToAllowedProps.set(e, t.allowProps), super.register(e, t.identifier)) : super.register(e, t);
  }
  getAllowedProps(e) {
    return this.classToAllowedProps.get(e);
  }
};
re();
re();
function Yq(e) {
  if ("values" in Object)
    return Object.values(e);
  const t = [];
  for (const n in e)
    e.hasOwnProperty(n) && t.push(e[n]);
  return t;
}
function Qq(e, t) {
  const n = Yq(e);
  if ("find" in n)
    return n.find(t);
  const r = n;
  for (let i = 0; i < r.length; i++) {
    const o = r[i];
    if (t(o))
      return o;
  }
}
function qs(e, t) {
  Object.entries(e).forEach(([n, r]) => t(r, n));
}
function uc(e, t) {
  return e.indexOf(t) !== -1;
}
function Ov(e, t) {
  for (let n = 0; n < e.length; n++) {
    const r = e[n];
    if (t(r))
      return r;
  }
}
var Zq = class {
  constructor() {
    this.transfomers = {};
  }
  register(e) {
    this.transfomers[e.name] = e;
  }
  findApplicable(e) {
    return Qq(this.transfomers, (t) => t.isApplicable(e));
  }
  findByName(e) {
    return this.transfomers[e];
  }
};
re();
re();
var Xq = (e) => Object.prototype.toString.call(e).slice(8, -1), Ak = (e) => typeof e > "u", Jq = (e) => e === null, Ml = (e) => typeof e != "object" || e === null || e === Object.prototype ? !1 : Object.getPrototypeOf(e) === null ? !0 : Object.getPrototypeOf(e) === Object.prototype, o0 = (e) => Ml(e) && Object.keys(e).length === 0, Ki = (e) => Array.isArray(e), eG = (e) => typeof e == "string", tG = (e) => typeof e == "number" && !isNaN(e), nG = (e) => typeof e == "boolean", rG = (e) => e instanceof RegExp, Al = (e) => e instanceof Map, Tl = (e) => e instanceof Set, Tk = (e) => Xq(e) === "Symbol", iG = (e) => e instanceof Date && !isNaN(e.valueOf()), oG = (e) => e instanceof Error, Iv = (e) => typeof e == "number" && isNaN(e), sG = (e) => nG(e) || Jq(e) || Ak(e) || tG(e) || eG(e) || Tk(e), aG = (e) => typeof e == "bigint", lG = (e) => e === 1 / 0 || e === -1 / 0, uG = (e) => ArrayBuffer.isView(e) && !(e instanceof DataView), cG = (e) => e instanceof URL;
re();
var Sk = (e) => e.replace(/\./g, "\\."), Wp = (e) => e.map(String).map(Sk).join("."), Wa = (e) => {
  const t = [];
  let n = "";
  for (let i = 0; i < e.length; i++) {
    let o = e.charAt(i);
    if (o === "\\" && e.charAt(i + 1) === ".") {
      n += ".", i++;
      continue;
    }
    if (o === ".") {
      t.push(n), n = "";
      continue;
    }
    n += o;
  }
  const r = n;
  return t.push(r), t;
};
re();
function yr(e, t, n, r) {
  return {
    isApplicable: e,
    annotation: t,
    transform: n,
    untransform: r
  };
}
var Ck = [
  yr(Ak, "undefined", () => null, () => {
  }),
  yr(aG, "bigint", (e) => e.toString(), (e) => typeof BigInt < "u" ? BigInt(e) : (console.error("Please add a BigInt polyfill."), e)),
  yr(iG, "Date", (e) => e.toISOString(), (e) => new Date(e)),
  yr(oG, "Error", (e, t) => {
    const n = {
      name: e.name,
      message: e.message
    };
    return t.allowedErrorProps.forEach((r) => {
      n[r] = e[r];
    }), n;
  }, (e, t) => {
    const n = new Error(e.message);
    return n.name = e.name, n.stack = e.stack, t.allowedErrorProps.forEach((r) => {
      n[r] = e[r];
    }), n;
  }),
  yr(rG, "regexp", (e) => "" + e, (e) => {
    const t = e.slice(1, e.lastIndexOf("/")), n = e.slice(e.lastIndexOf("/") + 1);
    return new RegExp(t, n);
  }),
  yr(
    Tl,
    "set",
    // (sets only exist in es6+)
    // eslint-disable-next-line es5/no-es6-methods
    (e) => [...e.values()],
    (e) => new Set(e)
  ),
  yr(Al, "map", (e) => [...e.entries()], (e) => new Map(e)),
  yr((e) => Iv(e) || lG(e), "number", (e) => Iv(e) ? "NaN" : e > 0 ? "Infinity" : "-Infinity", Number),
  yr((e) => e === 0 && 1 / e === -1 / 0, "number", () => "-0", Number),
  yr(cG, "URL", (e) => e.toString(), (e) => new URL(e))
];
function Cd(e, t, n, r) {
  return {
    isApplicable: e,
    annotation: t,
    transform: n,
    untransform: r
  };
}
var Nk = Cd((e, t) => Tk(e) ? !!t.symbolRegistry.getIdentifier(e) : !1, (e, t) => ["symbol", t.symbolRegistry.getIdentifier(e)], (e) => e.description, (e, t, n) => {
  const r = n.symbolRegistry.getValue(t[1]);
  if (!r)
    throw new Error("Trying to deserialize unknown symbol");
  return r;
}), fG = [
  Int8Array,
  Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
  Uint8ClampedArray
].reduce((e, t) => (e[t.name] = t, e), {}), Dk = Cd(uG, (e) => ["typed-array", e.constructor.name], (e) => [...e], (e, t) => {
  const n = fG[t[1]];
  if (!n)
    throw new Error("Trying to deserialize unknown typed array");
  return new n(e);
});
function Ok(e, t) {
  return e != null && e.constructor ? !!t.classRegistry.getIdentifier(e.constructor) : !1;
}
var Ik = Cd(Ok, (e, t) => ["class", t.classRegistry.getIdentifier(e.constructor)], (e, t) => {
  const n = t.classRegistry.getAllowedProps(e.constructor);
  if (!n)
    return { ...e };
  const r = {};
  return n.forEach((i) => {
    r[i] = e[i];
  }), r;
}, (e, t, n) => {
  const r = n.classRegistry.getValue(t[1]);
  if (!r)
    throw new Error("Trying to deserialize unknown class - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564");
  return Object.assign(Object.create(r.prototype), e);
}), Rk = Cd((e, t) => !!t.customTransformerRegistry.findApplicable(e), (e, t) => ["custom", t.customTransformerRegistry.findApplicable(e).name], (e, t) => t.customTransformerRegistry.findApplicable(e).serialize(e), (e, t, n) => {
  const r = n.customTransformerRegistry.findByName(t[1]);
  if (!r)
    throw new Error("Trying to deserialize unknown custom value");
  return r.deserialize(e);
}), dG = [Ik, Nk, Rk, Dk], Rv = (e, t) => {
  const n = Ov(dG, (i) => i.isApplicable(e, t));
  if (n)
    return {
      value: n.transform(e, t),
      type: n.annotation(e, t)
    };
  const r = Ov(Ck, (i) => i.isApplicable(e, t));
  if (r)
    return {
      value: r.transform(e, t),
      type: r.annotation
    };
}, Lk = {};
Ck.forEach((e) => {
  Lk[e.annotation] = e;
});
var pG = (e, t, n) => {
  if (Ki(t))
    switch (t[0]) {
      case "symbol":
        return Nk.untransform(e, t, n);
      case "class":
        return Ik.untransform(e, t, n);
      case "custom":
        return Rk.untransform(e, t, n);
      case "typed-array":
        return Dk.untransform(e, t, n);
      default:
        throw new Error("Unknown transformation: " + t);
    }
  else {
    const r = Lk[t];
    if (!r)
      throw new Error("Unknown transformation: " + t);
    return r.untransform(e, n);
  }
};
re();
var as = (e, t) => {
  const n = e.keys();
  for (; t > 0; )
    n.next(), t--;
  return n.next().value;
};
function Bk(e) {
  if (uc(e, "__proto__"))
    throw new Error("__proto__ is not allowed as a property");
  if (uc(e, "prototype"))
    throw new Error("prototype is not allowed as a property");
  if (uc(e, "constructor"))
    throw new Error("constructor is not allowed as a property");
}
var hG = (e, t) => {
  Bk(t);
  for (let n = 0; n < t.length; n++) {
    const r = t[n];
    if (Tl(e))
      e = as(e, +r);
    else if (Al(e)) {
      const i = +r, o = +t[++n] == 0 ? "key" : "value", s = as(e, i);
      switch (o) {
        case "key":
          e = s;
          break;
        case "value":
          e = e.get(s);
          break;
      }
    } else
      e = e[r];
  }
  return e;
}, s0 = (e, t, n) => {
  if (Bk(t), t.length === 0)
    return n(e);
  let r = e;
  for (let o = 0; o < t.length - 1; o++) {
    const s = t[o];
    if (Ki(r)) {
      const a = +s;
      r = r[a];
    } else if (Ml(r))
      r = r[s];
    else if (Tl(r)) {
      const a = +s;
      r = as(r, a);
    } else if (Al(r)) {
      if (o === t.length - 2)
        break;
      const l = +s, u = +t[++o] == 0 ? "key" : "value", c = as(r, l);
      switch (u) {
        case "key":
          r = c;
          break;
        case "value":
          r = r.get(c);
          break;
      }
    }
  }
  const i = t[t.length - 1];
  if (Ki(r) ? r[+i] = n(r[+i]) : Ml(r) && (r[i] = n(r[i])), Tl(r)) {
    const o = as(r, +i), s = n(o);
    o !== s && (r.delete(o), r.add(s));
  }
  if (Al(r)) {
    const o = +t[t.length - 2], s = as(r, o);
    switch (+i == 0 ? "key" : "value") {
      case "key": {
        const l = n(s);
        r.set(l, r.get(s)), l !== s && r.delete(s);
        break;
      }
      case "value": {
        r.set(s, n(r.get(s)));
        break;
      }
    }
  }
  return e;
};
function a0(e, t, n = []) {
  if (!e)
    return;
  if (!Ki(e)) {
    qs(e, (o, s) => a0(o, t, [...n, ...Wa(s)]));
    return;
  }
  const [r, i] = e;
  i && qs(i, (o, s) => {
    a0(o, t, [...n, ...Wa(s)]);
  }), t(r, n);
}
function gG(e, t, n) {
  return a0(t, (r, i) => {
    e = s0(e, i, (o) => pG(o, r, n));
  }), e;
}
function mG(e, t) {
  function n(r, i) {
    const o = hG(e, Wa(i));
    r.map(Wa).forEach((s) => {
      e = s0(e, s, () => o);
    });
  }
  if (Ki(t)) {
    const [r, i] = t;
    r.forEach((o) => {
      e = s0(e, Wa(o), () => e);
    }), i && qs(i, n);
  } else
    qs(t, n);
  return e;
}
var bG = (e, t) => Ml(e) || Ki(e) || Al(e) || Tl(e) || Ok(e, t);
function yG(e, t, n) {
  const r = n.get(e);
  r ? r.push(t) : n.set(e, [t]);
}
function vG(e, t) {
  const n = {};
  let r;
  return e.forEach((i) => {
    if (i.length <= 1)
      return;
    t || (i = i.map((a) => a.map(String)).sort((a, l) => a.length - l.length));
    const [o, ...s] = i;
    o.length === 0 ? r = s.map(Wp) : n[Wp(o)] = s.map(Wp);
  }), r ? o0(n) ? [r] : [r, n] : o0(n) ? void 0 : n;
}
var Pk = (e, t, n, r, i = [], o = [], s = /* @__PURE__ */ new Map()) => {
  var a;
  const l = sG(e);
  if (!l) {
    yG(e, i, t);
    const h = s.get(e);
    if (h)
      return r ? {
        transformedValue: null
      } : h;
  }
  if (!bG(e, n)) {
    const h = Rv(e, n), m = h ? {
      transformedValue: h.value,
      annotations: [h.type]
    } : {
      transformedValue: e
    };
    return l || s.set(e, m), m;
  }
  if (uc(o, e))
    return {
      transformedValue: null
    };
  const u = Rv(e, n), c = (a = u == null ? void 0 : u.value) != null ? a : e, f = Ki(c) ? [] : {}, d = {};
  qs(c, (h, m) => {
    if (m === "__proto__" || m === "constructor" || m === "prototype")
      throw new Error(`Detected property ${m}. This is a prototype pollution risk, please remove it from your object.`);
    const g = Pk(h, t, n, r, [...i, m], [...o, e], s);
    f[m] = g.transformedValue, Ki(g.annotations) ? d[m] = g.annotations : Ml(g.annotations) && qs(g.annotations, (y, _) => {
      d[Sk(m) + "." + _] = y;
    });
  });
  const p = o0(d) ? {
    transformedValue: f,
    annotations: u ? [u.type] : void 0
  } : {
    transformedValue: f,
    annotations: u ? [u.type, d] : d
  };
  return l || s.set(e, p), p;
};
re();
re();
function $k(e) {
  return Object.prototype.toString.call(e).slice(8, -1);
}
function Lv(e) {
  return $k(e) === "Array";
}
function _G(e) {
  if ($k(e) !== "Object")
    return !1;
  const t = Object.getPrototypeOf(e);
  return !!t && t.constructor === Object && t === Object.prototype;
}
function EG(e, t, n, r, i) {
  const o = {}.propertyIsEnumerable.call(r, t) ? "enumerable" : "nonenumerable";
  o === "enumerable" && (e[t] = n), i && o === "nonenumerable" && Object.defineProperty(e, t, {
    value: n,
    enumerable: !1,
    writable: !0,
    configurable: !0
  });
}
function l0(e, t = {}) {
  if (Lv(e))
    return e.map((i) => l0(i, t));
  if (!_G(e))
    return e;
  const n = Object.getOwnPropertyNames(e), r = Object.getOwnPropertySymbols(e);
  return [...n, ...r].reduce((i, o) => {
    if (Lv(t.props) && !t.props.includes(o))
      return i;
    const s = e[o], a = l0(s, t);
    return EG(i, o, a, e, t.nonenumerable), i;
  }, {});
}
var pt = class {
  /**
   * @param dedupeReferentialEqualities  If true, SuperJSON will make sure only one instance of referentially equal objects are serialized and the rest are replaced with `null`.
   */
  constructor({ dedupe: e = !1 } = {}) {
    this.classRegistry = new Kq(), this.symbolRegistry = new Mk((t) => {
      var n;
      return (n = t.description) != null ? n : "";
    }), this.customTransformerRegistry = new Zq(), this.allowedErrorProps = [], this.dedupe = e;
  }
  serialize(e) {
    const t = /* @__PURE__ */ new Map(), n = Pk(e, t, this, this.dedupe), r = {
      json: n.transformedValue
    };
    n.annotations && (r.meta = {
      ...r.meta,
      values: n.annotations
    });
    const i = vG(t, this.dedupe);
    return i && (r.meta = {
      ...r.meta,
      referentialEqualities: i
    }), r;
  }
  deserialize(e) {
    const { json: t, meta: n } = e;
    let r = l0(t);
    return n != null && n.values && (r = gG(r, n.values, this)), n != null && n.referentialEqualities && (r = mG(r, n.referentialEqualities)), r;
  }
  stringify(e) {
    return JSON.stringify(this.serialize(e));
  }
  parse(e) {
    return this.deserialize(JSON.parse(e));
  }
  registerClass(e, t) {
    this.classRegistry.register(e, t);
  }
  registerSymbol(e, t) {
    this.symbolRegistry.register(e, t);
  }
  registerCustom(e, t) {
    this.customTransformerRegistry.register({
      name: t,
      ...e
    });
  }
  allowErrorProps(...e) {
    this.allowedErrorProps.push(...e);
  }
};
pt.defaultInstance = new pt();
pt.serialize = pt.defaultInstance.serialize.bind(pt.defaultInstance);
pt.deserialize = pt.defaultInstance.deserialize.bind(pt.defaultInstance);
pt.stringify = pt.defaultInstance.stringify.bind(pt.defaultInstance);
pt.parse = pt.defaultInstance.parse.bind(pt.defaultInstance);
pt.registerClass = pt.defaultInstance.registerClass.bind(pt.defaultInstance);
pt.registerSymbol = pt.defaultInstance.registerSymbol.bind(pt.defaultInstance);
pt.registerCustom = pt.defaultInstance.registerCustom.bind(pt.defaultInstance);
pt.allowErrorProps = pt.defaultInstance.allowErrorProps.bind(pt.defaultInstance);
re();
re();
re();
re();
re();
re();
re();
re();
re();
re();
re();
re();
re();
re();
re();
re();
re();
re();
re();
re();
re();
re();
re();
var Bv, Pv;
(Pv = (Bv = Ee).__VUE_DEVTOOLS_KIT_MESSAGE_CHANNELS__) != null || (Bv.__VUE_DEVTOOLS_KIT_MESSAGE_CHANNELS__ = []);
var $v, zv;
(zv = ($v = Ee).__VUE_DEVTOOLS_KIT_RPC_CLIENT__) != null || ($v.__VUE_DEVTOOLS_KIT_RPC_CLIENT__ = null);
var Fv, jv;
(jv = (Fv = Ee).__VUE_DEVTOOLS_KIT_RPC_SERVER__) != null || (Fv.__VUE_DEVTOOLS_KIT_RPC_SERVER__ = null);
var Uv, Vv;
(Vv = (Uv = Ee).__VUE_DEVTOOLS_KIT_VITE_RPC_CLIENT__) != null || (Uv.__VUE_DEVTOOLS_KIT_VITE_RPC_CLIENT__ = null);
var Hv, qv;
(qv = (Hv = Ee).__VUE_DEVTOOLS_KIT_VITE_RPC_SERVER__) != null || (Hv.__VUE_DEVTOOLS_KIT_VITE_RPC_SERVER__ = null);
var Gv, Wv;
(Wv = (Gv = Ee).__VUE_DEVTOOLS_KIT_BROADCAST_RPC_SERVER__) != null || (Gv.__VUE_DEVTOOLS_KIT_BROADCAST_RPC_SERVER__ = null);
re();
re();
re();
re();
re();
re();
re();
/**
  * vee-validate v4.14.7
  * (c) 2024 Abdelrahman Awad
  * @license MIT
  */
function Zt(e) {
  return typeof e == "function";
}
function zk(e) {
  return e == null;
}
const Yi = (e) => e !== null && !!e && typeof e == "object" && !Array.isArray(e);
function c1(e) {
  return Number(e) >= 0;
}
function wG(e) {
  const t = parseFloat(e);
  return isNaN(t) ? e : t;
}
function xG(e) {
  return typeof e == "object" && e !== null;
}
function kG(e) {
  return e == null ? e === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e);
}
function Kv(e) {
  if (!xG(e) || kG(e) !== "[object Object]")
    return !1;
  if (Object.getPrototypeOf(e) === null)
    return !0;
  let t = e;
  for (; Object.getPrototypeOf(t) !== null; )
    t = Object.getPrototypeOf(t);
  return Object.getPrototypeOf(e) === t;
}
function Sl(e, t) {
  return Object.keys(t).forEach((n) => {
    if (Kv(t[n]) && Kv(e[n])) {
      e[n] || (e[n] = {}), Sl(e[n], t[n]);
      return;
    }
    e[n] = t[n];
  }), e;
}
function xa(e) {
  const t = e.split(".");
  if (!t.length)
    return "";
  let n = String(t[0]);
  for (let r = 1; r < t.length; r++) {
    if (c1(t[r])) {
      n += `[${t[r]}]`;
      continue;
    }
    n += `.${t[r]}`;
  }
  return n;
}
const MG = {};
function AG(e) {
  return MG[e];
}
function Yv(e, t, n) {
  typeof n.value == "object" && (n.value = nt(n.value)), !n.enumerable || n.get || n.set || !n.configurable || !n.writable || t === "__proto__" ? Object.defineProperty(e, t, n) : e[t] = n.value;
}
function nt(e) {
  if (typeof e != "object") return e;
  var t = 0, n, r, i, o = Object.prototype.toString.call(e);
  if (o === "[object Object]" ? i = Object.create(e.__proto__ || null) : o === "[object Array]" ? i = Array(e.length) : o === "[object Set]" ? (i = /* @__PURE__ */ new Set(), e.forEach(function(s) {
    i.add(nt(s));
  })) : o === "[object Map]" ? (i = /* @__PURE__ */ new Map(), e.forEach(function(s, a) {
    i.set(nt(a), nt(s));
  })) : o === "[object Date]" ? i = /* @__PURE__ */ new Date(+e) : o === "[object RegExp]" ? i = new RegExp(e.source, e.flags) : o === "[object DataView]" ? i = new e.constructor(nt(e.buffer)) : o === "[object ArrayBuffer]" ? i = e.slice(0) : o.slice(-6) === "Array]" && (i = new e.constructor(e)), i) {
    for (r = Object.getOwnPropertySymbols(e); t < r.length; t++)
      Yv(i, r[t], Object.getOwnPropertyDescriptor(e, r[t]));
    for (t = 0, r = Object.getOwnPropertyNames(e); t < r.length; t++)
      Object.hasOwnProperty.call(i, n = r[t]) && i[n] === e[n] || Yv(i, n, Object.getOwnPropertyDescriptor(e, n));
  }
  return i || e;
}
const f1 = Symbol("vee-validate-form"), TG = Symbol("vee-validate-form-context"), SG = Symbol("vee-validate-field-instance"), If = Symbol("Default empty value"), CG = typeof window < "u";
function u0(e) {
  return Zt(e) && !!e.__locatorRef;
}
function ur(e) {
  return !!e && Zt(e.parse) && e.__type === "VVTypedSchema";
}
function Rf(e) {
  return !!e && Zt(e.validate);
}
function tu(e) {
  return e === "checkbox" || e === "radio";
}
function NG(e) {
  return Yi(e) || Array.isArray(e);
}
function DG(e) {
  return Array.isArray(e) ? e.length === 0 : Yi(e) && Object.keys(e).length === 0;
}
function Nd(e) {
  return /^\[.+\]$/i.test(e);
}
function OG(e) {
  return Fk(e) && e.multiple;
}
function Fk(e) {
  return e.tagName === "SELECT";
}
function IG(e, t) {
  const n = ![!1, null, void 0, 0].includes(t.multiple) && !Number.isNaN(t.multiple);
  return e === "select" && "multiple" in t && n;
}
function RG(e, t) {
  return !IG(e, t) && t.type !== "file" && !tu(t.type);
}
function jk(e) {
  return d1(e) && e.target && "submit" in e.target;
}
function d1(e) {
  return e ? !!(typeof Event < "u" && Zt(Event) && e instanceof Event || e && e.srcElement) : !1;
}
function Qv(e, t) {
  return t in e && e[t] !== If;
}
function pn(e, t) {
  if (e === t)
    return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (e.constructor !== t.constructor)
      return !1;
    var n, r, i;
    if (Array.isArray(e)) {
      if (n = e.length, n != t.length)
        return !1;
      for (r = n; r-- !== 0; )
        if (!pn(e[r], t[r]))
          return !1;
      return !0;
    }
    if (e instanceof Map && t instanceof Map) {
      if (e.size !== t.size)
        return !1;
      for (r of e.entries())
        if (!t.has(r[0]))
          return !1;
      for (r of e.entries())
        if (!pn(r[1], t.get(r[0])))
          return !1;
      return !0;
    }
    if (Xv(e) && Xv(t))
      return !(e.size !== t.size || e.name !== t.name || e.lastModified !== t.lastModified || e.type !== t.type);
    if (e instanceof Set && t instanceof Set) {
      if (e.size !== t.size)
        return !1;
      for (r of e.entries())
        if (!t.has(r[0]))
          return !1;
      return !0;
    }
    if (ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) {
      if (n = e.length, n != t.length)
        return !1;
      for (r = n; r-- !== 0; )
        if (e[r] !== t[r])
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === t.source && e.flags === t.flags;
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === t.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === t.toString();
    if (i = Object.keys(e), n = i.length - Zv(e, i), n !== Object.keys(t).length - Zv(t, Object.keys(t)))
      return !1;
    for (r = n; r-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(t, i[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      var o = i[r];
      if (!pn(e[o], t[o]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function Zv(e, t) {
  let n = 0;
  for (let i = t.length; i-- !== 0; ) {
    var r = t[i];
    e[r] === void 0 && n++;
  }
  return n;
}
function Xv(e) {
  return CG ? e instanceof File : !1;
}
function p1(e) {
  return Nd(e) ? e.replace(/\[|\]/gi, "") : e;
}
function xn(e, t, n) {
  return e ? Nd(t) ? e[p1(t)] : (t || "").split(/\.|\[(\d+)\]/).filter(Boolean).reduce((i, o) => NG(i) && o in i ? i[o] : n, e) : n;
}
function Mr(e, t, n) {
  if (Nd(t)) {
    e[p1(t)] = n;
    return;
  }
  const r = t.split(/\.|\[(\d+)\]/).filter(Boolean);
  let i = e;
  for (let o = 0; o < r.length; o++) {
    if (o === r.length - 1) {
      i[r[o]] = n;
      return;
    }
    (!(r[o] in i) || zk(i[r[o]])) && (i[r[o]] = c1(r[o + 1]) ? [] : {}), i = i[r[o]];
  }
}
function Kp(e, t) {
  if (Array.isArray(e) && c1(t)) {
    e.splice(Number(t), 1);
    return;
  }
  Yi(e) && delete e[t];
}
function Jv(e, t) {
  if (Nd(t)) {
    delete e[p1(t)];
    return;
  }
  const n = t.split(/\.|\[(\d+)\]/).filter(Boolean);
  let r = e;
  for (let o = 0; o < n.length; o++) {
    if (o === n.length - 1) {
      Kp(r, n[o]);
      break;
    }
    if (!(n[o] in r) || zk(r[n[o]]))
      break;
    r = r[n[o]];
  }
  const i = n.map((o, s) => xn(e, n.slice(0, s).join(".")));
  for (let o = i.length - 1; o >= 0; o--)
    if (DG(i[o])) {
      if (o === 0) {
        Kp(e, n[0]);
        continue;
      }
      Kp(i[o - 1], n[o - 1]);
    }
}
function _n(e) {
  return Object.keys(e);
}
function Uk(e, t = void 0) {
  const n = jn();
  return (n == null ? void 0 : n.provides[e]) || Wr(e, t);
}
function e_(e, t, n) {
  if (Array.isArray(e)) {
    const r = [...e], i = r.findIndex((o) => pn(o, t));
    return i >= 0 ? r.splice(i, 1) : r.push(t), r;
  }
  return pn(e, t) ? n : t;
}
function LG(e, t) {
  let n, r;
  return function(...i) {
    const o = this;
    return n || (n = !0, setTimeout(() => n = !1, t), r = e.apply(o, i)), r;
  };
}
function t_(e, t = 0) {
  let n = null, r = [];
  return function(...i) {
    return n && clearTimeout(n), n = setTimeout(() => {
      const o = e(...i);
      r.forEach((s) => s(o)), r = [];
    }, t), new Promise((o) => r.push(o));
  };
}
function BG(e, t) {
  return Yi(t) && t.number ? wG(e) : e;
}
function c0(e, t) {
  let n;
  return async function(...i) {
    const o = e(...i);
    n = o;
    const s = await o;
    return o !== n ? s : (n = void 0, t(s, i));
  };
}
function f0(e) {
  return Array.isArray(e) ? e : e ? [e] : [];
}
function Pu(e, t) {
  const n = {};
  for (const r in e)
    t.includes(r) || (n[r] = e[r]);
  return n;
}
function PG(e) {
  let t = null, n = [];
  return function(...r) {
    const i = Ft(() => {
      if (t !== i)
        return;
      const o = e(...r);
      n.forEach((s) => s(o)), n = [], t = null;
    });
    return t = i, new Promise((o) => n.push(o));
  };
}
function Vk(e, t, n) {
  return t.slots.default ? typeof e == "string" || !e ? t.slots.default(n()) : {
    default: () => {
      var r, i;
      return (i = (r = t.slots).default) === null || i === void 0 ? void 0 : i.call(r, n());
    }
  } : t.slots.default;
}
function Yp(e) {
  if (Hk(e))
    return e._value;
}
function Hk(e) {
  return "_value" in e;
}
function $G(e) {
  return e.type === "number" || e.type === "range" ? Number.isNaN(e.valueAsNumber) ? e.value : e.valueAsNumber : e.value;
}
function Lf(e) {
  if (!d1(e))
    return e;
  const t = e.target;
  if (tu(t.type) && Hk(t))
    return Yp(t);
  if (t.type === "file" && t.files) {
    const n = Array.from(t.files);
    return t.multiple ? n : n[0];
  }
  if (OG(t))
    return Array.from(t.options).filter((n) => n.selected && !n.disabled).map(Yp);
  if (Fk(t)) {
    const n = Array.from(t.options).find((r) => r.selected);
    return n ? Yp(n) : t.value;
  }
  return $G(t);
}
function qk(e) {
  const t = {};
  return Object.defineProperty(t, "_$$isNormalized", {
    value: !0,
    writable: !1,
    enumerable: !1,
    configurable: !1
  }), e ? Yi(e) && e._$$isNormalized ? e : Yi(e) ? Object.keys(e).reduce((n, r) => {
    const i = zG(e[r]);
    return e[r] !== !1 && (n[r] = n_(i)), n;
  }, t) : typeof e != "string" ? t : e.split("|").reduce((n, r) => {
    const i = FG(r);
    return i.name && (n[i.name] = n_(i.params)), n;
  }, t) : t;
}
function zG(e) {
  return e === !0 ? [] : Array.isArray(e) || Yi(e) ? e : [e];
}
function n_(e) {
  const t = (n) => typeof n == "string" && n[0] === "@" ? jG(n.slice(1)) : n;
  return Array.isArray(e) ? e.map(t) : e instanceof RegExp ? [e] : Object.keys(e).reduce((n, r) => (n[r] = t(e[r]), n), {});
}
const FG = (e) => {
  let t = [];
  const n = e.split(":")[0];
  return e.includes(":") && (t = e.split(":").slice(1).join(":").split(",")), { name: n, params: t };
};
function jG(e) {
  const t = (n) => {
    var r;
    return (r = xn(n, e)) !== null && r !== void 0 ? r : n[e];
  };
  return t.__locatorRef = e, t;
}
function UG(e) {
  return Array.isArray(e) ? e.filter(u0) : _n(e).filter((t) => u0(e[t])).map((t) => e[t]);
}
const VG = {
  generateMessage: ({ field: e }) => `${e} is not valid.`,
  bails: !0,
  validateOnBlur: !0,
  validateOnChange: !0,
  validateOnInput: !1,
  validateOnModelUpdate: !0
};
let HG = Object.assign({}, VG);
const go = () => HG;
async function Gk(e, t, n = {}) {
  const r = n == null ? void 0 : n.bails, i = {
    name: (n == null ? void 0 : n.name) || "{field}",
    rules: t,
    label: n == null ? void 0 : n.label,
    bails: r ?? !0,
    formData: (n == null ? void 0 : n.values) || {}
  }, o = await qG(i, e);
  return Object.assign(Object.assign({}, o), { valid: !o.errors.length });
}
async function qG(e, t) {
  const n = e.rules;
  if (ur(n) || Rf(n))
    return WG(t, Object.assign(Object.assign({}, e), { rules: n }));
  if (Zt(n) || Array.isArray(n)) {
    const a = {
      field: e.label || e.name,
      name: e.name,
      label: e.label,
      form: e.formData,
      value: t
    }, l = Array.isArray(n) ? n : [n], u = l.length, c = [];
    for (let f = 0; f < u; f++) {
      const d = l[f], p = await d(t, a);
      if (!(typeof p != "string" && !Array.isArray(p) && p)) {
        if (Array.isArray(p))
          c.push(...p);
        else {
          const m = typeof p == "string" ? p : Kk(a);
          c.push(m);
        }
        if (e.bails)
          return {
            errors: c
          };
      }
    }
    return {
      errors: c
    };
  }
  const r = Object.assign(Object.assign({}, e), { rules: qk(n) }), i = [], o = Object.keys(r.rules), s = o.length;
  for (let a = 0; a < s; a++) {
    const l = o[a], u = await KG(r, t, {
      name: l,
      params: r.rules[l]
    });
    if (u.error && (i.push(u.error), e.bails))
      return {
        errors: i
      };
  }
  return {
    errors: i
  };
}
function GG(e) {
  return !!e && e.name === "ValidationError";
}
function Wk(e) {
  return {
    __type: "VVTypedSchema",
    async parse(n, r) {
      var i;
      try {
        return {
          output: await e.validate(n, { abortEarly: !1, context: (r == null ? void 0 : r.formData) || {} }),
          errors: []
        };
      } catch (o) {
        if (!GG(o))
          throw o;
        if (!(!((i = o.inner) === null || i === void 0) && i.length) && o.errors.length)
          return { errors: [{ path: o.path, errors: o.errors }] };
        const s = o.inner.reduce((a, l) => {
          const u = l.path || "";
          return a[u] || (a[u] = { errors: [], path: u }), a[u].errors.push(...l.errors), a;
        }, {});
        return { errors: Object.values(s) };
      }
    }
  };
}
async function WG(e, t) {
  const r = await (ur(t.rules) ? t.rules : Wk(t.rules)).parse(e, { formData: t.formData }), i = [];
  for (const o of r.errors)
    o.errors.length && i.push(...o.errors);
  return {
    value: r.value,
    errors: i
  };
}
async function KG(e, t, n) {
  const r = AG(n.name);
  if (!r)
    throw new Error(`No such validator '${n.name}' exists.`);
  const i = YG(n.params, e.formData), o = {
    field: e.label || e.name,
    name: e.name,
    label: e.label,
    value: t,
    form: e.formData,
    rule: Object.assign(Object.assign({}, n), { params: i })
  }, s = await r(t, i, o);
  return typeof s == "string" ? {
    error: s
  } : {
    error: s ? void 0 : Kk(o)
  };
}
function Kk(e) {
  const t = go().generateMessage;
  return t ? t(e) : "Field is invalid";
}
function YG(e, t) {
  const n = (r) => u0(r) ? r(t) : r;
  return Array.isArray(e) ? e.map(n) : Object.keys(e).reduce((r, i) => (r[i] = n(e[i]), r), {});
}
async function QG(e, t) {
  const r = await (ur(e) ? e : Wk(e)).parse(nt(t), { formData: nt(t) }), i = {}, o = {};
  for (const s of r.errors) {
    const a = s.errors, l = (s.path || "").replace(/\["(\d+)"\]/g, (u, c) => `[${c}]`);
    i[l] = { valid: !a.length, errors: a }, a.length && (o[l] = a[0]);
  }
  return {
    valid: !r.errors.length,
    results: i,
    errors: o,
    values: r.value,
    source: "schema"
  };
}
async function ZG(e, t, n) {
  const i = _n(e).map(async (u) => {
    var c, f, d;
    const p = (c = n == null ? void 0 : n.names) === null || c === void 0 ? void 0 : c[u], h = await Gk(xn(t, u), e[u], {
      name: (p == null ? void 0 : p.name) || u,
      label: p == null ? void 0 : p.label,
      values: t,
      bails: (d = (f = n == null ? void 0 : n.bailsMap) === null || f === void 0 ? void 0 : f[u]) !== null && d !== void 0 ? d : !0
    });
    return Object.assign(Object.assign({}, h), { path: u });
  });
  let o = !0;
  const s = await Promise.all(i), a = {}, l = {};
  for (const u of s)
    a[u.path] = {
      valid: u.valid,
      errors: u.errors
    }, u.valid || (o = !1, l[u.path] = u.errors[0]);
  return {
    valid: o,
    results: a,
    errors: l,
    source: "schema"
  };
}
let r_ = 0;
function XG(e, t) {
  const { value: n, initialValue: r, setInitialValue: i } = JG(e, t.modelValue, t.form);
  if (!t.form) {
    let d = function(p) {
      var h;
      "value" in p && (n.value = p.value), "errors" in p && u(p.errors), "touched" in p && (f.touched = (h = p.touched) !== null && h !== void 0 ? h : f.touched), "initialValue" in p && i(p.initialValue);
    };
    const { errors: l, setErrors: u } = nW(), c = r_ >= Number.MAX_SAFE_INTEGER ? 0 : ++r_, f = tW(n, r, l, t.schema);
    return {
      id: c,
      path: e,
      value: n,
      initialValue: r,
      meta: f,
      flags: { pendingUnmount: { [c]: !1 }, pendingReset: !1 },
      errors: l,
      setState: d
    };
  }
  const o = t.form.createPathState(e, {
    bails: t.bails,
    label: t.label,
    type: t.type,
    validate: t.validate,
    schema: t.schema
  }), s = R(() => o.errors);
  function a(l) {
    var u, c, f;
    "value" in l && (n.value = l.value), "errors" in l && ((u = t.form) === null || u === void 0 || u.setFieldError(b(e), l.errors)), "touched" in l && ((c = t.form) === null || c === void 0 || c.setFieldTouched(b(e), (f = l.touched) !== null && f !== void 0 ? f : !1)), "initialValue" in l && i(l.initialValue);
  }
  return {
    id: Array.isArray(o.id) ? o.id[o.id.length - 1] : o.id,
    path: e,
    value: n,
    errors: s,
    meta: o,
    initialValue: r,
    flags: o.__flags,
    setState: a
  };
}
function JG(e, t, n) {
  const r = _e(b(t));
  function i() {
    return n ? xn(n.initialValues.value, b(e), b(r)) : b(r);
  }
  function o(u) {
    if (!n) {
      r.value = u;
      return;
    }
    n.setFieldInitialValue(b(e), u, !0);
  }
  const s = R(i);
  if (!n)
    return {
      value: _e(i()),
      initialValue: s,
      setInitialValue: o
    };
  const a = eW(t, n, s, e);
  return n.stageInitialValue(b(e), a, !0), {
    value: R({
      get() {
        return xn(n.values, b(e));
      },
      set(u) {
        n.setFieldValue(b(e), u, !1);
      }
    }),
    initialValue: s,
    setInitialValue: o
  };
}
function eW(e, t, n, r) {
  return Co(e) ? b(e) : e !== void 0 ? e : xn(t.values, b(r), b(n));
}
function tW(e, t, n, r) {
  const i = R(() => {
    var s, a, l;
    return (l = (a = (s = Me(r)) === null || s === void 0 ? void 0 : s.describe) === null || a === void 0 ? void 0 : a.call(s).required) !== null && l !== void 0 ? l : !1;
  }), o = vs({
    touched: !1,
    pending: !1,
    valid: !0,
    required: i,
    validated: !!b(n).length,
    initialValue: R(() => b(t)),
    dirty: R(() => !pn(b(e), b(t)))
  });
  return Mt(n, (s) => {
    o.valid = !s.length;
  }, {
    immediate: !0,
    flush: "sync"
  }), o;
}
function nW() {
  const e = _e([]);
  return {
    errors: e,
    setErrors: (t) => {
      e.value = f0(t);
    }
  };
}
const Ka = {}, Ya = {}, Qa = "vee-validate-inspector", En = {
  error: 12405579,
  success: 448379,
  unknown: 5522283,
  white: 16777215,
  black: 0,
  blue: 218007,
  purple: 12157168,
  orange: 16099682,
  gray: 12304330
};
let Nt = null, oi;
function Yk(e) {
  process.env.NODE_ENV !== "production" && zq({
    id: "vee-validate-devtools-plugin",
    label: "VeeValidate Plugin",
    packageName: "vee-validate",
    homepage: "https://vee-validate.logaretm.com/v4",
    app: e,
    logo: "https://vee-validate.logaretm.com/v4/logo.png"
  }, (t) => {
    oi = t, t.addInspector({
      id: Qa,
      icon: "rule",
      label: "vee-validate",
      noSelectionText: "Select a vee-validate node to inspect",
      actions: [
        {
          icon: "done_outline",
          tooltip: "Validate selected item",
          action: async () => {
            if (!Nt) {
              console.error("There is not a valid selected vee-validate node or component");
              return;
            }
            if (Nt.type === "field") {
              await Nt.field.validate();
              return;
            }
            if (Nt.type === "form") {
              await Nt.form.validate();
              return;
            }
            Nt.type === "pathState" && await Nt.form.validateField(Nt.state.path);
          }
        },
        {
          icon: "delete_sweep",
          tooltip: "Clear validation state of the selected item",
          action: () => {
            if (!Nt) {
              console.error("There is not a valid selected vee-validate node or component");
              return;
            }
            if (Nt.type === "field") {
              Nt.field.resetField();
              return;
            }
            Nt.type === "form" && Nt.form.resetForm(), Nt.type === "pathState" && Nt.form.resetField(Nt.state.path);
          }
        }
      ]
    }), t.on.getInspectorTree((n) => {
      if (n.inspectorId !== Qa)
        return;
      const r = Object.values(Ka), i = Object.values(Ya);
      n.rootNodes = [
        ...r.map(oW),
        ...i.map((o) => aW(o))
      ];
    }), t.on.getInspectorState((n) => {
      if (n.inspectorId !== Qa)
        return;
      const { form: r, field: i, state: o, type: s } = lW(n.nodeId);
      if (t.unhighlightElement(), r && s === "form") {
        n.state = uW(r), Nt = { type: "form", form: r }, t.highlightElement(r._vm);
        return;
      }
      if (o && s === "pathState" && r) {
        n.state = i_(o), Nt = { type: "pathState", state: o, form: r };
        return;
      }
      if (i && s === "field") {
        n.state = i_({
          errors: i.errors.value,
          dirty: i.meta.dirty,
          valid: i.meta.valid,
          touched: i.meta.touched,
          value: i.value.value,
          initialValue: i.meta.initialValue
        }), Nt = { field: i, type: "field" }, t.highlightElement(i._vm);
        return;
      }
      Nt = null, t.unhighlightElement();
    });
  });
}
const Gs = LG(() => {
  setTimeout(async () => {
    await Ft(), oi == null || oi.sendInspectorState(Qa), oi == null || oi.sendInspectorTree(Qa);
  }, 100);
}, 100);
function rW(e) {
  const t = jn();
  if (!oi) {
    const n = t == null ? void 0 : t.appContext.app;
    if (!n)
      return;
    Yk(n);
  }
  Ka[e.formId] = Object.assign({}, e), Ka[e.formId]._vm = t, Zs(() => {
    delete Ka[e.formId], Gs();
  }), Gs();
}
function iW(e) {
  const t = jn();
  if (!oi) {
    const n = t == null ? void 0 : t.appContext.app;
    if (!n)
      return;
    Yk(n);
  }
  Ya[e.id] = Object.assign({}, e), Ya[e.id]._vm = t, Zs(() => {
    delete Ya[e.id], Gs();
  }), Gs();
}
function oW(e) {
  const { textColor: t, bgColor: n } = Zk(e.meta.value.valid), r = {};
  Object.values(e.getAllPathStates()).forEach((s) => {
    Mr(r, Me(s.path), sW(s, e));
  });
  function i(s, a = []) {
    const l = [...a].pop();
    return "id" in s ? Object.assign(Object.assign({}, s), { label: l || s.label }) : Yi(s) ? {
      id: `${a.join(".")}`,
      label: l || "",
      children: Object.keys(s).map((u) => i(s[u], [...a, u]))
    } : Array.isArray(s) ? {
      id: `${a.join(".")}`,
      label: `${l}[]`,
      children: s.map((u, c) => i(u, [...a, String(c)]))
    } : { id: "", label: "", children: [] };
  }
  const { children: o } = i(r);
  return {
    id: h1(e),
    label: e.name,
    children: o,
    tags: [
      {
        label: "Form",
        textColor: t,
        backgroundColor: n
      },
      {
        label: `${e.getAllPathStates().length} fields`,
        textColor: En.white,
        backgroundColor: En.unknown
      }
    ]
  };
}
function sW(e, t) {
  return {
    id: h1(t, e),
    label: Me(e.path),
    tags: Qk(e.multiple, e.fieldsCount, e.type, e.valid, t)
  };
}
function aW(e, t) {
  return {
    id: h1(t, e),
    label: b(e.name),
    tags: Qk(!1, 1, e.type, e.meta.valid, t)
  };
}
function Qk(e, t, n, r, i) {
  const { textColor: o, bgColor: s } = Zk(r);
  return [
    e ? void 0 : {
      label: "Field",
      textColor: o,
      backgroundColor: s
    },
    i ? void 0 : {
      label: "Standalone",
      textColor: En.black,
      backgroundColor: En.gray
    },
    n === "checkbox" ? {
      label: "Checkbox",
      textColor: En.white,
      backgroundColor: En.blue
    } : void 0,
    n === "radio" ? {
      label: "Radio",
      textColor: En.white,
      backgroundColor: En.purple
    } : void 0,
    e ? {
      label: "Multiple",
      textColor: En.black,
      backgroundColor: En.orange
    } : void 0
  ].filter(Boolean);
}
function h1(e, t) {
  const n = t ? "path" in t ? "pathState" : "field" : "form", r = t ? "path" in t ? t == null ? void 0 : t.path : Me(t == null ? void 0 : t.name) : "", i = { f: e == null ? void 0 : e.formId, ff: (t == null ? void 0 : t.id) || r, type: n };
  return btoa(encodeURIComponent(JSON.stringify(i)));
}
function lW(e) {
  try {
    const t = JSON.parse(decodeURIComponent(atob(e))), n = Ka[t.f];
    if (!n && t.ff) {
      const i = Ya[t.ff];
      return i ? {
        type: t.type,
        field: i
      } : {};
    }
    if (!n)
      return {};
    const r = n.getPathState(t.ff);
    return {
      type: t.type,
      form: n,
      state: r
    };
  } catch {
  }
  return {};
}
function i_(e) {
  return {
    "Field state": [
      { key: "errors", value: e.errors },
      {
        key: "initialValue",
        value: e.initialValue
      },
      {
        key: "currentValue",
        value: e.value
      },
      {
        key: "touched",
        value: e.touched
      },
      {
        key: "dirty",
        value: e.dirty
      },
      {
        key: "valid",
        value: e.valid
      }
    ]
  };
}
function uW(e) {
  const { errorBag: t, meta: n, values: r, isSubmitting: i, isValidating: o, submitCount: s } = e;
  return {
    "Form state": [
      {
        key: "submitCount",
        value: s.value
      },
      {
        key: "isSubmitting",
        value: i.value
      },
      {
        key: "isValidating",
        value: o.value
      },
      {
        key: "touched",
        value: n.value.touched
      },
      {
        key: "dirty",
        value: n.value.dirty
      },
      {
        key: "valid",
        value: n.value.valid
      },
      {
        key: "initialValues",
        value: n.value.initialValues
      },
      {
        key: "currentValues",
        value: r
      },
      {
        key: "errors",
        value: _n(t.value).reduce((a, l) => {
          var u;
          const c = (u = t.value[l]) === null || u === void 0 ? void 0 : u[0];
          return c && (a[l] = c), a;
        }, {})
      }
    ]
  };
}
function Zk(e) {
  return {
    bgColor: e ? En.success : En.error,
    textColor: e ? En.black : En.white
  };
}
function cW(e, t, n) {
  return tu(n == null ? void 0 : n.type) ? dW(e, t, n) : Xk(e, t, n);
}
function Xk(e, t, n) {
  const { initialValue: r, validateOnMount: i, bails: o, type: s, checkedValue: a, label: l, validateOnValueUpdate: u, uncheckedValue: c, controlled: f, keepValueOnUnmount: d, syncVModel: p, form: h } = fW(n), m = f ? Uk(f1) : void 0, g = h || m, y = R(() => xa(Me(e))), _ = R(() => {
    if (Me(g == null ? void 0 : g.schema))
      return;
    const ge = b(t);
    return Rf(ge) || ur(ge) || Zt(ge) || Array.isArray(ge) ? ge : qk(ge);
  }), E = !Zt(_.value) && ur(Me(t)), { id: v, value: M, initialValue: k, meta: T, setState: U, errors: C, flags: z } = XG(y, {
    modelValue: r,
    form: g,
    bails: o,
    label: l,
    type: s,
    validate: _.value ? ne : void 0,
    schema: E ? t : void 0
  }), H = R(() => C.value[0]);
  p && pW({
    value: M,
    prop: p,
    handleChange: w,
    shouldValidate: () => u && !z.pendingReset
  });
  const j = (Y, ge = !1) => {
    T.touched = !0, ge && Q();
  };
  async function V(Y) {
    var ge, me;
    if (g != null && g.validateSchema) {
      const { results: xe } = await g.validateSchema(Y);
      return (ge = xe[Me(y)]) !== null && ge !== void 0 ? ge : { valid: !0, errors: [] };
    }
    return _.value ? Gk(M.value, _.value, {
      name: Me(y),
      label: Me(l),
      values: (me = g == null ? void 0 : g.values) !== null && me !== void 0 ? me : {},
      bails: o
    }) : { valid: !0, errors: [] };
  }
  const Q = c0(async () => (T.pending = !0, T.validated = !0, V("validated-only")), (Y) => (z.pendingUnmount[P.id] || (U({ errors: Y.errors }), T.pending = !1, T.valid = Y.valid), Y)), le = c0(async () => V("silent"), (Y) => (T.valid = Y.valid, Y));
  function ne(Y) {
    return (Y == null ? void 0 : Y.mode) === "silent" ? le() : Q();
  }
  function w(Y, ge = !0) {
    const me = Lf(Y);
    se(me, ge);
  }
  Jn(() => {
    if (i)
      return Q();
    (!g || !g.validateSchema) && le();
  });
  function O(Y) {
    T.touched = Y;
  }
  function q(Y) {
    var ge;
    const me = Y && "value" in Y ? Y.value : k.value;
    U({
      value: nt(me),
      initialValue: nt(me),
      touched: (ge = Y == null ? void 0 : Y.touched) !== null && ge !== void 0 ? ge : !1,
      errors: (Y == null ? void 0 : Y.errors) || []
    }), T.pending = !1, T.validated = !1, le();
  }
  const X = jn();
  function se(Y, ge = !0) {
    M.value = X && p ? BG(Y, X.props.modelModifiers) : Y, (ge ? Q : le)();
  }
  function fe(Y) {
    U({ errors: Array.isArray(Y) ? Y : [Y] });
  }
  const Se = R({
    get() {
      return M.value;
    },
    set(Y) {
      se(Y, u);
    }
  }), P = {
    id: v,
    name: y,
    label: l,
    value: Se,
    meta: T,
    errors: C,
    errorMessage: H,
    type: s,
    checkedValue: a,
    uncheckedValue: c,
    bails: o,
    keepValueOnUnmount: d,
    resetField: q,
    handleReset: () => q(),
    validate: ne,
    handleChange: w,
    handleBlur: j,
    setState: U,
    setTouched: O,
    setErrors: fe,
    setValue: se
  };
  if (zi(SG, P), Co(t) && typeof b(t) != "function" && Mt(t, (Y, ge) => {
    pn(Y, ge) || (T.validated ? Q() : le());
  }, {
    deep: !0
  }), process.env.NODE_ENV !== "production" && (P._vm = jn(), Mt(() => Object.assign(Object.assign({ errors: C.value }, T), { value: M.value }), Gs, {
    deep: !0
  }), g || iW(P)), !g)
    return P;
  const ie = R(() => {
    const Y = _.value;
    return !Y || Zt(Y) || Rf(Y) || ur(Y) || Array.isArray(Y) ? {} : Object.keys(Y).reduce((ge, me) => {
      const xe = UG(Y[me]).map((Ve) => Ve.__locatorRef).reduce((Ve, qe) => {
        const ot = xn(g.values, qe) || g.values[qe];
        return ot !== void 0 && (Ve[qe] = ot), Ve;
      }, {});
      return Object.assign(ge, xe), ge;
    }, {});
  });
  return Mt(ie, (Y, ge) => {
    if (!Object.keys(Y).length)
      return;
    !pn(Y, ge) && (T.validated ? Q() : le());
  }), Qs(() => {
    var Y;
    const ge = (Y = Me(P.keepValueOnUnmount)) !== null && Y !== void 0 ? Y : Me(g.keepValuesOnUnmount), me = Me(y);
    if (ge || !g || z.pendingUnmount[P.id]) {
      g == null || g.removePathState(me, v);
      return;
    }
    z.pendingUnmount[P.id] = !0;
    const xe = g.getPathState(me);
    if (Array.isArray(xe == null ? void 0 : xe.id) && (xe != null && xe.multiple) ? xe != null && xe.id.includes(P.id) : (xe == null ? void 0 : xe.id) === P.id) {
      if (xe != null && xe.multiple && Array.isArray(xe.value)) {
        const qe = xe.value.findIndex((ot) => pn(ot, Me(P.checkedValue)));
        if (qe > -1) {
          const ot = [...xe.value];
          ot.splice(qe, 1), g.setFieldValue(me, ot);
        }
        Array.isArray(xe.id) && xe.id.splice(xe.id.indexOf(P.id), 1);
      } else
        g.unsetPathValue(Me(y));
      g.removePathState(me, v);
    }
  }), P;
}
function fW(e) {
  const t = () => ({
    initialValue: void 0,
    validateOnMount: !1,
    bails: !0,
    label: void 0,
    validateOnValueUpdate: !0,
    keepValueOnUnmount: void 0,
    syncVModel: !1,
    controlled: !0
  }), n = !!(e != null && e.syncVModel), r = typeof (e == null ? void 0 : e.syncVModel) == "string" ? e.syncVModel : (e == null ? void 0 : e.modelPropName) || "modelValue", i = n && !("initialValue" in (e || {})) ? d0(jn(), r) : e == null ? void 0 : e.initialValue;
  if (!e)
    return Object.assign(Object.assign({}, t()), { initialValue: i });
  const o = "valueProp" in e ? e.valueProp : e.checkedValue, s = "standalone" in e ? !e.standalone : e.controlled, a = (e == null ? void 0 : e.modelPropName) || (e == null ? void 0 : e.syncVModel) || !1;
  return Object.assign(Object.assign(Object.assign({}, t()), e || {}), {
    initialValue: i,
    controlled: s ?? !0,
    checkedValue: o,
    syncVModel: a
  });
}
function dW(e, t, n) {
  const r = n != null && n.standalone ? void 0 : Uk(f1), i = n == null ? void 0 : n.checkedValue, o = n == null ? void 0 : n.uncheckedValue;
  function s(a) {
    const l = a.handleChange, u = R(() => {
      const f = Me(a.value), d = Me(i);
      return Array.isArray(f) ? f.findIndex((p) => pn(p, d)) >= 0 : pn(d, f);
    });
    function c(f, d = !0) {
      var p, h;
      if (u.value === ((p = f == null ? void 0 : f.target) === null || p === void 0 ? void 0 : p.checked)) {
        d && a.validate();
        return;
      }
      const m = Me(e), g = r == null ? void 0 : r.getPathState(m), y = Lf(f);
      let _ = (h = Me(i)) !== null && h !== void 0 ? h : y;
      r && (g != null && g.multiple) && g.type === "checkbox" ? _ = e_(xn(r.values, m) || [], _, void 0) : (n == null ? void 0 : n.type) === "checkbox" && (_ = e_(Me(a.value), _, Me(o))), l(_, d);
    }
    return Object.assign(Object.assign({}, a), {
      checked: u,
      checkedValue: i,
      uncheckedValue: o,
      handleChange: c
    });
  }
  return s(Xk(e, t, n));
}
function pW({ prop: e, value: t, handleChange: n, shouldValidate: r }) {
  const i = jn();
  if (!i || !e) {
    process.env.NODE_ENV !== "production" && console.warn("Failed to setup model events because `useField` was not called in setup.");
    return;
  }
  const o = typeof e == "string" ? e : "modelValue", s = `update:${o}`;
  o in i.props && (Mt(t, (a) => {
    pn(a, d0(i, o)) || i.emit(s, a);
  }), Mt(() => d0(i, o), (a) => {
    if (a === If && t.value === void 0)
      return;
    const l = a === If ? void 0 : a;
    pn(l, t.value) || n(l, r());
  }));
}
function d0(e, t) {
  if (e)
    return e.props[t];
}
const hW = /* @__PURE__ */ S({
  name: "Field",
  inheritAttrs: !1,
  props: {
    as: {
      type: [String, Object],
      default: void 0
    },
    name: {
      type: String,
      required: !0
    },
    rules: {
      type: [Object, String, Function],
      default: void 0
    },
    validateOnMount: {
      type: Boolean,
      default: !1
    },
    validateOnBlur: {
      type: Boolean,
      default: void 0
    },
    validateOnChange: {
      type: Boolean,
      default: void 0
    },
    validateOnInput: {
      type: Boolean,
      default: void 0
    },
    validateOnModelUpdate: {
      type: Boolean,
      default: void 0
    },
    bails: {
      type: Boolean,
      default: () => go().bails
    },
    label: {
      type: String,
      default: void 0
    },
    uncheckedValue: {
      type: null,
      default: void 0
    },
    modelValue: {
      type: null,
      default: If
    },
    modelModifiers: {
      type: null,
      default: () => ({})
    },
    "onUpdate:modelValue": {
      type: null,
      default: void 0
    },
    standalone: {
      type: Boolean,
      default: !1
    },
    keepValue: {
      type: Boolean,
      default: void 0
    }
  },
  setup(e, t) {
    const n = Mi(e, "rules"), r = Mi(e, "name"), i = Mi(e, "label"), o = Mi(e, "uncheckedValue"), s = Mi(e, "keepValue"), { errors: a, value: l, errorMessage: u, validate: c, handleChange: f, handleBlur: d, setTouched: p, resetField: h, handleReset: m, meta: g, checked: y, setErrors: _, setValue: E } = cW(r, n, {
      validateOnMount: e.validateOnMount,
      bails: e.bails,
      standalone: e.standalone,
      type: t.attrs.type,
      initialValue: mW(e, t),
      // Only for checkboxes and radio buttons
      checkedValue: t.attrs.value,
      uncheckedValue: o,
      label: i,
      validateOnValueUpdate: e.validateOnModelUpdate,
      keepValueOnUnmount: s,
      syncVModel: !0
    }), v = function(z, H = !0) {
      f(z, H);
    }, M = R(() => {
      const { validateOnInput: C, validateOnChange: z, validateOnBlur: H, validateOnModelUpdate: j } = gW(e);
      function V(w) {
        d(w, H), Zt(t.attrs.onBlur) && t.attrs.onBlur(w);
      }
      function Q(w) {
        v(w, C), Zt(t.attrs.onInput) && t.attrs.onInput(w);
      }
      function le(w) {
        v(w, z), Zt(t.attrs.onChange) && t.attrs.onChange(w);
      }
      const ne = {
        name: e.name,
        onBlur: V,
        onInput: Q,
        onChange: le
      };
      return ne["onUpdate:modelValue"] = (w) => v(w, j), ne;
    }), k = R(() => {
      const C = Object.assign({}, M.value);
      tu(t.attrs.type) && y && (C.checked = y.value);
      const z = o_(e, t);
      return RG(z, t.attrs) && (C.value = l.value), C;
    }), T = R(() => Object.assign(Object.assign({}, M.value), { modelValue: l.value }));
    function U() {
      return {
        field: k.value,
        componentField: T.value,
        value: l.value,
        meta: g,
        errors: a.value,
        errorMessage: u.value,
        validate: c,
        resetField: h,
        handleChange: v,
        handleInput: (C) => v(C, !1),
        handleReset: m,
        handleBlur: M.value.onBlur,
        setTouched: p,
        setErrors: _,
        setValue: E
      };
    }
    return t.expose({
      value: l,
      meta: g,
      errors: a,
      errorMessage: u,
      setErrors: _,
      setTouched: p,
      setValue: E,
      reset: h,
      validate: c,
      handleChange: f
    }), () => {
      const C = Nr(o_(e, t)), z = Vk(C, t, U);
      return C ? Fr(C, Object.assign(Object.assign({}, t.attrs), k.value), z) : z;
    };
  }
});
function o_(e, t) {
  let n = e.as || "";
  return !e.as && !t.slots.default && (n = "input"), n;
}
function gW(e) {
  var t, n, r, i;
  const { validateOnInput: o, validateOnChange: s, validateOnBlur: a, validateOnModelUpdate: l } = go();
  return {
    validateOnInput: (t = e.validateOnInput) !== null && t !== void 0 ? t : o,
    validateOnChange: (n = e.validateOnChange) !== null && n !== void 0 ? n : s,
    validateOnBlur: (r = e.validateOnBlur) !== null && r !== void 0 ? r : a,
    validateOnModelUpdate: (i = e.validateOnModelUpdate) !== null && i !== void 0 ? i : l
  };
}
function mW(e, t) {
  return tu(t.attrs.type) ? Qv(e, "modelValue") ? e.modelValue : void 0 : Qv(e, "modelValue") ? e.modelValue : t.attrs.value;
}
const rne = hW;
let bW = 0;
const $u = ["bails", "fieldsCount", "id", "multiple", "type", "validate"];
function Jk(e) {
  const t = (e == null ? void 0 : e.initialValues) || {}, n = Object.assign({}, Me(t)), r = b(e == null ? void 0 : e.validationSchema);
  return r && ur(r) && Zt(r.cast) ? nt(r.cast(n) || {}) : nt(n);
}
function yW(e) {
  var t;
  const n = bW++, r = (e == null ? void 0 : e.name) || "Form";
  let i = 0;
  const o = _e(!1), s = _e(!1), a = _e(0), l = [], u = vs(Jk(e)), c = _e([]), f = _e({}), d = _e({}), p = PG(() => {
    d.value = c.value.reduce((N, I) => (N[xa(Me(I.path))] = I, N), {});
  });
  function h(N, I) {
    const J = w(N);
    if (!J) {
      typeof N == "string" && (f.value[xa(N)] = f0(I));
      return;
    }
    if (typeof N == "string") {
      const D = xa(N);
      f.value[D] && delete f.value[D];
    }
    J.errors = f0(I), J.valid = !J.errors.length;
  }
  function m(N) {
    _n(N).forEach((I) => {
      h(I, N[I]);
    });
  }
  e != null && e.initialErrors && m(e.initialErrors);
  const g = R(() => {
    const N = c.value.reduce((I, J) => (J.errors.length && (I[Me(J.path)] = J.errors), I), {});
    return Object.assign(Object.assign({}, f.value), N);
  }), y = R(() => _n(g.value).reduce((N, I) => {
    const J = g.value[I];
    return J != null && J.length && (N[I] = J[0]), N;
  }, {})), _ = R(() => c.value.reduce((N, I) => (N[Me(I.path)] = { name: Me(I.path) || "", label: I.label || "" }, N), {})), E = R(() => c.value.reduce((N, I) => {
    var J;
    return N[Me(I.path)] = (J = I.bails) !== null && J !== void 0 ? J : !0, N;
  }, {})), v = Object.assign({}, (e == null ? void 0 : e.initialErrors) || {}), M = (t = e == null ? void 0 : e.keepValuesOnUnmount) !== null && t !== void 0 ? t : !1, { initialValues: k, originalInitialValues: T, setInitialValues: U } = _W(c, u, e), C = vW(c, u, T, y), z = R(() => c.value.reduce((N, I) => {
    const J = xn(u, Me(I.path));
    return Mr(N, Me(I.path), J), N;
  }, {})), H = e == null ? void 0 : e.validationSchema;
  function j(N, I) {
    var J, D;
    const Z = R(() => xn(k.value, Me(N))), ae = d.value[Me(N)], he = (I == null ? void 0 : I.type) === "checkbox" || (I == null ? void 0 : I.type) === "radio";
    if (ae && he) {
      ae.multiple = !0;
      const en = i++;
      return Array.isArray(ae.id) ? ae.id.push(en) : ae.id = [ae.id, en], ae.fieldsCount++, ae.__flags.pendingUnmount[en] = !1, ae;
    }
    const Ae = R(() => xn(u, Me(N))), He = Me(N), it = q.findIndex((en) => en === He);
    it !== -1 && q.splice(it, 1);
    const Ze = R(() => {
      var en, mr, br, aa;
      const to = Me(H);
      if (ur(to))
        return (mr = (en = to.describe) === null || en === void 0 ? void 0 : en.call(to, Me(N)).required) !== null && mr !== void 0 ? mr : !1;
      const gi = Me(I == null ? void 0 : I.schema);
      return ur(gi) && (aa = (br = gi.describe) === null || br === void 0 ? void 0 : br.call(gi).required) !== null && aa !== void 0 ? aa : !1;
    }), Rt = i++, _t = vs({
      id: Rt,
      path: N,
      touched: !1,
      pending: !1,
      valid: !0,
      validated: !!(!((J = v[He]) === null || J === void 0) && J.length),
      required: Ze,
      initialValue: Z,
      errors: I0([]),
      bails: (D = I == null ? void 0 : I.bails) !== null && D !== void 0 ? D : !1,
      label: I == null ? void 0 : I.label,
      type: (I == null ? void 0 : I.type) || "default",
      value: Ae,
      multiple: !1,
      __flags: {
        pendingUnmount: { [Rt]: !1 },
        pendingReset: !1
      },
      fieldsCount: 1,
      validate: I == null ? void 0 : I.validate,
      dirty: R(() => !pn(b(Ae), b(Z)))
    });
    return c.value.push(_t), d.value[He] = _t, p(), y.value[He] && !v[He] && Ft(() => {
      Ke(He, { mode: "silent" });
    }), Co(N) && Mt(N, (en) => {
      p();
      const mr = nt(Ae.value);
      d.value[en] = _t, Ft(() => {
        Mr(u, en, mr);
      });
    }), _t;
  }
  const V = t_(Xe, 5), Q = t_(Xe, 5), le = c0(async (N) => await (N === "silent" ? V() : Q()), (N, [I]) => {
    const J = _n(ge.errorBag.value), Z = [
      .../* @__PURE__ */ new Set([..._n(N.results), ...c.value.map((ae) => ae.path), ...J])
    ].sort().reduce((ae, he) => {
      var Ae;
      const He = he, it = w(He) || O(He), Ze = ((Ae = N.results[He]) === null || Ae === void 0 ? void 0 : Ae.errors) || [], Rt = Me(it == null ? void 0 : it.path) || He, _t = EW({ errors: Ze, valid: !Ze.length }, ae.results[Rt]);
      return ae.results[Rt] = _t, _t.valid || (ae.errors[Rt] = _t.errors[0]), it && f.value[Rt] && delete f.value[Rt], it ? (it.valid = _t.valid, I === "silent" || I === "validated-only" && !it.validated || h(it, _t.errors), ae) : (h(Rt, Ze), ae);
    }, {
      valid: N.valid,
      results: {},
      errors: {},
      source: N.source
    });
    return N.values && (Z.values = N.values, Z.source = N.source), _n(Z.results).forEach((ae) => {
      var he;
      const Ae = w(ae);
      Ae && I !== "silent" && (I === "validated-only" && !Ae.validated || h(Ae, (he = Z.results[ae]) === null || he === void 0 ? void 0 : he.errors));
    }), Z;
  });
  function ne(N) {
    c.value.forEach(N);
  }
  function w(N) {
    const I = typeof N == "string" ? xa(N) : N;
    return typeof I == "string" ? d.value[I] : I;
  }
  function O(N) {
    return c.value.filter((J) => N.startsWith(Me(J.path))).reduce((J, D) => J ? D.path.length > J.path.length ? D : J : D, void 0);
  }
  let q = [], X;
  function se(N) {
    return q.push(N), X || (X = Ft(() => {
      [...q].sort().reverse().forEach((J) => {
        Jv(u, J);
      }), q = [], X = null;
    })), X;
  }
  function fe(N) {
    return function(J, D) {
      return function(ae) {
        return ae instanceof Event && (ae.preventDefault(), ae.stopPropagation()), ne((he) => he.touched = !0), o.value = !0, a.value++, ee().then((he) => {
          const Ae = nt(u);
          if (he.valid && typeof J == "function") {
            const He = nt(z.value);
            let it = N ? He : Ae;
            return he.values && (it = he.source === "schema" ? he.values : Object.assign({}, it, he.values)), J(it, {
              evt: ae,
              controlledValues: He,
              setErrors: m,
              setFieldError: h,
              setTouched: Fe,
              setFieldTouched: ot,
              setValues: Ve,
              setFieldValue: me,
              resetForm: St,
              resetField: $t
            });
          }
          !he.valid && typeof D == "function" && D({
            values: Ae,
            evt: ae,
            errors: he.errors,
            results: he.results
          });
        }).then((he) => (o.value = !1, he), (he) => {
          throw o.value = !1, he;
        });
      };
    };
  }
  const P = fe(!1);
  P.withControlled = fe(!0);
  function ie(N, I) {
    const J = c.value.findIndex((Z) => Z.path === N && (Array.isArray(Z.id) ? Z.id.includes(I) : Z.id === I)), D = c.value[J];
    if (!(J === -1 || !D)) {
      if (Ft(() => {
        Ke(N, { mode: "silent", warn: !1 });
      }), D.multiple && D.fieldsCount && D.fieldsCount--, Array.isArray(D.id)) {
        const Z = D.id.indexOf(I);
        Z >= 0 && D.id.splice(Z, 1), delete D.__flags.pendingUnmount[I];
      }
      (!D.multiple || D.fieldsCount <= 0) && (c.value.splice(J, 1), Te(N), p(), delete d.value[N]);
    }
  }
  function Y(N) {
    _n(d.value).forEach((I) => {
      I.startsWith(N) && delete d.value[I];
    }), c.value = c.value.filter((I) => !I.path.startsWith(N)), Ft(() => {
      p();
    });
  }
  const ge = {
    name: r,
    formId: n,
    values: u,
    controlledValues: z,
    errorBag: g,
    errors: y,
    schema: H,
    submitCount: a,
    meta: C,
    isSubmitting: o,
    isValidating: s,
    fieldArrays: l,
    keepValuesOnUnmount: M,
    validateSchema: b(H) ? le : void 0,
    validate: ee,
    setFieldError: h,
    validateField: Ke,
    setFieldValue: me,
    setValues: Ve,
    setErrors: m,
    setFieldTouched: ot,
    setTouched: Fe,
    resetForm: St,
    resetField: $t,
    handleSubmit: P,
    useFieldModel: F,
    defineInputBinds: K,
    defineComponentBinds: ue,
    defineField: vt,
    stageInitialValue: we,
    unsetInitialValue: Te,
    setFieldInitialValue: ut,
    createPathState: j,
    getPathState: w,
    unsetPathValue: se,
    removePathState: ie,
    initialValues: k,
    getAllPathStates: () => c.value,
    destroyPath: Y,
    isFieldTouched: Ie,
    isFieldDirty: ct,
    isFieldValid: yt
  };
  function me(N, I, J = !0) {
    const D = nt(I), Z = typeof N == "string" ? N : N.path;
    w(Z) || j(Z), Mr(u, Z, D), J && Ke(Z);
  }
  function xe(N, I = !0) {
    _n(u).forEach((J) => {
      delete u[J];
    }), _n(N).forEach((J) => {
      me(J, N[J], !1);
    }), I && ee();
  }
  function Ve(N, I = !0) {
    Sl(u, N), l.forEach((J) => J && J.reset()), I && ee();
  }
  function qe(N, I) {
    const J = w(Me(N)) || j(N);
    return R({
      get() {
        return J.value;
      },
      set(D) {
        var Z;
        const ae = Me(N);
        me(ae, D, (Z = Me(I)) !== null && Z !== void 0 ? Z : !1);
      }
    });
  }
  function ot(N, I) {
    const J = w(N);
    J && (J.touched = I);
  }
  function Ie(N) {
    const I = w(N);
    return I ? I.touched : c.value.filter((J) => J.path.startsWith(N)).some((J) => J.touched);
  }
  function ct(N) {
    const I = w(N);
    return I ? I.dirty : c.value.filter((J) => J.path.startsWith(N)).some((J) => J.dirty);
  }
  function yt(N) {
    const I = w(N);
    return I ? I.valid : c.value.filter((J) => J.path.startsWith(N)).every((J) => J.valid);
  }
  function Fe(N) {
    if (typeof N == "boolean") {
      ne((I) => {
        I.touched = N;
      });
      return;
    }
    _n(N).forEach((I) => {
      ot(I, !!N[I]);
    });
  }
  function $t(N, I) {
    var J;
    const D = I && "value" in I ? I.value : xn(k.value, N), Z = w(N);
    Z && (Z.__flags.pendingReset = !0), ut(N, nt(D), !0), me(N, D, !1), ot(N, (J = I == null ? void 0 : I.touched) !== null && J !== void 0 ? J : !1), h(N, (I == null ? void 0 : I.errors) || []), Ft(() => {
      Z && (Z.__flags.pendingReset = !1);
    });
  }
  function St(N, I) {
    let J = nt(N != null && N.values ? N.values : T.value);
    J = I != null && I.force ? J : Sl(T.value, J), J = ur(H) && Zt(H.cast) ? H.cast(J) : J, U(J, { force: I == null ? void 0 : I.force }), ne((D) => {
      var Z;
      D.__flags.pendingReset = !0, D.validated = !1, D.touched = ((Z = N == null ? void 0 : N.touched) === null || Z === void 0 ? void 0 : Z[Me(D.path)]) || !1, me(Me(D.path), xn(J, Me(D.path)), !1), h(Me(D.path), void 0);
    }), I != null && I.force ? xe(J, !1) : Ve(J, !1), m((N == null ? void 0 : N.errors) || {}), a.value = (N == null ? void 0 : N.submitCount) || 0, Ft(() => {
      ee({ mode: "silent" }), ne((D) => {
        D.__flags.pendingReset = !1;
      });
    });
  }
  async function ee(N) {
    const I = (N == null ? void 0 : N.mode) || "force";
    if (I === "force" && ne((he) => he.validated = !0), ge.validateSchema)
      return ge.validateSchema(I);
    s.value = !0;
    const J = await Promise.all(c.value.map((he) => he.validate ? he.validate(N).then((Ae) => ({
      key: Me(he.path),
      valid: Ae.valid,
      errors: Ae.errors,
      value: Ae.value
    })) : Promise.resolve({
      key: Me(he.path),
      valid: !0,
      errors: [],
      value: void 0
    })));
    s.value = !1;
    const D = {}, Z = {}, ae = {};
    for (const he of J)
      D[he.key] = {
        valid: he.valid,
        errors: he.errors
      }, he.value && Mr(ae, he.key, he.value), he.errors.length && (Z[he.key] = he.errors[0]);
    return {
      valid: J.every((he) => he.valid),
      results: D,
      errors: Z,
      values: ae,
      source: "fields"
    };
  }
  async function Ke(N, I) {
    var J;
    const D = w(N);
    if (D && (I == null ? void 0 : I.mode) !== "silent" && (D.validated = !0), H) {
      const { results: ae } = await le((I == null ? void 0 : I.mode) || "validated-only");
      return ae[N] || { errors: [], valid: !0 };
    }
    return D != null && D.validate ? D.validate(I) : (!D && ((J = I == null ? void 0 : I.warn) !== null && J !== void 0 ? J : !0) && process.env.NODE_ENV !== "production" && yM(`field with path ${N} was not found`), Promise.resolve({ errors: [], valid: !0 }));
  }
  function Te(N) {
    Jv(k.value, N);
  }
  function we(N, I, J = !1) {
    ut(N, I), Mr(u, N, I), J && !(e != null && e.initialValues) && Mr(T.value, N, nt(I));
  }
  function ut(N, I, J = !1) {
    Mr(k.value, N, nt(I)), J && Mr(T.value, N, nt(I));
  }
  async function Xe() {
    const N = b(H);
    if (!N)
      return { valid: !0, results: {}, errors: {}, source: "none" };
    s.value = !0;
    const I = Rf(N) || ur(N) ? await QG(N, u) : await ZG(N, u, {
      names: _.value,
      bailsMap: E.value
    });
    return s.value = !1, I;
  }
  const Ct = P((N, { evt: I }) => {
    jk(I) && I.target.submit();
  });
  Jn(() => {
    if (e != null && e.initialErrors && m(e.initialErrors), e != null && e.initialTouched && Fe(e.initialTouched), e != null && e.validateOnMount) {
      ee();
      return;
    }
    ge.validateSchema && ge.validateSchema("silent");
  }), Co(H) && Mt(H, () => {
    var N;
    (N = ge.validateSchema) === null || N === void 0 || N.call(ge, "validated-only");
  }), zi(f1, ge), process.env.NODE_ENV !== "production" && (rW(ge), Mt(() => Object.assign(Object.assign({ errors: g.value }, C.value), { values: u, isSubmitting: o.value, isValidating: s.value, submitCount: a.value }), Gs, {
    deep: !0
  }));
  function vt(N, I) {
    const J = Zt(I) || I == null ? void 0 : I.label, D = w(Me(N)) || j(N, { label: J }), Z = () => Zt(I) ? I(Pu(D, $u)) : I || {};
    function ae() {
      var Ze;
      D.touched = !0, ((Ze = Z().validateOnBlur) !== null && Ze !== void 0 ? Ze : go().validateOnBlur) && Ke(Me(D.path));
    }
    function he() {
      var Ze;
      ((Ze = Z().validateOnInput) !== null && Ze !== void 0 ? Ze : go().validateOnInput) && Ft(() => {
        Ke(Me(D.path));
      });
    }
    function Ae() {
      var Ze;
      ((Ze = Z().validateOnChange) !== null && Ze !== void 0 ? Ze : go().validateOnChange) && Ft(() => {
        Ke(Me(D.path));
      });
    }
    const He = R(() => {
      const Ze = {
        onChange: Ae,
        onInput: he,
        onBlur: ae
      };
      return Zt(I) ? Object.assign(Object.assign({}, Ze), I(Pu(D, $u)).props || {}) : I != null && I.props ? Object.assign(Object.assign({}, Ze), I.props(Pu(D, $u))) : Ze;
    });
    return [qe(N, () => {
      var Ze, Rt, _t;
      return (_t = (Ze = Z().validateOnModelUpdate) !== null && Ze !== void 0 ? Ze : (Rt = go()) === null || Rt === void 0 ? void 0 : Rt.validateOnModelUpdate) !== null && _t !== void 0 ? _t : !0;
    }), He];
  }
  function F(N) {
    return Array.isArray(N) ? N.map((I) => qe(I, !0)) : qe(N);
  }
  function K(N, I) {
    const [J, D] = vt(N, I);
    function Z() {
      D.value.onBlur();
    }
    function ae(Ae) {
      const He = Lf(Ae);
      me(Me(N), He, !1), D.value.onInput();
    }
    function he(Ae) {
      const He = Lf(Ae);
      me(Me(N), He, !1), D.value.onChange();
    }
    return R(() => Object.assign(Object.assign({}, D.value), {
      onBlur: Z,
      onInput: ae,
      onChange: he,
      value: J.value
    }));
  }
  function ue(N, I) {
    const [J, D] = vt(N, I), Z = w(Me(N));
    function ae(he) {
      J.value = he;
    }
    return R(() => {
      const he = Zt(I) ? I(Pu(Z, $u)) : I || {};
      return Object.assign({ [he.model || "modelValue"]: J.value, [`onUpdate:${he.model || "modelValue"}`]: ae }, D.value);
    });
  }
  const ve = Object.assign(Object.assign({}, ge), { values: Zf(u), handleReset: () => St(), submitForm: Ct });
  return zi(TG, ve), ve;
}
function vW(e, t, n, r) {
  const i = {
    touched: "some",
    pending: "some",
    valid: "every"
  }, o = R(() => !pn(t, b(n)));
  function s() {
    const l = e.value;
    return _n(i).reduce((u, c) => {
      const f = i[c];
      return u[c] = l[f]((d) => d[c]), u;
    }, {});
  }
  const a = vs(s());
  return lr(() => {
    const l = s();
    a.touched = l.touched, a.valid = l.valid, a.pending = l.pending;
  }), R(() => Object.assign(Object.assign({ initialValues: b(n) }, a), { valid: a.valid && !_n(r.value).length, dirty: o.value }));
}
function _W(e, t, n) {
  const r = Jk(n), i = _e(r), o = _e(nt(r));
  function s(a, l) {
    l != null && l.force ? (i.value = nt(a), o.value = nt(a)) : (i.value = Sl(nt(i.value) || {}, nt(a)), o.value = Sl(nt(o.value) || {}, nt(a))), l != null && l.updateFields && e.value.forEach((u) => {
      if (u.touched)
        return;
      const f = xn(i.value, Me(u.path));
      Mr(t, Me(u.path), nt(f));
    });
  }
  return {
    initialValues: i,
    originalInitialValues: o,
    setInitialValues: s
  };
}
function EW(e, t) {
  return t ? {
    valid: e.valid && t.valid,
    errors: [...e.errors, ...t.errors]
  } : e;
}
const wW = /* @__PURE__ */ S({
  name: "Form",
  inheritAttrs: !1,
  props: {
    as: {
      type: null,
      default: "form"
    },
    validationSchema: {
      type: Object,
      default: void 0
    },
    initialValues: {
      type: Object,
      default: void 0
    },
    initialErrors: {
      type: Object,
      default: void 0
    },
    initialTouched: {
      type: Object,
      default: void 0
    },
    validateOnMount: {
      type: Boolean,
      default: !1
    },
    onSubmit: {
      type: Function,
      default: void 0
    },
    onInvalidSubmit: {
      type: Function,
      default: void 0
    },
    keepValues: {
      type: Boolean,
      default: !1
    },
    name: {
      type: String,
      default: "Form"
    }
  },
  setup(e, t) {
    const n = Mi(e, "validationSchema"), r = Mi(e, "keepValues"), { errors: i, errorBag: o, values: s, meta: a, isSubmitting: l, isValidating: u, submitCount: c, controlledValues: f, validate: d, validateField: p, handleReset: h, resetForm: m, handleSubmit: g, setErrors: y, setFieldError: _, setFieldValue: E, setValues: v, setFieldTouched: M, setTouched: k, resetField: T } = yW({
      validationSchema: n.value ? n : void 0,
      initialValues: e.initialValues,
      initialErrors: e.initialErrors,
      initialTouched: e.initialTouched,
      validateOnMount: e.validateOnMount,
      keepValuesOnUnmount: r,
      name: e.name
    }), U = g((ne, { evt: w }) => {
      jk(w) && w.target.submit();
    }, e.onInvalidSubmit), C = e.onSubmit ? g(e.onSubmit, e.onInvalidSubmit) : U;
    function z(ne) {
      d1(ne) && ne.preventDefault(), h(), typeof t.attrs.onReset == "function" && t.attrs.onReset();
    }
    function H(ne, w) {
      return g(typeof ne == "function" && !w ? ne : w, e.onInvalidSubmit)(ne);
    }
    function j() {
      return nt(s);
    }
    function V() {
      return nt(a.value);
    }
    function Q() {
      return nt(i.value);
    }
    function le() {
      return {
        meta: a.value,
        errors: i.value,
        errorBag: o.value,
        values: s,
        isSubmitting: l.value,
        isValidating: u.value,
        submitCount: c.value,
        controlledValues: f.value,
        validate: d,
        validateField: p,
        handleSubmit: H,
        handleReset: h,
        submitForm: U,
        setErrors: y,
        setFieldError: _,
        setFieldValue: E,
        setValues: v,
        setFieldTouched: M,
        setTouched: k,
        resetForm: m,
        resetField: T,
        getValues: j,
        getMeta: V,
        getErrors: Q
      };
    }
    return t.expose({
      setFieldError: _,
      setErrors: y,
      setFieldValue: E,
      setValues: v,
      setFieldTouched: M,
      setTouched: k,
      resetForm: m,
      validate: d,
      validateField: p,
      resetField: T,
      getValues: j,
      getMeta: V,
      getErrors: Q,
      values: s,
      meta: a,
      errors: i
    }), function() {
      const w = e.as === "form" ? e.as : e.as ? Nr(e.as) : null, O = Vk(w, t, le);
      return w ? Fr(w, Object.assign(Object.assign(Object.assign({}, w === "form" ? {
        // Disables native validation as vee-validate will handle it.
        novalidate: !0
      } : {}), t.attrs), { onSubmit: C, onReset: z }), O) : O;
    };
  }
}), ine = wW, Dd = Symbol(), xW = /* @__PURE__ */ S({
  inheritAttrs: !1,
  __name: "FormItem",
  props: {
    class: {},
    errors: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      var s;
      return !((s = t.errors) != null && s.length);
    }), r = R(() => t.errors || []);
    zi(Dd, {
      errors: r,
      valid: n
    });
    const { class: i, ...o } = Z_();
    return (s, a) => (x(), W("div", oe({
      class: b(G)("space-y-2", t.class)
    }, o), [
      B(s.$slots, "default")
    ], 16));
  }
}), kW = /* @__PURE__ */ S({
  inheritAttrs: !1,
  __name: "FormLabel",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = Wr(Dd), n = t == null ? void 0 : t.valid, r = e;
    return (i, o) => (x(), L(b(r2), {
      class: ce(
        b(G)(
          "block text-left text-sm font-medium tracking-tight text-foreground",
          !b(n) && "text-destructive",
          r.class
        )
      )
    }, {
      default: A(() => [
        B(i.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), MW = /* @__PURE__ */ S({
  __name: "FormControl",
  setup(e) {
    const { valid: t } = Wr(Dd) || { valid: !0 };
    return (n, r) => (x(), L(b(QA), {
      "aria-invalid": !b(t)
    }, {
      default: A(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["aria-invalid"]));
  }
}), AW = /* @__PURE__ */ S({
  __name: "FormMessage",
  setup(e) {
    const t = Wr(Dd), n = t == null ? void 0 : t.errors;
    return (r, i) => (x(!0), W(Ge, null, ft(b(n), (o) => (x(), W("p", {
      key: o,
      class: "text-xs font-medium text-destructive"
    }, ze(o), 1))), 128));
  }
}), TW = /* @__PURE__ */ S({
  __name: "FormDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("p", {
      class: ce(b(G)("text-sm text-muted-foreground", t.class))
    }, [
      B(n.$slots, "default")
    ], 2));
  }
}), one = /* @__PURE__ */ S({
  __name: "HoverCard",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    openDelay: {},
    closeDelay: {}
  },
  setup(e) {
    const n = We(e);
    return (r, i) => (x(), L(b(ZA), Pe(Ue(b(n))), {
      default: A(() => [
        B(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), sne = /* @__PURE__ */ S({
  __name: "HoverCardTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(XA), Pe(Ue(t)), {
      default: A(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ane = /* @__PURE__ */ S({
  __name: "HoverCardContent",
  props: {
    forceMount: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(JA), null, {
      default: A(() => [
        $(b(eT), oe(b(r), {
          class: b(G)(
            "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
            t.class
          )
        }), {
          default: A(() => [
            B(i.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), SW = { class: "relative" }, CW = ["placeholder", "type", "pattern"], NW = { class: "absolute inset-y-0 right-0 flex items-center pr-3" }, e4 = /* @__PURE__ */ S({
  __name: "Input",
  props: {
    defaultValue: {},
    modelValue: {},
    type: { default: "text" },
    placeholder: {},
    pattern: { default: "" },
    class: {}
  },
  emits: ["blur", "focus", "input", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = H2(n, "modelValue", r, {
      passive: !0,
      defaultValue: n.defaultValue
    });
    return (o, s) => (x(), W("div", SW, [
      Ja(be("input", {
        placeholder: n.placeholder,
        "onUpdate:modelValue": s[0] || (s[0] = (a) => Co(i) ? i.value = a : null),
        type: o.type,
        pattern: o.pattern,
        class: ce(
          b(G)(
            "text-foreground-text ring-offset-background flex h-10 w-full rounded-md border border-input bg-layer-0 px-3 py-2 text-sm file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:italic placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
            n.class
          )
        ),
        onInput: s[1] || (s[1] = (a) => r("input", a)),
        onBlur: s[2] || (s[2] = (a) => r("blur", a)),
        onFocus: s[3] || (s[3] = (a) => r("focus", a))
      }, null, 42, CW), [
        [vM, b(i)]
      ]),
      be("div", NW, [
        B(o.$slots, "icon")
      ])
    ]));
  }
}), DW = /* @__PURE__ */ S({
  __name: "PhoneInput",
  props: {
    defaultValue: {},
    modelValue: {},
    errors: {}
  },
  emits: ["update:model-value", "blur", "focus"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R({
      get() {
        let { areaCode: o, prefix: s, lineNumber: a } = B1(Me(n.modelValue) || "");
        return (o == null ? void 0 : o.length) == 3 && (o = `${o}-`), `${o ?? ""}${(o == null ? void 0 : o.length) == 5 ? " " : ""}${s ?? ""}${(s == null ? void 0 : s.length) == 3 ? "-" : ""}${a ?? ""}`;
      },
      set(o) {
        const { areaCode: s, prefix: a, lineNumber: l } = B1(o);
        r(
          "update:model-value",
          `${s ? "+1" : ""}${s ?? ""}${a ?? ""}${l ?? ""}`
        );
      }
    });
    return (o, s) => (x(), L(b(e4), {
      modelValue: i.value,
      "onUpdate:modelValue": s[0] || (s[0] = (a) => i.value = a),
      "data-test-value": o.$props.modelValue,
      type: "tel",
      maxlength: "14",
      onFocus: s[1] || (s[1] = (a) => r("focus", a)),
      onBlur: s[2] || (s[2] = (a) => r("blur", a))
    }, null, 8, ["modelValue", "data-test-value"]));
  }
}), lne = /* @__PURE__ */ S({
  __name: "Label",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: r, ...i } = t;
      return i;
    });
    return (r, i) => (x(), L(b(r2), oe(n.value, {
      class: b(G)(
        "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
        t.class
      )
    }), {
      default: A(() => [
        B(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), une = /* @__PURE__ */ S({
  __name: "Menubar",
  props: {
    modelValue: {},
    defaultValue: {},
    dir: {},
    loop: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: s, ...a } = n;
      return a;
    }), o = Le(i, r);
    return (s, a) => (x(), L(b(tT), oe(b(o), {
      class: b(G)("flex h-10 items-center gap-x-1 rounded-md border bg-layer-0 p-1", n.class)
    }), {
      default: A(() => [
        B(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), cne = /* @__PURE__ */ S({
  __name: "MenubarItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: s, ...a } = n;
      return a;
    }), o = Le(i, r);
    return (s, a) => (x(), L(b(nT), oe(b(o), {
      class: b(G)(
        "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        s.inset && "pl-8",
        n.class
      ),
      onSelect: a[0] || (a[0] = (l) => r("select", l))
    }), {
      default: A(() => [
        B(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), fne = /* @__PURE__ */ S({
  __name: "MenubarContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: { default: 8 },
    align: { default: "start" },
    alignOffset: { default: -4 },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(i2), null, {
      default: A(() => [
        $(b(rT), oe(b(r), {
          class: b(G)(
            "z-50 min-w-48 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
            t.class
          )
        }), {
          default: A(() => [
            B(i.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), dne = /* @__PURE__ */ S({
  __name: "MenubarGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(iT), Pe(Ue(t)), {
      default: A(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), pne = /* @__PURE__ */ S({
  __name: "MenubarMenu",
  props: {
    value: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(oT), Pe(Ue(t)), {
      default: A(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), hne = /* @__PURE__ */ S({
  __name: "MenubarRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const i = Le(e, t);
    return (o, s) => (x(), L(b(sT), Pe(Ue(b(i))), {
      default: A(() => [
        B(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), OW = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, gne = /* @__PURE__ */ S({
  __name: "MenubarRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: s, ...a } = n;
      return a;
    }), o = Le(i, r);
    return (s, a) => (x(), L(b(aT), oe(b(o), {
      class: b(G)(
        "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      ),
      onSelect: a[0] || (a[0] = (l) => r("select", l))
    }), {
      default: A(() => [
        be("span", OW, [
          $(b(o2), null, {
            default: A(() => [
              $(b(Jf), { class: "h-2 w-2 fill-current" })
            ]),
            _: 1
          })
        ]),
        B(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), IW = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, mne = /* @__PURE__ */ S({
  __name: "MenubarCheckboxItem",
  props: {
    checked: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select", "update:checked"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: s, ...a } = n;
      return a;
    }), o = Le(i, r);
    return (s, a) => (x(), L(b(lT), oe(b(o), {
      class: b(G)(
        "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: A(() => [
        be("span", IW, [
          $(b(o2), null, {
            default: A(() => [
              $(b($l), { class: "h-4 w-4" })
            ]),
            _: 1
          })
        ]),
        B(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), bne = /* @__PURE__ */ S({
  __name: "MenubarSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(uT), oe({
      class: b(G)("-mx-1 my-1 h-px bg-muted", t.class)
    }, b(r)), null, 16, ["class"]));
  }
}), yne = /* @__PURE__ */ S({
  __name: "MenubarSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const i = Le(e, t);
    return (o, s) => (x(), L(b(cT), Pe(Ue(b(i))), {
      default: A(() => [
        B(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), vne = /* @__PURE__ */ S({
  __name: "MenubarSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: s, ...a } = n;
      return a;
    }), o = Le(i, r);
    return (s, a) => (x(), L(b(i2), null, {
      default: A(() => [
        $(b(fT), oe(b(o), {
          class: b(G)(
            "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
            n.class
          )
        }), {
          default: A(() => [
            B(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), _ne = /* @__PURE__ */ S({
  __name: "MenubarSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(dT), oe(b(r), {
      class: b(G)(
        "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
        i.inset && "pl-8",
        t.class
      )
    }), {
      default: A(() => [
        B(i.$slots, "default"),
        $(b(Xf), { class: "ml-auto h-4 w-4" })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Ene = /* @__PURE__ */ S({
  __name: "MenubarTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(pT), oe(b(r), {
      class: b(G)(
        "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
        t.class
      )
    }), {
      default: A(() => [
        B(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), wne = /* @__PURE__ */ S({
  __name: "MenubarShortcut",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("span", {
      class: ce(b(G)("ml-auto text-xs tracking-widest text-muted-foreground", t.class))
    }, [
      B(n.$slots, "default")
    ], 2));
  }
}), xne = /* @__PURE__ */ S({
  __name: "MenubarLabel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(hT), {
      class: ce(b(G)("px-2 py-1.5 text-sm font-semibold", n.inset && "pl-8", t.class))
    }, {
      default: A(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), RW = { class: "absolute left-0 top-full flex justify-center" }, LW = /* @__PURE__ */ S({
  __name: "NavigationMenuViewport",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), W("div", RW, [
      $(b(gT), oe(b(r), {
        class: b(G)(
          "origin-top-center relative mt-1.5 h-[--radix-navigation-menu-viewport-height] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[--radix-navigation-menu-viewport-width]",
          t.class
        )
      }), null, 16, ["class"])
    ]));
  }
}), kne = /* @__PURE__ */ S({
  __name: "NavigationMenu",
  props: {
    modelValue: {},
    defaultValue: {},
    dir: {},
    orientation: {},
    delayDuration: {},
    skipDelayDuration: {},
    disableClickTrigger: { type: Boolean },
    disableHoverTrigger: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: s, ...a } = n;
      return a;
    }), o = Le(i, r);
    return (s, a) => (x(), L(b(mT), oe(b(o), {
      class: b(G)("relative z-10 flex max-w-max flex-1 items-center justify-center", n.class)
    }), {
      default: A(() => [
        B(s.$slots, "default"),
        $(LW)
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Mne = /* @__PURE__ */ S({
  __name: "NavigationMenuList",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(bT), oe(b(r), {
      class: b(G)("group flex flex-1 list-none items-center justify-center gap-x-1", t.class)
    }), {
      default: A(() => [
        B(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Ane = /* @__PURE__ */ S({
  __name: "NavigationMenuItem",
  props: {
    value: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(yT), Pe(Ue(t)), {
      default: A(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Tne = /* @__PURE__ */ S({
  __name: "NavigationMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(vT), oe(b(r), {
      class: b(G)(b(BW)(), "group", t.class)
    }), {
      default: A(() => [
        B(i.$slots, "default"),
        $(b(Xs), {
          class: "relative top-px ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180",
          "aria-hidden": "true"
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Sne = /* @__PURE__ */ S({
  __name: "NavigationMenuContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: s, ...a } = n;
      return a;
    }), o = Le(i, r);
    return (s, a) => (x(), L(b(_T), oe(b(o), {
      class: b(G)(
        "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto",
        n.class
      )
    }), {
      default: A(() => [
        B(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Cne = /* @__PURE__ */ S({
  __name: "NavigationMenuLink",
  props: {
    active: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const i = Le(e, t);
    return (o, s) => (x(), L(b(ET), Pe(Ue(b(i))), {
      default: A(() => [
        B(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), BW = Js(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-layer-0 px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50"
), Nne = /* @__PURE__ */ S({
  __name: "PaginationEllipsis",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: r, ...i } = t;
      return i;
    });
    return (r, i) => (x(), L(b(wT), oe(n.value, {
      class: b(G)("flex h-9 w-9 items-center justify-center", t.class)
    }), {
      default: A(() => [
        B(r.$slots, "default", {}, () => [
          $(b(l2))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Dne = /* @__PURE__ */ S({
  __name: "PaginationFirst",
  props: {
    asChild: { type: Boolean, default: !0 },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: r, ...i } = t;
      return i;
    });
    return (r, i) => (x(), L(b(xT), Pe(Ue(n.value)), {
      default: A(() => [
        $(b(Kr), {
          class: ce(b(G)("h-10 w-10 p-0", t.class)),
          variant: "outline"
        }, {
          default: A(() => [
            B(r.$slots, "default", {}, () => [
              $(b(pS), { class: "h-4 w-4" })
            ])
          ]),
          _: 3
        }, 8, ["class"])
      ]),
      _: 3
    }, 16));
  }
}), One = /* @__PURE__ */ S({
  __name: "PaginationLast",
  props: {
    asChild: { type: Boolean, default: !0 },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: r, ...i } = t;
      return i;
    });
    return (r, i) => (x(), L(b(kT), Pe(Ue(n.value)), {
      default: A(() => [
        $(b(Kr), {
          class: ce(b(G)("h-10 w-10 p-0", t.class)),
          variant: "outline"
        }, {
          default: A(() => [
            B(r.$slots, "default", {}, () => [
              $(b(hS), { class: "h-4 w-4" })
            ])
          ]),
          _: 3
        }, 8, ["class"])
      ]),
      _: 3
    }, 16));
  }
}), Ine = /* @__PURE__ */ S({
  __name: "PaginationNext",
  props: {
    asChild: { type: Boolean, default: !0 },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: r, ...i } = t;
      return i;
    });
    return (r, i) => (x(), L(b(MT), Pe(Ue(n.value)), {
      default: A(() => [
        $(b(Kr), {
          class: ce(b(G)("h-10 w-10 p-0", t.class)),
          variant: "outline"
        }, {
          default: A(() => [
            B(r.$slots, "default", {}, () => [
              $(b(Xf), { class: "h-4 w-4" })
            ])
          ]),
          _: 3
        }, 8, ["class"])
      ]),
      _: 3
    }, 16));
  }
}), Rne = /* @__PURE__ */ S({
  __name: "PaginationPrev",
  props: {
    asChild: { type: Boolean, default: !0 },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: r, ...i } = t;
      return i;
    });
    return (r, i) => (x(), L(b(AT), Pe(Ue(n.value)), {
      default: A(() => [
        $(b(Kr), {
          class: ce(b(G)("h-10 w-10 p-0", t.class)),
          variant: "outline"
        }, {
          default: A(() => [
            B(r.$slots, "default", {}, () => [
              $(b(a2), { class: "h-4 w-4" })
            ])
          ]),
          _: 3
        }, 8, ["class"])
      ]),
      _: 3
    }, 16));
  }
}), Lne = /* @__PURE__ */ S({
  __name: "PinInput",
  props: {
    modelValue: { default: () => [] },
    defaultValue: {},
    placeholder: {},
    mask: { type: Boolean },
    otp: { type: Boolean },
    type: {},
    dir: {},
    name: {},
    disabled: { type: Boolean },
    required: { type: Boolean },
    id: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue", "complete"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: s, ...a } = n;
      return a;
    }), o = Le(i, r);
    return (s, a) => (x(), L(b(TT), oe(b(o), {
      class: b(G)("flex items-center gap-2", n.class)
    }), {
      default: A(() => [
        B(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Bne = /* @__PURE__ */ S({
  __name: "PinInputGroup",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(s2), oe(b(r), {
      class: b(G)("flex items-center", t.class)
    }), {
      default: A(() => [
        B(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Pne = /* @__PURE__ */ S({
  __name: "PinInputSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const n = We(e);
    return (r, i) => (x(), L(b(s2), Pe(Ue(b(n))), {
      default: A(() => [
        B(r.$slots, "default", {}, () => [
          $(b(gS))
        ])
      ]),
      _: 3
    }, 16));
  }
}), $ne = /* @__PURE__ */ S({
  __name: "PinInputInput",
  props: {
    index: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(ST), oe(b(r), {
      class: b(G)(
        "relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-center text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md focus:relative focus:z-10 focus:outline-none focus:ring-2 focus:ring-ring",
        t.class
      )
    }), null, 16, ["class"]));
  }
}), zne = /* @__PURE__ */ S({
  __name: "Progress",
  props: {
    modelValue: { default: 0 },
    max: {},
    getValueLabel: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    secondaryValue: { default: 0 },
    primaryColor: { default: "bg-primary" },
    secondaryColor: { default: "bg-indigo-200" }
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: r, ...i } = t;
      return i;
    });
    return (r, i) => (x(), L(b(CT), oe(n.value, {
      class: b(G)("relative h-4 w-full overflow-hidden rounded-full bg-secondary", t.class)
    }), {
      default: A(() => [
        $(b(L1), {
          class: ce(`${r.secondaryColor} absolute h-full w-full flex-1 rounded-full transition-all`),
          style: Rr(`transform: translateX(-${100 - (t.secondaryValue ?? 0)}%);`)
        }, null, 8, ["class", "style"]),
        $(b(L1), {
          class: ce(`${r.primaryColor} absolute h-full w-full flex-1 rounded-full transition-all`),
          style: Rr(`transform: translateX(-${100 - (t.modelValue ?? 0)}%);`)
        }, null, 8, ["class", "style"])
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), Fne = /* @__PURE__ */ S({
  __name: "RadioGroup",
  props: {
    modelValue: {},
    defaultValue: {},
    disabled: { type: Boolean },
    name: {},
    required: { type: Boolean },
    orientation: {},
    dir: {},
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: s, ...a } = n;
      return a;
    }), o = Le(i, r);
    return (s, a) => (x(), L(b(NT), oe({
      class: b(G)("grid gap-2", n.class)
    }, b(o)), {
      default: A(() => [
        B(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), jne = /* @__PURE__ */ S({
  __name: "RadioGroupItem",
  props: {
    id: {},
    value: {},
    disabled: { type: Boolean },
    required: { type: Boolean },
    name: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(DT), oe(b(r), {
      class: b(G)(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        t.class
      )
    }), {
      default: A(() => [
        $(b(OT), { class: "flex items-center justify-center" }, {
          default: A(() => [
            $(b(Jf), { class: "h-2.5 w-2.5 fill-current text-current" })
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), PW = ["data-active", "aria-checked", "data-state"], $W = ["data-state"], Une = /* @__PURE__ */ S({
  __name: "RadioGroupIndicator",
  props: {
    selected: { type: Boolean },
    size: { default: 24 }
  },
  emits: ["update:selected"],
  setup(e, { emit: t }) {
    const n = t;
    return (r, i) => (x(), W("button", {
      onClick: i[0] || (i[0] = K_((o) => n("update:selected", !r.selected), ["stop"])),
      class: "ring-offset-background aspect-square h-4 w-4 rounded-full border border-primary text-primary focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
      tabindex: "-1",
      "data-active": r.selected,
      role: "radio",
      type: "button",
      "aria-checked": r.selected,
      "data-state": r.selected ? "checked" : "unchecked",
      value: "value",
      "aria-label": "value"
    }, [
      be("span", {
        "data-state": r.selected ? "checked" : "unchecked",
        class: "flex items-center justify-center"
      }, [
        $(b(Jf), {
          size: r.size,
          class: ce(["h-2.5 w-2.5", {
            "fill-current text-current": r.selected,
            "text-transparent": !r.selected
          }])
        }, null, 8, ["size", "class"])
      ], 8, $W)
    ], 8, PW));
  }
}), zW = /* @__PURE__ */ S({
  __name: "ScrollBar",
  props: {
    orientation: { default: "vertical" },
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: r, ...i } = t;
      return i;
    });
    return (r, i) => (x(), L(b(IT), oe(n.value, {
      class: b(G)(
        "flex touch-none select-none transition-colors",
        r.orientation === "vertical" && "h-full w-2.5 border-l border-l-transparent p-px",
        r.orientation === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-px",
        t.class
      )
    }), {
      default: A(() => [
        $(b(RT), { class: "relative flex-1 rounded-full bg-border" })
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), Vne = /* @__PURE__ */ S({
  __name: "ScrollArea",
  props: {
    type: {},
    dir: {},
    scrollHideDelay: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: r, ...i } = t;
      return i;
    });
    return (r, i) => (x(), L(b(LT), oe(n.value, {
      class: b(G)("relative overflow-hidden", t.class)
    }), {
      default: A(() => [
        $(b(BT), { class: "h-full w-full rounded-[inherit]" }, {
          default: A(() => [
            B(r.$slots, "default")
          ]),
          _: 3
        }),
        $(zW),
        $(b(PT))
      ]),
      _: 3
    }, 16, ["class"]));
  }
});
var FW = Object.defineProperty, jW = (e, t, n) => t in e ? FW(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, un = (e, t, n) => jW(e, typeof t != "symbol" ? t + "" : t, n);
function UW(e) {
  if (typeof document > "u") return;
  let t = document.head || document.getElementsByTagName("head")[0], n = document.createElement("style");
  n.type = "text/css", t.appendChild(n), n.styleSheet ? n.styleSheet.cssText = e : n.appendChild(document.createTextNode(e));
}
UW(`:where([data-sonner-toaster][dir=ltr]),:where(html[dir=ltr]){--toast-icon-margin-start:-3px;--toast-icon-margin-end:4px;--toast-svg-margin-start:-1px;--toast-svg-margin-end:0px;--toast-button-margin-start:auto;--toast-button-margin-end:0;--toast-close-button-start:0;--toast-close-button-end:unset;--toast-close-button-transform:translate(-35%, -35%)}:where([data-sonner-toaster][dir=rtl]),:where(html[dir=rtl]){--toast-icon-margin-start:4px;--toast-icon-margin-end:-3px;--toast-svg-margin-start:0px;--toast-svg-margin-end:-1px;--toast-button-margin-start:0;--toast-button-margin-end:auto;--toast-close-button-start:unset;--toast-close-button-end:0;--toast-close-button-transform:translate(35%, -35%)}:where([data-sonner-toaster]){position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1:hsl(0, 0%, 99%);--gray2:hsl(0, 0%, 97.3%);--gray3:hsl(0, 0%, 95.1%);--gray4:hsl(0, 0%, 93%);--gray5:hsl(0, 0%, 90.9%);--gray6:hsl(0, 0%, 88.7%);--gray7:hsl(0, 0%, 85.8%);--gray8:hsl(0, 0%, 78%);--gray9:hsl(0, 0%, 56.1%);--gray10:hsl(0, 0%, 52.3%);--gray11:hsl(0, 0%, 43.5%);--gray12:hsl(0, 0%, 9%);--border-radius:8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:0;z-index:999999999}:where([data-sonner-toaster][data-x-position=right]){right:max(var(--offset),env(safe-area-inset-right))}:where([data-sonner-toaster][data-x-position=left]){left:max(var(--offset),env(safe-area-inset-left))}:where([data-sonner-toaster][data-x-position=center]){left:50%;transform:translateX(-50%)}:where([data-sonner-toaster][data-y-position=top]){top:max(var(--offset),env(safe-area-inset-top))}:where([data-sonner-toaster][data-y-position=bottom]){bottom:max(var(--offset),env(safe-area-inset-bottom))}:where([data-sonner-toast]){--y:translateY(100%);--lift-amount:calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);filter:blur(0);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:0;overflow-wrap:anywhere}:where([data-sonner-toast][data-styled=true]){padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px rgba(0,0,0,.1);width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}:where([data-sonner-toast]:focus-visible){box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}:where([data-sonner-toast][data-y-position=top]){top:0;--y:translateY(-100%);--lift:1;--lift-amount:calc(1 * var(--gap))}:where([data-sonner-toast][data-y-position=bottom]){bottom:0;--y:translateY(100%);--lift:-1;--lift-amount:calc(var(--lift) * var(--gap))}:where([data-sonner-toast]) :where([data-description]){font-weight:400;line-height:1.4;color:inherit}:where([data-sonner-toast]) :where([data-title]){font-weight:500;line-height:1.5;color:inherit}:where([data-sonner-toast]) :where([data-icon]){display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}:where([data-sonner-toast][data-promise=true]) :where([data-icon])>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}:where([data-sonner-toast]) :where([data-icon])>*{flex-shrink:0}:where([data-sonner-toast]) :where([data-icon]) svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}:where([data-sonner-toast]) :where([data-content]){display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;cursor:pointer;outline:0;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}:where([data-sonner-toast]) :where([data-button]):focus-visible{box-shadow:0 0 0 2px rgba(0,0,0,.4)}:where([data-sonner-toast]) :where([data-button]):first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}:where([data-sonner-toast]) :where([data-cancel]){color:var(--normal-text);background:rgba(0,0,0,.08)}:where([data-sonner-toast][data-theme=dark]) :where([data-cancel]){background:rgba(255,255,255,.3)}[data-sonner-toast] [data-close-button]{position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;background:var(--normal-bg);color:var(--normal-text);border:1px solid var(--normal-border);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast] [data-close-button]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}:where([data-sonner-toast]) :where([data-disabled=true]){cursor:not-allowed}[data-sonner-toast]:hover [data-close-button]:hover{background:var(--gray2);border-color:var(--gray5)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast]:hover [data-close-button]:hover{background:#000;border-color:#4c4c4c}:where([data-sonner-toast][data-swiping=true])::before{content:'';position:absolute;left:0;right:0;height:100%;z-index:-1}:where(
[data-sonner-toast][data-y-position=top][data-swiping=true]
)::before{bottom:50%;transform:scaleY(3) translateY(50%)}:where(
[data-sonner-toast][data-y-position=bottom][data-swiping=true]
)::before{top:50%;transform:scaleY(3) translateY(-50%)}:where([data-sonner-toast][data-swiping=false][data-removed=true])::before{content:'';position:absolute;inset:0;transform:scaleY(2)}:where([data-sonner-toast])::after{content:'';position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}:where([data-sonner-toast][data-mounted=true]){--y:translateY(0);opacity:1}:where([data-sonner-toast][data-expanded=false][data-front=false]){--scale:var(--toasts-before) * 0.05 + 1;--y:translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}:where([data-sonner-toast])>*{transition:opacity .4s}:where(
[data-sonner-toast][data-expanded=false][data-front=false][data-styled=true]
)>*{opacity:0}:where([data-sonner-toast][data-visible=false]){opacity:0;pointer-events:none}:where([data-sonner-toast][data-mounted=true][data-expanded=true]){--y:translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}:where(
[data-sonner-toast][data-removed=true][data-front=true][data-swipe-out=false]
){--y:translateY(calc(var(--lift) * -100%));opacity:0}:where(
[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=true]
){--y:translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}:where(
[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=false]
){--y:translateY(40%);opacity:0;transition:transform .5s,opacity .2s}:where([data-sonner-toast][data-removed=true][data-front=false])::before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount,0));transition:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation:swipe-out .2s ease-out forwards}@keyframes swipe-out{from{transform:translateY(calc(var(--lift) * var(--offset) + var(--swipe-amount)));opacity:1}to{transform:translateY(calc(var(--lift) * var(--offset) + var(--swipe-amount) + var(--lift) * -100%));opacity:0}}@media (max-width:600px){[data-sonner-toaster]{position:fixed;--mobile-offset:16px;right:var(--mobile-offset);left:var(--mobile-offset);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset)}[data-sonner-toaster][data-y-position=bottom]{bottom:20px}[data-sonner-toaster][data-y-position=top]{top:20px}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset);right:var(--mobile-offset);transform:none}}[data-sonner-toaster][data-theme=light]{--normal-bg:#fff;--normal-border:var(--gray4);--normal-text:var(--gray12);--success-bg:hsl(143, 85%, 96%);--success-border:hsl(145, 92%, 91%);--success-text:hsl(140, 100%, 27%);--info-bg:hsl(208, 100%, 97%);--info-border:hsl(221, 91%, 91%);--info-text:hsl(210, 92%, 45%);--warning-bg:hsl(49, 100%, 97%);--warning-border:hsl(49, 91%, 91%);--warning-text:hsl(31, 92%, 45%);--error-bg:hsl(359, 100%, 97%);--error-border:hsl(359, 100%, 94%);--error-text:hsl(360, 100%, 45%)}[data-sonner-toaster][data-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg:#fff;--normal-border:var(--gray3);--normal-text:var(--gray12)}[data-sonner-toaster][data-theme=dark]{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1);--success-bg:hsl(150, 100%, 6%);--success-border:hsl(147, 100%, 12%);--success-text:hsl(150, 86%, 65%);--info-bg:hsl(215, 100%, 6%);--info-border:hsl(223, 100%, 12%);--info-text:hsl(216, 87%, 65%);--warning-bg:hsl(64, 100%, 6%);--warning-border:hsl(60, 100%, 12%);--warning-text:hsl(46, 87%, 65%);--error-bg:hsl(358, 76%, 10%);--error-border:hsl(357, 89%, 16%);--error-text:hsl(358, 100%, 81%)}[data-rich-colors=true][data-sonner-toast][data-type=success]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size:16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:first-child{animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}100%{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}100%{opacity:.15}}@media (prefers-reduced-motion){.sonner-loading-bar,[data-sonner-toast],[data-sonner-toast]>*{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}`);
let p0 = 0;
class VW {
  constructor() {
    un(this, "subscribers"), un(this, "toasts"), un(this, "subscribe", (t) => (this.subscribers.push(t), () => {
      const n = this.subscribers.indexOf(t);
      this.subscribers.splice(n, 1);
    })), un(this, "publish", (t) => {
      this.subscribers.forEach((n) => n(t));
    }), un(this, "addToast", (t) => {
      this.publish(t), this.toasts = [...this.toasts, t];
    }), un(this, "create", (t) => {
      var n;
      const { message: r, ...i } = t, o = typeof t.id == "number" || t.id && ((n = t.id) == null ? void 0 : n.length) > 0 ? t.id : p0++, s = this.toasts.find((l) => l.id === o), a = t.dismissible === void 0 ? !0 : t.dismissible;
      return s ? this.toasts = this.toasts.map((l) => l.id === o ? (this.publish({ ...l, ...t, id: o, title: r }), {
        ...l,
        ...t,
        id: o,
        dismissible: a,
        title: r
      }) : l) : this.addToast({ title: r, ...i, dismissible: a, id: o }), o;
    }), un(this, "dismiss", (t) => (t || this.toasts.forEach((n) => {
      this.subscribers.forEach(
        (r) => r({ id: n.id, dismiss: !0 })
      );
    }), this.subscribers.forEach((n) => n({ id: t, dismiss: !0 })), t)), un(this, "message", (t, n) => this.create({ ...n, message: t, type: "default" })), un(this, "error", (t, n) => this.create({ ...n, type: "error", message: t })), un(this, "success", (t, n) => this.create({ ...n, type: "success", message: t })), un(this, "info", (t, n) => this.create({ ...n, type: "info", message: t })), un(this, "warning", (t, n) => this.create({ ...n, type: "warning", message: t })), un(this, "loading", (t, n) => this.create({ ...n, type: "loading", message: t })), un(this, "promise", (t, n) => {
      if (!n)
        return;
      let r;
      n.loading !== void 0 && (r = this.create({
        ...n,
        promise: t,
        type: "loading",
        message: n.loading,
        description: typeof n.description != "function" ? n.description : void 0
      }));
      const i = t instanceof Promise ? t : t();
      let o = r !== void 0, s;
      const a = i.then(async (u) => {
        if (s = ["resolve", u], qW(u) && !u.ok) {
          o = !1;
          const c = typeof n.error == "function" ? await n.error(
            `HTTP error! status: ${u.status}`
          ) : n.error, f = typeof n.description == "function" ? (
            // @ts-expect-error
            await n.description(`HTTP error! status: ${u.status}`)
          ) : n.description;
          this.create({ id: r, type: "error", message: c, description: f });
        } else if (n.success !== void 0) {
          o = !1;
          const c = typeof n.success == "function" ? await n.success(u) : n.success, f = typeof n.description == "function" ? await n.description(u) : n.description;
          this.create({ id: r, type: "success", message: c, description: f });
        }
      }).catch(async (u) => {
        if (s = ["reject", u], n.error !== void 0) {
          o = !1;
          const c = typeof n.error == "function" ? await n.error(u) : n.error, f = typeof n.description == "function" ? await n.description(
            u
          ) : n.description;
          this.create({ id: r, type: "error", message: c, description: f });
        }
      }).finally(() => {
        var u;
        o && (this.dismiss(r), r = void 0), (u = n.finally) == null || u.call(n);
      }), l = () => new Promise(
        (u, c) => a.then(
          () => s[0] === "reject" ? c(s[1]) : u(s[1])
        ).catch(c)
      );
      return typeof r != "string" && typeof r != "number" ? { unwrap: l } : Object.assign(r, { unwrap: l });
    }), un(this, "custom", (t, n) => {
      const r = (n == null ? void 0 : n.id) || p0++;
      return this.publish({ component: t, id: r, ...n }), r;
    }), this.subscribers = [], this.toasts = [];
  }
}
const Bn = new VW();
function HW(e, t) {
  const n = (t == null ? void 0 : t.id) || p0++;
  return Bn.create({
    message: e,
    id: n,
    type: "default",
    ...t
  }), n;
}
const qW = (e) => e && typeof e == "object" && "ok" in e && typeof e.ok == "boolean" && "status" in e && typeof e.status == "number", GW = HW, WW = () => Bn.toasts, Hne = Object.assign(
  GW,
  {
    success: Bn.success,
    info: Bn.info,
    warning: Bn.warning,
    error: Bn.error,
    custom: Bn.custom,
    message: Bn.message,
    promise: Bn.promise,
    dismiss: Bn.dismiss,
    loading: Bn.loading
  },
  {
    getHistory: WW
  }
);
function zu(e) {
  return e.label !== void 0;
}
function KW() {
  const e = _e(!1);
  return lr(() => {
    const t = () => {
      e.value = document.hidden;
    };
    return document.addEventListener("visibilitychange", t), () => window.removeEventListener("visibilitychange", t);
  }), {
    isDocumentHidden: e
  };
}
const YW = ["aria-live", "data-rich-colors", "data-styled", "data-mounted", "data-promise", "data-removed", "data-visible", "data-y-position", "data-x-position", "data-index", "data-front", "data-swiping", "data-dismissible", "data-type", "data-invert", "data-swipe-out", "data-expanded"], QW = ["aria-label", "data-disabled"], ZW = {
  key: 0,
  "data-icon": ""
}, XW = 4e3, JW = 20, eK = 200, tK = /* @__PURE__ */ S({
  __name: "Toast",
  props: {
    toast: {},
    toasts: {},
    index: {},
    expanded: { type: Boolean },
    invert: { type: Boolean },
    heights: {},
    gap: {},
    position: {},
    visibleToasts: {},
    expandByDefault: { type: Boolean },
    closeButton: { type: Boolean },
    interacting: { type: Boolean },
    style: {},
    cancelButtonStyle: {},
    actionButtonStyle: {},
    duration: {},
    class: {},
    unstyled: { type: Boolean },
    descriptionClass: {},
    loadingIcon: {},
    classes: {},
    icons: {},
    closeButtonAriaLabel: {},
    pauseWhenPageIsHidden: { type: Boolean },
    cn: { type: Function },
    defaultRichColors: { type: Boolean }
  },
  emits: ["update:heights", "removeToast"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = _e(!1), o = _e(!1), s = _e(!1), a = _e(!1), l = _e(0), u = _e(0), c = _e(null), f = _e(null), d = R(() => n.index === 0), p = R(() => n.index + 1 <= n.visibleToasts), h = R(() => n.toast.type), m = R(() => n.toast.dismissible !== !1), g = R(() => n.toast.class || ""), y = R(() => n.descriptionClass || ""), _ = n.toast.style || {}, E = R(
      () => n.heights.findIndex((P) => P.toastId === n.toast.id) || 0
    ), v = R(() => n.toast.closeButton ?? n.closeButton), M = R(
      () => n.toast.duration || n.duration || XW
    ), k = _e(0), T = _e(0), U = _e(0), C = _e(null), z = R(() => n.position.split("-")), H = R(() => z.value[0]), j = R(() => z.value[1]), V = R(() => typeof n.toast.title != "string"), Q = R(
      () => typeof n.toast.description != "string"
    ), le = R(() => n.heights.reduce((P, ie, Y) => Y >= E.value ? P : P + ie.height, 0)), ne = KW(), w = R(() => n.toast.invert || n.invert), O = R(() => h.value === "loading");
    Jn(() => {
      if (!i.value) return;
      const P = f.value, ie = P == null ? void 0 : P.style.height;
      P.style.height = "auto";
      const Y = P.getBoundingClientRect().height;
      P.style.height = ie, u.value = Y;
      let ge;
      n.heights.find(
        (me) => me.toastId === n.toast.id
      ) ? ge = n.heights.map(
        (me) => me.toastId === n.toast.id ? { ...me, height: Y } : me
      ) : ge = [
        {
          toastId: n.toast.id,
          height: Y,
          position: n.toast.position
        },
        ...n.heights
      ], r("update:heights", ge);
    });
    function q() {
      o.value = !0, l.value = T.value;
      const P = n.heights.filter(
        (ie) => ie.toastId !== n.toast.id
      );
      r("update:heights", P), setTimeout(() => {
        r("removeToast", n.toast);
      }, eK);
    }
    function X() {
      var P, ie;
      O.value || !m.value || (q(), (ie = (P = n.toast).onDismiss) == null || ie.call(P, n.toast));
    }
    function se(P) {
      O.value || !m.value || (c.value = /* @__PURE__ */ new Date(), l.value = T.value, P.target.setPointerCapture(P.pointerId), P.target.tagName !== "BUTTON" && (s.value = !0, C.value = { x: P.clientX, y: P.clientY }));
    }
    function fe() {
      var P, ie, Y, ge, me;
      if (a.value) return;
      C.value = null;
      const xe = Number(
        ((P = f.value) == null ? void 0 : P.style.getPropertyValue("--swipe-amount").replace("px", "")) || 0
      ), Ve = (/* @__PURE__ */ new Date()).getTime() - ((ie = c.value) == null ? void 0 : ie.getTime()), qe = Math.abs(xe) / Ve;
      if (Math.abs(xe) >= JW || qe > 0.11) {
        l.value = T.value, (ge = (Y = n.toast).onDismiss) == null || ge.call(Y, n.toast), q(), a.value = !0;
        return;
      }
      (me = f.value) == null || me.style.setProperty("--swipe-amount", "0px"), s.value = !1;
    }
    function Se(P) {
      var ie;
      if (!C.value || !m.value) return;
      const Y = P.clientY - C.value.y, ge = P.clientX - C.value.x, me = (z.value[0] === "top" ? Math.min : Math.max)(0, Y), xe = P.pointerType === "touch" ? 10 : 2;
      Math.abs(me) > xe ? (ie = f.value) == null || ie.style.setProperty("--swipe-amount", `${Y}px`) : Math.abs(ge) > xe && (C.value = null);
    }
    return lr(() => {
      T.value = E.value * (n == null ? void 0 : n.gap) + le.value;
    }), lr((P) => {
      if (n.toast.promise && h.value === "loading" || n.toast.duration === 1 / 0 || n.toast.type === "loading")
        return;
      let ie, Y = M.value;
      const ge = () => {
        if (U.value < k.value) {
          const xe = (/* @__PURE__ */ new Date()).getTime() - k.value;
          Y = Y - xe;
        }
        U.value = (/* @__PURE__ */ new Date()).getTime();
      }, me = () => {
        Y !== 1 / 0 && (k.value = (/* @__PURE__ */ new Date()).getTime(), ie = setTimeout(() => {
          var xe, Ve;
          (Ve = (xe = n.toast).onAutoClose) == null || Ve.call(xe, n.toast), q();
        }, Y));
      };
      n.expanded || n.interacting || n.pauseWhenPageIsHidden && ne ? ge() : me(), P(() => {
        clearTimeout(ie);
      });
    }), Mt(
      () => n.toast.delete,
      (P) => {
        P && q();
      }
    ), Jn(() => {
      if (f.value) {
        const P = f.value.getBoundingClientRect().height;
        u.value = P;
        const ie = [
          { toastId: n.toast.id, height: P, position: n.toast.position },
          ...n.heights
        ];
        r("update:heights", ie);
      }
      i.value = !0;
    }), Zs(() => {
      if (f.value) {
        const P = n.heights.filter(
          (ie) => ie.toastId !== n.toast.id
        );
        r("update:heights", P);
      }
    }), (P, ie) => {
      var Y, ge, me, xe, Ve, qe, ot, Ie, ct, yt, Fe, $t, St, ee, Ke, Te, we, ut, Xe, Ct, vt, F, K, ue;
      return x(), W("li", {
        ref_key: "toastRef",
        ref: f,
        "aria-live": P.toast.important ? "assertive" : "polite",
        "aria-atomic": "true",
        role: "status",
        tabindex: "0",
        "data-sonner-toast": "true",
        class: ce(P.cn(
          n.class,
          g.value,
          (Y = P.classes) == null ? void 0 : Y.toast,
          (ge = P.toast.classes) == null ? void 0 : ge.toast,
          // @ts-ignore
          (me = P.classes) == null ? void 0 : me[h.value],
          // @ts-ignore
          (Ve = (xe = P.toast) == null ? void 0 : xe.classes) == null ? void 0 : Ve[h.value]
        )),
        "data-rich-colors": P.toast.richColors ?? P.defaultRichColors,
        "data-styled": !(P.toast.component || (qe = P.toast) != null && qe.unstyled || P.unstyled),
        "data-mounted": i.value,
        "data-promise": !!P.toast.promise,
        "data-removed": o.value,
        "data-visible": p.value,
        "data-y-position": H.value,
        "data-x-position": j.value,
        "data-index": P.index,
        "data-front": d.value,
        "data-swiping": s.value,
        "data-dismissible": m.value,
        "data-type": h.value,
        "data-invert": w.value,
        "data-swipe-out": a.value,
        "data-expanded": !!(P.expanded || P.expandByDefault && i.value),
        style: Rr({
          "--index": P.index,
          "--toasts-before": P.index,
          "--z-index": P.toasts.length - P.index,
          "--offset": `${o.value ? l.value : T.value}px`,
          "--initial-height": P.expandByDefault ? "auto" : `${u.value}px`,
          ...P.style,
          ...b(_)
        }),
        onPointerdown: se,
        onPointerup: fe,
        onPointermove: Se
      }, [
        v.value && !P.toast.component ? (x(), W("button", {
          key: 0,
          "aria-label": P.closeButtonAriaLabel || "Close toast",
          "data-disabled": O.value,
          "data-close-button": "true",
          class: ce(P.cn((ot = P.classes) == null ? void 0 : ot.closeButton, (ct = (Ie = P.toast) == null ? void 0 : Ie.classes) == null ? void 0 : ct.closeButton)),
          onClick: X
        }, [
          (yt = P.icons) != null && yt.close ? (x(), L(Nr((Fe = P.icons) == null ? void 0 : Fe.close), { key: 0 })) : B(P.$slots, "close-icon", { key: 1 })
        ], 10, QW)) : Qe("", !0),
        P.toast.component ? (x(), L(Nr(P.toast.component), oe({ key: 1 }, P.toast.componentProps, { onCloseToast: X }), null, 16)) : (x(), W(Ge, { key: 2 }, [
          h.value !== "default" || P.toast.icon || P.toast.promise ? (x(), W("div", ZW, [
            (P.toast.promise || h.value === "loading") && !P.toast.icon ? B(P.$slots, "loading-icon", { key: 0 }) : Qe("", !0),
            P.toast.icon ? (x(), L(Nr(P.toast.icon), { key: 1 })) : (x(), W(Ge, { key: 2 }, [
              h.value === "success" ? B(P.$slots, "success-icon", { key: 0 }) : h.value === "error" ? B(P.$slots, "error-icon", { key: 1 }) : h.value === "warning" ? B(P.$slots, "warning-icon", { key: 2 }) : h.value === "info" ? B(P.$slots, "info-icon", { key: 3 }) : Qe("", !0)
            ], 64))
          ])) : Qe("", !0),
          be("div", {
            "data-content": "",
            class: ce(P.cn(($t = P.classes) == null ? void 0 : $t.content, (ee = (St = P.toast) == null ? void 0 : St.classes) == null ? void 0 : ee.content))
          }, [
            be("div", {
              "data-title": "",
              class: ce(P.cn((Ke = P.classes) == null ? void 0 : Ke.title, (Te = P.toast.classes) == null ? void 0 : Te.title))
            }, [
              V.value ? (x(), L(Nr(P.toast.title), Pe(oe({ key: 0 }, P.toast.componentProps)), null, 16)) : (x(), W(Ge, { key: 1 }, [
                Xt(ze(P.toast.title), 1)
              ], 64))
            ], 2),
            P.toast.description ? (x(), W("div", {
              key: 0,
              "data-description": "",
              class: ce(
                P.cn(
                  P.descriptionClass,
                  y.value,
                  (we = P.classes) == null ? void 0 : we.description,
                  (ut = P.toast.classes) == null ? void 0 : ut.description
                )
              )
            }, [
              Q.value ? (x(), L(Nr(P.toast.description), Pe(oe({ key: 0 }, P.toast.componentProps)), null, 16)) : (x(), W(Ge, { key: 1 }, [
                Xt(ze(P.toast.description), 1)
              ], 64))
            ], 2)) : Qe("", !0)
          ], 2),
          P.toast.cancel ? (x(), W("button", {
            key: 1,
            style: Rr(P.toast.cancelButtonStyle || P.cancelButtonStyle),
            class: ce(P.cn((Xe = P.classes) == null ? void 0 : Xe.cancelButton, (Ct = P.toast.classes) == null ? void 0 : Ct.cancelButton)),
            "data-button": "",
            "data-cancel": "",
            onClick: ie[0] || (ie[0] = (ve) => {
              var N, I;
              b(zu)(P.toast.cancel) && m.value && ((I = (N = P.toast.cancel).onClick) == null || I.call(N, ve), q());
            })
          }, ze(b(zu)(P.toast.cancel) ? (vt = P.toast.cancel) == null ? void 0 : vt.label : P.toast.cancel), 7)) : Qe("", !0),
          P.toast.action ? (x(), W("button", {
            key: 2,
            style: Rr(P.toast.actionButtonStyle || P.actionButtonStyle),
            class: ce(P.cn((F = P.classes) == null ? void 0 : F.actionButton, (K = P.toast.classes) == null ? void 0 : K.actionButton)),
            "data-button": "",
            "data-action": "",
            onClick: ie[1] || (ie[1] = (ve) => {
              var N, I;
              b(zu)(P.toast.action) && (ve.defaultPrevented || ((I = (N = P.toast.action).onClick) == null || I.call(N, ve), q()));
            })
          }, ze(b(zu)(P.toast.action) ? (ue = P.toast.action) == null ? void 0 : ue.label : P.toast.action), 7)) : Qe("", !0)
        ], 64))
      ], 46, YW);
    };
  }
}), nu = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [r, i] of t)
    n[r] = i;
  return n;
}, nK = {}, rK = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "12",
  height: "12",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stoke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function iK(e, t) {
  return x(), W("svg", rK, t[0] || (t[0] = [
    be("line", {
      x1: "18",
      y1: "6",
      x2: "6",
      y2: "18"
    }, null, -1),
    be("line", {
      x1: "6",
      y1: "6",
      x2: "18",
      y2: "18"
    }, null, -1)
  ]));
}
const oK = /* @__PURE__ */ nu(nK, [["render", iK]]), sK = ["data-visible"], aK = { class: "sonner-spinner" }, lK = /* @__PURE__ */ S({
  __name: "Loader",
  props: {
    visible: { type: Boolean }
  },
  setup(e) {
    const t = Array(12).fill(0);
    return (n, r) => (x(), W("div", {
      class: "sonner-loading-wrapper",
      "data-visible": n.visible
    }, [
      be("div", aK, [
        (x(!0), W(Ge, null, ft(b(t), (i) => (x(), W("div", {
          key: `spinner-bar-${i}`,
          class: "sonner-loading-bar"
        }))), 128))
      ])
    ], 8, sK));
  }
}), uK = {}, cK = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function fK(e, t) {
  return x(), W("svg", cK, t[0] || (t[0] = [
    be("path", {
      "fill-rule": "evenodd",
      d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
      "clip-rule": "evenodd"
    }, null, -1)
  ]));
}
const dK = /* @__PURE__ */ nu(uK, [["render", fK]]), pK = {}, hK = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function gK(e, t) {
  return x(), W("svg", hK, t[0] || (t[0] = [
    be("path", {
      "fill-rule": "evenodd",
      d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
      "clip-rule": "evenodd"
    }, null, -1)
  ]));
}
const mK = /* @__PURE__ */ nu(pK, [["render", gK]]), bK = {}, yK = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function vK(e, t) {
  return x(), W("svg", yK, t[0] || (t[0] = [
    be("path", {
      "fill-rule": "evenodd",
      d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
      "clip-rule": "evenodd"
    }, null, -1)
  ]));
}
const _K = /* @__PURE__ */ nu(bK, [["render", vK]]), EK = {}, wK = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function xK(e, t) {
  return x(), W("svg", wK, t[0] || (t[0] = [
    be("path", {
      "fill-rule": "evenodd",
      d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
      "clip-rule": "evenodd"
    }, null, -1)
  ]));
}
const kK = /* @__PURE__ */ nu(EK, [["render", xK]]), MK = ["aria-label"], AK = ["dir", "data-theme", "data-rich-colors", "data-y-position", "data-x-position"], TK = 3, s_ = "32px", SK = 356, CK = 14, NK = typeof window < "u" && typeof document < "u";
function DK(...e) {
  return e.filter(Boolean).join(" ");
}
const OK = /* @__PURE__ */ S({
  name: "Toaster",
  inheritAttrs: !1,
  __name: "Toaster",
  props: {
    invert: { type: Boolean, default: !1 },
    theme: { default: "light" },
    position: { default: "bottom-right" },
    hotkey: { default: () => ["altKey", "KeyT"] },
    richColors: { type: Boolean, default: !1 },
    expand: { type: Boolean, default: !1 },
    duration: {},
    gap: { default: CK },
    visibleToasts: { default: TK },
    closeButton: { type: Boolean, default: !1 },
    toastOptions: { default: () => ({}) },
    class: { default: "" },
    style: { default: () => ({}) },
    offset: { default: s_ },
    dir: { default: "auto" },
    icons: {},
    containerAriaLabel: { default: "Notifications" },
    pauseWhenPageIsHidden: { type: Boolean, default: !1 },
    cn: { type: Function, default: DK }
  },
  setup(e) {
    const t = e;
    function n() {
      if (typeof window > "u" || typeof document > "u") return "ltr";
      const _ = document.documentElement.getAttribute("dir");
      return _ === "auto" || !_ ? window.getComputedStyle(document.documentElement).direction : _;
    }
    const r = Z_(), i = _e([]), o = R(() => {
      const _ = i.value.filter((E) => E.position).map((E) => E.position);
      return _.length > 0 ? Array.from(new Set([t.position].concat(_))) : [t.position];
    }), s = _e([]), a = _e(!1), l = _e(!1), u = _e(
      t.theme !== "system" ? t.theme : typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"
    ), c = _e(null), f = _e(null), d = _e(!1), p = t.hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    function h(_) {
      var E;
      (E = i.value.find((v) => v.id === _.id)) != null && E.delete || Bn.dismiss(_.id), i.value = i.value.filter(({ id: v }) => v !== _.id);
    }
    function m(_) {
      var E, v;
      d.value && !((v = (E = _.currentTarget) == null ? void 0 : E.contains) != null && v.call(E, _.relatedTarget)) && (d.value = !1, f.value && (f.value.focus({ preventScroll: !0 }), f.value = null));
    }
    function g(_) {
      _.target instanceof HTMLElement && _.target.dataset.dismissible === "false" || d.value || (d.value = !0, f.value = _.relatedTarget);
    }
    function y(_) {
      _.target && _.target instanceof HTMLElement && _.target.dataset.dismissible === "false" || (l.value = !1);
    }
    return lr((_) => {
      const E = Bn.subscribe((v) => {
        if (v.dismiss) {
          i.value = i.value.map(
            (M) => M.id === v.id ? { ...M, delete: !0 } : M
          );
          return;
        }
        Ft(() => {
          const M = i.value.findIndex(
            (k) => k.id === v.id
          );
          M !== -1 ? i.value = [
            ...i.value.slice(0, M),
            { ...i.value[M], ...v },
            ...i.value.slice(M + 1)
          ] : i.value = [v, ...i.value];
        });
      });
      _(() => {
        E();
      });
    }), Mt(
      () => t.theme,
      (_) => {
        if (_ !== "system") {
          u.value = _;
          return;
        }
        _ === "system" && (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? u.value = "dark" : u.value = "light"), !(typeof window > "u") && window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches: E }) => {
          E ? u.value = "dark" : u.value = "light";
        });
      }
    ), lr(() => {
      c.value && f.value && (f.value.focus({ preventScroll: !0 }), f.value = null, d.value = !1);
    }), lr(() => {
      i.value.length <= 1 && (a.value = !1);
    }), lr((_) => {
      function E(v) {
        const M = t.hotkey.every(
          (U) => v[U] || v.code === U
        ), k = Array.isArray(c.value) ? c.value[0] : c.value;
        M && (a.value = !0, k == null || k.focus());
        const T = document.activeElement === c.value || (k == null ? void 0 : k.contains(document.activeElement));
        v.code === "Escape" && T && (a.value = !1);
      }
      NK && (document.addEventListener("keydown", E), _(() => {
        document.removeEventListener("keydown", E);
      }));
    }), (_, E) => (x(), W("section", {
      "aria-label": `${_.containerAriaLabel} ${b(p)}`,
      tabIndex: -1
    }, [
      (x(!0), W(Ge, null, ft(o.value, (v, M) => {
        var k;
        return x(), W("ol", oe({
          key: v,
          ref_for: !0,
          ref_key: "listRef",
          ref: c,
          "data-sonner-toaster": "",
          class: t.class,
          dir: _.dir === "auto" ? n() : _.dir,
          tabIndex: -1,
          "data-theme": _.theme,
          "data-rich-colors": _.richColors,
          "data-y-position": v.split("-")[0],
          "data-x-position": v.split("-")[1],
          style: {
            "--front-toast-height": `${(k = s.value[0]) == null ? void 0 : k.height}px`,
            "--offset": typeof _.offset == "number" ? `${_.offset}px` : _.offset || s_,
            "--width": `${SK}px`,
            "--gap": `${_.gap}px`,
            ..._.style,
            ...b(r).style
          }
        }, _.$attrs, {
          onBlur: m,
          onFocus: g,
          onMouseenter: E[1] || (E[1] = () => a.value = !0),
          onMousemove: E[2] || (E[2] = () => a.value = !0),
          onMouseleave: E[3] || (E[3] = () => {
            l.value || (a.value = !1);
          }),
          onPointerdown: y,
          onPointerup: E[4] || (E[4] = () => l.value = !1)
        }), [
          (x(!0), W(Ge, null, ft(i.value.filter(
            (T) => !T.position && M === 0 || T.position === v
          ), (T, U) => {
            var C, z, H, j, V, Q, le, ne, w;
            return x(), L(tK, {
              key: T.id,
              heights: s.value.filter((O) => O.position === T.position),
              icons: _.icons,
              index: U,
              toast: T,
              defaultRichColors: _.richColors,
              duration: ((C = _.toastOptions) == null ? void 0 : C.duration) ?? _.duration,
              class: ce(((z = _.toastOptions) == null ? void 0 : z.class) ?? ""),
              descriptionClass: (H = _.toastOptions) == null ? void 0 : H.descriptionClass,
              invert: _.invert,
              visibleToasts: _.visibleToasts,
              closeButton: ((j = _.toastOptions) == null ? void 0 : j.closeButton) ?? _.closeButton,
              interacting: l.value,
              position: v,
              style: Rr((V = _.toastOptions) == null ? void 0 : V.style),
              unstyled: (Q = _.toastOptions) == null ? void 0 : Q.unstyled,
              classes: (le = _.toastOptions) == null ? void 0 : le.classes,
              cancelButtonStyle: (ne = _.toastOptions) == null ? void 0 : ne.cancelButtonStyle,
              actionButtonStyle: (w = _.toastOptions) == null ? void 0 : w.actionButtonStyle,
              toasts: i.value.filter((O) => O.position === T.position),
              expandByDefault: _.expand,
              gap: _.gap,
              expanded: a.value,
              pauseWhenPageIsHidden: _.pauseWhenPageIsHidden,
              cn: _.cn,
              "onUpdate:heights": E[0] || (E[0] = (O) => {
                s.value = O;
              }),
              onRemoveToast: h
            }, {
              "close-icon": A(() => [
                B(_.$slots, "close-icon", {}, () => [
                  $(oK)
                ])
              ]),
              "loading-icon": A(() => [
                B(_.$slots, "loading-icon", {}, () => [
                  $(lK, {
                    visible: T.type === "loading"
                  }, null, 8, ["visible"])
                ])
              ]),
              "success-icon": A(() => [
                B(_.$slots, "success-icon", {}, () => [
                  $(dK)
                ])
              ]),
              "error-icon": A(() => [
                B(_.$slots, "error-icon", {}, () => [
                  $(kK)
                ])
              ]),
              "warning-icon": A(() => [
                B(_.$slots, "warning-icon", {}, () => [
                  $(_K)
                ])
              ]),
              "info-icon": A(() => [
                B(_.$slots, "info-icon", {}, () => [
                  $(mK)
                ])
              ]),
              _: 2
            }, 1032, ["heights", "icons", "index", "toast", "defaultRichColors", "duration", "class", "descriptionClass", "invert", "visibleToasts", "closeButton", "interacting", "position", "style", "unstyled", "classes", "cancelButtonStyle", "actionButtonStyle", "toasts", "expandByDefault", "gap", "expanded", "pauseWhenPageIsHidden", "cn"]);
          }), 128))
        ], 16, AK);
      }), 128))
    ], 8, MK));
  }
}), qne = /* @__PURE__ */ S({
  __name: "Sonner",
  props: {
    invert: { type: Boolean },
    theme: {},
    position: {},
    hotkey: {},
    richColors: { type: Boolean },
    expand: { type: Boolean },
    duration: {},
    gap: {},
    visibleToasts: {},
    closeButton: { type: Boolean },
    toastOptions: {},
    class: {},
    style: {},
    offset: {},
    dir: {},
    icons: {},
    containerAriaLabel: {},
    pauseWhenPageIsHidden: { type: Boolean },
    cn: { type: Function }
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(OK), oe({
      class: "toaster group",
      "class-names": {
        toast: "group toast group-[.toaster]:bg-layer-0 group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
        description: "group-[.toast]:text-muted-foreground",
        actionButton: "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
        cancelButton: "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground"
      }
    }, t), null, 16));
  }
}), IK = { class: "copied-sonner-style" }, RK = { class: "grid-rows-auto grid" }, LK = { class: "flex items-center justify-between" }, BK = { class: "font-semibold" }, PK = { key: 0 }, Gne = /* @__PURE__ */ S({
  __name: "CustomToast",
  props: {
    title: {},
    description: {},
    dismissable: { type: Boolean },
    isError: { type: Boolean }
  },
  emits: ["close"],
  setup(e, { emit: t }) {
    const n = t;
    return (r, i) => (x(), W("div", {
      class: ce(`top-border-radius border-t-4 border-solid ${r.isError ? "border-red-500" : "border-green-500"}`)
    }, [
      be("div", IK, [
        be("div", RK, [
          be("div", LK, [
            be("div", BK, ze(r.title), 1),
            r.dismissable ? (x(), L(b(Kr), {
              key: 0,
              variant: "ghost",
              size: "sm",
              class: "p-1",
              onClick: i[0] || (i[0] = (o) => n("close"))
            }, {
              default: A(() => [
                $(b(L0), { class: "h-4" })
              ]),
              _: 1
            })) : Qe("", !0)
          ]),
          r.description ? (x(), W("div", PK, ze(r.description), 1)) : Qe("", !0)
        ])
      ])
    ], 2));
  }
}), $K = ["for"], zK = ["for"], Wne = /* @__PURE__ */ S({
  __name: "Switch",
  props: {
    defaultChecked: { type: Boolean },
    checked: { type: Boolean },
    disabled: { type: Boolean },
    required: { type: Boolean },
    name: {},
    id: {},
    value: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    label: {},
    labelPosition: {}
  },
  emits: ["update:checked"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: s, ...a } = n;
      return a;
    }), o = Le(i, r);
    return (s, a) => (x(), W(Ge, null, [
      n.labelPosition === "left" ? (x(), W("label", {
        key: 0,
        class: "mr-2 cursor-pointer select-none pt-1 leading-none",
        for: n.id
      }, ze(n.label), 9, $K)) : Qe("", !0),
      $(b($T), oe(b(o), {
        class: b(G)(
          "focus-visible:ring-offset-background peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
          n.class
        )
      }), {
        default: A(() => [
          $(b(zT), {
            class: ce(
              b(G)(
                "pointer-events-none block h-5 w-5 rounded-full bg-layer-0 shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
              )
            )
          }, null, 8, ["class"])
        ]),
        _: 1
      }, 16, ["class"]),
      n.labelPosition !== "left" ? (x(), W("label", {
        key: 1,
        class: "ml-2 cursor-pointer select-none pt-1 leading-none",
        for: n.id
      }, ze(n.label), 9, zK)) : Qe("", !0)
    ], 64));
  }
}), FK = { class: "relative w-full overflow-auto" }, jK = /* @__PURE__ */ S({
  __name: "Table",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("div", FK, [
      be("table", {
        class: ce(b(G)("w-full table-auto caption-bottom text-sm", t.class))
      }, [
        B(n.$slots, "default")
      ], 2)
    ]));
  }
}), UK = /* @__PURE__ */ S({
  __name: "TableBody",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("tbody", {
      class: ce(b(G)("[&_tr:last-child]:border-0", t.class))
    }, [
      B(n.$slots, "default")
    ], 2));
  }
}), cc = /* @__PURE__ */ S({
  __name: "TableCell",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("td", {
      class: ce(b(G)("p-4 align-middle [&:has([role=checkbox])]:pr-0", t.class))
    }, [
      B(n.$slots, "default")
    ], 2));
  }
}), Kne = /* @__PURE__ */ S({
  __name: "TableHead",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("th", {
      class: ce(
        b(G)(
          "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
          t.class
        )
      )
    }, [
      B(n.$slots, "default")
    ], 2));
  }
}), VK = /* @__PURE__ */ S({
  __name: "TableHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("thead", {
      class: ce(b(G)("[&_tr]:border-b", t.class))
    }, [
      B(n.$slots, "default")
    ], 2));
  }
}), fc = /* @__PURE__ */ S({
  __name: "TableRow",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("tr", {
      class: ce(
        b(G)("border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted", t.class)
      )
    }, [
      B(n.$slots, "default")
    ], 2));
  }
}), Yne = /* @__PURE__ */ S({
  __name: "TableCaption",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), W("caption", {
      class: ce(b(G)("mt-4 text-sm text-muted-foreground", t.class))
    }, [
      B(n.$slots, "default")
    ], 2));
  }
}), HK = { class: "flex items-center justify-center py-10" }, Qne = /* @__PURE__ */ S({
  __name: "TableEmpty",
  props: {
    class: {},
    colspan: { default: 1 }
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: r, ...i } = t;
      return i;
    });
    return (r, i) => (x(), L(fc, null, {
      default: A(() => [
        $(cc, oe({
          class: b(G)("whitespace-nowrap p-4 align-middle text-sm text-foreground", t.class)
        }, n.value), {
          default: A(() => [
            be("div", HK, [
              B(r.$slots, "default")
            ])
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), Zne = /* @__PURE__ */ S({
  __name: "Tabs",
  props: {
    defaultValue: {},
    orientation: {},
    dir: {},
    activationMode: {},
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const i = Le(e, t);
    return (o, s) => (x(), L(b(FT), Pe(Ue(b(i))), {
      default: A(() => [
        B(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Xne = /* @__PURE__ */ S({
  __name: "TabsTrigger",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: i, ...o } = t;
      return o;
    }), r = We(n);
    return (i, o) => (x(), L(b(jT), oe(b(r), {
      class: b(G)(
        "ring-offset-background inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-layer-0 data-[state=active]:text-foreground data-[state=active]:shadow-sm",
        t.class
      )
    }), {
      default: A(() => [
        B(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Jne = /* @__PURE__ */ S({
  __name: "TabsList",
  props: {
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: r, ...i } = t;
      return i;
    });
    return (r, i) => (x(), L(b(UT), oe(n.value, {
      class: b(G)(
        "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
        t.class
      )
    }), {
      default: A(() => [
        B(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), ere = /* @__PURE__ */ S({
  __name: "TabsContent",
  props: {
    value: {},
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = R(() => {
      const { class: r, ...i } = t;
      return i;
    });
    return (r, i) => (x(), L(b(VT), oe({
      class: b(G)(
        "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
        t.class
      )
    }, n.value), {
      default: A(() => [
        B(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), tre = /* @__PURE__ */ S({
  __name: "Textarea",
  props: {
    class: {},
    defaultValue: {},
    modelValue: {}
  },
  emits: ["update:modelValue"],
  setup(e, { expose: t, emit: n }) {
    const r = e, i = n, o = H2(r, "modelValue", i, {
      passive: !0,
      defaultValue: r.defaultValue
    }), s = _e();
    return t({
      focus() {
        s.value && s.value.focus();
      },
      insertAtTextareaCaret(a) {
        if (!s.value) return;
        const l = s.value.selectionStart, u = r.modelValue, c = u.substring(0, l), f = u.substring(l);
        i("update:modelValue", c + a + f);
        const d = l + a.length;
        s.value.setSelectionRange(d, d), this.focus();
      }
    }), (a, l) => Ja((x(), W("textarea", {
      ref_key: "textareaRef",
      ref: s,
      "onUpdate:modelValue": l[0] || (l[0] = (u) => Co(o) ? o.value = u : null),
      class: ce(
        b(G)(
          "ring-offset-background flex max-h-36 min-h-20 w-full overflow-y-auto rounded-md border border-input bg-layer-0 px-3 py-2 text-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          r.class
        )
      )
    }, null, 2)), [
      [Q_, b(o)]
    ]);
  }
}), qK = {
  key: 0,
  class: "text-red-500"
}, g1 = /* @__PURE__ */ S({
  __name: "ValidationFormItem",
  props: {
    validate: {},
    field: {},
    label: {},
    description: {},
    errors: { default: () => [] },
    required: { type: Boolean },
    debounceDelay: { default: 250 }
  },
  setup(e) {
    const t = e, n = G6(i, t.debounceDelay);
    function r() {
    }
    function i() {
      t.validate({ fields: [t.field] });
    }
    return (o, s) => (x(), L(b(xW), {
      errors: o.errors,
      field: o.field
    }, {
      default: A(() => [
        o.label ? (x(), L(b(kW), { key: 0 }, {
          default: A(() => [
            Xt(ze(o.label) + " ", 1),
            o.required ? (x(), W("span", qK, "*")) : Qe("", !0)
          ]),
          _: 1
        })) : Qe("", !0),
        $(b(MW), null, {
          default: A(() => [
            B(o.$slots, "default", {
              triggerValidate: b(n),
              triggerFocus: r
            })
          ]),
          _: 3
        }),
        $(b(AW)),
        o.description ? (x(), L(b(TW), { key: 1 }, {
          default: A(() => [
            Xt(ze(o.description), 1)
          ]),
          _: 1
        })) : Qe("", !0)
      ]),
      _: 3
    }, 8, ["errors", "field"]));
  }
}), nre = /* @__PURE__ */ S({
  inheritAttrs: !1,
  __name: "ValidationFormInput",
  props: {
    validate: {},
    modelValue: {},
    field: {},
    label: {},
    description: {},
    errors: { default: () => [] },
    required: { type: Boolean },
    wrapperClass: {},
    debounceDelay: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = t;
    return (r, i) => (x(), L(b(g1), {
      class: ce(r.wrapperClass),
      field: r.field,
      label: r.label,
      validate: r.validate,
      errors: r.errors,
      required: r.required,
      "debounce-delay": r.debounceDelay
    }, {
      default: A(({ triggerValidate: o }) => [
        $(b(e4), oe({ "model-value": r.modelValue }, r.$attrs, {
          "onUpdate:modelValue": i[0] || (i[0] = (s) => n("update:modelValue", s)),
          onInput: o
        }), null, 16, ["model-value", "onInput"])
      ]),
      _: 1
    }, 8, ["class", "field", "label", "validate", "errors", "required", "debounce-delay"]));
  }
}), rre = /* @__PURE__ */ S({
  inheritAttrs: !1,
  __name: "ValidationFormPhoneInput",
  props: {
    validate: {},
    modelValue: {},
    field: { default: "phone" },
    label: { default: "Phone Number" },
    description: {},
    errors: { default: () => [] },
    debounceDelay: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = t;
    return (r, i) => (x(), L(b(g1), {
      field: r.field,
      label: r.label,
      validate: r.validate,
      errors: r.errors,
      debounceDelay: r.debounceDelay
    }, {
      default: A(({ triggerValidate: o }) => [
        $(b(DW), oe({ "model-value": r.modelValue }, r.$attrs, {
          "onUpdate:modelValue": i[0] || (i[0] = (s) => n("update:modelValue", s)),
          onInput: o
        }), null, 16, ["model-value", "onInput"])
      ]),
      _: 1
    }, 8, ["field", "label", "validate", "errors", "debounceDelay"]));
  }
}), ire = /* @__PURE__ */ S({
  __name: "ValidationFormTimeZoneInput",
  props: {
    validate: {},
    modelValue: {},
    field: { default: "time_zone" },
    label: { default: "Time Zone" },
    description: {},
    errors: { default: () => [] }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = t;
    return (r, i) => (x(), L(b(g1), {
      field: r.field,
      label: r.label,
      validate: r.validate,
      errors: r.errors
    }, {
      default: A(({ triggerValidate: o }) => [
        $(b(P6), oe({ "model-value": r.modelValue }, r.$attrs, {
          "onUpdate:modelValue": i[0] || (i[0] = (s) => n("update:modelValue", s)),
          onBlur: o
        }), null, 16, ["model-value", "onBlur"])
      ]),
      _: 1
    }, 8, ["field", "label", "validate", "errors"]));
  }
}), ore = /* @__PURE__ */ S({
  __name: "ResizablePanelGroup",
  props: {
    id: {},
    autoSaveId: {},
    direction: {},
    keyboardResizeBy: {},
    storage: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["layout"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: s, ...a } = n;
      return a;
    }), o = Le(i, r);
    return (s, a) => (x(), L(b(HT), oe(b(o), {
      class: b(G)("flex h-full w-full data-[panel-group-direction=vertical]:flex-col", n.class)
    }), {
      default: A(() => [
        B(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), GK = {
  key: 0,
  class: "z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border"
}, sre = /* @__PURE__ */ S({
  __name: "ResizableHandle",
  props: {
    id: {},
    hitAreaMargins: {},
    tabindex: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {},
    withHandle: { type: Boolean }
  },
  emits: ["dragging"],
  setup(e, { emit: t }) {
    const n = e, r = t, i = R(() => {
      const { class: s, ...a } = n;
      return a;
    }), o = Le(i, r);
    return (s, a) => (x(), L(b(qT), oe(b(o), {
      class: b(G)(
        "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 [&[data-orientation=vertical]>div]:rotate-90 [&[data-orientation=vertical]]:h-px [&[data-orientation=vertical]]:w-full [&[data-orientation=vertical]]:after:left-0 [&[data-orientation=vertical]]:after:h-1 [&[data-orientation=vertical]]:after:w-full [&[data-orientation=vertical]]:after:-translate-y-1/2 [&[data-orientation=vertical]]:after:translate-x-0",
        n.class
      )
    }), {
      default: A(() => [
        n.withHandle ? (x(), W("div", GK, [
          $(b(mS), { class: "h-2.5 w-2.5" })
        ])) : Qe("", !0)
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), are = /* @__PURE__ */ S({
  __name: "DataTable",
  props: {
    columns: {},
    rows: {},
    rowKey: { default: "id" },
    hideHeader: { type: Boolean, default: !1 }
  },
  emits: ["row-click"],
  setup(e, { emit: t }) {
    const n = t;
    return (r, i) => (x(), L(b(jK), null, {
      default: A(() => [
        r.hideHeader ? Qe("", !0) : (x(), L(b(VK), { key: 0 }, {
          default: A(() => [
            B(r.$slots, "header", {}, () => [
              $(b(fc), null, {
                default: A(() => [
                  (x(!0), W(Ge, null, ft(r.columns, (o) => B(r.$slots, `header-cell-${o.name}`, {
                    key: o.name
                  }, () => [
                    $(b(cc), {
                      style: Rr(o.headerStyle || ""),
                      class: ce(o.headerClasses || "")
                    }, {
                      default: A(() => [
                        Xt(ze(o.label), 1)
                      ]),
                      _: 2
                    }, 1032, ["style", "class"])
                  ])), 128))
                ]),
                _: 3
              })
            ])
          ]),
          _: 3
        })),
        $(b(UK), null, {
          default: A(() => [
            r.rows.length ? (x(!0), W(Ge, { key: 0 }, ft(r.rows, (o) => B(r.$slots, "body-row", {
              key: o[r.rowKey],
              row: o
            }, () => [
              $(b(fc), {
                onClick: (s) => n("row-click", o)
              }, {
                default: A(() => [
                  (x(!0), W(Ge, null, ft(r.columns, (s) => B(r.$slots, `body-cell-${s.name}`, {
                    key: s.name,
                    row: o
                  }, () => [
                    $(b(cc), {
                      style: Rr(s.bodyStyle || ""),
                      class: ce(s.bodyClasses || "")
                    }, {
                      default: A(() => [
                        s.format ? (x(), W(Ge, { key: 0 }, [
                          Xt(ze(s.format(o)), 1)
                        ], 64)) : (x(), W(Ge, { key: 1 }, [
                          Xt(ze(o[s.field]), 1)
                        ], 64))
                      ]),
                      _: 2
                    }, 1032, ["style", "class"])
                  ])), 128))
                ]),
                _: 2
              }, 1032, ["onClick"])
            ])), 128)) : B(r.$slots, "no-data", { key: 1 }, () => [
              $(b(fc), null, {
                default: A(() => [
                  $(b(cc), {
                    colspan: r.columns.length,
                    class: "h-24 text-center"
                  }, {
                    default: A(() => i[0] || (i[0] = [
                      Xt(" No results. ")
                    ])),
                    _: 1
                  }, 8, ["colspan"])
                ]),
                _: 1
              })
            ])
          ]),
          _: 3
        })
      ]),
      _: 3
    }));
  }
});
let Qp = null;
function WK() {
  return Qp == null && (Qp = new Intl.DateTimeFormat().resolvedOptions().timeZone), Qp;
}
let Zp = /* @__PURE__ */ new Map();
class KK {
  /** Formats a date as a string according to the locale and format options passed to the constructor. */
  format(t) {
    return this.formatter.format(t);
  }
  /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */
  formatToParts(t) {
    return this.formatter.formatToParts(t);
  }
  /** Formats a date range as a string. */
  formatRange(t, n) {
    if (typeof this.formatter.formatRange == "function")
      return this.formatter.formatRange(t, n);
    if (n < t) throw new RangeError("End date must be >= start date");
    return `${this.formatter.format(t)}  ${this.formatter.format(n)}`;
  }
  /** Formats a date range as an array of parts. */
  formatRangeToParts(t, n) {
    if (typeof this.formatter.formatRangeToParts == "function")
      return this.formatter.formatRangeToParts(t, n);
    if (n < t) throw new RangeError("End date must be >= start date");
    let r = this.formatter.formatToParts(t), i = this.formatter.formatToParts(n);
    return [
      ...r.map((o) => ({
        ...o,
        source: "startRange"
      })),
      {
        type: "literal",
        value: "  ",
        source: "shared"
      },
      ...i.map((o) => ({
        ...o,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let t = this.formatter.resolvedOptions();
    return ZK() && (this.resolvedHourCycle || (this.resolvedHourCycle = XK(t.locale, this.options)), t.hourCycle = this.resolvedHourCycle, t.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12"), t.calendar === "ethiopic-amete-alem" && (t.calendar = "ethioaa"), t;
  }
  constructor(t, n = {}) {
    this.formatter = t4(t, n), this.options = n;
  }
}
const YK = {
  true: {
    // Only Japanese uses the h11 style for 12 hour time. All others use h12.
    ja: "h11"
  },
  false: {}
};
function t4(e, t = {}) {
  if (typeof t.hour12 == "boolean" && QK()) {
    t = {
      ...t
    };
    let i = YK[String(t.hour12)][e.split("-")[0]], o = t.hour12 ? "h12" : "h23";
    t.hourCycle = i ?? o, delete t.hour12;
  }
  let n = e + (t ? Object.entries(t).sort((i, o) => i[0] < o[0] ? -1 : 1).join() : "");
  if (Zp.has(n)) return Zp.get(n);
  let r = new Intl.DateTimeFormat(e, t);
  return Zp.set(n, r), r;
}
let Xp = null;
function QK() {
  return Xp == null && (Xp = new Intl.DateTimeFormat("en-US", {
    hour: "numeric",
    hour12: !1
  }).format(new Date(2020, 2, 3, 0)) === "24"), Xp;
}
let Jp = null;
function ZK() {
  return Jp == null && (Jp = new Intl.DateTimeFormat("fr", {
    hour: "numeric",
    hour12: !1
  }).resolvedOptions().hourCycle === "h12"), Jp;
}
function XK(e, t) {
  if (!t.timeStyle && !t.hour) return;
  e = e.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, ""), e += (e.includes("-u-") ? "" : "-u") + "-nu-latn";
  let n = t4(e, {
    ...t,
    timeZone: void 0
    // use local timezone
  }), r = parseInt(n.formatToParts(new Date(2020, 2, 3, 0)).find((o) => o.type === "hour").value, 10), i = parseInt(n.formatToParts(new Date(2020, 2, 3, 23)).find((o) => o.type === "hour").value, 10);
  if (r === 0 && i === 23) return "h23";
  if (r === 24 && i === 23) return "h24";
  if (r === 0 && i === 11) return "h11";
  if (r === 12 && i === 11) return "h12";
  throw new Error("Unexpected hour cycle result");
}
const JK = { class: "flex items-center space-x-2" }, lre = /* @__PURE__ */ S({
  __name: "DatePicker",
  props: {
    modelValue: {}
  },
  emits: ["update:model-value"],
  setup(e, { emit: t }) {
    const n = t, r = new KK("en-US", {
      dateStyle: "long"
    });
    return (i, o) => (x(), L(b(z0), null, {
      default: A(() => [
        $(b(F0), { "as-child": "" }, {
          default: A(() => [
            $(b(Kr), oe({
              variant: "ghost",
              class: b(G)("justify-start text-left font-normal", !i.modelValue && "text-muted-foreground")
            }, i.$attrs), {
              default: A(() => [
                be("div", JK, [
                  $(b(bS), { class: "mr-2 h-4 w-4" }),
                  Xt(" " + ze(i.modelValue ? b(r).format(i.modelValue.toDate(b(WK)())) : "Pick a date"), 1)
                ])
              ]),
              _: 1
            }, 16, ["class"])
          ]),
          _: 1
        }),
        $(b(j0), { class: "w-auto p-0" }, {
          default: A(() => [
            $(b(ES), {
              "model-value": i.modelValue,
              "onUpdate:modelValue": o[0] || (o[0] = (s) => n("update:model-value", s)),
              "initial-focus": ""
            }, null, 8, ["model-value"])
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
}), ure = /* @__PURE__ */ S({
  __name: "Avatar",
  props: {
    class: {},
    size: { default: "sm" },
    shape: { default: "circle" }
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(GT), {
      class: ce(b(G)(b(eY)({ size: n.size, shape: n.shape }), t.class))
    }, {
      default: A(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), cre = /* @__PURE__ */ S({
  __name: "AvatarImage",
  props: {
    src: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(WT), oe(t, { class: "h-full w-full object-cover" }), null, 16));
  }
}), fre = /* @__PURE__ */ S({
  __name: "AvatarFallback",
  props: {
    delayMs: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, r) => (x(), L(b(KT), Pe(Ue(t)), {
      default: A(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), eY = Js(
  "inline-flex items-center justify-center font-normal text-foreground select-none shrink-0 bg-secondary overflow-hidden",
  {
    variants: {
      size: {
        xs: "h-6 w-6 text-xs",
        sm: "h-10 w-10 text-sm",
        base: "h-16 w-16 text-2xl",
        lg: "h-32 w-32 text-5xl"
      },
      shape: {
        circle: "rounded-full",
        square: "rounded-md"
      }
    }
  }
);
var h0 = "http://www.w3.org/1999/xhtml";
const a_ = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: h0,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function Od(e) {
  var t = e += "", n = t.indexOf(":");
  return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), a_.hasOwnProperty(t) ? { space: a_[t], local: e } : e;
}
function tY(e) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === h0 && t.documentElement.namespaceURI === h0 ? t.createElement(e) : t.createElementNS(n, e);
  };
}
function nY(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function n4(e) {
  var t = Od(e);
  return (t.local ? nY : tY)(t);
}
function rY() {
}
function m1(e) {
  return e == null ? rY : function() {
    return this.querySelector(e);
  };
}
function iY(e) {
  typeof e != "function" && (e = m1(e));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var o = t[i], s = o.length, a = r[i] = new Array(s), l, u, c = 0; c < s; ++c)
      (l = o[c]) && (u = e.call(l, l.__data__, c, o)) && ("__data__" in l && (u.__data__ = l.__data__), a[c] = u);
  return new Hn(r, this._parents);
}
function oY(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function sY() {
  return [];
}
function r4(e) {
  return e == null ? sY : function() {
    return this.querySelectorAll(e);
  };
}
function aY(e) {
  return function() {
    return oY(e.apply(this, arguments));
  };
}
function lY(e) {
  typeof e == "function" ? e = aY(e) : e = r4(e);
  for (var t = this._groups, n = t.length, r = [], i = [], o = 0; o < n; ++o)
    for (var s = t[o], a = s.length, l, u = 0; u < a; ++u)
      (l = s[u]) && (r.push(e.call(l, l.__data__, u, s)), i.push(l));
  return new Hn(r, i);
}
function i4(e) {
  return function() {
    return this.matches(e);
  };
}
function o4(e) {
  return function(t) {
    return t.matches(e);
  };
}
var uY = Array.prototype.find;
function cY(e) {
  return function() {
    return uY.call(this.children, e);
  };
}
function fY() {
  return this.firstElementChild;
}
function dY(e) {
  return this.select(e == null ? fY : cY(typeof e == "function" ? e : o4(e)));
}
var pY = Array.prototype.filter;
function hY() {
  return Array.from(this.children);
}
function gY(e) {
  return function() {
    return pY.call(this.children, e);
  };
}
function mY(e) {
  return this.selectAll(e == null ? hY : gY(typeof e == "function" ? e : o4(e)));
}
function bY(e) {
  typeof e != "function" && (e = i4(e));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var o = t[i], s = o.length, a = r[i] = [], l, u = 0; u < s; ++u)
      (l = o[u]) && e.call(l, l.__data__, u, o) && a.push(l);
  return new Hn(r, this._parents);
}
function s4(e) {
  return new Array(e.length);
}
function yY() {
  return new Hn(this._enter || this._groups.map(s4), this._parents);
}
function Bf(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
Bf.prototype = {
  constructor: Bf,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function vY(e) {
  return function() {
    return e;
  };
}
function _Y(e, t, n, r, i, o) {
  for (var s = 0, a, l = t.length, u = o.length; s < u; ++s)
    (a = t[s]) ? (a.__data__ = o[s], r[s] = a) : n[s] = new Bf(e, o[s]);
  for (; s < l; ++s)
    (a = t[s]) && (i[s] = a);
}
function EY(e, t, n, r, i, o, s) {
  var a, l, u = /* @__PURE__ */ new Map(), c = t.length, f = o.length, d = new Array(c), p;
  for (a = 0; a < c; ++a)
    (l = t[a]) && (d[a] = p = s.call(l, l.__data__, a, t) + "", u.has(p) ? i[a] = l : u.set(p, l));
  for (a = 0; a < f; ++a)
    p = s.call(e, o[a], a, o) + "", (l = u.get(p)) ? (r[a] = l, l.__data__ = o[a], u.delete(p)) : n[a] = new Bf(e, o[a]);
  for (a = 0; a < c; ++a)
    (l = t[a]) && u.get(d[a]) === l && (i[a] = l);
}
function wY(e) {
  return e.__data__;
}
function xY(e, t) {
  if (!arguments.length) return Array.from(this, wY);
  var n = t ? EY : _Y, r = this._parents, i = this._groups;
  typeof e != "function" && (e = vY(e));
  for (var o = i.length, s = new Array(o), a = new Array(o), l = new Array(o), u = 0; u < o; ++u) {
    var c = r[u], f = i[u], d = f.length, p = kY(e.call(c, c && c.__data__, u, r)), h = p.length, m = a[u] = new Array(h), g = s[u] = new Array(h), y = l[u] = new Array(d);
    n(c, f, m, g, y, p, t);
    for (var _ = 0, E = 0, v, M; _ < h; ++_)
      if (v = m[_]) {
        for (_ >= E && (E = _ + 1); !(M = g[E]) && ++E < h; ) ;
        v._next = M || null;
      }
  }
  return s = new Hn(s, r), s._enter = a, s._exit = l, s;
}
function kY(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function MY() {
  return new Hn(this._exit || this._groups.map(s4), this._parents);
}
function AY(e, t, n) {
  var r = this.enter(), i = this, o = this.exit();
  return typeof e == "function" ? (r = e(r), r && (r = r.selection())) : r = r.append(e + ""), t != null && (i = t(i), i && (i = i.selection())), n == null ? o.remove() : n(o), r && i ? r.merge(i).order() : i;
}
function TY(e) {
  for (var t = e.selection ? e.selection() : e, n = this._groups, r = t._groups, i = n.length, o = r.length, s = Math.min(i, o), a = new Array(i), l = 0; l < s; ++l)
    for (var u = n[l], c = r[l], f = u.length, d = a[l] = new Array(f), p, h = 0; h < f; ++h)
      (p = u[h] || c[h]) && (d[h] = p);
  for (; l < i; ++l)
    a[l] = n[l];
  return new Hn(a, this._parents);
}
function SY() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; )
    for (var r = e[t], i = r.length - 1, o = r[i], s; --i >= 0; )
      (s = r[i]) && (o && s.compareDocumentPosition(o) ^ 4 && o.parentNode.insertBefore(s, o), o = s);
  return this;
}
function CY(e) {
  e || (e = NY);
  function t(f, d) {
    return f && d ? e(f.__data__, d.__data__) : !f - !d;
  }
  for (var n = this._groups, r = n.length, i = new Array(r), o = 0; o < r; ++o) {
    for (var s = n[o], a = s.length, l = i[o] = new Array(a), u, c = 0; c < a; ++c)
      (u = s[c]) && (l[c] = u);
    l.sort(t);
  }
  return new Hn(i, this._parents).order();
}
function NY(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function DY() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function OY() {
  return Array.from(this);
}
function IY() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], i = 0, o = r.length; i < o; ++i) {
      var s = r[i];
      if (s) return s;
    }
  return null;
}
function RY() {
  let e = 0;
  for (const t of this) ++e;
  return e;
}
function LY() {
  return !this.node();
}
function BY(e) {
  for (var t = this._groups, n = 0, r = t.length; n < r; ++n)
    for (var i = t[n], o = 0, s = i.length, a; o < s; ++o)
      (a = i[o]) && e.call(a, a.__data__, o, i);
  return this;
}
function PY(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function $Y(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function zY(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function FY(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function jY(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
  };
}
function UY(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
  };
}
function VY(e, t) {
  var n = Od(e);
  if (arguments.length < 2) {
    var r = this.node();
    return n.local ? r.getAttributeNS(n.space, n.local) : r.getAttribute(n);
  }
  return this.each((t == null ? n.local ? $Y : PY : typeof t == "function" ? n.local ? UY : jY : n.local ? FY : zY)(n, t));
}
function a4(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function HY(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function qY(e, t, n) {
  return function() {
    this.style.setProperty(e, t, n);
  };
}
function GY(e, t, n) {
  return function() {
    var r = t.apply(this, arguments);
    r == null ? this.style.removeProperty(e) : this.style.setProperty(e, r, n);
  };
}
function WY(e, t, n) {
  return arguments.length > 1 ? this.each((t == null ? HY : typeof t == "function" ? GY : qY)(e, t, n ?? "")) : Ws(this.node(), e);
}
function Ws(e, t) {
  return e.style.getPropertyValue(t) || a4(e).getComputedStyle(e, null).getPropertyValue(t);
}
function KY(e) {
  return function() {
    delete this[e];
  };
}
function YY(e, t) {
  return function() {
    this[e] = t;
  };
}
function QY(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e] : this[e] = n;
  };
}
function ZY(e, t) {
  return arguments.length > 1 ? this.each((t == null ? KY : typeof t == "function" ? QY : YY)(e, t)) : this.node()[e];
}
function l4(e) {
  return e.trim().split(/^|\s+/);
}
function b1(e) {
  return e.classList || new u4(e);
}
function u4(e) {
  this._node = e, this._names = l4(e.getAttribute("class") || "");
}
u4.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function c4(e, t) {
  for (var n = b1(e), r = -1, i = t.length; ++r < i; ) n.add(t[r]);
}
function f4(e, t) {
  for (var n = b1(e), r = -1, i = t.length; ++r < i; ) n.remove(t[r]);
}
function XY(e) {
  return function() {
    c4(this, e);
  };
}
function JY(e) {
  return function() {
    f4(this, e);
  };
}
function eQ(e, t) {
  return function() {
    (t.apply(this, arguments) ? c4 : f4)(this, e);
  };
}
function tQ(e, t) {
  var n = l4(e + "");
  if (arguments.length < 2) {
    for (var r = b1(this.node()), i = -1, o = n.length; ++i < o; ) if (!r.contains(n[i])) return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? eQ : t ? XY : JY)(n, t));
}
function nQ() {
  this.textContent = "";
}
function rQ(e) {
  return function() {
    this.textContent = e;
  };
}
function iQ(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function oQ(e) {
  return arguments.length ? this.each(e == null ? nQ : (typeof e == "function" ? iQ : rQ)(e)) : this.node().textContent;
}
function sQ() {
  this.innerHTML = "";
}
function aQ(e) {
  return function() {
    this.innerHTML = e;
  };
}
function lQ(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function uQ(e) {
  return arguments.length ? this.each(e == null ? sQ : (typeof e == "function" ? lQ : aQ)(e)) : this.node().innerHTML;
}
function cQ() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function fQ() {
  return this.each(cQ);
}
function dQ() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function pQ() {
  return this.each(dQ);
}
function hQ(e) {
  var t = typeof e == "function" ? e : n4(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function gQ() {
  return null;
}
function mQ(e, t) {
  var n = typeof e == "function" ? e : n4(e), r = t == null ? gQ : typeof t == "function" ? t : m1(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), r.apply(this, arguments) || null);
  });
}
function bQ() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function yQ() {
  return this.each(bQ);
}
function vQ() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function _Q() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function EQ(e) {
  return this.select(e ? _Q : vQ);
}
function wQ(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function xQ(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function kQ(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var n = "", r = t.indexOf(".");
    return r >= 0 && (n = t.slice(r + 1), t = t.slice(0, r)), { type: t, name: n };
  });
}
function MQ(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var n = 0, r = -1, i = t.length, o; n < i; ++n)
        o = t[n], (!e.type || o.type === e.type) && o.name === e.name ? this.removeEventListener(o.type, o.listener, o.options) : t[++r] = o;
      ++r ? t.length = r : delete this.__on;
    }
  };
}
function AQ(e, t, n) {
  return function() {
    var r = this.__on, i, o = xQ(t);
    if (r) {
      for (var s = 0, a = r.length; s < a; ++s)
        if ((i = r[s]).type === e.type && i.name === e.name) {
          this.removeEventListener(i.type, i.listener, i.options), this.addEventListener(i.type, i.listener = o, i.options = n), i.value = t;
          return;
        }
    }
    this.addEventListener(e.type, o, n), i = { type: e.type, name: e.name, value: t, listener: o, options: n }, r ? r.push(i) : this.__on = [i];
  };
}
function TQ(e, t, n) {
  var r = kQ(e + ""), i, o = r.length, s;
  if (arguments.length < 2) {
    var a = this.node().__on;
    if (a) {
      for (var l = 0, u = a.length, c; l < u; ++l)
        for (i = 0, c = a[l]; i < o; ++i)
          if ((s = r[i]).type === c.type && s.name === c.name)
            return c.value;
    }
    return;
  }
  for (a = t ? AQ : MQ, i = 0; i < o; ++i) this.each(a(r[i], t, n));
  return this;
}
function d4(e, t, n) {
  var r = a4(e), i = r.CustomEvent;
  typeof i == "function" ? i = new i(t, n) : (i = r.document.createEvent("Event"), n ? (i.initEvent(t, n.bubbles, n.cancelable), i.detail = n.detail) : i.initEvent(t, !1, !1)), e.dispatchEvent(i);
}
function SQ(e, t) {
  return function() {
    return d4(this, e, t);
  };
}
function CQ(e, t) {
  return function() {
    return d4(this, e, t.apply(this, arguments));
  };
}
function NQ(e, t) {
  return this.each((typeof t == "function" ? CQ : SQ)(e, t));
}
function* DQ() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], i = 0, o = r.length, s; i < o; ++i)
      (s = r[i]) && (yield s);
}
var p4 = [null];
function Hn(e, t) {
  this._groups = e, this._parents = t;
}
function ru() {
  return new Hn([[document.documentElement]], p4);
}
function OQ() {
  return this;
}
Hn.prototype = ru.prototype = {
  constructor: Hn,
  select: iY,
  selectAll: lY,
  selectChild: dY,
  selectChildren: mY,
  filter: bY,
  data: xY,
  enter: yY,
  exit: MY,
  join: AY,
  merge: TY,
  selection: OQ,
  order: SY,
  sort: CY,
  call: DY,
  nodes: OY,
  node: IY,
  size: RY,
  empty: LY,
  each: BY,
  attr: VY,
  style: WY,
  property: ZY,
  classed: tQ,
  text: oQ,
  html: uQ,
  raise: fQ,
  lower: pQ,
  append: hQ,
  insert: mQ,
  remove: yQ,
  clone: EQ,
  datum: wQ,
  on: TQ,
  dispatch: NQ,
  [Symbol.iterator]: DQ
};
function gs(e) {
  return typeof e == "string" ? new Hn([[document.querySelector(e)]], [document.documentElement]) : new Hn([[e]], p4);
}
function IQ(e) {
  let t;
  for (; t = e.sourceEvent; ) e = t;
  return e;
}
function l_(e, t) {
  if (e = IQ(e), t === void 0 && (t = e.currentTarget), t) {
    var n = t.ownerSVGElement || t;
    if (n.createSVGPoint) {
      var r = n.createSVGPoint();
      return r.x = e.clientX, r.y = e.clientY, r = r.matrixTransform(t.getScreenCTM().inverse()), [r.x, r.y];
    }
    if (t.getBoundingClientRect) {
      var i = t.getBoundingClientRect();
      return [e.clientX - i.left - t.clientLeft, e.clientY - i.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
var Za;
(function(e) {
  e[e.SVG = 0] = "SVG", e[e.HTML = 1] = "HTML";
})(Za || (Za = {}));
var ci;
(function(e) {
  e.Fit = "fit", e.Extend = "extend", e.FitWidth = "fit_width";
})(ci || (ci = {}));
function RQ(e, t, n) {
  var r = {}, i = r.noTrailing, o = i === void 0 ? !1 : i, s = r.noLeading, a = s === void 0 ? !1 : s, l = r.debounceMode, u = l === void 0 ? void 0 : l, c, f = !1, d = 0;
  function p() {
    c && clearTimeout(c);
  }
  function h(g) {
    var y = g || {}, _ = y.upcomingOnly, E = _ === void 0 ? !1 : _;
    p(), f = !E;
  }
  function m() {
    for (var g = arguments.length, y = new Array(g), _ = 0; _ < g; _++)
      y[_] = arguments[_];
    var E = this, v = Date.now() - d;
    if (f)
      return;
    function M() {
      d = Date.now(), t.apply(E, y);
    }
    function k() {
      c = void 0;
    }
    !a && u && !c && M(), p(), u === void 0 && v > e ? a ? (d = Date.now(), o || (c = setTimeout(u ? k : M, e))) : M() : o !== !0 && (c = setTimeout(u ? k : M, u === void 0 ? e - v : e));
  }
  return m.cancel = h, m;
}
const y1 = (e) => typeof e == "number", h4 = (e) => typeof e == "function", g4 = (e) => Array.isArray(e), LQ = (e) => e instanceof Object, Pf = (e) => e.constructor.name !== "Function" && e.constructor.name !== "Object", u_ = (e) => LQ(e) && !g4(e) && !h4(e) && !Pf(e), $f = (e, t, n = /* @__PURE__ */ new Set()) => {
  if (Array.isArray(e)) {
    if (!Array.isArray(t) || e.length !== t.length)
      return !1;
    if (n.has(e))
      return !0;
    n.add(e);
    for (let r = 0; r < e.length; r++)
      if (!$f(e[r], t[r], n))
        return !1;
    return !0;
  }
  if (e instanceof Date && t instanceof Date)
    return e.getTime() === t.getTime();
  if (typeof e == "object" && e !== null && t !== null) {
    if (typeof t != "object")
      return !1;
    if (e === t)
      return !0;
    if (Object.keys(e).length !== Object.keys(t).length)
      return !1;
    if (n.has(e))
      return !0;
    n.add(e);
    for (const i in e)
      if (!$f(e[i], t[i], n))
        return !1;
    return !0;
  }
  return e === t;
}, BQ = (e) => e.flat(), zf = (e, t = /* @__PURE__ */ new Map()) => {
  if (typeof e != "object" || e === null)
    return e;
  if (e instanceof Date)
    return new Date(e.getTime());
  if (e instanceof Array) {
    const n = [];
    t.set(e, n);
    for (const r of e)
      n.push(t.has(r) ? t.get(r) : zf(r, t));
    return n;
  }
  if (Pf(e))
    return e;
  if (e instanceof Object) {
    const n = {};
    t.set(e, n);
    const r = e;
    return Object.keys(e).reduce((i, o) => (i[o] = t.has(r[o]) ? t.get(r[o]) : zf(r[o], t), i), n), n;
  }
  return e;
}, Id = (e, t, n = /* @__PURE__ */ new Map()) => {
  if (!e || !t || e === t)
    return e;
  const r = Pf(e) ? e : zf(e);
  return n.has(t) ? n.get(t) : (n.set(t, r), Object.keys(t).forEach((i) => {
    i === "__proto__" || i === "constructor" || (u_(e[i]) && u_(t[i]) ? r[i] = Id(e[i], t[i], n) : Pf(t) ? r[i] = t : r[i] = zf(t[i]));
  }), r);
}, PQ = (e, t) => (e = Object.assign({}, e), t.forEach((n) => delete e[n]), e), Ff = (e, t, n) => RQ(t, e);
function m4(e, t, n) {
  return h4(t) ? t(e, n) : t;
}
function $Q(e, t, n) {
  return m4(e, t, n);
}
function c_(e, t, n) {
  return m4(e, t, n);
}
function g0(e, t, n) {
  return Math.min(Math.max(e, t), n);
}
var Ao = [], zQ = function() {
  return Ao.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, FQ = function() {
  return Ao.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, f_ = "ResizeObserver loop completed with undelivered notifications.", jQ = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: f_
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = f_), window.dispatchEvent(e);
}, Cl;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(Cl || (Cl = {}));
var To = function(e) {
  return Object.freeze(e);
}, UQ = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, To(this);
  }
  return e;
}(), b4 = function() {
  function e(t, n, r, i) {
    return this.x = t, this.y = n, this.width = r, this.height = i, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, To(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, i = t.top, o = t.right, s = t.bottom, a = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: i, right: o, bottom: s, left: a, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), v1 = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, y4 = function(e) {
  if (v1(e)) {
    var t = e.getBBox(), n = t.width, r = t.height;
    return !n && !r;
  }
  var i = e, o = i.offsetWidth, s = i.offsetHeight;
  return !(o || s || e.getClientRects().length);
}, d_ = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var n = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(n && e instanceof n.Element);
}, VQ = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, Xa = typeof window < "u" ? window : {}, Fu = /* @__PURE__ */ new WeakMap(), p_ = /auto|scroll/, HQ = /^tb|vertical/, qQ = /msie|trident/i.test(Xa.navigator && Xa.navigator.userAgent), vr = function(e) {
  return parseFloat(e || "0");
}, ms = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new UQ((n ? t : e) || 0, (n ? e : t) || 0);
}, h_ = To({
  devicePixelContentBoxSize: ms(),
  borderBoxSize: ms(),
  contentBoxSize: ms(),
  contentRect: new b4(0, 0, 0, 0)
}), v4 = function(e, t) {
  if (t === void 0 && (t = !1), Fu.has(e) && !t)
    return Fu.get(e);
  if (y4(e))
    return Fu.set(e, h_), h_;
  var n = getComputedStyle(e), r = v1(e) && e.ownerSVGElement && e.getBBox(), i = !qQ && n.boxSizing === "border-box", o = HQ.test(n.writingMode || ""), s = !r && p_.test(n.overflowY || ""), a = !r && p_.test(n.overflowX || ""), l = r ? 0 : vr(n.paddingTop), u = r ? 0 : vr(n.paddingRight), c = r ? 0 : vr(n.paddingBottom), f = r ? 0 : vr(n.paddingLeft), d = r ? 0 : vr(n.borderTopWidth), p = r ? 0 : vr(n.borderRightWidth), h = r ? 0 : vr(n.borderBottomWidth), m = r ? 0 : vr(n.borderLeftWidth), g = f + u, y = l + c, _ = m + p, E = d + h, v = a ? e.offsetHeight - E - e.clientHeight : 0, M = s ? e.offsetWidth - _ - e.clientWidth : 0, k = i ? g + _ : 0, T = i ? y + E : 0, U = r ? r.width : vr(n.width) - k - M, C = r ? r.height : vr(n.height) - T - v, z = U + g + M + _, H = C + y + v + E, j = To({
    devicePixelContentBoxSize: ms(Math.round(U * devicePixelRatio), Math.round(C * devicePixelRatio), o),
    borderBoxSize: ms(z, H, o),
    contentBoxSize: ms(U, C, o),
    contentRect: new b4(f, l, U, C)
  });
  return Fu.set(e, j), j;
}, _4 = function(e, t, n) {
  var r = v4(e, n), i = r.borderBoxSize, o = r.contentBoxSize, s = r.devicePixelContentBoxSize;
  switch (t) {
    case Cl.DEVICE_PIXEL_CONTENT_BOX:
      return s;
    case Cl.BORDER_BOX:
      return i;
    default:
      return o;
  }
}, GQ = /* @__PURE__ */ function() {
  function e(t) {
    var n = v4(t);
    this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = To([n.borderBoxSize]), this.contentBoxSize = To([n.contentBoxSize]), this.devicePixelContentBoxSize = To([n.devicePixelContentBoxSize]);
  }
  return e;
}(), E4 = function(e) {
  if (y4(e))
    return 1 / 0;
  for (var t = 0, n = e.parentNode; n; )
    t += 1, n = n.parentNode;
  return t;
}, WQ = function() {
  var e = 1 / 0, t = [];
  Ao.forEach(function(s) {
    if (s.activeTargets.length !== 0) {
      var a = [];
      s.activeTargets.forEach(function(u) {
        var c = new GQ(u.target), f = E4(u.target);
        a.push(c), u.lastReportedSize = _4(u.target, u.observedBox), f < e && (e = f);
      }), t.push(function() {
        s.callback.call(s.observer, a, s.observer);
      }), s.activeTargets.splice(0, s.activeTargets.length);
    }
  });
  for (var n = 0, r = t; n < r.length; n++) {
    var i = r[n];
    i();
  }
  return e;
}, g_ = function(e) {
  Ao.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(i) {
      i.isActive() && (E4(i.target) > e ? n.activeTargets.push(i) : n.skippedTargets.push(i));
    });
  });
}, KQ = function() {
  var e = 0;
  for (g_(e); zQ(); )
    e = WQ(), g_(e);
  return FQ() && jQ(), e > 0;
}, eh, w4 = [], YQ = function() {
  return w4.splice(0).forEach(function(e) {
    return e();
  });
}, QQ = function(e) {
  if (!eh) {
    var t = 0, n = document.createTextNode(""), r = { characterData: !0 };
    new MutationObserver(function() {
      return YQ();
    }).observe(n, r), eh = function() {
      n.textContent = "".concat(t ? t-- : t++);
    };
  }
  w4.push(e), eh();
}, ZQ = function(e) {
  QQ(function() {
    requestAnimationFrame(e);
  });
}, dc = 0, XQ = function() {
  return !!dc;
}, JQ = 250, eZ = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, m_ = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], b_ = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, th = !1, tZ = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var n = this;
    if (t === void 0 && (t = JQ), !th) {
      th = !0;
      var r = b_(t);
      ZQ(function() {
        var i = !1;
        try {
          i = KQ();
        } finally {
          if (th = !1, t = r - b_(), !XQ())
            return;
          i ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, n = function() {
      return t.observer && t.observer.observe(document.body, eZ);
    };
    document.body ? n() : Xa.addEventListener("DOMContentLoaded", n);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), m_.forEach(function(n) {
      return Xa.addEventListener(n, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), m_.forEach(function(n) {
      return Xa.removeEventListener(n, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), m0 = new tZ(), y_ = function(e) {
  !dc && e > 0 && m0.start(), dc += e, !dc && m0.stop();
}, nZ = function(e) {
  return !v1(e) && !VQ(e) && getComputedStyle(e).display === "inline";
}, rZ = function() {
  function e(t, n) {
    this.target = t, this.observedBox = n || Cl.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = _4(this.target, this.observedBox, !0);
    return nZ(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), iZ = /* @__PURE__ */ function() {
  function e(t, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
  }
  return e;
}(), ju = /* @__PURE__ */ new WeakMap(), v_ = function(e, t) {
  for (var n = 0; n < e.length; n += 1)
    if (e[n].target === t)
      return n;
  return -1;
}, Uu = function() {
  function e() {
  }
  return e.connect = function(t, n) {
    var r = new iZ(t, n);
    ju.set(t, r);
  }, e.observe = function(t, n, r) {
    var i = ju.get(t), o = i.observationTargets.length === 0;
    v_(i.observationTargets, n) < 0 && (o && Ao.push(i), i.observationTargets.push(new rZ(n, r && r.box)), y_(1), m0.schedule());
  }, e.unobserve = function(t, n) {
    var r = ju.get(t), i = v_(r.observationTargets, n), o = r.observationTargets.length === 1;
    i >= 0 && (o && Ao.splice(Ao.indexOf(r), 1), r.observationTargets.splice(i, 1), y_(-1));
  }, e.disconnect = function(t) {
    var n = this, r = ju.get(t);
    r.observationTargets.slice().forEach(function(i) {
      return n.unobserve(t, i.target);
    }), r.activeTargets.splice(0, r.activeTargets.length);
  }, e;
}(), oZ = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    Uu.connect(this, t);
  }
  return e.prototype.observe = function(t, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!d_(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Uu.observe(this, t, n);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!d_(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Uu.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    Uu.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
const sZ = globalThis.ResizeObserver || oZ, x4 = {
  duration: void 0,
  margin: {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  },
  padding: {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  },
  sizing: ci.Fit,
  width: void 0,
  height: void 0,
  svgDefs: void 0,
  ariaLabel: void 0
};
class Nl {
  constructor(t) {
    this._defaultConfig = x4, this._isFirstRender = !0, this._requestedAnimationFrame = null, this._container = t;
    const n = gs(this._container);
    n.attr("role", "figure"), this.svg = n.append("svg").style("display", "block").attr("xmlns", "http://www.w3.org/2000/svg").attr("height", Nl.DEFAULT_CONTAINER_HEIGHT).attr("aria-hidden", !0), this._svgDefs = this.svg.append("defs"), this._svgDefsExternal = this.svg.append("defs"), this.element = this.svg.node();
  }
  updateContainer(t) {
    this.prevConfig = this.config, this.config = Id(this._defaultConfig, t);
  }
  // The `_preRender` step should be used to perform some actions before rendering.
  // For example, calculating scales, setting component sizes, etc ...
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  _preRender() {
  }
  // The `_render` step should be used to perform the actual rendering
  _render(t) {
    const { config: n, prevConfig: r } = this;
    (n == null ? void 0 : n.svgDefs) !== (r == null ? void 0 : r.svgDefs) && (this._svgDefsExternal.selectAll("*").remove(), this._svgDefsExternal.html(n.svgDefs)), gs(this._container).attr("aria-label", n.ariaLabel), this._isFirstRender = !1;
  }
  // Warning: Some Containers (i.e. Single Container) may override this method, so if you introduce any changes here,
  // make sure to check that other containers didn't break after them.
  render(t = this.config.duration) {
    const n = this.config.width || this.containerWidth, r = this.config.height || this.containerHeight;
    this.svg.attr("width", n).attr("height", r), this._resizeObserver || this._setUpResizeObserver(), cancelAnimationFrame(this._requestedAnimationFrame), this._requestedAnimationFrame = requestAnimationFrame(() => {
      this._preRender(), this._render(t);
    });
  }
  get containerWidth() {
    return this.config.width ? this.element.clientWidth : this._container.clientWidth || this._container.getBoundingClientRect().width;
  }
  get containerHeight() {
    return this.config.height ? this.element.clientHeight : this._container.clientHeight || this._container.getBoundingClientRect().height || Nl.DEFAULT_CONTAINER_HEIGHT;
  }
  get width() {
    return g0(this.containerWidth - this.config.margin.left - this.config.margin.right, 0, Number.POSITIVE_INFINITY);
  }
  get height() {
    return g0(this.containerHeight - this.config.margin.top - this.config.margin.bottom, 0, Number.POSITIVE_INFINITY);
  }
  _removeAllChildren() {
    for (; this.element.firstChild; )
      this.element.removeChild(this.element.firstChild);
  }
  _onResize() {
    const { config: t } = this;
    (t.sizing === ci.Fit || t.sizing === ci.FitWidth) && this.render(0);
  }
  _setUpResizeObserver() {
    if (this._resizeObserver)
      return;
    const t = this._container.getBoundingClientRect();
    this._containerSize = { width: t.width, height: t.height }, this._resizeObserver = new sZ((n, r) => {
      const i = this._container.getBoundingClientRect(), o = { width: i.width, height: i.height };
      !$f(this._containerSize, o) && o.width && o.height && (this._containerSize = o, this._onResize());
    }), this._resizeObserver.observe(this._container);
  }
  destroy() {
    var t;
    cancelAnimationFrame(this._requestedAnimationFrame), (t = this._resizeObserver) === null || t === void 0 || t.disconnect(), this.svg.remove();
  }
}
Nl.DEFAULT_CONTAINER_HEIGHT = 300;
var aZ = !1;
function lZ(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function uZ(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var cZ = /* @__PURE__ */ function() {
  function e(n) {
    var r = this;
    this._insertTag = function(i) {
      var o;
      r.tags.length === 0 ? r.insertionPoint ? o = r.insertionPoint.nextSibling : r.prepend ? o = r.container.firstChild : o = r.before : o = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(i, o), r.tags.push(i);
    }, this.isSpeedy = n.speedy === void 0 ? !aZ : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(r) {
    r.forEach(this._insertTag);
  }, t.insert = function(r) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(uZ(this));
    var i = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var o = lZ(i);
      try {
        o.insertRule(r, o.cssRules.length);
      } catch {
      }
    } else
      i.appendChild(document.createTextNode(r));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(r) {
      var i;
      return (i = r.parentNode) == null ? void 0 : i.removeChild(r);
    }), this.tags = [], this.ctr = 0;
  }, e;
}(), rn = "-ms-", jf = "-moz-", Je = "-webkit-", k4 = "comm", _1 = "rule", E1 = "decl", fZ = "@import", M4 = "@keyframes", dZ = "@layer", pZ = Math.abs, Rd = String.fromCharCode, hZ = Object.assign;
function gZ(e, t) {
  return Kt(e, 0) ^ 45 ? (((t << 2 ^ Kt(e, 0)) << 2 ^ Kt(e, 1)) << 2 ^ Kt(e, 2)) << 2 ^ Kt(e, 3) : 0;
}
function A4(e) {
  return e.trim();
}
function mZ(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function et(e, t, n) {
  return e.replace(t, n);
}
function b0(e, t) {
  return e.indexOf(t);
}
function Kt(e, t) {
  return e.charCodeAt(t) | 0;
}
function Dl(e, t, n) {
  return e.slice(t, n);
}
function Sr(e) {
  return e.length;
}
function w1(e) {
  return e.length;
}
function Vu(e, t) {
  return t.push(e), e;
}
function bZ(e, t) {
  return e.map(t).join("");
}
var Ld = 1, Ks = 1, T4 = 0, On = 0, Ot = 0, sa = "";
function Bd(e, t, n, r, i, o, s) {
  return { value: e, root: t, parent: n, type: r, props: i, children: o, line: Ld, column: Ks, length: s, return: "" };
}
function pa(e, t) {
  return hZ(Bd("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function yZ() {
  return Ot;
}
function vZ() {
  return Ot = On > 0 ? Kt(sa, --On) : 0, Ks--, Ot === 10 && (Ks = 1, Ld--), Ot;
}
function Fn() {
  return Ot = On < T4 ? Kt(sa, On++) : 0, Ks++, Ot === 10 && (Ks = 1, Ld++), Ot;
}
function $r() {
  return Kt(sa, On);
}
function pc() {
  return On;
}
function iu(e, t) {
  return Dl(sa, e, t);
}
function Ol(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function S4(e) {
  return Ld = Ks = 1, T4 = Sr(sa = e), On = 0, [];
}
function C4(e) {
  return sa = "", e;
}
function hc(e) {
  return A4(iu(On - 1, y0(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function _Z(e) {
  for (; (Ot = $r()) && Ot < 33; )
    Fn();
  return Ol(e) > 2 || Ol(Ot) > 3 ? "" : " ";
}
function EZ(e, t) {
  for (; --t && Fn() && !(Ot < 48 || Ot > 102 || Ot > 57 && Ot < 65 || Ot > 70 && Ot < 97); )
    ;
  return iu(e, pc() + (t < 6 && $r() == 32 && Fn() == 32));
}
function y0(e) {
  for (; Fn(); )
    switch (Ot) {
      case e:
        return On;
      case 34:
      case 39:
        e !== 34 && e !== 39 && y0(Ot);
        break;
      case 40:
        e === 41 && y0(e);
        break;
      case 92:
        Fn();
        break;
    }
  return On;
}
function wZ(e, t) {
  for (; Fn() && e + Ot !== 57; )
    if (e + Ot === 84 && $r() === 47)
      break;
  return "/*" + iu(t, On - 1) + "*" + Rd(e === 47 ? e : Fn());
}
function xZ(e) {
  for (; !Ol($r()); )
    Fn();
  return iu(e, On);
}
function kZ(e) {
  return C4(gc("", null, null, null, [""], e = S4(e), 0, [0], e));
}
function gc(e, t, n, r, i, o, s, a, l) {
  for (var u = 0, c = 0, f = s, d = 0, p = 0, h = 0, m = 1, g = 1, y = 1, _ = 0, E = "", v = i, M = o, k = r, T = E; g; )
    switch (h = _, _ = Fn()) {
      case 40:
        if (h != 108 && Kt(T, f - 1) == 58) {
          b0(T += et(hc(_), "&", "&\f"), "&\f") != -1 && (y = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        T += hc(_);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        T += _Z(h);
        break;
      case 92:
        T += EZ(pc() - 1, 7);
        continue;
      case 47:
        switch ($r()) {
          case 42:
          case 47:
            Vu(MZ(wZ(Fn(), pc()), t, n), l);
            break;
          default:
            T += "/";
        }
        break;
      case 123 * m:
        a[u++] = Sr(T) * y;
      case 125 * m:
      case 59:
      case 0:
        switch (_) {
          case 0:
          case 125:
            g = 0;
          case 59 + c:
            y == -1 && (T = et(T, /\f/g, "")), p > 0 && Sr(T) - f && Vu(p > 32 ? E_(T + ";", r, n, f - 1) : E_(et(T, " ", "") + ";", r, n, f - 2), l);
            break;
          case 59:
            T += ";";
          default:
            if (Vu(k = __(T, t, n, u, c, i, a, E, v = [], M = [], f), o), _ === 123)
              if (c === 0)
                gc(T, t, k, k, v, o, f, a, M);
              else
                switch (d === 99 && Kt(T, 3) === 110 ? 100 : d) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    gc(e, k, k, r && Vu(__(e, k, k, 0, 0, i, a, E, i, v = [], f), M), i, M, f, a, r ? v : M);
                    break;
                  default:
                    gc(T, k, k, k, [""], M, 0, a, M);
                }
        }
        u = c = p = 0, m = y = 1, E = T = "", f = s;
        break;
      case 58:
        f = 1 + Sr(T), p = h;
      default:
        if (m < 1) {
          if (_ == 123)
            --m;
          else if (_ == 125 && m++ == 0 && vZ() == 125)
            continue;
        }
        switch (T += Rd(_), _ * m) {
          case 38:
            y = c > 0 ? 1 : (T += "\f", -1);
            break;
          case 44:
            a[u++] = (Sr(T) - 1) * y, y = 1;
            break;
          case 64:
            $r() === 45 && (T += hc(Fn())), d = $r(), c = f = Sr(E = T += xZ(pc())), _++;
            break;
          case 45:
            h === 45 && Sr(T) == 2 && (m = 0);
        }
    }
  return o;
}
function __(e, t, n, r, i, o, s, a, l, u, c) {
  for (var f = i - 1, d = i === 0 ? o : [""], p = w1(d), h = 0, m = 0, g = 0; h < r; ++h)
    for (var y = 0, _ = Dl(e, f + 1, f = pZ(m = s[h])), E = e; y < p; ++y)
      (E = A4(m > 0 ? d[y] + " " + _ : et(_, /&\f/g, d[y]))) && (l[g++] = E);
  return Bd(e, t, n, i === 0 ? _1 : a, l, u, c);
}
function MZ(e, t, n) {
  return Bd(e, t, n, k4, Rd(yZ()), Dl(e, 2, -2), 0);
}
function E_(e, t, n, r) {
  return Bd(e, t, n, E1, Dl(e, 0, r), Dl(e, r + 1, -1), r);
}
function bs(e, t) {
  for (var n = "", r = w1(e), i = 0; i < r; i++)
    n += t(e[i], i, e, t) || "";
  return n;
}
function AZ(e, t, n, r) {
  switch (e.type) {
    case dZ:
      if (e.children.length) break;
    case fZ:
    case E1:
      return e.return = e.return || e.value;
    case k4:
      return "";
    case M4:
      return e.return = e.value + "{" + bs(e.children, r) + "}";
    case _1:
      e.value = e.props.join(",");
  }
  return Sr(n = bs(e.children, r)) ? e.return = e.value + "{" + n + "}" : "";
}
function TZ(e) {
  var t = w1(e);
  return function(n, r, i, o) {
    for (var s = "", a = 0; a < t; a++)
      s += e[a](n, r, i, o) || "";
    return s;
  };
}
function SZ(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function CZ(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var NZ = function(t, n, r) {
  for (var i = 0, o = 0; i = o, o = $r(), i === 38 && o === 12 && (n[r] = 1), !Ol(o); )
    Fn();
  return iu(t, On);
}, DZ = function(t, n) {
  var r = -1, i = 44;
  do
    switch (Ol(i)) {
      case 0:
        i === 38 && $r() === 12 && (n[r] = 1), t[r] += NZ(On - 1, n, r);
        break;
      case 2:
        t[r] += hc(i);
        break;
      case 4:
        if (i === 44) {
          t[++r] = $r() === 58 ? "&\f" : "", n[r] = t[r].length;
          break;
        }
      default:
        t[r] += Rd(i);
    }
  while (i = Fn());
  return t;
}, OZ = function(t, n) {
  return C4(DZ(S4(t), n));
}, w_ = /* @__PURE__ */ new WeakMap(), IZ = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var n = t.value, r = t.parent, i = t.column === r.column && t.line === r.line; r.type !== "rule"; )
      if (r = r.parent, !r) return;
    if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !w_.get(r)) && !i) {
      w_.set(t, !0);
      for (var o = [], s = OZ(n, o), a = r.props, l = 0, u = 0; l < s.length; l++)
        for (var c = 0; c < a.length; c++, u++)
          t.props[u] = o[l] ? s[l].replace(/&\f/g, a[c]) : a[c] + " " + s[l];
    }
  }
}, RZ = function(t) {
  if (t.type === "decl") {
    var n = t.value;
    // charcode for l
    n.charCodeAt(0) === 108 && // charcode for b
    n.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
};
function N4(e, t) {
  switch (gZ(e, t)) {
    case 5103:
      return Je + "print-" + e + e;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return Je + e + e;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return Je + e + jf + e + rn + e + e;
    case 6828:
    case 4268:
      return Je + e + rn + e + e;
    case 6165:
      return Je + e + rn + "flex-" + e + e;
    case 5187:
      return Je + e + et(e, /(\w+).+(:[^]+)/, Je + "box-$1$2" + rn + "flex-$1$2") + e;
    case 5443:
      return Je + e + rn + "flex-item-" + et(e, /flex-|-self/, "") + e;
    case 4675:
      return Je + e + rn + "flex-line-pack" + et(e, /align-content|flex-|-self/, "") + e;
    case 5548:
      return Je + e + rn + et(e, "shrink", "negative") + e;
    case 5292:
      return Je + e + rn + et(e, "basis", "preferred-size") + e;
    case 6060:
      return Je + "box-" + et(e, "-grow", "") + Je + e + rn + et(e, "grow", "positive") + e;
    case 4554:
      return Je + et(e, /([^-])(transform)/g, "$1" + Je + "$2") + e;
    case 6187:
      return et(et(et(e, /(zoom-|grab)/, Je + "$1"), /(image-set)/, Je + "$1"), e, "") + e;
    case 5495:
    case 3959:
      return et(e, /(image-set\([^]*)/, Je + "$1$`$1");
    case 4968:
      return et(et(e, /(.+:)(flex-)?(.*)/, Je + "box-pack:$3" + rn + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + Je + e + e;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return et(e, /(.+)-inline(.+)/, Je + "$1$2") + e;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Sr(e) - 1 - t > 6) switch (Kt(e, t + 1)) {
        case 109:
          if (Kt(e, t + 4) !== 45) break;
        case 102:
          return et(e, /(.+:)(.+)-([^]+)/, "$1" + Je + "$2-$3$1" + jf + (Kt(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
        case 115:
          return ~b0(e, "stretch") ? N4(et(e, "stretch", "fill-available"), t) + e : e;
      }
      break;
    case 4949:
      if (Kt(e, t + 1) !== 115) break;
    case 6444:
      switch (Kt(e, Sr(e) - 3 - (~b0(e, "!important") && 10))) {
        case 107:
          return et(e, ":", ":" + Je) + e;
        case 101:
          return et(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + Je + (Kt(e, 14) === 45 ? "inline-" : "") + "box$3$1" + Je + "$2$3$1" + rn + "$2box$3") + e;
      }
      break;
    case 5936:
      switch (Kt(e, t + 11)) {
        case 114:
          return Je + e + rn + et(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        case 108:
          return Je + e + rn + et(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        case 45:
          return Je + e + rn + et(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return Je + e + rn + e + e;
  }
  return e;
}
var LZ = function(t, n, r, i) {
  if (t.length > -1 && !t.return) switch (t.type) {
    case E1:
      t.return = N4(t.value, t.length);
      break;
    case M4:
      return bs([pa(t, {
        value: et(t.value, "@", "@" + Je)
      })], i);
    case _1:
      if (t.length) return bZ(t.props, function(o) {
        switch (mZ(o, /(::plac\w+|:read-\w+)/)) {
          case ":read-only":
          case ":read-write":
            return bs([pa(t, {
              props: [et(o, /:(read-\w+)/, ":" + jf + "$1")]
            })], i);
          case "::placeholder":
            return bs([pa(t, {
              props: [et(o, /:(plac\w+)/, ":" + Je + "input-$1")]
            }), pa(t, {
              props: [et(o, /:(plac\w+)/, ":" + jf + "$1")]
            }), pa(t, {
              props: [et(o, /:(plac\w+)/, rn + "input-$1")]
            })], i);
        }
        return "";
      });
  }
}, BZ = [LZ], PZ = function(t) {
  var n = t.key;
  if (n === "css") {
    var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(r, function(m) {
      var g = m.getAttribute("data-emotion");
      g.indexOf(" ") !== -1 && (document.head.appendChild(m), m.setAttribute("data-s", ""));
    });
  }
  var i = t.stylisPlugins || BZ, o = {}, s, a = [];
  s = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
    function(m) {
      for (var g = m.getAttribute("data-emotion").split(" "), y = 1; y < g.length; y++)
        o[g[y]] = !0;
      a.push(m);
    }
  );
  var l, u = [IZ, RZ];
  {
    var c, f = [AZ, SZ(function(m) {
      c.insert(m);
    })], d = TZ(u.concat(i, f)), p = function(g) {
      return bs(kZ(g), d);
    };
    l = function(g, y, _, E) {
      c = _, p(g ? g + "{" + y.styles + "}" : y.styles), E && (h.inserted[y.name] = !0);
    };
  }
  var h = {
    key: n,
    sheet: new cZ({
      key: n,
      container: s,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: o,
    registered: {},
    insert: l
  };
  return h.sheet.hydrate(a), h;
};
function $Z(e) {
  for (var t = 0, n, r = 0, i = e.length; i >= 4; ++r, i -= 4)
    n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (i) {
    case 3:
      t ^= (e.charCodeAt(r + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(r + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(r) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var zZ = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, FZ = !1, jZ = /[A-Z]|^ms/g, UZ = /_EMO_([^_]+?)_([^]*?)_EMO_/g, D4 = function(t) {
  return t.charCodeAt(1) === 45;
}, x_ = function(t) {
  return t != null && typeof t != "boolean";
}, nh = /* @__PURE__ */ CZ(function(e) {
  return D4(e) ? e : e.replace(jZ, "-$&").toLowerCase();
}), k_ = function(t, n) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof n == "string")
        return n.replace(UZ, function(r, i, o) {
          return $i = {
            name: i,
            styles: o,
            next: $i
          }, i;
        });
  }
  return zZ[t] !== 1 && !D4(t) && typeof n == "number" && n !== 0 ? n + "px" : n;
}, VZ = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function Uf(e, t, n) {
  if (n == null)
    return "";
  var r = n;
  if (r.__emotion_styles !== void 0)
    return r;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      var i = n;
      if (i.anim === 1)
        return $i = {
          name: i.name,
          styles: i.styles,
          next: $i
        }, i.name;
      var o = n;
      if (o.styles !== void 0) {
        var s = o.next;
        if (s !== void 0)
          for (; s !== void 0; )
            $i = {
              name: s.name,
              styles: s.styles,
              next: $i
            }, s = s.next;
        var a = o.styles + ";";
        return a;
      }
      return HZ(e, t, n);
    }
  }
  var l = n;
  if (t == null)
    return l;
  var u = t[l];
  return u !== void 0 ? u : l;
}
function HZ(e, t, n) {
  var r = "";
  if (Array.isArray(n))
    for (var i = 0; i < n.length; i++)
      r += Uf(e, t, n[i]) + ";";
  else
    for (var o in n) {
      var s = n[o];
      if (typeof s != "object") {
        var a = s;
        t != null && t[a] !== void 0 ? r += o + "{" + t[a] + "}" : x_(a) && (r += nh(o) + ":" + k_(o, a) + ";");
      } else {
        if (o === "NO_COMPONENT_SELECTOR" && FZ)
          throw new Error(VZ);
        if (Array.isArray(s) && typeof s[0] == "string" && (t == null || t[s[0]] === void 0))
          for (var l = 0; l < s.length; l++)
            x_(s[l]) && (r += nh(o) + ":" + k_(o, s[l]) + ";");
        else {
          var u = Uf(e, t, s);
          switch (o) {
            case "animation":
            case "animationName": {
              r += nh(o) + ":" + u + ";";
              break;
            }
            default:
              r += o + "{" + u + "}";
          }
        }
      }
    }
  return r;
}
var M_ = /label:\s*([^\s;{]+)\s*(;|$)/g, $i;
function rh(e, t, n) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var r = !0, i = "";
  $i = void 0;
  var o = e[0];
  if (o == null || o.raw === void 0)
    r = !1, i += Uf(n, t, o);
  else {
    var s = o;
    i += s[0];
  }
  for (var a = 1; a < e.length; a++)
    if (i += Uf(n, t, e[a]), r) {
      var l = o;
      i += l[a];
    }
  M_.lastIndex = 0;
  for (var u = "", c; (c = M_.exec(i)) !== null; )
    u += "-" + c[1];
  var f = $Z(i) + u;
  return {
    name: f,
    styles: i,
    next: $i
  };
}
function O4(e, t, n) {
  var r = "";
  return n.split(" ").forEach(function(i) {
    e[i] !== void 0 ? t.push(e[i] + ";") : i && (r += i + " ");
  }), r;
}
var qZ = function(t, n, r) {
  var i = t.key + "-" + n.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  t.registered[i] === void 0 && (t.registered[i] = n.styles);
}, GZ = function(t, n, r) {
  qZ(t, n);
  var i = t.key + "-" + n.name;
  if (t.inserted[n.name] === void 0) {
    var o = n;
    do
      t.insert(n === o ? "." + i : "", o, t.sheet, !0), o = o.next;
    while (o !== void 0);
  }
};
function A_(e, t) {
  if (e.inserted[t.name] === void 0)
    return e.insert("", t, e.sheet, !0);
}
function T_(e, t, n) {
  var r = [], i = O4(e, r, n);
  return r.length < 2 ? n : i + t(r);
}
var WZ = function(t) {
  var n = PZ(t);
  n.sheet.speedy = function(a) {
    this.isSpeedy = a;
  }, n.compat = !0;
  var r = function() {
    for (var l = arguments.length, u = new Array(l), c = 0; c < l; c++)
      u[c] = arguments[c];
    var f = rh(u, n.registered, void 0);
    return GZ(n, f), n.key + "-" + f.name;
  }, i = function() {
    for (var l = arguments.length, u = new Array(l), c = 0; c < l; c++)
      u[c] = arguments[c];
    var f = rh(u, n.registered), d = "animation-" + f.name;
    return A_(n, {
      name: f.name,
      styles: "@keyframes " + d + "{" + f.styles + "}"
    }), d;
  }, o = function() {
    for (var l = arguments.length, u = new Array(l), c = 0; c < l; c++)
      u[c] = arguments[c];
    var f = rh(u, n.registered);
    A_(n, f);
  }, s = function() {
    for (var l = arguments.length, u = new Array(l), c = 0; c < l; c++)
      u[c] = arguments[c];
    return T_(n.registered, r, KZ(u));
  };
  return {
    css: r,
    cx: s,
    injectGlobal: o,
    keyframes: i,
    hydrate: function(l) {
      l.forEach(function(u) {
        n.inserted[u] = !0;
      });
    },
    flush: function() {
      n.registered = {}, n.inserted = {}, n.sheet.flush();
    },
    sheet: n.sheet,
    cache: n,
    getRegisteredStyles: O4.bind(null, n.registered),
    merge: T_.bind(null, n.registered, r)
  };
}, KZ = function e(t) {
  for (var n = "", r = 0; r < t.length; r++) {
    var i = t[r];
    if (i != null) {
      var o = void 0;
      switch (typeof i) {
        case "boolean":
          break;
        case "object": {
          if (Array.isArray(i))
            o = e(i);
          else {
            o = "";
            for (var s in i)
              i[s] && s && (o && (o += " "), o += s);
          }
          break;
        }
        default:
          o = i;
      }
      o && (n && (n += " "), n += o);
    }
  }
  return n;
}, I4 = WZ({
  key: "css"
}), x1 = I4.injectGlobal, hr = I4.css, YZ = function(t, n) {
  n || (n = [0, ""]), t = String(t);
  var r = parseFloat(t, 10);
  return n[0] = r, n[1] = t.match(/[\d.\-\+]*\s*(.*)/)[1] || "", n;
}, R4 = YZ, ha = L4("in", document.body);
function v0(e, t) {
  var n = R4(getComputedStyle(e).getPropertyValue(t));
  return n[0] * B4(n[1], e);
}
function L4(e, t) {
  var n = document.createElement("div");
  n.style.height = "128" + e, t.appendChild(n);
  var r = v0(n, "height") / 128;
  return t.removeChild(n), r;
}
function B4(e, t) {
  if (!e) return null;
  switch (t = t || document.body, e = (e + "" || "px").trim().toLowerCase(), (t === window || t === document) && (t = document.body), e) {
    case "%":
      return t.clientHeight / 100;
    case "ch":
    case "ex":
      return L4(e, t);
    case "em":
      return v0(t, "font-size");
    case "rem":
      return v0(document.body, "font-size");
    case "vw":
      return window.innerWidth / 100;
    case "vh":
      return window.innerHeight / 100;
    case "vmin":
      return Math.min(window.innerWidth, window.innerHeight) / 100;
    case "vmax":
      return Math.max(window.innerWidth, window.innerHeight) / 100;
    case "in":
      return ha;
    case "cm":
      return ha / 2.54;
    case "mm":
      return ha / 25.4;
    case "pt":
      return ha / 72;
    case "pc":
      return ha / 6;
    case "px":
      return 1;
  }
  var n = R4(e);
  if (!isNaN(n[0]) && n[1]) {
    var r = B4(n[1], t);
    return typeof r == "number" ? n[0] * r : null;
  }
  return null;
}
function QZ() {
  const e = () => Math.floor((1 + crypto.getRandomValues(new Uint32Array(1))[0]) * 65536).toString(16).substring(1);
  return `${e() + e()}-${e()}-${e()}-${e()}-${e()}${e()}${e()}`;
}
function k1(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function P4(e, t) {
  var n = Object.create(e.prototype);
  for (var r in t) n[r] = t[r];
  return n;
}
function ou() {
}
var Il = 0.7, Vf = 1 / Il, ys = "\\s*([+-]?\\d+)\\s*", Rl = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", zr = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", ZZ = /^#([0-9a-f]{3,8})$/, XZ = new RegExp(`^rgb\\(${ys},${ys},${ys}\\)$`), JZ = new RegExp(`^rgb\\(${zr},${zr},${zr}\\)$`), eX = new RegExp(`^rgba\\(${ys},${ys},${ys},${Rl}\\)$`), tX = new RegExp(`^rgba\\(${zr},${zr},${zr},${Rl}\\)$`), nX = new RegExp(`^hsl\\(${Rl},${zr},${zr}\\)$`), rX = new RegExp(`^hsla\\(${Rl},${zr},${zr},${Rl}\\)$`), S_ = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
k1(ou, Bo, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: C_,
  // Deprecated! Use color.formatHex.
  formatHex: C_,
  formatHex8: iX,
  formatHsl: oX,
  formatRgb: N_,
  toString: N_
});
function C_() {
  return this.rgb().formatHex();
}
function iX() {
  return this.rgb().formatHex8();
}
function oX() {
  return $4(this).formatHsl();
}
function N_() {
  return this.rgb().formatRgb();
}
function Bo(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = ZZ.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? D_(t) : n === 3 ? new kn(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? Hu(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? Hu(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = XZ.exec(e)) ? new kn(t[1], t[2], t[3], 1) : (t = JZ.exec(e)) ? new kn(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = eX.exec(e)) ? Hu(t[1], t[2], t[3], t[4]) : (t = tX.exec(e)) ? Hu(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = nX.exec(e)) ? R_(t[1], t[2] / 100, t[3] / 100, 1) : (t = rX.exec(e)) ? R_(t[1], t[2] / 100, t[3] / 100, t[4]) : S_.hasOwnProperty(e) ? D_(S_[e]) : e === "transparent" ? new kn(NaN, NaN, NaN, 0) : null;
}
function D_(e) {
  return new kn(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function Hu(e, t, n, r) {
  return r <= 0 && (e = t = n = NaN), new kn(e, t, n, r);
}
function sX(e) {
  return e instanceof ou || (e = Bo(e)), e ? (e = e.rgb(), new kn(e.r, e.g, e.b, e.opacity)) : new kn();
}
function _0(e, t, n, r) {
  return arguments.length === 1 ? sX(e) : new kn(e, t, n, r ?? 1);
}
function kn(e, t, n, r) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +r;
}
k1(kn, _0, P4(ou, {
  brighter(e) {
    return e = e == null ? Vf : Math.pow(Vf, e), new kn(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Il : Math.pow(Il, e), new kn(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new kn(So(this.r), So(this.g), So(this.b), Hf(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: O_,
  // Deprecated! Use color.formatHex.
  formatHex: O_,
  formatHex8: aX,
  formatRgb: I_,
  toString: I_
}));
function O_() {
  return `#${mo(this.r)}${mo(this.g)}${mo(this.b)}`;
}
function aX() {
  return `#${mo(this.r)}${mo(this.g)}${mo(this.b)}${mo((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function I_() {
  const e = Hf(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${So(this.r)}, ${So(this.g)}, ${So(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function Hf(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function So(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function mo(e) {
  return e = So(e), (e < 16 ? "0" : "") + e.toString(16);
}
function R_(e, t, n, r) {
  return r <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new ar(e, t, n, r);
}
function $4(e) {
  if (e instanceof ar) return new ar(e.h, e.s, e.l, e.opacity);
  if (e instanceof ou || (e = Bo(e)), !e) return new ar();
  if (e instanceof ar) return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, r = e.b / 255, i = Math.min(t, n, r), o = Math.max(t, n, r), s = NaN, a = o - i, l = (o + i) / 2;
  return a ? (t === o ? s = (n - r) / a + (n < r) * 6 : n === o ? s = (r - t) / a + 2 : s = (t - n) / a + 4, a /= l < 0.5 ? o + i : 2 - o - i, s *= 60) : a = l > 0 && l < 1 ? 0 : s, new ar(s, a, l, e.opacity);
}
function M1(e, t, n, r) {
  return arguments.length === 1 ? $4(e) : new ar(e, t, n, r ?? 1);
}
function ar(e, t, n, r) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;
}
k1(ar, M1, P4(ou, {
  brighter(e) {
    return e = e == null ? Vf : Math.pow(Vf, e), new ar(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Il : Math.pow(Il, e), new ar(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * t, i = 2 * n - r;
    return new kn(
      ih(e >= 240 ? e - 240 : e + 120, i, r),
      ih(e, i, r),
      ih(e < 120 ? e + 240 : e - 120, i, r),
      this.opacity
    );
  },
  clamp() {
    return new ar(L_(this.h), qu(this.s), qu(this.l), Hf(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = Hf(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${L_(this.h)}, ${qu(this.s) * 100}%, ${qu(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function L_(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function qu(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function ih(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const ka = (globalThis == null ? void 0 : globalThis.UNOVIS_COLORS) || ["#4D8CFD", "#FF6B7E", "#F4B83E", "#A6CC74", "#00C19A", "#6859BE"], lX = (globalThis == null ? void 0 : globalThis.UNOVIS_COLORS_DARK) || ["#4D8CFD", "#FF6B7E", "#FFC16D", "#A6CC74", "#00C19A", "#7887E0"], xi = (e) => `--vis-${y1(e) ? `color${e % ka.length}` : e}`;
function uX(e, t = 0.4) {
  const n = M1(e);
  return n.l = n.l * (1 + t), n.formatHex();
}
function cX(e, t = 0.4, n = 0.6) {
  const r = M1(e);
  return r.s = r.s * (1 - n), r.l = r.l * (1 - t), r.formatHex();
}
const qf = 10, E0 = [
  { id: "stripes-diagonal", svg: '<path d="M-1,1 l2,-2 M0,10 l10,-10 M9,11 l2,-2" stroke="#000"/>' },
  { id: "dots", svg: '<path d="m0-1.5a1 1 0 010 3m10-3a1 1 0 000 3M5 3.5a1 1 0 010 3 1 1 0 010-3M0 8.5 a1 1 0 010 3m10-3a1 1 0 000 3" fill"#000"/>' },
  { id: "stripes-vertical", svg: '<path d="M 5,-1 L5,11" stroke="#000"/>' },
  { id: "crosshatch", svg: '<path d="M0 0L10 10ZM10 0L0 10Z" stroke="#000"/>' },
  { id: "waves", svg: '<path d="M0 4Q2.5 1 5 4 7.5 7 10 4v2Q7.5 9 5 6 2.5 3 0 6Z" fill="#000"/>' },
  { id: "circles", svg: '<circle cx="5" cy="5" r="3" stroke="#000" fill="#fff"/>' }
], w0 = [
  { id: "circle", marker: '<circle cx="5" cy="5" r="5"/>', dashArray: [] },
  { id: "triangle", marker: '<path d="M5,0 L10,9 L0,9Z">', dashArray: [9, 1] },
  { id: "diamond", marker: '<path d="M 0 5 L5 0 L 10 5 L 5 10 L 0 5Z">', dashArray: [2] },
  { id: "arrow", marker: '<path d="M4 0 0 0 6 5 0 10 4 10 10 5Z">', dashArray: [2, 3, 8, 3] },
  { id: "square", marker: '<rect x="1" y="1" width="8" height="8"/>', dashArray: [6] },
  { id: "star", marker: '<path d="m2 9 3-9 3 9L0 3h10Z"/>', dashArray: [1, 6] }
];
function ki(e) {
  return `vis-${`pattern-${e.svg ? "fill" : "marker"}`}-${e.id}`;
}
const fX = (e) => `<mask id="${ki(e)}">
    <pattern id="${e.id}" viewBox="0 0 10 10" width="${qf}" height="${qf}" patternUnits="userSpaceOnUse">
      <rect width="100%" height="100%" fill="#fff"/>
      ${e.svg}
    </pattern>
    <rect x="-50%" y="-50%" width="200%" height="200%" fill="url(#${e.id})"/>
  </mask>`, dX = (e, t) => `<marker id="${ki(e)}"
    fill="var(${xi(t)})"
    markerUnits="userSpaceOnUse"
    refX="5"
    refY="5"
    markerWidth="${qf}"
    markerHeight="${qf}">
    ${e.marker}
  </marker>`;
function pX() {
  const e = E0.map(fX).concat(w0.map(dX)).join(""), t = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  t.setAttribute("height", "100%"), t.setAttribute("width", "100%"), t.style.position = "fixed", t.style.zIndex = "-99999999", t.innerHTML = `<defs>${e}</defs>`, document.body.appendChild(t);
}
typeof window < "u" && pX();
const hX = (globalThis == null ? void 0 : globalThis.UNOVIS_FONT_W2H_RATIO_DEFAULT) || 0.5;
x1`
  :root {
    label: vis-root-styles;
    --vis-font-family: Inter, Arial, "Helvetica Neue", Helvetica, sans-serif;
    --vis-font-wh-ratio: ${hX};
    --vis-color-main: var(${xi(0)});
    --vis-color-main-light: ${uX(ka[0])};
    --vis-color-main-dark: ${cX(ka[0])};
    --vis-color-grey: #2a2a2a;
    ${ka.map((e, t) => `${xi(t)}: ${e};`)}
    ${lX.map((e, t) => `--vis-dark-color${t}: ${e};`)}
    ${E0.map((e, t) => `
      --${ki(e)}: url(#${ki(e)});
      --vis-pattern-fill${t}: var(--${ki(e)});
    `)}
    ${w0.map((e, t) => {
  var n;
  return `
      --${ki(e)}: url(#${ki(e)});
      --vis-pattern-marker${t}: var(--${ki(e)});
      --vis-pattern-dasharray${t}: ${(n = e.dashArray) === null || n === void 0 ? void 0 : n.join(" ")};
    `;
})}

    body.theme-dark {
      ${ka.map((e, t) => `${xi(t)}: var(--vis-dark-color${t});`)}
    }

    body.theme-patterns {
      ${E0.map((e, t) => `path[style*="fill: var(${xi(t)})"]  {
        mask: var(--vis-pattern-fill${t});
      }`)}
      ${w0.map((e, t) => `
      path[stroke="var(${xi(t)})"]:not([style*="fill"]),
      path[style*="stroke: var(${xi(t)})"]:not([style*="fill"]) {
        marker: var(--vis-pattern-marker${t});
        stroke-dasharray: var(--vis-pattern-dasharray${t});
      }
    `)}
}
`;
var gX = { value: () => {
} };
function z4() {
  for (var e = 0, t = arguments.length, n = {}, r; e < t; ++e) {
    if (!(r = arguments[e] + "") || r in n || /[\s.]/.test(r)) throw new Error("illegal type: " + r);
    n[r] = [];
  }
  return new mc(n);
}
function mc(e) {
  this._ = e;
}
function mX(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var r = "", i = n.indexOf(".");
    if (i >= 0 && (r = n.slice(i + 1), n = n.slice(0, i)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);
    return { type: n, name: r };
  });
}
mc.prototype = z4.prototype = {
  constructor: mc,
  on: function(e, t) {
    var n = this._, r = mX(e + "", n), i, o = -1, s = r.length;
    if (arguments.length < 2) {
      for (; ++o < s; ) if ((i = (e = r[o]).type) && (i = bX(n[i], e.name))) return i;
      return;
    }
    if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
    for (; ++o < s; )
      if (i = (e = r[o]).type) n[i] = B_(n[i], e.name, t);
      else if (t == null) for (i in n) n[i] = B_(n[i], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t) e[n] = t[n].slice();
    return new mc(e);
  },
  call: function(e, t) {
    if ((i = arguments.length - 2) > 0) for (var n = new Array(i), r = 0, i, o; r < i; ++r) n[r] = arguments[r + 2];
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (o = this._[e], r = 0, i = o.length; r < i; ++r) o[r].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (var r = this._[e], i = 0, o = r.length; i < o; ++i) r[i].value.apply(t, n);
  }
};
function bX(e, t) {
  for (var n = 0, r = e.length, i; n < r; ++n)
    if ((i = e[n]).name === t)
      return i.value;
}
function B_(e, t, n) {
  for (var r = 0, i = e.length; r < i; ++r)
    if (e[r].name === t) {
      e[r] = gX, e = e.slice(0, r).concat(e.slice(r + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var Ys = 0, Ma = 0, ga = 0, F4 = 1e3, Gf, Aa, Wf = 0, Po = 0, Pd = 0, Ll = typeof performance == "object" && performance.now ? performance : Date, j4 = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function A1() {
  return Po || (j4(yX), Po = Ll.now() + Pd);
}
function yX() {
  Po = 0;
}
function Kf() {
  this._call = this._time = this._next = null;
}
Kf.prototype = U4.prototype = {
  constructor: Kf,
  restart: function(e, t, n) {
    if (typeof e != "function") throw new TypeError("callback is not a function");
    n = (n == null ? A1() : +n) + (t == null ? 0 : +t), !this._next && Aa !== this && (Aa ? Aa._next = this : Gf = this, Aa = this), this._call = e, this._time = n, x0();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, x0());
  }
};
function U4(e, t, n) {
  var r = new Kf();
  return r.restart(e, t, n), r;
}
function vX() {
  A1(), ++Ys;
  for (var e = Gf, t; e; )
    (t = Po - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --Ys;
}
function P_() {
  Po = (Wf = Ll.now()) + Pd, Ys = Ma = 0;
  try {
    vX();
  } finally {
    Ys = 0, EX(), Po = 0;
  }
}
function _X() {
  var e = Ll.now(), t = e - Wf;
  t > F4 && (Pd -= t, Wf = e);
}
function EX() {
  for (var e, t = Gf, n, r = 1 / 0; t; )
    t._call ? (r > t._time && (r = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : Gf = n);
  Aa = e, x0(r);
}
function x0(e) {
  if (!Ys) {
    Ma && (Ma = clearTimeout(Ma));
    var t = e - Po;
    t > 24 ? (e < 1 / 0 && (Ma = setTimeout(P_, e - Ll.now() - Pd)), ga && (ga = clearInterval(ga))) : (ga || (Wf = Ll.now(), ga = setInterval(_X, F4)), Ys = 1, j4(P_));
  }
}
function $_(e, t, n) {
  var r = new Kf();
  return t = t == null ? 0 : +t, r.restart((i) => {
    r.stop(), e(i + t);
  }, t, n), r;
}
var wX = z4("start", "end", "cancel", "interrupt"), xX = [], V4 = 0, z_ = 1, k0 = 2, bc = 3, F_ = 4, M0 = 5, yc = 6;
function $d(e, t, n, r, i, o) {
  var s = e.__transition;
  if (!s) e.__transition = {};
  else if (n in s) return;
  kX(e, n, {
    name: t,
    index: r,
    // For context during callback.
    group: i,
    // For context during callback.
    on: wX,
    tween: xX,
    time: o.time,
    delay: o.delay,
    duration: o.duration,
    ease: o.ease,
    timer: null,
    state: V4
  });
}
function T1(e, t) {
  var n = gr(e, t);
  if (n.state > V4) throw new Error("too late; already scheduled");
  return n;
}
function Xr(e, t) {
  var n = gr(e, t);
  if (n.state > bc) throw new Error("too late; already running");
  return n;
}
function gr(e, t) {
  var n = e.__transition;
  if (!n || !(n = n[t])) throw new Error("transition not found");
  return n;
}
function kX(e, t, n) {
  var r = e.__transition, i;
  r[t] = n, n.timer = U4(o, 0, n.time);
  function o(u) {
    n.state = z_, n.timer.restart(s, n.delay, n.time), n.delay <= u && s(u - n.delay);
  }
  function s(u) {
    var c, f, d, p;
    if (n.state !== z_) return l();
    for (c in r)
      if (p = r[c], p.name === n.name) {
        if (p.state === bc) return $_(s);
        p.state === F_ ? (p.state = yc, p.timer.stop(), p.on.call("interrupt", e, e.__data__, p.index, p.group), delete r[c]) : +c < t && (p.state = yc, p.timer.stop(), p.on.call("cancel", e, e.__data__, p.index, p.group), delete r[c]);
      }
    if ($_(function() {
      n.state === bc && (n.state = F_, n.timer.restart(a, n.delay, n.time), a(u));
    }), n.state = k0, n.on.call("start", e, e.__data__, n.index, n.group), n.state === k0) {
      for (n.state = bc, i = new Array(d = n.tween.length), c = 0, f = -1; c < d; ++c)
        (p = n.tween[c].value.call(e, e.__data__, n.index, n.group)) && (i[++f] = p);
      i.length = f + 1;
    }
  }
  function a(u) {
    for (var c = u < n.duration ? n.ease.call(null, u / n.duration) : (n.timer.restart(l), n.state = M0, 1), f = -1, d = i.length; ++f < d; )
      i[f].call(e, c);
    n.state === M0 && (n.on.call("end", e, e.__data__, n.index, n.group), l());
  }
  function l() {
    n.state = yc, n.timer.stop(), delete r[t];
    for (var u in r) return;
    delete e.__transition;
  }
}
function H4(e, t) {
  var n = e.__transition, r, i, o = !0, s;
  if (n) {
    t = t == null ? null : t + "";
    for (s in n) {
      if ((r = n[s]).name !== t) {
        o = !1;
        continue;
      }
      i = r.state > k0 && r.state < M0, r.state = yc, r.timer.stop(), r.on.call(i ? "interrupt" : "cancel", e, e.__data__, r.index, r.group), delete n[s];
    }
    o && delete e.__transition;
  }
}
function MX(e) {
  return this.each(function() {
    H4(this, e);
  });
}
const S1 = (e) => () => e;
function AX(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function TX(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(r) {
    return Math.pow(e + r * t, n);
  };
}
function SX(e) {
  return (e = +e) == 1 ? q4 : function(t, n) {
    return n - t ? TX(t, n, e) : S1(isNaN(t) ? n : t);
  };
}
function q4(e, t) {
  var n = t - e;
  return n ? AX(e, n) : S1(isNaN(e) ? t : e);
}
const Yf = function e(t) {
  var n = SX(t);
  function r(i, o) {
    var s = n((i = _0(i)).r, (o = _0(o)).r), a = n(i.g, o.g), l = n(i.b, o.b), u = q4(i.opacity, o.opacity);
    return function(c) {
      return i.r = s(c), i.g = a(c), i.b = l(c), i.opacity = u(c), i + "";
    };
  }
  return r.gamma = e, r;
}(1);
function CX(e, t) {
  t || (t = []);
  var n = e ? Math.min(t.length, e.length) : 0, r = t.slice(), i;
  return function(o) {
    for (i = 0; i < n; ++i) r[i] = e[i] * (1 - o) + t[i] * o;
    return r;
  };
}
function NX(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function DX(e, t) {
  var n = t ? t.length : 0, r = e ? Math.min(n, e.length) : 0, i = new Array(r), o = new Array(n), s;
  for (s = 0; s < r; ++s) i[s] = C1(e[s], t[s]);
  for (; s < n; ++s) o[s] = t[s];
  return function(a) {
    for (s = 0; s < r; ++s) o[s] = i[s](a);
    return o;
  };
}
function OX(e, t) {
  var n = /* @__PURE__ */ new Date();
  return e = +e, t = +t, function(r) {
    return n.setTime(e * (1 - r) + t * r), n;
  };
}
function Cr(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
function IX(e, t) {
  var n = {}, r = {}, i;
  (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
  for (i in t)
    i in e ? n[i] = C1(e[i], t[i]) : r[i] = t[i];
  return function(o) {
    for (i in n) r[i] = n[i](o);
    return r;
  };
}
var A0 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, oh = new RegExp(A0.source, "g");
function RX(e) {
  return function() {
    return e;
  };
}
function LX(e) {
  return function(t) {
    return e(t) + "";
  };
}
function G4(e, t) {
  var n = A0.lastIndex = oh.lastIndex = 0, r, i, o, s = -1, a = [], l = [];
  for (e = e + "", t = t + ""; (r = A0.exec(e)) && (i = oh.exec(t)); )
    (o = i.index) > n && (o = t.slice(n, o), a[s] ? a[s] += o : a[++s] = o), (r = r[0]) === (i = i[0]) ? a[s] ? a[s] += i : a[++s] = i : (a[++s] = null, l.push({ i: s, x: Cr(r, i) })), n = oh.lastIndex;
  return n < t.length && (o = t.slice(n), a[s] ? a[s] += o : a[++s] = o), a.length < 2 ? l[0] ? LX(l[0].x) : RX(t) : (t = l.length, function(u) {
    for (var c = 0, f; c < t; ++c) a[(f = l[c]).i] = f.x(u);
    return a.join("");
  });
}
function C1(e, t) {
  var n = typeof t, r;
  return t == null || n === "boolean" ? S1(t) : (n === "number" ? Cr : n === "string" ? (r = Bo(t)) ? (t = r, Yf) : G4 : t instanceof Bo ? Yf : t instanceof Date ? OX : NX(t) ? CX : Array.isArray(t) ? DX : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? IX : Cr)(e, t);
}
var j_ = 180 / Math.PI, T0 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function W4(e, t, n, r, i, o) {
  var s, a, l;
  return (s = Math.sqrt(e * e + t * t)) && (e /= s, t /= s), (l = e * n + t * r) && (n -= e * l, r -= t * l), (a = Math.sqrt(n * n + r * r)) && (n /= a, r /= a, l /= a), e * r < t * n && (e = -e, t = -t, l = -l, s = -s), {
    translateX: i,
    translateY: o,
    rotate: Math.atan2(t, e) * j_,
    skewX: Math.atan(l) * j_,
    scaleX: s,
    scaleY: a
  };
}
var Gu;
function BX(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? T0 : W4(t.a, t.b, t.c, t.d, t.e, t.f);
}
function PX(e) {
  return e == null || (Gu || (Gu = document.createElementNS("http://www.w3.org/2000/svg", "g")), Gu.setAttribute("transform", e), !(e = Gu.transform.baseVal.consolidate())) ? T0 : (e = e.matrix, W4(e.a, e.b, e.c, e.d, e.e, e.f));
}
function K4(e, t, n, r) {
  function i(u) {
    return u.length ? u.pop() + " " : "";
  }
  function o(u, c, f, d, p, h) {
    if (u !== f || c !== d) {
      var m = p.push("translate(", null, t, null, n);
      h.push({ i: m - 4, x: Cr(u, f) }, { i: m - 2, x: Cr(c, d) });
    } else (f || d) && p.push("translate(" + f + t + d + n);
  }
  function s(u, c, f, d) {
    u !== c ? (u - c > 180 ? c += 360 : c - u > 180 && (u += 360), d.push({ i: f.push(i(f) + "rotate(", null, r) - 2, x: Cr(u, c) })) : c && f.push(i(f) + "rotate(" + c + r);
  }
  function a(u, c, f, d) {
    u !== c ? d.push({ i: f.push(i(f) + "skewX(", null, r) - 2, x: Cr(u, c) }) : c && f.push(i(f) + "skewX(" + c + r);
  }
  function l(u, c, f, d, p, h) {
    if (u !== f || c !== d) {
      var m = p.push(i(p) + "scale(", null, ",", null, ")");
      h.push({ i: m - 4, x: Cr(u, f) }, { i: m - 2, x: Cr(c, d) });
    } else (f !== 1 || d !== 1) && p.push(i(p) + "scale(" + f + "," + d + ")");
  }
  return function(u, c) {
    var f = [], d = [];
    return u = e(u), c = e(c), o(u.translateX, u.translateY, c.translateX, c.translateY, f, d), s(u.rotate, c.rotate, f, d), a(u.skewX, c.skewX, f, d), l(u.scaleX, u.scaleY, c.scaleX, c.scaleY, f, d), u = c = null, function(p) {
      for (var h = -1, m = d.length, g; ++h < m; ) f[(g = d[h]).i] = g.x(p);
      return f.join("");
    };
  };
}
var $X = K4(BX, "px, ", "px)", "deg)"), zX = K4(PX, ", ", ")", ")");
function FX(e, t) {
  var n, r;
  return function() {
    var i = Xr(this, e), o = i.tween;
    if (o !== n) {
      r = n = o;
      for (var s = 0, a = r.length; s < a; ++s)
        if (r[s].name === t) {
          r = r.slice(), r.splice(s, 1);
          break;
        }
    }
    i.tween = r;
  };
}
function jX(e, t, n) {
  var r, i;
  if (typeof n != "function") throw new Error();
  return function() {
    var o = Xr(this, e), s = o.tween;
    if (s !== r) {
      i = (r = s).slice();
      for (var a = { name: t, value: n }, l = 0, u = i.length; l < u; ++l)
        if (i[l].name === t) {
          i[l] = a;
          break;
        }
      l === u && i.push(a);
    }
    o.tween = i;
  };
}
function UX(e, t) {
  var n = this._id;
  if (e += "", arguments.length < 2) {
    for (var r = gr(this.node(), n).tween, i = 0, o = r.length, s; i < o; ++i)
      if ((s = r[i]).name === e)
        return s.value;
    return null;
  }
  return this.each((t == null ? FX : jX)(n, e, t));
}
function N1(e, t, n) {
  var r = e._id;
  return e.each(function() {
    var i = Xr(this, r);
    (i.value || (i.value = {}))[t] = n.apply(this, arguments);
  }), function(i) {
    return gr(i, r).value[t];
  };
}
function Y4(e, t) {
  var n;
  return (typeof t == "number" ? Cr : t instanceof Bo ? Yf : (n = Bo(t)) ? (t = n, Yf) : G4)(e, t);
}
function VX(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function HX(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function qX(e, t, n) {
  var r, i = n + "", o;
  return function() {
    var s = this.getAttribute(e);
    return s === i ? null : s === r ? o : o = t(r = s, n);
  };
}
function GX(e, t, n) {
  var r, i = n + "", o;
  return function() {
    var s = this.getAttributeNS(e.space, e.local);
    return s === i ? null : s === r ? o : o = t(r = s, n);
  };
}
function WX(e, t, n) {
  var r, i, o;
  return function() {
    var s, a = n(this), l;
    return a == null ? void this.removeAttribute(e) : (s = this.getAttribute(e), l = a + "", s === l ? null : s === r && l === i ? o : (i = l, o = t(r = s, a)));
  };
}
function KX(e, t, n) {
  var r, i, o;
  return function() {
    var s, a = n(this), l;
    return a == null ? void this.removeAttributeNS(e.space, e.local) : (s = this.getAttributeNS(e.space, e.local), l = a + "", s === l ? null : s === r && l === i ? o : (i = l, o = t(r = s, a)));
  };
}
function YX(e, t) {
  var n = Od(e), r = n === "transform" ? zX : Y4;
  return this.attrTween(e, typeof t == "function" ? (n.local ? KX : WX)(n, r, N1(this, "attr." + e, t)) : t == null ? (n.local ? HX : VX)(n) : (n.local ? GX : qX)(n, r, t));
}
function QX(e, t) {
  return function(n) {
    this.setAttribute(e, t.call(this, n));
  };
}
function ZX(e, t) {
  return function(n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n));
  };
}
function XX(e, t) {
  var n, r;
  function i() {
    var o = t.apply(this, arguments);
    return o !== r && (n = (r = o) && ZX(e, o)), n;
  }
  return i._value = t, i;
}
function JX(e, t) {
  var n, r;
  function i() {
    var o = t.apply(this, arguments);
    return o !== r && (n = (r = o) && QX(e, o)), n;
  }
  return i._value = t, i;
}
function eJ(e, t) {
  var n = "attr." + e;
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (t == null) return this.tween(n, null);
  if (typeof t != "function") throw new Error();
  var r = Od(e);
  return this.tween(n, (r.local ? XX : JX)(r, t));
}
function tJ(e, t) {
  return function() {
    T1(this, e).delay = +t.apply(this, arguments);
  };
}
function nJ(e, t) {
  return t = +t, function() {
    T1(this, e).delay = t;
  };
}
function rJ(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? tJ : nJ)(t, e)) : gr(this.node(), t).delay;
}
function iJ(e, t) {
  return function() {
    Xr(this, e).duration = +t.apply(this, arguments);
  };
}
function oJ(e, t) {
  return t = +t, function() {
    Xr(this, e).duration = t;
  };
}
function sJ(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? iJ : oJ)(t, e)) : gr(this.node(), t).duration;
}
function aJ(e, t) {
  if (typeof t != "function") throw new Error();
  return function() {
    Xr(this, e).ease = t;
  };
}
function lJ(e) {
  var t = this._id;
  return arguments.length ? this.each(aJ(t, e)) : gr(this.node(), t).ease;
}
function uJ(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function") throw new Error();
    Xr(this, e).ease = n;
  };
}
function cJ(e) {
  if (typeof e != "function") throw new Error();
  return this.each(uJ(this._id, e));
}
function fJ(e) {
  typeof e != "function" && (e = i4(e));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var o = t[i], s = o.length, a = r[i] = [], l, u = 0; u < s; ++u)
      (l = o[u]) && e.call(l, l.__data__, u, o) && a.push(l);
  return new pi(r, this._parents, this._name, this._id);
}
function dJ(e) {
  if (e._id !== this._id) throw new Error();
  for (var t = this._groups, n = e._groups, r = t.length, i = n.length, o = Math.min(r, i), s = new Array(r), a = 0; a < o; ++a)
    for (var l = t[a], u = n[a], c = l.length, f = s[a] = new Array(c), d, p = 0; p < c; ++p)
      (d = l[p] || u[p]) && (f[p] = d);
  for (; a < r; ++a)
    s[a] = t[a];
  return new pi(s, this._parents, this._name, this._id);
}
function pJ(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function hJ(e, t, n) {
  var r, i, o = pJ(t) ? T1 : Xr;
  return function() {
    var s = o(this, e), a = s.on;
    a !== r && (i = (r = a).copy()).on(t, n), s.on = i;
  };
}
function gJ(e, t) {
  var n = this._id;
  return arguments.length < 2 ? gr(this.node(), n).on.on(e) : this.each(hJ(n, e, t));
}
function mJ(e) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition) if (+n !== e) return;
    t && t.removeChild(this);
  };
}
function bJ() {
  return this.on("end.remove", mJ(this._id));
}
function yJ(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = m1(e));
  for (var r = this._groups, i = r.length, o = new Array(i), s = 0; s < i; ++s)
    for (var a = r[s], l = a.length, u = o[s] = new Array(l), c, f, d = 0; d < l; ++d)
      (c = a[d]) && (f = e.call(c, c.__data__, d, a)) && ("__data__" in c && (f.__data__ = c.__data__), u[d] = f, $d(u[d], t, n, d, u, gr(c, n)));
  return new pi(o, this._parents, t, n);
}
function vJ(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = r4(e));
  for (var r = this._groups, i = r.length, o = [], s = [], a = 0; a < i; ++a)
    for (var l = r[a], u = l.length, c, f = 0; f < u; ++f)
      if (c = l[f]) {
        for (var d = e.call(c, c.__data__, f, l), p, h = gr(c, n), m = 0, g = d.length; m < g; ++m)
          (p = d[m]) && $d(p, t, n, m, d, h);
        o.push(d), s.push(c);
      }
  return new pi(o, s, t, n);
}
var _J = ru.prototype.constructor;
function EJ() {
  return new _J(this._groups, this._parents);
}
function wJ(e, t) {
  var n, r, i;
  return function() {
    var o = Ws(this, e), s = (this.style.removeProperty(e), Ws(this, e));
    return o === s ? null : o === n && s === r ? i : i = t(n = o, r = s);
  };
}
function Q4(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function xJ(e, t, n) {
  var r, i = n + "", o;
  return function() {
    var s = Ws(this, e);
    return s === i ? null : s === r ? o : o = t(r = s, n);
  };
}
function kJ(e, t, n) {
  var r, i, o;
  return function() {
    var s = Ws(this, e), a = n(this), l = a + "";
    return a == null && (l = a = (this.style.removeProperty(e), Ws(this, e))), s === l ? null : s === r && l === i ? o : (i = l, o = t(r = s, a));
  };
}
function MJ(e, t) {
  var n, r, i, o = "style." + t, s = "end." + o, a;
  return function() {
    var l = Xr(this, e), u = l.on, c = l.value[o] == null ? a || (a = Q4(t)) : void 0;
    (u !== n || i !== c) && (r = (n = u).copy()).on(s, i = c), l.on = r;
  };
}
function AJ(e, t, n) {
  var r = (e += "") == "transform" ? $X : Y4;
  return t == null ? this.styleTween(e, wJ(e, r)).on("end.style." + e, Q4(e)) : typeof t == "function" ? this.styleTween(e, kJ(e, r, N1(this, "style." + e, t))).each(MJ(this._id, e)) : this.styleTween(e, xJ(e, r, t), n).on("end.style." + e, null);
}
function TJ(e, t, n) {
  return function(r) {
    this.style.setProperty(e, t.call(this, r), n);
  };
}
function SJ(e, t, n) {
  var r, i;
  function o() {
    var s = t.apply(this, arguments);
    return s !== i && (r = (i = s) && TJ(e, s, n)), r;
  }
  return o._value = t, o;
}
function CJ(e, t, n) {
  var r = "style." + (e += "");
  if (arguments.length < 2) return (r = this.tween(r)) && r._value;
  if (t == null) return this.tween(r, null);
  if (typeof t != "function") throw new Error();
  return this.tween(r, SJ(e, t, n ?? ""));
}
function NJ(e) {
  return function() {
    this.textContent = e;
  };
}
function DJ(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function OJ(e) {
  return this.tween("text", typeof e == "function" ? DJ(N1(this, "text", e)) : NJ(e == null ? "" : e + ""));
}
function IJ(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function RJ(e) {
  var t, n;
  function r() {
    var i = e.apply(this, arguments);
    return i !== n && (t = (n = i) && IJ(i)), t;
  }
  return r._value = e, r;
}
function LJ(e) {
  var t = "text";
  if (arguments.length < 1) return (t = this.tween(t)) && t._value;
  if (e == null) return this.tween(t, null);
  if (typeof e != "function") throw new Error();
  return this.tween(t, RJ(e));
}
function BJ() {
  for (var e = this._name, t = this._id, n = Z4(), r = this._groups, i = r.length, o = 0; o < i; ++o)
    for (var s = r[o], a = s.length, l, u = 0; u < a; ++u)
      if (l = s[u]) {
        var c = gr(l, t);
        $d(l, e, n, u, s, {
          time: c.time + c.delay + c.duration,
          delay: 0,
          duration: c.duration,
          ease: c.ease
        });
      }
  return new pi(r, this._parents, e, n);
}
function PJ() {
  var e, t, n = this, r = n._id, i = n.size();
  return new Promise(function(o, s) {
    var a = { value: s }, l = { value: function() {
      --i === 0 && o();
    } };
    n.each(function() {
      var u = Xr(this, r), c = u.on;
      c !== e && (t = (e = c).copy(), t._.cancel.push(a), t._.interrupt.push(a), t._.end.push(l)), u.on = t;
    }), i === 0 && o();
  });
}
var $J = 0;
function pi(e, t, n, r) {
  this._groups = e, this._parents = t, this._name = n, this._id = r;
}
function Z4() {
  return ++$J;
}
var ei = ru.prototype;
pi.prototype = {
  constructor: pi,
  select: yJ,
  selectAll: vJ,
  selectChild: ei.selectChild,
  selectChildren: ei.selectChildren,
  filter: fJ,
  merge: dJ,
  selection: EJ,
  transition: BJ,
  call: ei.call,
  nodes: ei.nodes,
  node: ei.node,
  size: ei.size,
  empty: ei.empty,
  each: ei.each,
  on: gJ,
  attr: YX,
  attrTween: eJ,
  style: AJ,
  styleTween: CJ,
  text: OJ,
  textTween: LJ,
  remove: bJ,
  tween: UX,
  delay: rJ,
  duration: sJ,
  ease: lJ,
  easeVarying: cJ,
  end: PJ,
  [Symbol.iterator]: ei[Symbol.iterator]
};
function zJ(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var FJ = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: zJ
};
function jJ(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function UJ(e) {
  var t, n;
  e instanceof pi ? (t = e._id, e = e._name) : (t = Z4(), (n = FJ).time = A1(), e = e == null ? null : e + "");
  for (var r = this._groups, i = r.length, o = 0; o < i; ++o)
    for (var s = r[o], a = s.length, l, u = 0; u < a; ++u)
      (l = s[u]) && $d(l, e, t, u, s, n || jJ(l, t));
  return new pi(r, this._parents, e, t);
}
ru.prototype.interrupt = MX;
ru.prototype.transition = UJ;
function zd(e, t, n) {
  return e.nodes().forEach((r) => H4(r)), t ? e.transition().duration(t) : e;
}
const VJ = Object.assign(Object.assign({}, x4), { tooltip: void 0, annotations: void 0 });
class HJ extends Nl {
  constructor(t, n, r) {
    var i;
    super(t), this._defaultConfig = VJ, this.config = this._defaultConfig, n && (this.updateContainer(n, !0), this.component = n.component), r && this.setData(r, !0), !((i = this.component) === null || i === void 0) && i.datamodel.data && this.render();
  }
  setData(t, n) {
    var r;
    const { config: i } = this;
    this.component && this.component.setData(t), n || this.render(), (r = i.tooltip) === null || r === void 0 || r.hide();
  }
  updateContainer(t, n) {
    super.updateContainer(t), this._removeAllChildren(), this.component = t.component, t.sizing && (this.component.sizing = t.sizing), this.element.appendChild(this.component.element);
    const r = t.tooltip;
    r && (r.hasContainer() || r.setContainer(this._container), r.setComponents([this.component]));
    const i = t.annotations;
    i && this.element.appendChild(i.element), this.element.appendChild(this._svgDefs.node()), this.element.appendChild(this._svgDefsExternal.node()), n || this.render();
  }
  updateComponent(t, n) {
    this.component.setConfig(t), n || this.render();
  }
  update(t, n, r) {
    t && this.updateContainer(t, !0), n && this.updateComponent(n, !0), r && this.setData(r, !0), this.render();
  }
  getFitWidthScale() {
    const { config: t, component: n } = this, r = n;
    if (!r.getWidth)
      return 1;
    const i = r.getWidth() + t.margin.left + t.margin.right;
    return this.width / i;
  }
  _preRender() {
    var t;
    super._preRender(), this.component.setSize(this.width, this.height, this.containerWidth, this.containerHeight), (t = this.config.annotations) === null || t === void 0 || t.setSize(this.width, this.height, this.containerWidth, this.containerHeight);
  }
  _render(t) {
    var n;
    const { config: r, component: i } = this;
    super._render(t), i.g.attr("transform", `translate(${r.margin.left},${r.margin.top})`), i.render(t), (n = r.annotations) === null || n === void 0 || n.render(t), r.tooltip && r.tooltip.update();
  }
  // Re-defining the `render()` function to handle different sizing techniques (`Sizing.Extend` and `Sizing.FitWidth`)
  // Not calling `super.render()` because we don't want it to interfere with setting the SVG size here.
  render(t = this.config.duration) {
    const { config: n, component: r } = this;
    if (n.sizing === ci.Extend || n.sizing === ci.FitWidth) {
      const i = n.sizing === ci.FitWidth, o = r, s = o.getWidth() + n.margin.left + n.margin.right, a = o.getHeight() + n.margin.top + n.margin.bottom, l = i ? this.getFitWidthScale() : 1, u = this.svg.attr("width"), c = this.svg.attr("height"), f = s * l, d = a * l, p = u || c;
      zd(this.svg, p ? t : 0).attr("width", f).attr("height", d).attr("viewBox", `0 0 ${s} ${i ? d : a}`).attr("preserveAspectRatio", "xMinYMin");
    } else
      this.svg.attr("width", this.config.width || this.containerWidth).attr("height", this.config.height || this.containerHeight);
    this._resizeObserver || this._setUpResizeObserver(), cancelAnimationFrame(this._requestedAnimationFrame), this._requestedAnimationFrame = requestAnimationFrame(() => {
      this._preRender(), this._render(t);
    });
  }
  _onResize() {
    var t;
    const { config: n } = this;
    super._onResize(), (t = n.tooltip) === null || t === void 0 || t.hide();
  }
  destroy() {
    var t, n;
    const { component: r, config: i } = this;
    super.destroy(), r == null || r.destroy(), (t = i.tooltip) === null || t === void 0 || t.destroy(), (n = i.annotations) === null || n === void 0 || n.destroy();
  }
}
class X4 {
  constructor(t) {
    this.data = t;
  }
  get data() {
    return this._data;
  }
  set data(t) {
    this._data = t;
  }
}
const J4 = {
  duration: 600,
  events: {},
  attributes: {}
};
class qJ {
  constructor(t = Za.SVG) {
    var n, r;
    this.type = Za.SVG, this.datamodel = new X4(), this.sizing = ci.Fit, this.events = {}, this._defaultConfig = J4, this._width = 400, this._height = 200, this._containerWidth = void 0, this._containerHeight = void 0, this._setUpComponentEventsThrottled = Ff(this._setUpComponentEvents, 500), this._setCustomAttributesThrottled = Ff(this._setCustomAttributes, 500), t === Za.SVG ? this.element = document.createElementNS("http://www.w3.org/2000/svg", "g") : this.element = document.createElement("div"), this.uid = QZ(), this.g = gs(this.element);
    const i = (r = (n = this.constructor) === null || n === void 0 ? void 0 : n.selectors) === null || r === void 0 ? void 0 : r.root;
    i && this.g.attr("class", i);
  }
  setConfig(t) {
    this.prevConfig = this.config, this.config = Id(this._defaultConfig, t);
  }
  setData(t) {
    this.datamodel.data = t;
  }
  setSize(t, n, r, i) {
    isFinite(t) && (this._width = t), isFinite(n) && (this._height = n), isFinite(r) && (this._containerWidth = r), isFinite(i) && (this._containerHeight = i);
  }
  render(t = this.config.duration) {
    this._render(t);
    const n = "animating";
    t && (this.g.attr(n, ""), this.g.transition(n).duration(t).on("end interrupt", () => {
      this.g.attr(n, null);
    })), this._setUpComponentEventsThrottled(), this._setCustomAttributesThrottled();
  }
  get bleed() {
    return { top: 0, bottom: 0, left: 0, right: 0 };
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  _render(t = this.config.duration) {
  }
  _setCustomAttributes() {
    const t = this.config.attributes;
    Object.keys(t).forEach((n) => {
      Object.keys(t[n]).forEach((r) => {
        this.g.selectAll(`.${n}`).attr(r, t[n][r]);
      });
    });
  }
  _setUpComponentEvents() {
    this._bindEvents(this.events), this._bindEvents(this.config.events, ".user");
  }
  _bindEvents(t = this.events, n = "") {
    Object.keys(t).forEach((r) => {
      Object.keys(t[r]).forEach((i) => {
        const o = this.g.selectAll(`.${r}`);
        o.on(i + n, (s, a) => {
          const l = o.nodes(), u = l.indexOf(s.currentTarget), c = t[r][i];
          return c == null ? void 0 : c(a, s, u, l);
        });
      });
    });
  }
  destroy() {
    var t;
    (t = this.g) === null || t === void 0 || t.remove(), this.element = void 0;
  }
  isDestroyed() {
    return !this.element;
  }
}
class GJ extends X4 {
  constructor(t) {
    super(t);
  }
  get data() {
    var t;
    return (t = this._data) !== null && t !== void 0 ? t : [];
  }
  set data(t) {
    Array.isArray(t) && (this._data = t);
  }
}
var st;
(function(e) {
  e.Top = "top", e.Bottom = "bottom", e.Left = "left", e.Right = "right", e.Center = "center", e.Auto = "auto";
})(st || (st = {}));
var U_;
(function(e) {
  e.Absolute = "absolute", e.Fixed = "fixed";
})(U_ || (U_ = {}));
var V_;
(function(e) {
  e.Inside = "inside", e.Outside = "outside";
})(V_ || (V_ = {}));
var H_;
(function(e) {
  e.Horizontal = "horizontal", e.Vertical = "vertical";
})(H_ || (H_ = {}));
const WJ = {
  components: [],
  container: void 0,
  followCursor: !0,
  allowHover: !0,
  horizontalPlacement: st.Auto,
  horizontalShift: 0,
  verticalPlacement: st.Top,
  verticalShift: 0,
  attributes: {},
  triggers: {},
  className: void 0
}, Fd = hr`
  label: tooltip;
  display: inline-block;
  left: 0;
  bottom: 0;
  min-width: max-content;
  position: absolute;
  opacity: 0;
  transition: opacity;
  transition-duration: var(--vis-tooltip-transition-duration);
  z-index: 999999;
  padding: var(--vis-tooltip-padding);
  color: var(--vis-tooltip-text-color);
  border-radius: var(--vis-tooltip-border-radius);
  box-shadow: var(--vis-tooltip-box-shadow);
  border: solid 1px var(--vis-tooltip-border-color);
  background-color: var(--vis-tooltip-background-color);
  backdrop-filter: var(--vis-tooltip-backdrop-filter);
`, KJ = Fd, YJ = x1`
  :root {
    --vis-tooltip-background-color: rgba(255, 255, 255, 0.95);
    --vis-tooltip-border-color: #e5e9f7;
    --vis-tooltip-text-color: #000;
    --vis-tooltip-shadow-color: rgba(172, 179, 184, 0.35);
    --vis-tooltip-backdrop-filter: none;
    --vis-tooltip-padding: 10px 15px;
    --vis-tooltip-border-radius: 5px;
    --vis-tooltip-transition-duration: 300ms;
    --vis-tooltip-box-shadow: none;

    --vis-dark-tooltip-background-color: rgba(30,30,30, 0.95);
    --vis-dark-tooltip-text-color: #e5e9f7;
    --vis-dark-tooltip-border-color: var(--vis-color-grey);
    --vis-dark-tooltip-shadow-color: rgba(0,0,0, 0.95);
  }

  body.theme-dark ${`.${Fd}`} {
    --vis-tooltip-background-color: var(--vis-dark-tooltip-background-color);
    --vis-tooltip-text-color: var(--vis-dark-tooltip-text-color);
    --vis-tooltip-border-color: var(--vis-dark-tooltip-border-color);
    --vis-tooltip-shadow-color: var(--vis-dark-tooltip-shadow-color);
  }

  body.theme-dark {
    --vis-tooltip-background-color: rgba(30,30,30, 0.95);
    --vis-tooltip-text-color: #e5e9f7;
    --vis-tooltip-border-color: var(--vis-color-grey);
    --vis-tooltip-shadow-color: rgba(0,0,0, 0.95);
  }
`, eM = hr`
  bottom: unset;
  position: fixed;
`, S0 = hr`
  opacity: 1;
`, C0 = hr`
  display: none;
`, tM = hr`
  label: non-interactive;
  pointer-events: none;
  user-select: none;
`, QJ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hidden: C0,
  nonInteractive: tM,
  positionFixed: eM,
  root: Fd,
  show: S0,
  tooltip: KJ,
  variables: YJ
}, Symbol.toStringTag, { value: "Module" }));
class nM {
  constructor(t = {}) {
    this._defaultConfig = WJ, this.config = this._defaultConfig, this._setUpEventsThrottled = Ff(this._setUpEvents, 500), this._setContainerPositionThrottled = Ff(this._setContainerPosition, 500), this._isShown = !1, this.element = document.createElement("div"), this.div = gs(this.element).attr("class", Fd), this.setConfig(t), this.components = this.config.components, this._mutationObserver = new MutationObserver(() => {
      this._isShown && (!this.config.followCursor && this._hoveredElement ? this.placeByElement(this._hoveredElement) : this._position && this.place({ x: this._position[0], y: this._position[1] }));
    }), this._mutationObserver.observe(this.div.node(), { childList: !0, subtree: !0 });
  }
  setConfig(t) {
    var n;
    this.prevConfig = this.config, this.config = Id(this._defaultConfig, t), this.config.container && this.config.container !== ((n = this.prevConfig) === null || n === void 0 ? void 0 : n.container) && this.setContainer(this.config.container), this._setUpAttributes();
  }
  setContainer(t) {
    var n;
    (n = this.element.parentNode) === null || n === void 0 || n.removeChild(this.element), this._container = t, this._container.appendChild(this.element), this._setContainerPositionThrottled();
  }
  getContainer() {
    return this._container;
  }
  hasContainer() {
    return !!this._container && this._container.isConnected;
  }
  setComponents(t) {
    this.components = t;
  }
  update() {
    this._container && this._setUpEventsThrottled();
  }
  /** Show the tooltip by providing content and position */
  show(t, n) {
    this.render(t), this.place(n);
  }
  /** Hide the tooltip */
  hide() {
    this.div.classed(S0, !1).on("transitionend", () => {
      this.div.classed(C0, !this._isShown);
    }), this._isShown = !1;
  }
  /** Simply displays the tooltip with its previous content on position */
  display() {
    this.div.classed(C0, !1).classed(S0, !0), this._isShown = !0;
  }
  place(t) {
    if (this._position = [t.x, t.y], !this.hasContainer()) {
      console.warn("Unovis | Tooltip: Container was not set or is not initialized yet");
      return;
    }
    const { config: n } = this, r = this.element.offsetWidth, i = this.element.offsetHeight, o = n.horizontalPlacement === st.Auto ? st.Center : n.horizontalPlacement, s = n.verticalPlacement === st.Auto ? t.y - i < 0 ? st.Bottom : st.Top : n.verticalPlacement, a = 5, l = o === st.Left ? -r - a - n.horizontalShift : o === st.Center ? -r / 2 : a + n.horizontalShift, u = s === st.Bottom ? a + n.verticalShift : s === st.Center ? -i / 2 : -a - n.verticalShift - i, [c, f] = this._constraintPosToContainer(t.x + l, t.y + u, r, i);
    this._applyPosition(c, f, i);
  }
  placeByElement(t) {
    const { config: n } = this;
    this._hoveredElement = t;
    const r = 5, i = this.element.offsetWidth, o = this.element.offsetHeight, s = this.isContainerBody(), a = s ? window.innerWidth : this._container.scrollWidth, l = t.getBoundingClientRect(), u = s ? [l.x, l.y] : l_({
      clientX: l.x,
      clientY: l.y,
      pageX: l.x,
      pageY: l.y
    }, this._container), c = n.horizontalPlacement === st.Auto ? u[0] - i < 0 ? st.Right : u[0] + i > a ? st.Left : st.Center : n.horizontalPlacement;
    let f = 0;
    switch (c) {
      case st.Left:
        f = -i - r - n.horizontalShift;
        break;
      case st.Right:
        f = l.width + r + n.horizontalShift;
        break;
      case st.Center:
      default:
        f = (-i + l.width) / 2;
        break;
    }
    const d = n.verticalPlacement === st.Auto ? c !== st.Center ? st.Center : u[1] - o < 0 ? st.Bottom : st.Top : n.verticalPlacement;
    let p = -o;
    switch (d) {
      case st.Center:
        p += (o + l.height) / 2;
        break;
      case st.Bottom:
        p += o + l.height + r + n.verticalShift;
        break;
      case st.Top:
      default:
        p += -r - n.verticalShift;
        break;
    }
    const [h, m] = this._constraintPosToContainer(u[0] + f, u[1] + p, i, o);
    this._applyPosition(h, m, o);
  }
  isContainerBody() {
    return this._container === document.body;
  }
  render(t) {
    var n;
    const { config: r, prevConfig: i } = this;
    t instanceof HTMLElement ? this.div.select(":first-child").node() !== t && this.div.html("").append(() => t) : t && this.div.html(t), this.div.classed((n = r.className) !== null && n !== void 0 ? n : "", !!r.className).classed(tM, !r.allowHover || r.followCursor), i != null && i.className && i.className !== r.className && this.div.classed(i.className, !1), this.display();
  }
  _applyPosition(t, n, r) {
    const i = this.isContainerBody(), o = i ? window.innerHeight : this._container.scrollHeight;
    this.div.classed(eM, i).style("top", i ? `${n}px` : "unset").style("bottom", i ? "unset" : `${o - n - r}px`).style("left", `${t}px`);
  }
  _constraintPosToContainer(t, n, r, i) {
    const o = this.isContainerBody(), s = o ? window.innerHeight : this._container.scrollHeight, a = o ? window.innerWidth : this._container.scrollWidth, l = 10, u = t > a - r - l, c = t < l, f = u ? a - r - l : c ? l : t, d = 10, p = n > s - i - d, h = n < d, m = p ? s - i - d : h ? d : n;
    return [
      a < r ? 0 : f,
      s < i ? 0 : m
    ];
  }
  _setContainerPosition() {
    var t;
    this._container !== document.body && ((t = getComputedStyle(this._container)) === null || t === void 0 ? void 0 : t.position) === "static" && (this._container.style.position = "relative");
  }
  _setUpEvents() {
    const { config: t } = this;
    this.components.forEach((n) => {
      const r = gs(n.element);
      r.on("mousemove.tooltip", (i) => {
        const o = i.composedPath && i.composedPath() || i.path || [i.target];
        for (const s of Object.keys(t.triggers)) {
          const a = t.triggers[s];
          if (!a)
            continue;
          const l = r.selectAll(`.${s}`).nodes();
          for (const u of o) {
            if (u === r.node())
              break;
            if (u.classList.contains(s)) {
              const c = l.indexOf(u), f = gs(u).datum(), d = a(f, c, l), [p, h] = this.isContainerBody() ? [i.clientX, i.clientY] : l_(i, this._container);
              d === null ? this.hide() : (this.render(d), t.followCursor ? this.place({ x: p, y: h }) : this.placeByElement(u)), i.stopPropagation();
              return;
            }
          }
        }
        this._isShown && this.hide();
      }).on("mouseleave.tooltip", (i) => {
        i.stopPropagation(), this.hide();
      });
    }), t.allowHover && !t.followCursor ? this.div.on("mouseenter.tooltip", this.display.bind(this)).on("mouseleave.tooltip", this.hide.bind(this)) : this.div.on("mouseenter.tooltip", null).on("mouseleave.tooltip", null);
  }
  _setUpAttributes() {
    const t = this.config.attributes;
    t && Object.keys(t).forEach((n) => {
      this.div.attr(n, t[n]);
    });
  }
  destroy() {
    var t;
    this._mutationObserver.disconnect(), (t = this.div) === null || t === void 0 || t.remove();
  }
}
nM.selectors = QJ;
function fn(e) {
  return function() {
    return e;
  };
}
const q_ = Math.abs, nn = Math.atan2, io = Math.cos, ZJ = Math.max, sh = Math.min, _r = Math.sin, ls = Math.sqrt, yn = 1e-12, Bl = Math.PI, Qf = Bl / 2, vc = 2 * Bl;
function XJ(e) {
  return e > 1 ? 0 : e < -1 ? Bl : Math.acos(e);
}
function G_(e) {
  return e >= 1 ? Qf : e <= -1 ? -Qf : Math.asin(e);
}
const N0 = Math.PI, D0 = 2 * N0, ao = 1e-6, JJ = D0 - ao;
function rM(e) {
  this._ += e[0];
  for (let t = 1, n = e.length; t < n; ++t)
    this._ += arguments[t] + e[t];
}
function eee(e) {
  let t = Math.floor(e);
  if (!(t >= 0)) throw new Error(`invalid digits: ${e}`);
  if (t > 15) return rM;
  const n = 10 ** t;
  return function(r) {
    this._ += r[0];
    for (let i = 1, o = r.length; i < o; ++i)
      this._ += Math.round(arguments[i] * n) / n + r[i];
  };
}
class tee {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? rM : eee(t);
  }
  moveTo(t, n) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, n) {
    this._append`L${this._x1 = +t},${this._y1 = +n}`;
  }
  quadraticCurveTo(t, n, r, i) {
    this._append`Q${+t},${+n},${this._x1 = +r},${this._y1 = +i}`;
  }
  bezierCurveTo(t, n, r, i, o, s) {
    this._append`C${+t},${+n},${+r},${+i},${this._x1 = +o},${this._y1 = +s}`;
  }
  arcTo(t, n, r, i, o) {
    if (t = +t, n = +n, r = +r, i = +i, o = +o, o < 0) throw new Error(`negative radius: ${o}`);
    let s = this._x1, a = this._y1, l = r - t, u = i - n, c = s - t, f = a - n, d = c * c + f * f;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = n}`;
    else if (d > ao) if (!(Math.abs(f * l - u * c) > ao) || !o)
      this._append`L${this._x1 = t},${this._y1 = n}`;
    else {
      let p = r - s, h = i - a, m = l * l + u * u, g = p * p + h * h, y = Math.sqrt(m), _ = Math.sqrt(d), E = o * Math.tan((N0 - Math.acos((m + d - g) / (2 * y * _))) / 2), v = E / _, M = E / y;
      Math.abs(v - 1) > ao && this._append`L${t + v * c},${n + v * f}`, this._append`A${o},${o},0,0,${+(f * p > c * h)},${this._x1 = t + M * l},${this._y1 = n + M * u}`;
    }
  }
  arc(t, n, r, i, o, s) {
    if (t = +t, n = +n, r = +r, s = !!s, r < 0) throw new Error(`negative radius: ${r}`);
    let a = r * Math.cos(i), l = r * Math.sin(i), u = t + a, c = n + l, f = 1 ^ s, d = s ? i - o : o - i;
    this._x1 === null ? this._append`M${u},${c}` : (Math.abs(this._x1 - u) > ao || Math.abs(this._y1 - c) > ao) && this._append`L${u},${c}`, r && (d < 0 && (d = d % D0 + D0), d > JJ ? this._append`A${r},${r},0,1,${f},${t - a},${n - l}A${r},${r},0,1,${f},${this._x1 = u},${this._y1 = c}` : d > ao && this._append`A${r},${r},0,${+(d >= N0)},${f},${this._x1 = t + r * Math.cos(o)},${this._y1 = n + r * Math.sin(o)}`);
  }
  rect(t, n, r, i) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${r = +r}v${+i}h${-r}Z`;
  }
  toString() {
    return this._;
  }
}
function nee(e) {
  let t = 3;
  return e.digits = function(n) {
    if (!arguments.length) return t;
    if (n == null)
      t = null;
    else {
      const r = Math.floor(n);
      if (!(r >= 0)) throw new RangeError(`invalid digits: ${n}`);
      t = r;
    }
    return e;
  }, () => new tee(t);
}
function ree(e) {
  return e.innerRadius;
}
function iee(e) {
  return e.outerRadius;
}
function oee(e) {
  return e.startAngle;
}
function see(e) {
  return e.endAngle;
}
function aee(e) {
  return e && e.padAngle;
}
function lee(e, t, n, r, i, o, s, a) {
  var l = n - e, u = r - t, c = s - i, f = a - o, d = f * l - c * u;
  if (!(d * d < yn))
    return d = (c * (t - o) - f * (e - i)) / d, [e + d * l, t + d * u];
}
function Wu(e, t, n, r, i, o, s) {
  var a = e - n, l = t - r, u = (s ? o : -o) / ls(a * a + l * l), c = u * l, f = -u * a, d = e + c, p = t + f, h = n + c, m = r + f, g = (d + h) / 2, y = (p + m) / 2, _ = h - d, E = m - p, v = _ * _ + E * E, M = i - o, k = d * m - h * p, T = (E < 0 ? -1 : 1) * ls(ZJ(0, M * M * v - k * k)), U = (k * E - _ * T) / v, C = (-k * _ - E * T) / v, z = (k * E + _ * T) / v, H = (-k * _ + E * T) / v, j = U - g, V = C - y, Q = z - g, le = H - y;
  return j * j + V * V > Q * Q + le * le && (U = z, C = H), {
    cx: U,
    cy: C,
    x01: -c,
    y01: -f,
    x11: U * (i / M - 1),
    y11: C * (i / M - 1)
  };
}
function uee() {
  var e = ree, t = iee, n = fn(0), r = null, i = oee, o = see, s = aee, a = null, l = nee(u);
  function u() {
    var c, f, d = +e.apply(this, arguments), p = +t.apply(this, arguments), h = i.apply(this, arguments) - Qf, m = o.apply(this, arguments) - Qf, g = q_(m - h), y = m > h;
    if (a || (a = c = l()), p < d && (f = p, p = d, d = f), !(p > yn)) a.moveTo(0, 0);
    else if (g > vc - yn)
      a.moveTo(p * io(h), p * _r(h)), a.arc(0, 0, p, h, m, !y), d > yn && (a.moveTo(d * io(m), d * _r(m)), a.arc(0, 0, d, m, h, y));
    else {
      var _ = h, E = m, v = h, M = m, k = g, T = g, U = s.apply(this, arguments) / 2, C = U > yn && (r ? +r.apply(this, arguments) : ls(d * d + p * p)), z = sh(q_(p - d) / 2, +n.apply(this, arguments)), H = z, j = z, V, Q;
      if (C > yn) {
        var le = G_(C / d * _r(U)), ne = G_(C / p * _r(U));
        (k -= le * 2) > yn ? (le *= y ? 1 : -1, v += le, M -= le) : (k = 0, v = M = (h + m) / 2), (T -= ne * 2) > yn ? (ne *= y ? 1 : -1, _ += ne, E -= ne) : (T = 0, _ = E = (h + m) / 2);
      }
      var w = p * io(_), O = p * _r(_), q = d * io(M), X = d * _r(M);
      if (z > yn) {
        var se = p * io(E), fe = p * _r(E), Se = d * io(v), P = d * _r(v), ie;
        if (g < Bl)
          if (ie = lee(w, O, Se, P, se, fe, q, X)) {
            var Y = w - ie[0], ge = O - ie[1], me = se - ie[0], xe = fe - ie[1], Ve = 1 / _r(XJ((Y * me + ge * xe) / (ls(Y * Y + ge * ge) * ls(me * me + xe * xe))) / 2), qe = ls(ie[0] * ie[0] + ie[1] * ie[1]);
            H = sh(z, (d - qe) / (Ve - 1)), j = sh(z, (p - qe) / (Ve + 1));
          } else
            H = j = 0;
      }
      T > yn ? j > yn ? (V = Wu(Se, P, w, O, p, j, y), Q = Wu(se, fe, q, X, p, j, y), a.moveTo(V.cx + V.x01, V.cy + V.y01), j < z ? a.arc(V.cx, V.cy, j, nn(V.y01, V.x01), nn(Q.y01, Q.x01), !y) : (a.arc(V.cx, V.cy, j, nn(V.y01, V.x01), nn(V.y11, V.x11), !y), a.arc(0, 0, p, nn(V.cy + V.y11, V.cx + V.x11), nn(Q.cy + Q.y11, Q.cx + Q.x11), !y), a.arc(Q.cx, Q.cy, j, nn(Q.y11, Q.x11), nn(Q.y01, Q.x01), !y))) : (a.moveTo(w, O), a.arc(0, 0, p, _, E, !y)) : a.moveTo(w, O), !(d > yn) || !(k > yn) ? a.lineTo(q, X) : H > yn ? (V = Wu(q, X, se, fe, d, -H, y), Q = Wu(w, O, Se, P, d, -H, y), a.lineTo(V.cx + V.x01, V.cy + V.y01), H < z ? a.arc(V.cx, V.cy, H, nn(V.y01, V.x01), nn(Q.y01, Q.x01), !y) : (a.arc(V.cx, V.cy, H, nn(V.y01, V.x01), nn(V.y11, V.x11), !y), a.arc(0, 0, d, nn(V.cy + V.y11, V.cx + V.x11), nn(Q.cy + Q.y11, Q.cx + Q.x11), y), a.arc(Q.cx, Q.cy, H, nn(Q.y11, Q.x11), nn(Q.y01, Q.x01), !y))) : a.arc(0, 0, d, M, v, y);
    }
    if (a.closePath(), c) return a = null, c + "" || null;
  }
  return u.centroid = function() {
    var c = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2, f = (+i.apply(this, arguments) + +o.apply(this, arguments)) / 2 - Bl / 2;
    return [io(f) * c, _r(f) * c];
  }, u.innerRadius = function(c) {
    return arguments.length ? (e = typeof c == "function" ? c : fn(+c), u) : e;
  }, u.outerRadius = function(c) {
    return arguments.length ? (t = typeof c == "function" ? c : fn(+c), u) : t;
  }, u.cornerRadius = function(c) {
    return arguments.length ? (n = typeof c == "function" ? c : fn(+c), u) : n;
  }, u.padRadius = function(c) {
    return arguments.length ? (r = c == null ? null : typeof c == "function" ? c : fn(+c), u) : r;
  }, u.startAngle = function(c) {
    return arguments.length ? (i = typeof c == "function" ? c : fn(+c), u) : i;
  }, u.endAngle = function(c) {
    return arguments.length ? (o = typeof c == "function" ? c : fn(+c), u) : o;
  }, u.padAngle = function(c) {
    return arguments.length ? (s = typeof c == "function" ? c : fn(+c), u) : s;
  }, u.context = function(c) {
    return arguments.length ? (a = c ?? null, u) : a;
  }, u;
}
function cee(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function fee(e, t) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function dee(e) {
  return e;
}
function pee() {
  var e = dee, t = fee, n = null, r = fn(0), i = fn(vc), o = fn(0);
  function s(a) {
    var l, u = (a = cee(a)).length, c, f, d = 0, p = new Array(u), h = new Array(u), m = +r.apply(this, arguments), g = Math.min(vc, Math.max(-vc, i.apply(this, arguments) - m)), y, _ = Math.min(Math.abs(g) / u, o.apply(this, arguments)), E = _ * (g < 0 ? -1 : 1), v;
    for (l = 0; l < u; ++l)
      (v = h[p[l] = l] = +e(a[l], l, a)) > 0 && (d += v);
    for (t != null ? p.sort(function(M, k) {
      return t(h[M], h[k]);
    }) : n != null && p.sort(function(M, k) {
      return n(a[M], a[k]);
    }), l = 0, f = d ? (g - u * E) / d : 0; l < u; ++l, m = y)
      c = p[l], v = h[c], y = m + (v > 0 ? v * f : 0) + E, h[c] = {
        data: a[c],
        index: l,
        value: v,
        startAngle: m,
        endAngle: y,
        padAngle: _
      };
    return h;
  }
  return s.value = function(a) {
    return arguments.length ? (e = typeof a == "function" ? a : fn(+a), s) : e;
  }, s.sortValues = function(a) {
    return arguments.length ? (t = a, n = null, s) : t;
  }, s.sort = function(a) {
    return arguments.length ? (n = a, t = null, s) : n;
  }, s.startAngle = function(a) {
    return arguments.length ? (r = typeof a == "function" ? a : fn(+a), s) : r;
  }, s.endAngle = function(a) {
    return arguments.length ? (i = typeof a == "function" ? a : fn(+a), s) : i;
  }, s.padAngle = function(a) {
    return arguments.length ? (o = typeof a == "function" ? a : fn(+a), s) : o;
  }, s;
}
function iM(e, t, n, r) {
  return Array.isArray(t) && isFinite(n) ? t[n % t.length] : $Q(e, t, n) || (y1(n) && !r ? `var(${xi(n)})` : null);
}
var hee = { exports: {} };
(function(e) {
  (function(t) {
    if (typeof n != "function") {
      var n = function(h) {
        return h;
      };
      n.nonNative = !0;
    }
    const r = n("plaintext"), i = n("html"), o = n("comment"), s = /<(\w*)>/g, a = /<\/?([^\s\/>]+)/;
    function l(h, m, g) {
      h = h || "", m = m || [], g = g || "";
      let y = c(m, g);
      return f(h, y);
    }
    function u(h, m) {
      h = h || [], m = m || "";
      let g = c(h, m);
      return function(_) {
        return f(_ || "", g);
      };
    }
    l.init_streaming_mode = u;
    function c(h, m) {
      return h = d(h), {
        allowable_tags: h,
        tag_replacement: m,
        state: r,
        tag_buffer: "",
        depth: 0,
        in_quote_char: ""
      };
    }
    function f(h, m) {
      if (typeof h != "string")
        throw new TypeError("'html' parameter must be a string");
      let g = m.allowable_tags, y = m.tag_replacement, _ = m.state, E = m.tag_buffer, v = m.depth, M = m.in_quote_char, k = "";
      for (let T = 0, U = h.length; T < U; T++) {
        let C = h[T];
        if (_ === r)
          switch (C) {
            case "<":
              _ = i, E += C;
              break;
            default:
              k += C;
              break;
          }
        else if (_ === i)
          switch (C) {
            case "<":
              if (M)
                break;
              v++;
              break;
            case ">":
              if (M)
                break;
              if (v) {
                v--;
                break;
              }
              M = "", _ = r, E += ">", g.has(p(E)) ? k += E : k += y, E = "";
              break;
            case '"':
            case "'":
              C === M ? M = "" : M = M || C, E += C;
              break;
            case "-":
              E === "<!-" && (_ = o), E += C;
              break;
            case " ":
            case `
`:
              if (E === "<") {
                _ = r, k += "< ", E = "";
                break;
              }
              E += C;
              break;
            default:
              E += C;
              break;
          }
        else if (_ === o)
          switch (C) {
            case ">":
              E.slice(-2) == "--" && (_ = r), E = "";
              break;
            default:
              E += C;
              break;
          }
      }
      return m.state = _, m.tag_buffer = E, m.depth = v, m.in_quote_char = M, k;
    }
    function d(h) {
      let m = /* @__PURE__ */ new Set();
      if (typeof h == "string") {
        let g;
        for (; g = s.exec(h); )
          m.add(g[1]);
      } else !n.nonNative && typeof h[n.iterator] == "function" ? m = new Set(h) : typeof h.forEach == "function" && h.forEach(m.add, m);
      return m;
    }
    function p(h) {
      let m = a.exec(h);
      return m ? m[1].toLowerCase() : null;
    }
    e.exports ? e.exports = l : t.striptags = l;
  })(sz);
})(hee);
function gee(e, t = [" "]) {
  let n = [e];
  for (let r = 0; r < t.length; r++) {
    const i = t[r];
    n.forEach((o, s) => {
      const a = o.split(i), l = a.map((u, c) => `${u}${c === a.length - 1 ? "" : i}`);
      n[s] = l;
    }), n = BQ(n);
  }
  return n;
}
function mee(e, t, n = [" ", "-", ".", ","]) {
  const r = e.text();
  if (!r)
    return;
  const i = g4(n) ? n : [n], o = gee(r, i), s = parseFloat(e.attr("x")) || 0;
  e.text("");
  let a = e.append("tspan").attr("x", s), l = `${o[0]}`;
  a.text(l), o.forEach((u, c) => {
    if (c === 0)
      return;
    const f = `${l}${u}`;
    a.text(f), a.node().getComputedTextLength() > t ? (a.text(l.trim()), a = e.append("tspan").attr("x", s).attr("dy", "1.2em").text(u), l = u) : l += u;
  });
}
const bee = Object.assign(Object.assign({}, J4), { id: (e, t) => {
  var n;
  return (n = e.id) !== null && n !== void 0 ? n : t;
}, value: void 0, angleRange: [0, 2 * Math.PI], padAngle: 0, sortFunction: void 0, cornerRadius: 0, color: void 0, radius: void 0, arcWidth: 20, centralLabel: void 0, centralSubLabel: void 0, centralSubLabelWrap: !0, showEmptySegments: !1, emptySegmentAngle: 0.5 * Math.PI / 180, showBackground: !0, backgroundAngleRange: void 0 });
function yee(e, t) {
  e.style("fill", (n) => iM(n.data, t.color, n.index)).style("opacity", 0).each((n, r, i) => {
    const o = i[r], s = (n.startAngle + n.endAngle) / 2, a = (n.endAngle - n.startAngle) / 2;
    o._animState = {
      startAngle: s - a,
      endAngle: s + a,
      innerRadius: n.innerRadius,
      outerRadius: n.outerRadius,
      padAngle: n.padAngle
    };
  });
}
function vee(e, t, n, r) {
  e.style("transition", `fill ${r}ms`).style("fill", (o) => iM(o.data, t.color, o.index));
  const i = (o) => t.showEmptySegments || o.value ? 1 : 0;
  r ? zd(e, r).style("opacity", i).attrTween("d", (s, a, l) => {
    const u = l[a], c = {
      startAngle: s.startAngle,
      endAngle: s.endAngle,
      innerRadius: s.innerRadius,
      outerRadius: s.outerRadius,
      padAngle: s.padAngle
    }, f = C1(u._animState, c);
    return (d) => (u._animState = f(d), n(u._animState));
  }) : e.attr("d", n).style("opacity", i);
}
function _ee(e, t) {
  zd(e, t).style("opacity", 0).remove();
}
const oM = hr`
  label: donut-component;
`, Eee = x1`
  :root {
    --vis-donut-central-label-font-size: 16px;
    --vis-donut-central-label-text-color: #5b5f6d;
    // Undefined by default to allow proper fallback to var(--vis-font-family)
    /* --vis-donut-central-label-font-family: */
    --vis-donut-central-label-font-weight: 600;

    --vis-donut-central-sub-label-font-size: 12px;
    --vis-donut-central-sub-label-text-color: #5b5f6d;
    // Undefined by default to allow proper fallback to var(--vis-font-family)
    /* --vis-donut-central-sub-label-font-family: */
    --vis-donut-central-sub-label-font-weight: 500;

    --vis-donut-background-color: #E7E9F3;
    --vis-donut-segment-stroke-width: 0;
    // The line segment color variable is not defined by default
    // to allow it to fallback to the donut background color
    /* --vis-donut-segment-stroke-color: none; */

    --vis-dark-donut-central-label-text-color: #C2BECE;
    --vis-dark-donut-central-sub-label-text-color: #C2BECE;
    --vis-dark-donut-background-color: #18160C;
  }

  body.theme-dark ${`.${oM}`} {
    --vis-donut-central-label-text-color: var(--vis-dark-donut-central-label-text-color);
    --vis-donut-central-sub-label-text-color: var(--vis-dark-donut-central-sub-label-text-color);
    --vis-donut-background-color: var(--vis-dark-donut-background-color);
  }
`, sM = hr`
  label: background;
  fill: var(--vis-donut-background-color);
`, O0 = hr`
  label: segment;
  stroke-width: var(--vis-donut-segment-stroke-width);
  stroke: var(--vis-donut-segment-stroke-color, var(--vis-donut-background-color));
`, aM = hr`
  label: segment-exit;
`, lM = hr`
  label: central-label;
  text-anchor: middle;
  dominant-baseline: middle;
  font-size: var(--vis-donut-central-label-font-size);
  font-family: var(--vis-donut-central-label-font-family, var(--vis-font-family));
  font-weight: var(--vis-donut-central-label-font-weight);
  fill: var(--vis-donut-central-label-text-color);
`, uM = hr`
  label: central-label;
  text-anchor: middle;
  dominant-baseline: middle;
  font-size: var(--vis-donut-central-sub-label-font-size);
  font-family: var(--vis-donut-central-sub-label-font-family, var(--vis-font-family));
  font-weight: var(--vis-donut-central-sub-label-font-weight);
  fill: var(--vis-donut-central-sub-label-text-color);
`, wee = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  background: sM,
  centralLabel: lM,
  centralSubLabel: uM,
  root: oM,
  segment: O0,
  segmentExit: aM,
  variables: Eee
}, Symbol.toStringTag, { value: "Module" }));
class Pl extends qJ {
  constructor(t) {
    super(), this._defaultConfig = bee, this.config = this._defaultConfig, this.datamodel = new GJ(), this.arcGen = uee(), this.events = {}, t && this.setConfig(t), this.arcBackground = this.g.append("path"), this.arcGroup = this.g.append("g"), this.centralLabel = this.g.append("text").attr("class", lM), this.centralSubLabel = this.g.append("text").attr("class", uM);
  }
  get bleed() {
    return { top: 0, bottom: 0, left: 0, right: 0 };
  }
  _render(t) {
    var n, r, i, o, s, a, l, u, c, f, d, p, h, m;
    const { config: g, datamodel: y, bleed: _ } = this, E = y.data.map((j, V) => ({
      index: V,
      datum: j
    })).filter((j) => g.showEmptySegments || c_(j.datum, g.value, j.index)), v = y1(t) ? t : g.duration, M = g.radius || Math.min(this._width - _.left - _.right, this._height - _.top - _.bottom) / 2, k = g.arcWidth === 0 ? 0 : g0(M - g.arcWidth, 0, M - 1);
    this.arcGen.startAngle((j) => j.startAngle).endAngle((j) => j.endAngle).innerRadius((j) => j.innerRadius).outerRadius((j) => j.outerRadius).padAngle((j) => j.padAngle).cornerRadius(g.cornerRadius);
    const T = pee().startAngle((r = (n = g.angleRange) === null || n === void 0 ? void 0 : n[0]) !== null && r !== void 0 ? r : 0).endAngle((o = (i = g.angleRange) === null || i === void 0 ? void 0 : i[1]) !== null && o !== void 0 ? o : 2 * Math.PI).padAngle(g.padAngle).value((j) => c_(j.datum, g.value, j.index) || 0).sort((j, V) => {
      var Q;
      return (Q = g.sortFunction) === null || Q === void 0 ? void 0 : Q.call(g, j.datum, V.datum);
    });
    this.arcGroup.attr("transform", `translate(${this._width / 2},${this._height / 2})`);
    const U = T(E).map((j) => {
      const V = Object.assign(Object.assign({}, j), {
        data: j.data.datum,
        index: j.data.index,
        innerRadius: k,
        outerRadius: M
      });
      return g.showEmptySegments && j.endAngle - j.startAngle - j.padAngle <= Number.EPSILON && (V.endAngle = j.startAngle + Math.max(g.emptySegmentAngle, g.padAngle), V.padAngle = j.padAngle / 2), V;
    }), C = this.arcGroup.selectAll(`.${O0}`).data(U, (j) => g.id(j.data, j.index)), z = C.enter().append("path").attr("class", O0).call(yee, g), H = C.merge(z);
    H.call(vee, g, this.arcGen, v), H.sort((j, V) => V.value - j.value), C.exit().attr("class", aM).call(_ee, v), this.centralLabel.attr("transform", `translate(${this._width / 2},${this._height / 2})`).attr("dy", g.centralSubLabel ? "-0.55em" : null).text((s = g.centralLabel) !== null && s !== void 0 ? s : null), this.centralSubLabel.attr("transform", `translate(${this._width / 2},${this._height / 2})`).attr("dy", g.centralLabel ? "0.55em" : null).text((a = g.centralSubLabel) !== null && a !== void 0 ? a : null), g.centralSubLabelWrap && mee(this.centralSubLabel, k * 1.9), this.arcBackground.attr("class", sM).attr("visibility", g.showBackground ? null : "hidden").attr("transform", `translate(${this._width / 2},${this._height / 2})`), zd(this.arcBackground, v).attr("d", this.arcGen({
      startAngle: (f = (u = (l = g.backgroundAngleRange) === null || l === void 0 ? void 0 : l[0]) !== null && u !== void 0 ? u : (c = g.angleRange) === null || c === void 0 ? void 0 : c[0]) !== null && f !== void 0 ? f : 0,
      endAngle: (m = (p = (d = g.backgroundAngleRange) === null || d === void 0 ? void 0 : d[1]) !== null && p !== void 0 ? p : (h = g.angleRange) === null || h === void 0 ? void 0 : h[1]) !== null && m !== void 0 ? m : 2 * Math.PI,
      innerRadius: k,
      outerRadius: M
    }));
  }
}
Pl.selectors = wee;
const cM = Symbol("componentAccessorKey"), fM = Symbol("tooltipAccessorKey"), xee = Symbol("annotationsAccessorKey");
function dM(e, t) {
  return $f(e, t);
}
function D1(e) {
  const t = jn(), n = t.attrs;
  return R(() => {
    const r = {}, i = (t == null ? void 0 : t.vnode.props) ?? {};
    return Object.keys(i).forEach((o) => {
      r[I1(o)] = e[I1(o)];
    }), { ...r, ...n };
  });
}
const kee = /* @__PURE__ */ S({
  __name: "index",
  props: {
    component: {},
    tooltip: {},
    annotations: {},
    duration: {},
    margin: {},
    padding: {},
    sizing: {},
    width: {},
    height: {},
    svgDefs: {},
    ariaLabel: {},
    data: {}
  },
  setup(e, { expose: t }) {
    const n = e, { data: r } = _M(n), i = D1(n);
    let o;
    const s = vs({
      component: void 0,
      tooltip: void 0,
      annotations: void 0
    }), a = _e(), l = () => {
      o || a.value && s.component && (o = new HJ(a.value, { ...Sa(s) }, r.value));
    };
    return lr(() => {
      var u;
      l(), (u = s.component) == null || u.config, o == null || o.updateContainer({ ...Sa(i.value), ...Sa(s) });
    }), Mt(r, () => {
      o ? o.setData(r.value, !0) : l();
    }), Zs(() => o == null ? void 0 : o.destroy()), zi(cM, {
      data: r,
      update: (u) => s.component = u,
      destroy: () => s.component = void 0
    }), zi(fM, {
      data: r,
      update: (u) => s.tooltip = u,
      destroy: () => {
        s.tooltip = void 0;
      }
    }), zi(xee, {
      data: r,
      update: (u) => s.annotations = u,
      destroy: () => {
        s.annotations = void 0;
      }
    }), t({
      component: o
    }), (u, c) => (x(), W("div", {
      "data-vis-single-container": "",
      ref_key: "elRef",
      ref: a,
      class: "unovis-single-container"
    }, [
      B(u.$slots, "default")
    ], 512));
  }
}), Mee = { "data-vis-component": "" };
Pl.selectors;
const Aee = /* @__PURE__ */ S({
  __name: "index",
  props: {
    id: { type: Function },
    value: { type: [Function, Number, null] },
    angleRange: {},
    padAngle: {},
    sortFunction: { type: Function },
    cornerRadius: {},
    color: { type: [Function, String, Array, null] },
    radius: {},
    arcWidth: {},
    centralLabel: {},
    centralSubLabel: {},
    centralSubLabelWrap: { type: Boolean },
    showEmptySegments: { type: Boolean },
    emptySegmentAngle: {},
    showBackground: { type: Boolean },
    backgroundAngleRange: {},
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(e, { expose: t }) {
    const n = e, r = Wr(cM), i = R(() => r.data.value ?? n.data), o = D1(n), s = _e();
    return Jn(() => {
      Ft(() => {
        var a;
        s.value = new Pl(o.value), (a = s.value) == null || a.setData(i.value), r.update(s.value);
      });
    }), Zs(() => {
      var a;
      (a = s.value) == null || a.destroy(), r.destroy();
    }), Mt(o, (a, l) => {
      var u;
      dM(a, l) || (u = s.value) == null || u.setConfig(o.value);
    }), Mt(i, () => {
      var a;
      (a = s.value) == null || a.setData(i.value);
    }), t({
      component: s
    }), (a, l) => (x(), W("div", Mee));
  }
}), Tee = { "data-vis-tooltip": "" }, See = /* @__PURE__ */ S({
  __name: "index",
  props: {
    components: {},
    container: {},
    followCursor: { type: Boolean },
    allowHover: { type: Boolean },
    horizontalPlacement: {},
    horizontalShift: {},
    verticalPlacement: {},
    verticalShift: {},
    triggers: {},
    attributes: {},
    className: {},
    data: {}
  },
  setup(e, { expose: t }) {
    const n = e, r = Wr(fM), i = D1(n), o = _e();
    return Jn(() => {
      Ft(() => {
        o.value = new nM(i.value), r.update(o.value);
      });
    }), Zs(() => {
      var s;
      (s = o.value) == null || s.destroy(), r.destroy();
    }), Mt(i, (s, a) => {
      var l;
      dM(s, a) || (l = o.value) == null || l.setConfig(i.value);
    }), t({
      component: o
    }), (s, a) => (x(), W("div", Tee));
  }
});
(function() {
  try {
    if (typeof document < "u") {
      var e = document.createElement("style");
      e.appendChild(document.createTextNode("[data-vis-leaflet-map]{display:block;position:relative}.unovis-single-container{display:block;position:relative;width:100%}[data-vis-bullet-legend]{display:block}[data-vis-leaflet-flow-map]{display:block;position:relative}.unovis-xy-container{display:block;position:relative;width:100%}")), document.head.appendChild(e);
    }
  } catch (t) {
    console.error("vite-plugin-css-injected-by-js", t);
  }
})();
const Cee = { class: "flex items-center" }, Nee = { class: "w-2.5 h-2.5 mr-2" }, Dee = {
  width: "100%",
  height: "100%",
  viewBox: "0 0 30 30"
}, Oee = ["stroke", "fill"], Iee = { class: "font-semibold ml-4" }, W_ = /* @__PURE__ */ S({
  __name: "ChartTooltip",
  props: {
    title: {},
    data: {}
  },
  setup(e) {
    return (t, n) => (x(), L(b(u2), { class: "text-sm" }, {
      default: A(() => [
        t.title ? (x(), L(b(c2), {
          key: 0,
          class: "p-3 border-b"
        }, {
          default: A(() => [
            $(b(f2), null, {
              default: A(() => [
                Xt(ze(t.title), 1)
              ]),
              _: 1
            })
          ]),
          _: 1
        })) : Qe("", !0),
        $(b(ah), { class: "p-3 min-w-[180px] flex flex-col gap-1" }, {
          default: A(() => [
            (x(!0), W(Ge, null, ft(t.data, (r, i) => (x(), W("div", {
              key: i,
              class: "flex justify-between"
            }, [
              be("div", Cee, [
                be("span", Nee, [
                  (x(), W("svg", Dee, [
                    be("path", {
                      d: " M 15 15 m -14, 0 a 14,14 0 1,1 28,0 a 14,14 0 1,1 -28,0",
                      stroke: r.color,
                      fill: r.color,
                      "stroke-width": "1"
                    }, null, 8, Oee)
                  ]))
                ]),
                be("span", null, ze(r.name), 1)
              ]),
              be("span", Iee, ze(r.value), 1)
            ]))), 128))
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
}), Ree = /* @__PURE__ */ S({
  __name: "ChartSingleTooltip",
  props: {
    selector: {},
    index: {},
    items: {},
    valueFormatter: { type: Function, default: (e) => `${e}` },
    customTooltip: {}
  },
  setup(e) {
    const t = e, n = /* @__PURE__ */ new WeakMap();
    function r(i, o, s) {
      if (t.index in i) {
        if (n.has(i))
          return n.get(i);
        {
          const a = document.createElement("div"), l = Object.entries(PQ(i, [t.index])).map(([c, f]) => {
            var p;
            return { ...(p = t.items) == null ? void 0 : p.find((h) => h.name === c), value: t.valueFormatter(f) };
          }), u = t.customTooltip ?? W_;
          return R1(u, { title: i[t.index], data: l }).mount(a), n.set(i, a.innerHTML), a.innerHTML;
        }
      } else {
        const a = i.data;
        if (n.has(a))
          return n.get(a);
        {
          const l = getComputedStyle(s[o]), u = [{ name: a.name, value: t.valueFormatter(a[t.index]), color: l.fill }], c = document.createElement("div"), f = t.customTooltip ?? W_;
          return R1(f, { title: i[t.index], data: u }).mount(c), n.set(i, c.innerHTML), c.innerHTML;
        }
      }
    }
    return (i, o) => (x(), L(b(See), {
      "horizontal-shift": 20,
      "vertical-shift": 20,
      triggers: {
        [i.selector]: r
      }
    }, null, 8, ["triggers"]));
  }
});
function Lee(e = 3) {
  const t = Math.floor(e / 2), n = e % 2, r = t + n, i = t;
  return [
    ...Array.from(Array(r).keys()).map((o) => `hsl(var(--vis-primary-color) / ${1 - 1 / r * o})`),
    ...Array.from(Array(i).keys()).map((o) => `hsl(var(--vis-secondary-color) / ${1 - 1 / i * o})`)
  ];
}
const dre = /* @__PURE__ */ S({
  __name: "DonutChart",
  props: {
    data: {},
    colors: {},
    index: {},
    margin: { default: () => ({ top: 0, bottom: 0, left: 0, right: 0 }) },
    showLegend: { type: Boolean, default: !0 },
    showTooltip: { type: Boolean, default: !0 },
    filterOpacity: { default: 0.2 },
    category: {},
    radius: { default: 20 },
    arcWidth: { default: 10 },
    useEvents: { type: Boolean, default: !1 },
    type: { default: "donut" },
    sortFunction: { type: Function, default: () => {
    } },
    valueFormatter: { type: Function, default: (e) => `${e}` },
    customTooltip: {}
  },
  setup(e) {
    const t = e, n = R(() => t.category), r = R(() => t.index), i = j2(), o = _e(), s = R(
      () => {
        var u;
        return (u = t.colors) != null && u.length ? t.colors : Lee(t.data.filter((c) => c[t.category]).filter(Boolean).length);
      }
    ), a = R(
      () => t.data.map((u, c) => ({
        name: u[t.index],
        color: s.value[c],
        inactive: !1
      }))
    ), l = R(
      () => t.data.reduce((u, c) => u + c[t.category], 0)
    );
    return (u, c) => (x(), W("div", {
      class: ce(b(G)("flex h-48 w-full flex-col items-end", u.$attrs.class ?? ""))
    }, [
      $(b(kee), {
        style: Rr({ height: b(i) ? "100%" : "auto" }),
        margin: u.margin,
        data: u.data
      }, {
        default: A(() => [
          u.showTooltip ? (x(), L(b(Ree), {
            key: 0,
            selector: b(Pl).selectors.segment,
            index: n.value,
            items: a.value,
            "value-formatter": u.valueFormatter,
            "custom-tooltip": u.customTooltip
          }, null, 8, ["selector", "index", "items", "value-formatter", "custom-tooltip"])) : Qe("", !0),
          $(b(Aee), {
            value: (f) => f[n.value],
            "sort-function": u.sortFunction,
            color: s.value,
            "arc-width": u.type === "donut" ? u.arcWidth : 0,
            "show-background": !0,
            radius: u.radius,
            "central-label": u.type === "donut" ? u.valueFormatter(l.value) : "",
            events: u.useEvents ? {
              [b(Pl).selectors.segment]: {
                click: (f, d, p, h) => {
                  var m, g;
                  ((m = f == null ? void 0 : f.data) == null ? void 0 : m[r.value]) === o.value ? (o.value = void 0, h.forEach((y) => y.style.opacity = "1")) : (o.value = (g = f == null ? void 0 : f.data) == null ? void 0 : g[r.value], h.forEach((y) => y.style.opacity = `${u.filterOpacity}`), h[p].style.opacity = "1");
                }
              }
            } : {}
          }, null, 8, ["value", "sort-function", "color", "arc-width", "radius", "central-label", "events"]),
          B(u.$slots, "default")
        ]),
        _: 3
      }, 8, ["style", "margin", "data"])
    ], 2));
  }
});
export {
  Uee as Accordion,
  Vee as AccordionContent,
  Hee as AccordionItem,
  qee as AccordionTrigger,
  Gee as Alert,
  Kee as AlertDescription,
  Yee as AlertDialog,
  nte as AlertDialogAction,
  rte as AlertDialogCancel,
  Zee as AlertDialogContent,
  ete as AlertDialogDescription,
  tte as AlertDialogFooter,
  Xee as AlertDialogHeader,
  Jee as AlertDialogTitle,
  Qee as AlertDialogTrigger,
  Wee as AlertTitle,
  ure as Avatar,
  fre as AvatarFallback,
  cre as AvatarImage,
  ite as Badge,
  Kr as Button,
  ES as Calendar,
  wS as CalendarCell,
  xS as CalendarCellTrigger,
  kS as CalendarGrid,
  MS as CalendarGridBody,
  AS as CalendarGridHead,
  P1 as CalendarGridRow,
  TS as CalendarHeadCell,
  SS as CalendarHeader,
  CS as CalendarHeading,
  NS as CalendarNextButton,
  DS as CalendarPrevButton,
  u2 as Card,
  ah as CardContent,
  ote as CardDescription,
  OS as CardFooter,
  c2 as CardHeader,
  f2 as CardTitle,
  ste as Checkbox,
  ate as Collapsible,
  ute as CollapsibleContent,
  lte as CollapsibleTrigger,
  d2 as Command,
  bte as CommandDialog,
  yte as CommandEmpty,
  LS as CommandGroup,
  vte as CommandInput,
  PS as CommandItem,
  _te as CommandList,
  Ete as CommandSeparator,
  wte as CommandShortcut,
  Gne as CustomToast,
  are as DataTable,
  lre as DatePicker,
  IS as Dialog,
  cte as DialogClose,
  RS as DialogContent,
  hte as DialogDescription,
  mte as DialogFooter,
  dte as DialogHeader,
  gte as DialogScrollContent,
  pte as DialogTitle,
  fte as DialogTrigger,
  dre as DonutChart,
  Ite as DragAndDropList,
  qte as DragWindow,
  jte as Drawer,
  p2 as DropdownMenu,
  Mte as DropdownMenuCheckboxItem,
  g2 as DropdownMenuContent,
  xte as DropdownMenuGroup,
  m2 as DropdownMenuItem,
  Cte as DropdownMenuLabel,
  gre as DropdownMenuPortal,
  kte as DropdownMenuRadioGroup,
  Ate as DropdownMenuRadioItem,
  Ste as DropdownMenuSeparator,
  Tte as DropdownMenuShortcut,
  Nte as DropdownMenuSub,
  Ote as DropdownMenuSubContent,
  Dte as DropdownMenuSubTrigger,
  h2 as DropdownMenuTrigger,
  $L as EmojiSelector,
  nne as EnhancedTextarea,
  zL as EnhancedTextareaEmoji,
  eR as EnhancedTextareaHeadings,
  rR as EnhancedTextareaLists,
  rw as EnhancedTextareaShortcutKey,
  UL as EnhancedTextareaToolbar,
  Vc as EnhancedTextareaToolbarButton,
  iw as EnhancedTextareaToolbarSection,
  nR as EnhancedTextareaTypography,
  Ute as ExpandableCard,
  ine as Form,
  MW as FormControl,
  TW as FormDescription,
  rne as FormField,
  xW as FormItem,
  kW as FormLabel,
  AW as FormMessage,
  one as HoverCard,
  ane as HoverCardContent,
  sne as HoverCardTrigger,
  Vte as InitialCircle,
  e4 as Input,
  lne as Label,
  Hte as ListLoader,
  une as Menubar,
  mne as MenubarCheckboxItem,
  fne as MenubarContent,
  dne as MenubarGroup,
  cne as MenubarItem,
  xne as MenubarLabel,
  pne as MenubarMenu,
  hne as MenubarRadioGroup,
  gne as MenubarRadioItem,
  bne as MenubarSeparator,
  wne as MenubarShortcut,
  yne as MenubarSub,
  vne as MenubarSubContent,
  _ne as MenubarSubTrigger,
  Ene as MenubarTrigger,
  Rte as MultiSelect,
  kne as NavigationMenu,
  Sne as NavigationMenuContent,
  Ane as NavigationMenuItem,
  Cne as NavigationMenuLink,
  Mne as NavigationMenuList,
  Tne as NavigationMenuTrigger,
  mre as Pagination,
  Nne as PaginationEllipsis,
  Dne as PaginationFirst,
  One as PaginationLast,
  bre as PaginationList,
  yre as PaginationListItem,
  Ine as PaginationNext,
  Rne as PaginationPrev,
  DW as PhoneInput,
  Lne as PinInput,
  Bne as PinInputGroup,
  $ne as PinInputInput,
  Pne as PinInputSeparator,
  z0 as Popover,
  j0 as PopoverContent,
  F0 as PopoverTrigger,
  zne as Progress,
  Fne as RadioGroup,
  Une as RadioGroupIndicator,
  jne as RadioGroupItem,
  sre as ResizableHandle,
  vre as ResizablePanel,
  ore as ResizablePanelGroup,
  Vne as ScrollArea,
  zW as ScrollBar,
  N2 as Select,
  I2 as SelectContent,
  R2 as SelectGroup,
  L2 as SelectItem,
  Lte as SelectItemText,
  Bte as SelectLabel,
  I6 as SelectScrollDownButton,
  O6 as SelectScrollUpButton,
  Pte as SelectSeparator,
  O2 as SelectTrigger,
  D2 as SelectValue,
  _p as Separator,
  Di as Skeleton,
  $te as StateSelect,
  zte as StickyNote,
  Wne as Switch,
  jK as Table,
  UK as TableBody,
  Yne as TableCaption,
  cc as TableCell,
  Qne as TableEmpty,
  Kne as TableHead,
  VK as TableHeader,
  fc as TableRow,
  Zne as Tabs,
  ere as TabsContent,
  Jne as TabsList,
  Xne as TabsTrigger,
  tre as Textarea,
  P6 as TimezoneSelect,
  qne as Toaster,
  W9 as Toggle,
  Fte as ToggleTheme,
  q2 as Tooltip,
  W2 as TooltipContent,
  Kte as TooltipProvider,
  G2 as TooltipTrigger,
  nre as ValidationFormInput,
  g1 as ValidationFormItem,
  rre as ValidationFormPhoneInput,
  ire as ValidationFormTimeZoneInput,
  yS as alertVariants,
  eY as avatarVariant,
  vS as badgeVariants,
  ea as buttonVariants,
  G as cn,
  BW as navigationMenuTriggerStyle,
  B1 as parsePhone,
  Hne as toast,
  K9 as toggleVariants
};
